/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_pose_h
#define impl_type_pose_h










#include "impl_type_double.h"
#include "impl_type_quaternion.h"
#include "impl_type_pointenu.h"
#include "impl_type_point3d.h"


struct Pose {
    ::PointENU position;
    
    ::Quaternion orientation;
    
    ::Point3D linear_velocity;
    
    ::Point3D linear_acceleration;
    
    ::Point3D angular_velocity;
    
    ::Double heading;
    
    ::Point3D linear_acceleration_vrf;
    
    ::Point3D angular_velocity_vrf;
    
    ::Point3D euler_angles;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(position);
        fun(orientation);
        fun(linear_velocity);
        fun(linear_acceleration);
        fun(angular_velocity);
        fun(heading);
        fun(linear_acceleration_vrf);
        fun(angular_velocity_vrf);
        fun(euler_angles);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(position);
        fun(orientation);
        fun(linear_velocity);
        fun(linear_acceleration);
        fun(angular_velocity);
        fun(heading);
        fun(linear_acceleration_vrf);
        fun(angular_velocity_vrf);
        fun(euler_angles);
    }

    bool operator == (const ::Pose& t) const {
        return (position == t.position) && (orientation == t.orientation) && (linear_velocity == t.linear_velocity) && (linear_acceleration == t.linear_acceleration) && (angular_velocity == t.angular_velocity) && (heading == t.heading) && (linear_acceleration_vrf == t.linear_acceleration_vrf) && (angular_velocity_vrf == t.angular_velocity_vrf) && (euler_angles == t.euler_angles);
    }
};


#endif // impl_type_pose_h
