/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_controlcommand_h
#define impl_type_controlcommand_h

#pragma pack(1)





























#include "impl_type_bool.h"
#include "impl_type_latencystats.h"
#include "impl_type_gearposition.h"
#include "impl_type_double.h"
#include "impl_type_turnsignal.h"
#include "impl_type_int32.h"
#include "impl_type_padmessage.h"
#include "impl_type_header.h"
#include "impl_type_drivingmode.h"
#include "impl_type_engageadvice.h"
#include "impl_type_debug.h"
#include "impl_type_vehiclesignal.h"


struct ControlCommand {
    ::Header header;
    
    ::Double steering_target;
    
    ::Bool parking_brake;
    
    ::Double speed;
    
    ::Double acceleration;
    
    ::Bool reset_model;
    
    ::Bool engine_on_off;
    
    ::Double trajectory_fraction;
    
    ::DrivingMode driving_mode;
    
    ::GearPosition gear_location;
    
    ::Debug debug;
    
    ::VehicleSignal signal;
    
    ::LatencyStats latency_stats;
    
    ::PadMessage pad_msg;
    
    ::EngageAdvice engage_advice;
    
    ::Bool is_in_safe_mode;
    
    ::Double steering_torque;
    
    ::Int32 PAM_ESP_Target_Gear_Request;
    
    ::Bool ACC_StandstillReq;
    
    ::TurnSignal turnsignal;
    
    ::Double throttle;
    
    ::Double brake;
    
    ::Double steering_rate;
    
    ::Bool left_turn;
    
    ::Bool right_turn;
    
    ::Bool high_beam;
    
    ::Bool low_beam;
    
    ::Bool horn;
    
    ::Double steering_angle;
    
    ::Int32 pam_esp_stop_distance;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(header);
        fun(steering_target);
        fun(parking_brake);
        fun(speed);
        fun(acceleration);
        fun(reset_model);
        fun(engine_on_off);
        fun(trajectory_fraction);
        fun(driving_mode);
        fun(gear_location);
        fun(debug);
        fun(signal);
        fun(latency_stats);
        fun(pad_msg);
        fun(engage_advice);
        fun(is_in_safe_mode);
        fun(steering_torque);
        fun(PAM_ESP_Target_Gear_Request);
        fun(ACC_StandstillReq);
        fun(turnsignal);
        fun(throttle);
        fun(brake);
        fun(steering_rate);
        fun(left_turn);
        fun(right_turn);
        fun(high_beam);
        fun(low_beam);
        fun(horn);
        fun(steering_angle);
        fun(pam_esp_stop_distance);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(header);
        fun(steering_target);
        fun(parking_brake);
        fun(speed);
        fun(acceleration);
        fun(reset_model);
        fun(engine_on_off);
        fun(trajectory_fraction);
        fun(driving_mode);
        fun(gear_location);
        fun(debug);
        fun(signal);
        fun(latency_stats);
        fun(pad_msg);
        fun(engage_advice);
        fun(is_in_safe_mode);
        fun(steering_torque);
        fun(PAM_ESP_Target_Gear_Request);
        fun(ACC_StandstillReq);
        fun(turnsignal);
        fun(throttle);
        fun(brake);
        fun(steering_rate);
        fun(left_turn);
        fun(right_turn);
        fun(high_beam);
        fun(low_beam);
        fun(horn);
        fun(steering_angle);
        fun(pam_esp_stop_distance);
    }

    bool operator == (const ::ControlCommand& t) const {
        return (header == t.header) && (steering_target == t.steering_target) && (parking_brake == t.parking_brake) && (speed == t.speed) && (acceleration == t.acceleration) && (reset_model == t.reset_model) && (engine_on_off == t.engine_on_off) && (trajectory_fraction == t.trajectory_fraction) && (driving_mode == t.driving_mode) && (gear_location == t.gear_location) && (debug == t.debug) && (signal == t.signal) && (latency_stats == t.latency_stats) && (pad_msg == t.pad_msg) && (engage_advice == t.engage_advice) && (is_in_safe_mode == t.is_in_safe_mode) && (steering_torque == t.steering_torque) && (PAM_ESP_Target_Gear_Request == t.PAM_ESP_Target_Gear_Request) && (ACC_StandstillReq == t.ACC_StandstillReq) && (turnsignal == t.turnsignal) && (throttle == t.throttle) && (brake == t.brake) && (steering_rate == t.steering_rate) && (left_turn == t.left_turn) && (right_turn == t.right_turn) && (high_beam == t.high_beam) && (low_beam == t.low_beam) && (horn == t.horn) && (steering_angle == t.steering_angle) && (pam_esp_stop_distance == t.pam_esp_stop_distance);
    }
};

#pragma pack()
#endif // impl_type_controlcommand_h
