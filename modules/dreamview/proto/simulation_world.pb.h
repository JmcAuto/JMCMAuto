// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/dreamview/proto/simulation_world.proto

#ifndef PROTOBUF_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto__INCLUDED
#define PROTOBUF_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common/monitor_log/proto/monitor_log.pb.h"
#include "modules/planning/proto/planning_internal.pb.h"
#include "modules/perception/proto/perception_obstacle.pb.h"
#include "modules/common/proto/pnc_point.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace common {
class FrenetFramePoint;
class FrenetFramePointDefaultTypeInternal;
extern FrenetFramePointDefaultTypeInternal _FrenetFramePoint_default_instance_;
class GaussianInfo;
class GaussianInfoDefaultTypeInternal;
extern GaussianInfoDefaultTypeInternal _GaussianInfo_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathPoint;
class PathPointDefaultTypeInternal;
extern PathPointDefaultTypeInternal _PathPoint_default_instance_;
class SLPoint;
class SLPointDefaultTypeInternal;
extern SLPointDefaultTypeInternal _SLPoint_default_instance_;
class SpeedPoint;
class SpeedPointDefaultTypeInternal;
extern SpeedPointDefaultTypeInternal _SpeedPoint_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
class VehicleMotion;
class VehicleMotionDefaultTypeInternal;
extern VehicleMotionDefaultTypeInternal _VehicleMotion_default_instance_;
class VehicleMotionPoint;
class VehicleMotionPointDefaultTypeInternal;
extern VehicleMotionPointDefaultTypeInternal _VehicleMotionPoint_default_instance_;
namespace monitor {
class MonitorMessage;
class MonitorMessageDefaultTypeInternal;
extern MonitorMessageDefaultTypeInternal _MonitorMessage_default_instance_;
class MonitorMessageItem;
class MonitorMessageItemDefaultTypeInternal;
extern MonitorMessageItemDefaultTypeInternal _MonitorMessageItem_default_instance_;
}  // namespace monitor
}  // namespace common
namespace dreamview {
class ControlData;
class ControlDataDefaultTypeInternal;
extern ControlDataDefaultTypeInternal _ControlData_default_instance_;
class Decision;
class DecisionDefaultTypeInternal;
extern DecisionDefaultTypeInternal _Decision_default_instance_;
class DelaysInMs;
class DelaysInMsDefaultTypeInternal;
extern DelaysInMsDefaultTypeInternal _DelaysInMs_default_instance_;
class Latency;
class LatencyDefaultTypeInternal;
extern LatencyDefaultTypeInternal _Latency_default_instance_;
class MapElementIds;
class MapElementIdsDefaultTypeInternal;
extern MapElementIdsDefaultTypeInternal _MapElementIds_default_instance_;
class Notification;
class NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class PolygonPoint;
class PolygonPointDefaultTypeInternal;
extern PolygonPointDefaultTypeInternal _PolygonPoint_default_instance_;
class Prediction;
class PredictionDefaultTypeInternal;
extern PredictionDefaultTypeInternal _Prediction_default_instance_;
class RoutePath;
class RoutePathDefaultTypeInternal;
extern RoutePathDefaultTypeInternal _RoutePath_default_instance_;
class SimulationWorld;
class SimulationWorldDefaultTypeInternal;
extern SimulationWorldDefaultTypeInternal _SimulationWorld_default_instance_;
}  // namespace dreamview
namespace perception {
class CIPVInfo;
class CIPVInfoDefaultTypeInternal;
extern CIPVInfoDefaultTypeInternal _CIPVInfo_default_instance_;
class LaneMarker;
class LaneMarkerDefaultTypeInternal;
extern LaneMarkerDefaultTypeInternal _LaneMarker_default_instance_;
class LaneMarkers;
class LaneMarkersDefaultTypeInternal;
extern LaneMarkersDefaultTypeInternal _LaneMarkers_default_instance_;
class PerceptionObstacle;
class PerceptionObstacleDefaultTypeInternal;
extern PerceptionObstacleDefaultTypeInternal _PerceptionObstacle_default_instance_;
class PerceptionObstacles;
class PerceptionObstaclesDefaultTypeInternal;
extern PerceptionObstaclesDefaultTypeInternal _PerceptionObstacles_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
}  // namespace perception
namespace planning_internal {
class AutoTuningTrainingData;
class AutoTuningTrainingDataDefaultTypeInternal;
extern AutoTuningTrainingDataDefaultTypeInternal _AutoTuningTrainingData_default_instance_;
class CloudReferenceLineRequest;
class CloudReferenceLineRequestDefaultTypeInternal;
extern CloudReferenceLineRequestDefaultTypeInternal _CloudReferenceLineRequest_default_instance_;
class CloudReferenceLineResponse;
class CloudReferenceLineResponseDefaultTypeInternal;
extern CloudReferenceLineResponseDefaultTypeInternal _CloudReferenceLineResponse_default_instance_;
class CloudReferenceLineRoutingRequest;
class CloudReferenceLineRoutingRequestDefaultTypeInternal;
extern CloudReferenceLineRoutingRequestDefaultTypeInternal _CloudReferenceLineRoutingRequest_default_instance_;
class CostComponents;
class CostComponentsDefaultTypeInternal;
extern CostComponentsDefaultTypeInternal _CostComponents_default_instance_;
class Debug;
class DebugDefaultTypeInternal;
extern DebugDefaultTypeInternal _Debug_default_instance_;
class DecisionTag;
class DecisionTagDefaultTypeInternal;
extern DecisionTagDefaultTypeInternal _DecisionTag_default_instance_;
class DpPolyGraphDebug;
class DpPolyGraphDebugDefaultTypeInternal;
extern DpPolyGraphDebugDefaultTypeInternal _DpPolyGraphDebug_default_instance_;
class LatticeStPixel;
class LatticeStPixelDefaultTypeInternal;
extern LatticeStPixelDefaultTypeInternal _LatticeStPixel_default_instance_;
class LatticeStTraining;
class LatticeStTrainingDefaultTypeInternal;
extern LatticeStTrainingDefaultTypeInternal _LatticeStTraining_default_instance_;
class ObstacleDebug;
class ObstacleDebugDefaultTypeInternal;
extern ObstacleDebugDefaultTypeInternal _ObstacleDebug_default_instance_;
class OpenSpaceDebug;
class OpenSpaceDebugDefaultTypeInternal;
extern OpenSpaceDebugDefaultTypeInternal _OpenSpaceDebug_default_instance_;
class PlanningData;
class PlanningDataDefaultTypeInternal;
extern PlanningDataDefaultTypeInternal _PlanningData_default_instance_;
class PullOverDebug;
class PullOverDebugDefaultTypeInternal;
extern PullOverDebugDefaultTypeInternal _PullOverDebug_default_instance_;
class ReferenceLineDebug;
class ReferenceLineDebugDefaultTypeInternal;
extern ReferenceLineDebugDefaultTypeInternal _ReferenceLineDebug_default_instance_;
class SLFrameDebug;
class SLFrameDebugDefaultTypeInternal;
extern SLFrameDebugDefaultTypeInternal _SLFrameDebug_default_instance_;
class STGraphDebug;
class STGraphDebugDefaultTypeInternal;
extern STGraphDebugDefaultTypeInternal _STGraphDebug_default_instance_;
class STGraphDebug_STGraphKernelCuiseRef;
class STGraphDebug_STGraphKernelCuiseRefDefaultTypeInternal;
extern STGraphDebug_STGraphKernelCuiseRefDefaultTypeInternal _STGraphDebug_STGraphKernelCuiseRef_default_instance_;
class STGraphDebug_STGraphKernelFollowRef;
class STGraphDebug_STGraphKernelFollowRefDefaultTypeInternal;
extern STGraphDebug_STGraphKernelFollowRefDefaultTypeInternal _STGraphDebug_STGraphKernelFollowRef_default_instance_;
class STGraphDebug_STGraphSpeedConstraint;
class STGraphDebug_STGraphSpeedConstraintDefaultTypeInternal;
extern STGraphDebug_STGraphSpeedConstraintDefaultTypeInternal _STGraphDebug_STGraphSpeedConstraint_default_instance_;
class SampleLayerDebug;
class SampleLayerDebugDefaultTypeInternal;
extern SampleLayerDebugDefaultTypeInternal _SampleLayerDebug_default_instance_;
class ScenarioDebug;
class ScenarioDebugDefaultTypeInternal;
extern ScenarioDebugDefaultTypeInternal _ScenarioDebug_default_instance_;
class SignalLightDebug;
class SignalLightDebugDefaultTypeInternal;
extern SignalLightDebugDefaultTypeInternal _SignalLightDebug_default_instance_;
class SignalLightDebug_SignalDebug;
class SignalLightDebug_SignalDebugDefaultTypeInternal;
extern SignalLightDebug_SignalDebugDefaultTypeInternal _SignalLightDebug_SignalDebug_default_instance_;
class SmootherDebug;
class SmootherDebugDefaultTypeInternal;
extern SmootherDebugDefaultTypeInternal _SmootherDebug_default_instance_;
class SpeedPlan;
class SpeedPlanDefaultTypeInternal;
extern SpeedPlanDefaultTypeInternal _SpeedPlan_default_instance_;
class StGraphBoundaryDebug;
class StGraphBoundaryDebugDefaultTypeInternal;
extern StGraphBoundaryDebugDefaultTypeInternal _StGraphBoundaryDebug_default_instance_;
class Trajectories;
class TrajectoriesDefaultTypeInternal;
extern TrajectoriesDefaultTypeInternal _Trajectories_default_instance_;
}  // namespace planning_internal
namespace routing {
class LaneSegment;
class LaneSegmentDefaultTypeInternal;
extern LaneSegmentDefaultTypeInternal _LaneSegment_default_instance_;
class LaneWaypoint;
class LaneWaypointDefaultTypeInternal;
extern LaneWaypointDefaultTypeInternal _LaneWaypoint_default_instance_;
class Measurement;
class MeasurementDefaultTypeInternal;
extern MeasurementDefaultTypeInternal _Measurement_default_instance_;
class ParkingInfo;
class ParkingInfoDefaultTypeInternal;
extern ParkingInfoDefaultTypeInternal _ParkingInfo_default_instance_;
class Passage;
class PassageDefaultTypeInternal;
extern PassageDefaultTypeInternal _Passage_default_instance_;
class RoadSegment;
class RoadSegmentDefaultTypeInternal;
extern RoadSegmentDefaultTypeInternal _RoadSegment_default_instance_;
class RoutingRequest;
class RoutingRequestDefaultTypeInternal;
extern RoutingRequestDefaultTypeInternal _RoutingRequest_default_instance_;
class RoutingResponse;
class RoutingResponseDefaultTypeInternal;
extern RoutingResponseDefaultTypeInternal _RoutingResponse_default_instance_;
}  // namespace routing
}  // namespace jmc_auto

namespace jmc_auto {
namespace dreamview {

namespace protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto

enum Decision_Type {
  Decision_Type_IGNORE = 0,
  Decision_Type_STOP = 1,
  Decision_Type_NUDGE = 2,
  Decision_Type_YIELD = 3,
  Decision_Type_OVERTAKE = 4,
  Decision_Type_FOLLOW = 5,
  Decision_Type_SIDEPASS = 6
};
bool Decision_Type_IsValid(int value);
const Decision_Type Decision_Type_Type_MIN = Decision_Type_IGNORE;
const Decision_Type Decision_Type_Type_MAX = Decision_Type_SIDEPASS;
const int Decision_Type_Type_ARRAYSIZE = Decision_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Decision_Type_descriptor();
inline const ::std::string& Decision_Type_Name(Decision_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Decision_Type_descriptor(), value);
}
inline bool Decision_Type_Parse(
    const ::std::string& name, Decision_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Decision_Type>(
    Decision_Type_descriptor(), name, value);
}
enum Decision_StopReasonCode {
  Decision_StopReasonCode_STOP_REASON_HEAD_VEHICLE = 1,
  Decision_StopReasonCode_STOP_REASON_DESTINATION = 2,
  Decision_StopReasonCode_STOP_REASON_PEDESTRIAN = 3,
  Decision_StopReasonCode_STOP_REASON_OBSTACLE = 4,
  Decision_StopReasonCode_STOP_REASON_SIGNAL = 100,
  Decision_StopReasonCode_STOP_REASON_STOP_SIGN = 101,
  Decision_StopReasonCode_STOP_REASON_YIELD_SIGN = 102,
  Decision_StopReasonCode_STOP_REASON_CLEAR_ZONE = 103,
  Decision_StopReasonCode_STOP_REASON_CROSSWALK = 104,
  Decision_StopReasonCode_STOP_REASON_EMERGENCY = 105,
  Decision_StopReasonCode_STOP_REASON_NOT_READY = 106
};
bool Decision_StopReasonCode_IsValid(int value);
const Decision_StopReasonCode Decision_StopReasonCode_StopReasonCode_MIN = Decision_StopReasonCode_STOP_REASON_HEAD_VEHICLE;
const Decision_StopReasonCode Decision_StopReasonCode_StopReasonCode_MAX = Decision_StopReasonCode_STOP_REASON_NOT_READY;
const int Decision_StopReasonCode_StopReasonCode_ARRAYSIZE = Decision_StopReasonCode_StopReasonCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Decision_StopReasonCode_descriptor();
inline const ::std::string& Decision_StopReasonCode_Name(Decision_StopReasonCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Decision_StopReasonCode_descriptor(), value);
}
inline bool Decision_StopReasonCode_Parse(
    const ::std::string& name, Decision_StopReasonCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Decision_StopReasonCode>(
    Decision_StopReasonCode_descriptor(), name, value);
}
enum Object_DisengageType {
  Object_DisengageType_DISENGAGE_NONE = 0,
  Object_DisengageType_DISENGAGE_UNKNOWN = 1,
  Object_DisengageType_DISENGAGE_MANUAL = 2,
  Object_DisengageType_DISENGAGE_EMERGENCY = 3,
  Object_DisengageType_DISENGAGE_AUTO_STEER_ONLY = 4,
  Object_DisengageType_DISENGAGE_AUTO_SPEED_ONLY = 5,
  Object_DisengageType_DISENGAGE_CHASSIS_ERROR = 6
};
bool Object_DisengageType_IsValid(int value);
const Object_DisengageType Object_DisengageType_DisengageType_MIN = Object_DisengageType_DISENGAGE_NONE;
const Object_DisengageType Object_DisengageType_DisengageType_MAX = Object_DisengageType_DISENGAGE_CHASSIS_ERROR;
const int Object_DisengageType_DisengageType_ARRAYSIZE = Object_DisengageType_DisengageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_DisengageType_descriptor();
inline const ::std::string& Object_DisengageType_Name(Object_DisengageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_DisengageType_descriptor(), value);
}
inline bool Object_DisengageType_Parse(
    const ::std::string& name, Object_DisengageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_DisengageType>(
    Object_DisengageType_descriptor(), name, value);
}
enum Object_Type {
  Object_Type_UNKNOWN = 0,
  Object_Type_UNKNOWN_MOVABLE = 1,
  Object_Type_UNKNOWN_UNMOVABLE = 2,
  Object_Type_PEDESTRIAN = 3,
  Object_Type_BICYCLE = 4,
  Object_Type_VEHICLE = 5,
  Object_Type_VIRTUAL = 6,
  Object_Type_CIPV = 7
};
bool Object_Type_IsValid(int value);
const Object_Type Object_Type_Type_MIN = Object_Type_UNKNOWN;
const Object_Type Object_Type_Type_MAX = Object_Type_CIPV;
const int Object_Type_Type_ARRAYSIZE = Object_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_Type_descriptor();
inline const ::std::string& Object_Type_Name(Object_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_Type_descriptor(), value);
}
inline bool Object_Type_Parse(
    const ::std::string& name, Object_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_Type>(
    Object_Type_descriptor(), name, value);
}
enum Object_DisengageTypegear {
  Object_DisengageTypegear_GEAR_NEUTRAL = 0,
  Object_DisengageTypegear_GEAR_DRIVE = 1,
  Object_DisengageTypegear_GEAR_REVERSE = 2,
  Object_DisengageTypegear_GEAR_PARKING = 3,
  Object_DisengageTypegear_GEAR_LOW = 4,
  Object_DisengageTypegear_GEAR_INVALID = 5,
  Object_DisengageTypegear_GEAR_NONE = 6,
  Object_DisengageTypegear_GEAR_CHASSIS_ERROR = 7
};
bool Object_DisengageTypegear_IsValid(int value);
const Object_DisengageTypegear Object_DisengageTypegear_DisengageTypegear_MIN = Object_DisengageTypegear_GEAR_NEUTRAL;
const Object_DisengageTypegear Object_DisengageTypegear_DisengageTypegear_MAX = Object_DisengageTypegear_GEAR_CHASSIS_ERROR;
const int Object_DisengageTypegear_DisengageTypegear_ARRAYSIZE = Object_DisengageTypegear_DisengageTypegear_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_DisengageTypegear_descriptor();
inline const ::std::string& Object_DisengageTypegear_Name(Object_DisengageTypegear value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_DisengageTypegear_descriptor(), value);
}
inline bool Object_DisengageTypegear_Parse(
    const ::std::string& name, Object_DisengageTypegear* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_DisengageTypegear>(
    Object_DisengageTypegear_descriptor(), name, value);
}
// ===================================================================

class PolygonPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.PolygonPoint) */ {
 public:
  PolygonPoint();
  virtual ~PolygonPoint();

  PolygonPoint(const PolygonPoint& from);

  inline PolygonPoint& operator=(const PolygonPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PolygonPoint& default_instance();

  static inline const PolygonPoint* internal_default_instance() {
    return reinterpret_cast<const PolygonPoint*>(
               &_PolygonPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PolygonPoint* other);

  // implements Message ----------------------------------------------

  inline PolygonPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PolygonPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PolygonPoint& from);
  void MergeFrom(const PolygonPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PolygonPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.PolygonPoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Prediction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.Prediction) */ {
 public:
  Prediction();
  virtual ~Prediction();

  Prediction(const Prediction& from);

  inline Prediction& operator=(const Prediction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Prediction& default_instance();

  static inline const Prediction* internal_default_instance() {
    return reinterpret_cast<const Prediction*>(
               &_Prediction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Prediction* other);

  // implements Message ----------------------------------------------

  inline Prediction* New() const PROTOBUF_FINAL { return New(NULL); }

  Prediction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Prediction& from);
  void MergeFrom(const Prediction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Prediction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.dreamview.PolygonPoint predicted_trajectory = 2;
  int predicted_trajectory_size() const;
  void clear_predicted_trajectory();
  static const int kPredictedTrajectoryFieldNumber = 2;
  const ::jmc_auto::dreamview::PolygonPoint& predicted_trajectory(int index) const;
  ::jmc_auto::dreamview::PolygonPoint* mutable_predicted_trajectory(int index);
  ::jmc_auto::dreamview::PolygonPoint* add_predicted_trajectory();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
      mutable_predicted_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
      predicted_trajectory() const;

  // optional double probability = 1;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 1;
  double probability() const;
  void set_probability(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.Prediction)
 private:
  void set_has_probability();
  void clear_has_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint > predicted_trajectory_;
  double probability_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Decision : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.Decision) */ {
 public:
  Decision();
  virtual ~Decision();

  Decision(const Decision& from);

  inline Decision& operator=(const Decision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Decision& default_instance();

  static inline const Decision* internal_default_instance() {
    return reinterpret_cast<const Decision*>(
               &_Decision_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Decision* other);

  // implements Message ----------------------------------------------

  inline Decision* New() const PROTOBUF_FINAL { return New(NULL); }

  Decision* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Decision& from);
  void MergeFrom(const Decision& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Decision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Decision_Type Type;
  static const Type IGNORE =
    Decision_Type_IGNORE;
  static const Type STOP =
    Decision_Type_STOP;
  static const Type NUDGE =
    Decision_Type_NUDGE;
  static const Type YIELD =
    Decision_Type_YIELD;
  static const Type OVERTAKE =
    Decision_Type_OVERTAKE;
  static const Type FOLLOW =
    Decision_Type_FOLLOW;
  static const Type SIDEPASS =
    Decision_Type_SIDEPASS;
  static inline bool Type_IsValid(int value) {
    return Decision_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Decision_Type_Type_MIN;
  static const Type Type_MAX =
    Decision_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Decision_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Decision_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Decision_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Decision_Type_Parse(name, value);
  }

  typedef Decision_StopReasonCode StopReasonCode;
  static const StopReasonCode STOP_REASON_HEAD_VEHICLE =
    Decision_StopReasonCode_STOP_REASON_HEAD_VEHICLE;
  static const StopReasonCode STOP_REASON_DESTINATION =
    Decision_StopReasonCode_STOP_REASON_DESTINATION;
  static const StopReasonCode STOP_REASON_PEDESTRIAN =
    Decision_StopReasonCode_STOP_REASON_PEDESTRIAN;
  static const StopReasonCode STOP_REASON_OBSTACLE =
    Decision_StopReasonCode_STOP_REASON_OBSTACLE;
  static const StopReasonCode STOP_REASON_SIGNAL =
    Decision_StopReasonCode_STOP_REASON_SIGNAL;
  static const StopReasonCode STOP_REASON_STOP_SIGN =
    Decision_StopReasonCode_STOP_REASON_STOP_SIGN;
  static const StopReasonCode STOP_REASON_YIELD_SIGN =
    Decision_StopReasonCode_STOP_REASON_YIELD_SIGN;
  static const StopReasonCode STOP_REASON_CLEAR_ZONE =
    Decision_StopReasonCode_STOP_REASON_CLEAR_ZONE;
  static const StopReasonCode STOP_REASON_CROSSWALK =
    Decision_StopReasonCode_STOP_REASON_CROSSWALK;
  static const StopReasonCode STOP_REASON_EMERGENCY =
    Decision_StopReasonCode_STOP_REASON_EMERGENCY;
  static const StopReasonCode STOP_REASON_NOT_READY =
    Decision_StopReasonCode_STOP_REASON_NOT_READY;
  static inline bool StopReasonCode_IsValid(int value) {
    return Decision_StopReasonCode_IsValid(value);
  }
  static const StopReasonCode StopReasonCode_MIN =
    Decision_StopReasonCode_StopReasonCode_MIN;
  static const StopReasonCode StopReasonCode_MAX =
    Decision_StopReasonCode_StopReasonCode_MAX;
  static const int StopReasonCode_ARRAYSIZE =
    Decision_StopReasonCode_StopReasonCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StopReasonCode_descriptor() {
    return Decision_StopReasonCode_descriptor();
  }
  static inline const ::std::string& StopReasonCode_Name(StopReasonCode value) {
    return Decision_StopReasonCode_Name(value);
  }
  static inline bool StopReasonCode_Parse(const ::std::string& name,
      StopReasonCode* value) {
    return Decision_StopReasonCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.dreamview.PolygonPoint polygon_point = 2;
  int polygon_point_size() const;
  void clear_polygon_point();
  static const int kPolygonPointFieldNumber = 2;
  const ::jmc_auto::dreamview::PolygonPoint& polygon_point(int index) const;
  ::jmc_auto::dreamview::PolygonPoint* mutable_polygon_point(int index);
  ::jmc_auto::dreamview::PolygonPoint* add_polygon_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
      mutable_polygon_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
      polygon_point() const;

  // optional double heading = 3;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  double heading() const;
  void set_heading(double value);

  // optional double latitude = 4;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 5;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // optional double position_x = 6;
  bool has_position_x() const;
  void clear_position_x();
  static const int kPositionXFieldNumber = 6;
  double position_x() const;
  void set_position_x(double value);

  // optional .jmc_auto.dreamview.Decision.Type type = 1 [default = IGNORE];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::jmc_auto::dreamview::Decision_Type type() const;
  void set_type(::jmc_auto::dreamview::Decision_Type value);

  // optional .jmc_auto.routing.ChangeLaneType change_lane_type = 12;
  bool has_change_lane_type() const;
  void clear_change_lane_type();
  static const int kChangeLaneTypeFieldNumber = 12;
  ::jmc_auto::routing::ChangeLaneType change_lane_type() const;
  void set_change_lane_type(::jmc_auto::routing::ChangeLaneType value);

  // optional double position_y = 7;
  bool has_position_y() const;
  void clear_position_y();
  static const int kPositionYFieldNumber = 7;
  double position_y() const;
  void set_position_y(double value);

  // optional .jmc_auto.dreamview.Decision.StopReasonCode stopReason = 11;
  bool has_stopreason() const;
  void clear_stopreason();
  static const int kStopReasonFieldNumber = 11;
  ::jmc_auto::dreamview::Decision_StopReasonCode stopreason() const;
  void set_stopreason(::jmc_auto::dreamview::Decision_StopReasonCode value);

  // optional double length = 8 [default = 2.8];
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 8;
  double length() const;
  void set_length(double value);

  // optional double width = 9 [default = 1.4];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 9;
  double width() const;
  void set_width(double value);

  // optional double height = 10 [default = 1.8];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  double height() const;
  void set_height(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.Decision)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_heading();
  void clear_has_heading();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_position_x();
  void clear_has_position_x();
  void set_has_position_y();
  void clear_has_position_y();
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_stopreason();
  void clear_has_stopreason();
  void set_has_change_lane_type();
  void clear_has_change_lane_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint > polygon_point_;
  double heading_;
  double latitude_;
  double longitude_;
  double position_x_;
  int type_;
  int change_lane_type_;
  double position_y_;
  int stopreason_;
  double length_;
  double width_;
  double height_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  inline Object* New() const PROTOBUF_FINAL { return New(NULL); }

  Object* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Object_DisengageType DisengageType;
  static const DisengageType DISENGAGE_NONE =
    Object_DisengageType_DISENGAGE_NONE;
  static const DisengageType DISENGAGE_UNKNOWN =
    Object_DisengageType_DISENGAGE_UNKNOWN;
  static const DisengageType DISENGAGE_MANUAL =
    Object_DisengageType_DISENGAGE_MANUAL;
  static const DisengageType DISENGAGE_EMERGENCY =
    Object_DisengageType_DISENGAGE_EMERGENCY;
  static const DisengageType DISENGAGE_AUTO_STEER_ONLY =
    Object_DisengageType_DISENGAGE_AUTO_STEER_ONLY;
  static const DisengageType DISENGAGE_AUTO_SPEED_ONLY =
    Object_DisengageType_DISENGAGE_AUTO_SPEED_ONLY;
  static const DisengageType DISENGAGE_CHASSIS_ERROR =
    Object_DisengageType_DISENGAGE_CHASSIS_ERROR;
  static inline bool DisengageType_IsValid(int value) {
    return Object_DisengageType_IsValid(value);
  }
  static const DisengageType DisengageType_MIN =
    Object_DisengageType_DisengageType_MIN;
  static const DisengageType DisengageType_MAX =
    Object_DisengageType_DisengageType_MAX;
  static const int DisengageType_ARRAYSIZE =
    Object_DisengageType_DisengageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DisengageType_descriptor() {
    return Object_DisengageType_descriptor();
  }
  static inline const ::std::string& DisengageType_Name(DisengageType value) {
    return Object_DisengageType_Name(value);
  }
  static inline bool DisengageType_Parse(const ::std::string& name,
      DisengageType* value) {
    return Object_DisengageType_Parse(name, value);
  }

  typedef Object_Type Type;
  static const Type UNKNOWN =
    Object_Type_UNKNOWN;
  static const Type UNKNOWN_MOVABLE =
    Object_Type_UNKNOWN_MOVABLE;
  static const Type UNKNOWN_UNMOVABLE =
    Object_Type_UNKNOWN_UNMOVABLE;
  static const Type PEDESTRIAN =
    Object_Type_PEDESTRIAN;
  static const Type BICYCLE =
    Object_Type_BICYCLE;
  static const Type VEHICLE =
    Object_Type_VEHICLE;
  static const Type VIRTUAL =
    Object_Type_VIRTUAL;
  static const Type CIPV =
    Object_Type_CIPV;
  static inline bool Type_IsValid(int value) {
    return Object_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Object_Type_Type_MIN;
  static const Type Type_MAX =
    Object_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Object_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Object_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Object_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Object_Type_Parse(name, value);
  }

  typedef Object_DisengageTypegear DisengageTypegear;
  static const DisengageTypegear GEAR_NEUTRAL =
    Object_DisengageTypegear_GEAR_NEUTRAL;
  static const DisengageTypegear GEAR_DRIVE =
    Object_DisengageTypegear_GEAR_DRIVE;
  static const DisengageTypegear GEAR_REVERSE =
    Object_DisengageTypegear_GEAR_REVERSE;
  static const DisengageTypegear GEAR_PARKING =
    Object_DisengageTypegear_GEAR_PARKING;
  static const DisengageTypegear GEAR_LOW =
    Object_DisengageTypegear_GEAR_LOW;
  static const DisengageTypegear GEAR_INVALID =
    Object_DisengageTypegear_GEAR_INVALID;
  static const DisengageTypegear GEAR_NONE =
    Object_DisengageTypegear_GEAR_NONE;
  static const DisengageTypegear GEAR_CHASSIS_ERROR =
    Object_DisengageTypegear_GEAR_CHASSIS_ERROR;
  static inline bool DisengageTypegear_IsValid(int value) {
    return Object_DisengageTypegear_IsValid(value);
  }
  static const DisengageTypegear DisengageTypegear_MIN =
    Object_DisengageTypegear_DisengageTypegear_MIN;
  static const DisengageTypegear DisengageTypegear_MAX =
    Object_DisengageTypegear_DisengageTypegear_MAX;
  static const int DisengageTypegear_ARRAYSIZE =
    Object_DisengageTypegear_DisengageTypegear_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DisengageTypegear_descriptor() {
    return Object_DisengageTypegear_descriptor();
  }
  static inline const ::std::string& DisengageTypegear_Name(DisengageTypegear value) {
    return Object_DisengageTypegear_Name(value);
  }
  static inline bool DisengageTypegear_Parse(const ::std::string& name,
      DisengageTypegear* value) {
    return Object_DisengageTypegear_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.dreamview.PolygonPoint polygon_point = 2;
  int polygon_point_size() const;
  void clear_polygon_point();
  static const int kPolygonPointFieldNumber = 2;
  const ::jmc_auto::dreamview::PolygonPoint& polygon_point(int index) const;
  ::jmc_auto::dreamview::PolygonPoint* mutable_polygon_point(int index);
  ::jmc_auto::dreamview::PolygonPoint* add_polygon_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
      mutable_polygon_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
      polygon_point() const;

  // repeated string signal_set = 19;
  int signal_set_size() const;
  void clear_signal_set();
  static const int kSignalSetFieldNumber = 19;
  const ::std::string& signal_set(int index) const;
  ::std::string* mutable_signal_set(int index);
  void set_signal_set(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signal_set(int index, ::std::string&& value);
  #endif
  void set_signal_set(int index, const char* value);
  void set_signal_set(int index, const char* value, size_t size);
  ::std::string* add_signal_set();
  void add_signal_set(const ::std::string& value);
  #if LANG_CXX11
  void add_signal_set(::std::string&& value);
  #endif
  void add_signal_set(const char* value);
  void add_signal_set(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signal_set() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signal_set();

  // repeated .jmc_auto.dreamview.Decision decision = 22;
  int decision_size() const;
  void clear_decision();
  static const int kDecisionFieldNumber = 22;
  const ::jmc_auto::dreamview::Decision& decision(int index) const;
  ::jmc_auto::dreamview::Decision* mutable_decision(int index);
  ::jmc_auto::dreamview::Decision* add_decision();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Decision >*
      mutable_decision();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Decision >&
      decision() const;

  // repeated .jmc_auto.dreamview.Prediction prediction = 30;
  int prediction_size() const;
  void clear_prediction();
  static const int kPredictionFieldNumber = 30;
  const ::jmc_auto::dreamview::Prediction& prediction(int index) const;
  ::jmc_auto::dreamview::Prediction* mutable_prediction(int index);
  ::jmc_auto::dreamview::Prediction* add_prediction();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Prediction >*
      mutable_prediction();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Prediction >&
      prediction() const;

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string current_signal = 20;
  bool has_current_signal() const;
  void clear_current_signal();
  static const int kCurrentSignalFieldNumber = 20;
  const ::std::string& current_signal() const;
  void set_current_signal(const ::std::string& value);
  #if LANG_CXX11
  void set_current_signal(::std::string&& value);
  #endif
  void set_current_signal(const char* value);
  void set_current_signal(const char* value, size_t size);
  ::std::string* mutable_current_signal();
  ::std::string* release_current_signal();
  void set_allocated_current_signal(::std::string* current_signal);

  // optional double heading = 3;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  double heading() const;
  void set_heading(double value);

  // optional double latitude = 4;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 5;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // optional double position_x = 6;
  bool has_position_x() const;
  void clear_position_x();
  static const int kPositionXFieldNumber = 6;
  double position_x() const;
  void set_position_x(double value);

  // optional double position_y = 7;
  bool has_position_y() const;
  void clear_position_y();
  static const int kPositionYFieldNumber = 7;
  double position_y() const;
  void set_position_y(double value);

  // optional double speed = 11;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 11;
  double speed() const;
  void set_speed(double value);

  // optional double speed_acceleration = 12;
  bool has_speed_acceleration() const;
  void clear_speed_acceleration();
  static const int kSpeedAccelerationFieldNumber = 12;
  double speed_acceleration() const;
  void set_speed_acceleration(double value);

  // optional double speed_jerk = 13;
  bool has_speed_jerk() const;
  void clear_speed_jerk();
  static const int kSpeedJerkFieldNumber = 13;
  double speed_jerk() const;
  void set_speed_jerk(double value);

  // optional double spin = 14;
  bool has_spin() const;
  void clear_spin();
  static const int kSpinFieldNumber = 14;
  double spin() const;
  void set_spin(double value);

  // optional double spin_acceleration = 15;
  bool has_spin_acceleration() const;
  void clear_spin_acceleration();
  static const int kSpinAccelerationFieldNumber = 15;
  double spin_acceleration() const;
  void set_spin_acceleration(double value);

  // optional double spin_jerk = 16;
  bool has_spin_jerk() const;
  void clear_spin_jerk();
  static const int kSpinJerkFieldNumber = 16;
  double spin_jerk() const;
  void set_spin_jerk(double value);

  // optional double speed_heading = 17;
  bool has_speed_heading() const;
  void clear_speed_heading();
  static const int kSpeedHeadingFieldNumber = 17;
  double speed_heading() const;
  void set_speed_heading(double value);

  // optional double kappa = 18;
  bool has_kappa() const;
  void clear_kappa();
  static const int kKappaFieldNumber = 18;
  double kappa() const;
  void set_kappa(double value);

  // optional double timestamp_sec = 21;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 21;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional double throttle_percentage = 23;
  bool has_throttle_percentage() const;
  void clear_throttle_percentage();
  static const int kThrottlePercentageFieldNumber = 23;
  double throttle_percentage() const;
  void set_throttle_percentage(double value);

  // optional double brake_percentage = 24;
  bool has_brake_percentage() const;
  void clear_brake_percentage();
  static const int kBrakePercentageFieldNumber = 24;
  double brake_percentage() const;
  void set_brake_percentage(double value);

  // optional double steering_percentage = 25;
  bool has_steering_percentage() const;
  void clear_steering_percentage();
  static const int kSteeringPercentageFieldNumber = 25;
  double steering_percentage() const;
  void set_steering_percentage(double value);

  // optional double steering_angle = 26;
  bool has_steering_angle() const;
  void clear_steering_angle();
  static const int kSteeringAngleFieldNumber = 26;
  double steering_angle() const;
  void set_steering_angle(double value);

  // optional double steering_ratio = 27;
  bool has_steering_ratio() const;
  void clear_steering_ratio();
  static const int kSteeringRatioFieldNumber = 27;
  double steering_ratio() const;
  void set_steering_ratio(double value);

  // optional .jmc_auto.dreamview.Object.DisengageType disengage_type = 28;
  bool has_disengage_type() const;
  void clear_disengage_type();
  static const int kDisengageTypeFieldNumber = 28;
  ::jmc_auto::dreamview::Object_DisengageType disengage_type() const;
  void set_disengage_type(::jmc_auto::dreamview::Object_DisengageType value);

  // optional .jmc_auto.dreamview.Object.Type type = 29;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 29;
  ::jmc_auto::dreamview::Object_Type type() const;
  void set_type(::jmc_auto::dreamview::Object_Type value);

  // optional .jmc_auto.dreamview.Object.DisengageTypegear disengage_typegear = 32;
  bool has_disengage_typegear() const;
  void clear_disengage_typegear();
  static const int kDisengageTypegearFieldNumber = 32;
  ::jmc_auto::dreamview::Object_DisengageTypegear disengage_typegear() const;
  void set_disengage_typegear(::jmc_auto::dreamview::Object_DisengageTypegear value);

  // optional bool yielded_obstacle = 33 [default = false];
  bool has_yielded_obstacle() const;
  void clear_yielded_obstacle();
  static const int kYieldedObstacleFieldNumber = 33;
  bool yielded_obstacle() const;
  void set_yielded_obstacle(bool value);

  // optional double length = 8 [default = 2.8];
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 8;
  double length() const;
  void set_length(double value);

  // optional double width = 9 [default = 1.4];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 9;
  double width() const;
  void set_width(double value);

  // optional double height = 10 [default = 1.8];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  double height() const;
  void set_height(double value);

  // optional double confidence = 31 [default = 1];
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 31;
  double confidence() const;
  void set_confidence(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.Object)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_heading();
  void clear_has_heading();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_position_x();
  void clear_has_position_x();
  void set_has_position_y();
  void clear_has_position_y();
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_speed();
  void clear_has_speed();
  void set_has_speed_acceleration();
  void clear_has_speed_acceleration();
  void set_has_speed_jerk();
  void clear_has_speed_jerk();
  void set_has_spin();
  void clear_has_spin();
  void set_has_spin_acceleration();
  void clear_has_spin_acceleration();
  void set_has_spin_jerk();
  void clear_has_spin_jerk();
  void set_has_speed_heading();
  void clear_has_speed_heading();
  void set_has_kappa();
  void clear_has_kappa();
  void set_has_current_signal();
  void clear_has_current_signal();
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_yielded_obstacle();
  void clear_has_yielded_obstacle();
  void set_has_throttle_percentage();
  void clear_has_throttle_percentage();
  void set_has_brake_percentage();
  void clear_has_brake_percentage();
  void set_has_steering_percentage();
  void clear_has_steering_percentage();
  void set_has_steering_angle();
  void clear_has_steering_angle();
  void set_has_steering_ratio();
  void clear_has_steering_ratio();
  void set_has_disengage_type();
  void clear_has_disengage_type();
  void set_has_type();
  void clear_has_type();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_disengage_typegear();
  void clear_has_disengage_typegear();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint > polygon_point_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signal_set_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Decision > decision_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Prediction > prediction_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr current_signal_;
  double heading_;
  double latitude_;
  double longitude_;
  double position_x_;
  double position_y_;
  double speed_;
  double speed_acceleration_;
  double speed_jerk_;
  double spin_;
  double spin_acceleration_;
  double spin_jerk_;
  double speed_heading_;
  double kappa_;
  double timestamp_sec_;
  double throttle_percentage_;
  double brake_percentage_;
  double steering_percentage_;
  double steering_angle_;
  double steering_ratio_;
  int disengage_type_;
  int type_;
  int disengage_typegear_;
  bool yielded_obstacle_;
  double length_;
  double width_;
  double height_;
  double confidence_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelaysInMs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.DelaysInMs) */ {
 public:
  DelaysInMs();
  virtual ~DelaysInMs();

  DelaysInMs(const DelaysInMs& from);

  inline DelaysInMs& operator=(const DelaysInMs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelaysInMs& default_instance();

  static inline const DelaysInMs* internal_default_instance() {
    return reinterpret_cast<const DelaysInMs*>(
               &_DelaysInMs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DelaysInMs* other);

  // implements Message ----------------------------------------------

  inline DelaysInMs* New() const PROTOBUF_FINAL { return New(NULL); }

  DelaysInMs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelaysInMs& from);
  void MergeFrom(const DelaysInMs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelaysInMs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double chassis = 1;
  bool has_chassis() const;
  void clear_chassis();
  static const int kChassisFieldNumber = 1;
  double chassis() const;
  void set_chassis(double value);

  // optional double localization = 3;
  bool has_localization() const;
  void clear_localization();
  static const int kLocalizationFieldNumber = 3;
  double localization() const;
  void set_localization(double value);

  // optional double perception_obstacle = 4;
  bool has_perception_obstacle() const;
  void clear_perception_obstacle();
  static const int kPerceptionObstacleFieldNumber = 4;
  double perception_obstacle() const;
  void set_perception_obstacle(double value);

  // optional double planning = 5;
  bool has_planning() const;
  void clear_planning();
  static const int kPlanningFieldNumber = 5;
  double planning() const;
  void set_planning(double value);

  // optional double prediction = 7;
  bool has_prediction() const;
  void clear_prediction();
  static const int kPredictionFieldNumber = 7;
  double prediction() const;
  void set_prediction(double value);

  // optional double traffic_light = 8;
  bool has_traffic_light() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 8;
  double traffic_light() const;
  void set_traffic_light(double value);

  // optional double control = 9;
  bool has_control() const;
  void clear_control();
  static const int kControlFieldNumber = 9;
  double control() const;
  void set_control(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.DelaysInMs)
 private:
  void set_has_chassis();
  void clear_has_chassis();
  void set_has_localization();
  void clear_has_localization();
  void set_has_perception_obstacle();
  void clear_has_perception_obstacle();
  void set_has_planning();
  void clear_has_planning();
  void set_has_prediction();
  void clear_has_prediction();
  void set_has_traffic_light();
  void clear_has_traffic_light();
  void set_has_control();
  void clear_has_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double chassis_;
  double localization_;
  double perception_obstacle_;
  double planning_;
  double prediction_;
  double traffic_light_;
  double control_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoutePath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.RoutePath) */ {
 public:
  RoutePath();
  virtual ~RoutePath();

  RoutePath(const RoutePath& from);

  inline RoutePath& operator=(const RoutePath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutePath& default_instance();

  static inline const RoutePath* internal_default_instance() {
    return reinterpret_cast<const RoutePath*>(
               &_RoutePath_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RoutePath* other);

  // implements Message ----------------------------------------------

  inline RoutePath* New() const PROTOBUF_FINAL { return New(NULL); }

  RoutePath* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoutePath& from);
  void MergeFrom(const RoutePath& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoutePath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.dreamview.PolygonPoint point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::jmc_auto::dreamview::PolygonPoint& point(int index) const;
  ::jmc_auto::dreamview::PolygonPoint* mutable_point(int index);
  ::jmc_auto::dreamview::PolygonPoint* add_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
      point() const;

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.RoutePath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint > point_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Latency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.Latency) */ {
 public:
  Latency();
  virtual ~Latency();

  Latency(const Latency& from);

  inline Latency& operator=(const Latency& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Latency& default_instance();

  static inline const Latency* internal_default_instance() {
    return reinterpret_cast<const Latency*>(
               &_Latency_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Latency* other);

  // implements Message ----------------------------------------------

  inline Latency* New() const PROTOBUF_FINAL { return New(NULL); }

  Latency* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Latency& from);
  void MergeFrom(const Latency& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Latency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double planning = 1;
  bool has_planning() const;
  void clear_planning();
  static const int kPlanningFieldNumber = 1;
  double planning() const;
  void set_planning(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.Latency)
 private:
  void set_has_planning();
  void clear_has_planning();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double planning_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapElementIds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.MapElementIds) */ {
 public:
  MapElementIds();
  virtual ~MapElementIds();

  MapElementIds(const MapElementIds& from);

  inline MapElementIds& operator=(const MapElementIds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapElementIds& default_instance();

  static inline const MapElementIds* internal_default_instance() {
    return reinterpret_cast<const MapElementIds*>(
               &_MapElementIds_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MapElementIds* other);

  // implements Message ----------------------------------------------

  inline MapElementIds* New() const PROTOBUF_FINAL { return New(NULL); }

  MapElementIds* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapElementIds& from);
  void MergeFrom(const MapElementIds& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapElementIds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string lane = 1;
  int lane_size() const;
  void clear_lane();
  static const int kLaneFieldNumber = 1;
  const ::std::string& lane(int index) const;
  ::std::string* mutable_lane(int index);
  void set_lane(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lane(int index, ::std::string&& value);
  #endif
  void set_lane(int index, const char* value);
  void set_lane(int index, const char* value, size_t size);
  ::std::string* add_lane();
  void add_lane(const ::std::string& value);
  #if LANG_CXX11
  void add_lane(::std::string&& value);
  #endif
  void add_lane(const char* value);
  void add_lane(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& lane() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lane();

  // repeated string crosswalk = 2;
  int crosswalk_size() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 2;
  const ::std::string& crosswalk(int index) const;
  ::std::string* mutable_crosswalk(int index);
  void set_crosswalk(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_crosswalk(int index, ::std::string&& value);
  #endif
  void set_crosswalk(int index, const char* value);
  void set_crosswalk(int index, const char* value, size_t size);
  ::std::string* add_crosswalk();
  void add_crosswalk(const ::std::string& value);
  #if LANG_CXX11
  void add_crosswalk(::std::string&& value);
  #endif
  void add_crosswalk(const char* value);
  void add_crosswalk(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& crosswalk() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_crosswalk();

  // repeated string junction = 3;
  int junction_size() const;
  void clear_junction();
  static const int kJunctionFieldNumber = 3;
  const ::std::string& junction(int index) const;
  ::std::string* mutable_junction(int index);
  void set_junction(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_junction(int index, ::std::string&& value);
  #endif
  void set_junction(int index, const char* value);
  void set_junction(int index, const char* value, size_t size);
  ::std::string* add_junction();
  void add_junction(const ::std::string& value);
  #if LANG_CXX11
  void add_junction(::std::string&& value);
  #endif
  void add_junction(const char* value);
  void add_junction(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& junction() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_junction();

  // repeated string signal = 4;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 4;
  const ::std::string& signal(int index) const;
  ::std::string* mutable_signal(int index);
  void set_signal(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signal(int index, ::std::string&& value);
  #endif
  void set_signal(int index, const char* value);
  void set_signal(int index, const char* value, size_t size);
  ::std::string* add_signal();
  void add_signal(const ::std::string& value);
  #if LANG_CXX11
  void add_signal(::std::string&& value);
  #endif
  void add_signal(const char* value);
  void add_signal(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signal() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signal();

  // repeated string stop_sign = 5;
  int stop_sign_size() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 5;
  const ::std::string& stop_sign(int index) const;
  ::std::string* mutable_stop_sign(int index);
  void set_stop_sign(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_stop_sign(int index, ::std::string&& value);
  #endif
  void set_stop_sign(int index, const char* value);
  void set_stop_sign(int index, const char* value, size_t size);
  ::std::string* add_stop_sign();
  void add_stop_sign(const ::std::string& value);
  #if LANG_CXX11
  void add_stop_sign(::std::string&& value);
  #endif
  void add_stop_sign(const char* value);
  void add_stop_sign(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& stop_sign() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_stop_sign();

  // repeated string yield = 6;
  int yield_size() const;
  void clear_yield();
  static const int kYieldFieldNumber = 6;
  const ::std::string& yield(int index) const;
  ::std::string* mutable_yield(int index);
  void set_yield(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_yield(int index, ::std::string&& value);
  #endif
  void set_yield(int index, const char* value);
  void set_yield(int index, const char* value, size_t size);
  ::std::string* add_yield();
  void add_yield(const ::std::string& value);
  #if LANG_CXX11
  void add_yield(::std::string&& value);
  #endif
  void add_yield(const char* value);
  void add_yield(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& yield() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_yield();

  // repeated string overlap = 7;
  int overlap_size() const;
  void clear_overlap();
  static const int kOverlapFieldNumber = 7;
  const ::std::string& overlap(int index) const;
  ::std::string* mutable_overlap(int index);
  void set_overlap(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_overlap(int index, ::std::string&& value);
  #endif
  void set_overlap(int index, const char* value);
  void set_overlap(int index, const char* value, size_t size);
  ::std::string* add_overlap();
  void add_overlap(const ::std::string& value);
  #if LANG_CXX11
  void add_overlap(::std::string&& value);
  #endif
  void add_overlap(const char* value);
  void add_overlap(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& overlap() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_overlap();

  // repeated string road = 8;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 8;
  const ::std::string& road(int index) const;
  ::std::string* mutable_road(int index);
  void set_road(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_road(int index, ::std::string&& value);
  #endif
  void set_road(int index, const char* value);
  void set_road(int index, const char* value, size_t size);
  ::std::string* add_road();
  void add_road(const ::std::string& value);
  #if LANG_CXX11
  void add_road(::std::string&& value);
  #endif
  void add_road(const char* value);
  void add_road(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& road() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_road();

  // repeated string clear_area = 9;
  int clear_area_size() const;
  void clear_clear_area();
  static const int kClearAreaFieldNumber = 9;
  const ::std::string& clear_area(int index) const;
  ::std::string* mutable_clear_area(int index);
  void set_clear_area(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_clear_area(int index, ::std::string&& value);
  #endif
  void set_clear_area(int index, const char* value);
  void set_clear_area(int index, const char* value, size_t size);
  ::std::string* add_clear_area();
  void add_clear_area(const ::std::string& value);
  #if LANG_CXX11
  void add_clear_area(::std::string&& value);
  #endif
  void add_clear_area(const char* value);
  void add_clear_area(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& clear_area() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_clear_area();

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.MapElementIds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lane_;
  ::google::protobuf::RepeatedPtrField< ::std::string> crosswalk_;
  ::google::protobuf::RepeatedPtrField< ::std::string> junction_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signal_;
  ::google::protobuf::RepeatedPtrField< ::std::string> stop_sign_;
  ::google::protobuf::RepeatedPtrField< ::std::string> yield_;
  ::google::protobuf::RepeatedPtrField< ::std::string> overlap_;
  ::google::protobuf::RepeatedPtrField< ::std::string> road_;
  ::google::protobuf::RepeatedPtrField< ::std::string> clear_area_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControlData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.ControlData) */ {
 public:
  ControlData();
  virtual ~ControlData();

  ControlData(const ControlData& from);

  inline ControlData& operator=(const ControlData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlData& default_instance();

  static inline const ControlData* internal_default_instance() {
    return reinterpret_cast<const ControlData*>(
               &_ControlData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ControlData* other);

  // implements Message ----------------------------------------------

  inline ControlData* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlData& from);
  void MergeFrom(const ControlData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional double station_error = 2;
  bool has_station_error() const;
  void clear_station_error();
  static const int kStationErrorFieldNumber = 2;
  double station_error() const;
  void set_station_error(double value);

  // optional double lateral_error = 3;
  bool has_lateral_error() const;
  void clear_lateral_error();
  static const int kLateralErrorFieldNumber = 3;
  double lateral_error() const;
  void set_lateral_error(double value);

  // optional double heading_error = 4;
  bool has_heading_error() const;
  void clear_heading_error();
  static const int kHeadingErrorFieldNumber = 4;
  double heading_error() const;
  void set_heading_error(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.ControlData)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_station_error();
  void clear_has_station_error();
  void set_has_lateral_error();
  void clear_has_lateral_error();
  void set_has_heading_error();
  void clear_has_heading_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double timestamp_sec_;
  double station_error_;
  double lateral_error_;
  double heading_error_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.Notification) */ {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notification& default_instance();

  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Notification* other);

  // implements Message ----------------------------------------------

  inline Notification* New() const PROTOBUF_FINAL { return New(NULL); }

  Notification* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Notification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.common.monitor.MonitorMessageItem item = 2;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 2;
  const ::jmc_auto::common::monitor::MonitorMessageItem& item() const;
  ::jmc_auto::common::monitor::MonitorMessageItem* mutable_item();
  ::jmc_auto::common::monitor::MonitorMessageItem* release_item();
  void set_allocated_item(::jmc_auto::common::monitor::MonitorMessageItem* item);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.Notification)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_item();
  void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::common::monitor::MonitorMessageItem* item_;
  double timestamp_sec_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimulationWorld : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.dreamview.SimulationWorld) */ {
 public:
  SimulationWorld();
  virtual ~SimulationWorld();

  SimulationWorld(const SimulationWorld& from);

  inline SimulationWorld& operator=(const SimulationWorld& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulationWorld& default_instance();

  static inline const SimulationWorld* internal_default_instance() {
    return reinterpret_cast<const SimulationWorld*>(
               &_SimulationWorld_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SimulationWorld* other);

  // implements Message ----------------------------------------------

  inline SimulationWorld* New() const PROTOBUF_FINAL { return New(NULL); }

  SimulationWorld* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimulationWorld& from);
  void MergeFrom(const SimulationWorld& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimulationWorld* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.dreamview.Object object = 3;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 3;
  const ::jmc_auto::dreamview::Object& object(int index) const;
  ::jmc_auto::dreamview::Object* mutable_object(int index);
  ::jmc_auto::dreamview::Object* add_object();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >*
      mutable_object();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >&
      object() const;

  // repeated .jmc_auto.dreamview.RoutePath route_path = 6;
  int route_path_size() const;
  void clear_route_path();
  static const int kRoutePathFieldNumber = 6;
  const ::jmc_auto::dreamview::RoutePath& route_path(int index) const;
  ::jmc_auto::dreamview::RoutePath* mutable_route_path(int index);
  ::jmc_auto::dreamview::RoutePath* add_route_path();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::RoutePath >*
      mutable_route_path();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::RoutePath >&
      route_path() const;

  // repeated .jmc_auto.dreamview.Object planning_trajectory = 8;
  int planning_trajectory_size() const;
  void clear_planning_trajectory();
  static const int kPlanningTrajectoryFieldNumber = 8;
  const ::jmc_auto::dreamview::Object& planning_trajectory(int index) const;
  ::jmc_auto::dreamview::Object* mutable_planning_trajectory(int index);
  ::jmc_auto::dreamview::Object* add_planning_trajectory();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >*
      mutable_planning_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >&
      planning_trajectory() const;

  // repeated .jmc_auto.common.Path navigation_path = 23;
  int navigation_path_size() const;
  void clear_navigation_path();
  static const int kNavigationPathFieldNumber = 23;
  const ::jmc_auto::common::Path& navigation_path(int index) const;
  ::jmc_auto::common::Path* mutable_navigation_path(int index);
  ::jmc_auto::common::Path* add_navigation_path();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Path >*
      mutable_navigation_path();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Path >&
      navigation_path() const;

  // repeated .jmc_auto.dreamview.Notification notification = 25;
  int notification_size() const;
  void clear_notification();
  static const int kNotificationFieldNumber = 25;
  const ::jmc_auto::dreamview::Notification& notification(int index) const;
  ::jmc_auto::dreamview::Notification* mutable_notification(int index);
  ::jmc_auto::dreamview::Notification* add_notification();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Notification >*
      mutable_notification();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Notification >&
      notification() const;

  // optional string engage_advice = 13;
  bool has_engage_advice() const;
  void clear_engage_advice();
  static const int kEngageAdviceFieldNumber = 13;
  const ::std::string& engage_advice() const;
  void set_engage_advice(const ::std::string& value);
  #if LANG_CXX11
  void set_engage_advice(::std::string&& value);
  #endif
  void set_engage_advice(const char* value);
  void set_engage_advice(const char* value, size_t size);
  ::std::string* mutable_engage_advice();
  ::std::string* release_engage_advice();
  void set_allocated_engage_advice(::std::string* engage_advice);

  // optional .jmc_auto.dreamview.Object auto_driving_car = 4;
  bool has_auto_driving_car() const;
  void clear_auto_driving_car();
  static const int kAutoDrivingCarFieldNumber = 4;
  const ::jmc_auto::dreamview::Object& auto_driving_car() const;
  ::jmc_auto::dreamview::Object* mutable_auto_driving_car();
  ::jmc_auto::dreamview::Object* release_auto_driving_car();
  void set_allocated_auto_driving_car(::jmc_auto::dreamview::Object* auto_driving_car);

  // optional .jmc_auto.dreamview.Object traffic_signal = 5;
  bool has_traffic_signal() const;
  void clear_traffic_signal();
  static const int kTrafficSignalFieldNumber = 5;
  const ::jmc_auto::dreamview::Object& traffic_signal() const;
  ::jmc_auto::dreamview::Object* mutable_traffic_signal();
  ::jmc_auto::dreamview::Object* release_traffic_signal();
  void set_allocated_traffic_signal(::jmc_auto::dreamview::Object* traffic_signal);

  // optional .jmc_auto.dreamview.Object main_stop = 9 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_main_stop() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_main_stop();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kMainStopFieldNumber = 9;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::jmc_auto::dreamview::Object& main_stop() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::jmc_auto::dreamview::Object* mutable_main_stop();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::jmc_auto::dreamview::Object* release_main_stop();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_main_stop(::jmc_auto::dreamview::Object* main_stop);

  // optional .jmc_auto.dreamview.DelaysInMs delay = 11;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 11;
  const ::jmc_auto::dreamview::DelaysInMs& delay() const;
  ::jmc_auto::dreamview::DelaysInMs* mutable_delay();
  ::jmc_auto::dreamview::DelaysInMs* release_delay();
  void set_allocated_delay(::jmc_auto::dreamview::DelaysInMs* delay);

  // optional .jmc_auto.common.monitor.MonitorMessage monitor = 12 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_monitor() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_monitor();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kMonitorFieldNumber = 12;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::jmc_auto::common::monitor::MonitorMessage& monitor() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::jmc_auto::common::monitor::MonitorMessage* mutable_monitor();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::jmc_auto::common::monitor::MonitorMessage* release_monitor();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_monitor(::jmc_auto::common::monitor::MonitorMessage* monitor);

  // optional .jmc_auto.dreamview.Latency latency = 14;
  bool has_latency() const;
  void clear_latency();
  static const int kLatencyFieldNumber = 14;
  const ::jmc_auto::dreamview::Latency& latency() const;
  ::jmc_auto::dreamview::Latency* mutable_latency();
  ::jmc_auto::dreamview::Latency* release_latency();
  void set_allocated_latency(::jmc_auto::dreamview::Latency* latency);

  // optional .jmc_auto.dreamview.MapElementIds map_element_ids = 15;
  bool has_map_element_ids() const;
  void clear_map_element_ids();
  static const int kMapElementIdsFieldNumber = 15;
  const ::jmc_auto::dreamview::MapElementIds& map_element_ids() const;
  ::jmc_auto::dreamview::MapElementIds* mutable_map_element_ids();
  ::jmc_auto::dreamview::MapElementIds* release_map_element_ids();
  void set_allocated_map_element_ids(::jmc_auto::dreamview::MapElementIds* map_element_ids);

  // optional .jmc_auto.planning_internal.PlanningData planning_data = 19;
  bool has_planning_data() const;
  void clear_planning_data();
  static const int kPlanningDataFieldNumber = 19;
  const ::jmc_auto::planning_internal::PlanningData& planning_data() const;
  ::jmc_auto::planning_internal::PlanningData* mutable_planning_data();
  ::jmc_auto::planning_internal::PlanningData* release_planning_data();
  void set_allocated_planning_data(::jmc_auto::planning_internal::PlanningData* planning_data);

  // optional .jmc_auto.dreamview.Object gps = 20;
  bool has_gps() const;
  void clear_gps();
  static const int kGpsFieldNumber = 20;
  const ::jmc_auto::dreamview::Object& gps() const;
  ::jmc_auto::dreamview::Object* mutable_gps();
  ::jmc_auto::dreamview::Object* release_gps();
  void set_allocated_gps(::jmc_auto::dreamview::Object* gps);

  // optional .jmc_auto.perception.LaneMarkers lane_marker = 21;
  bool has_lane_marker() const;
  void clear_lane_marker();
  static const int kLaneMarkerFieldNumber = 21;
  const ::jmc_auto::perception::LaneMarkers& lane_marker() const;
  ::jmc_auto::perception::LaneMarkers* mutable_lane_marker();
  ::jmc_auto::perception::LaneMarkers* release_lane_marker();
  void set_allocated_lane_marker(::jmc_auto::perception::LaneMarkers* lane_marker);

  // optional .jmc_auto.dreamview.ControlData control_data = 22;
  bool has_control_data() const;
  void clear_control_data();
  static const int kControlDataFieldNumber = 22;
  const ::jmc_auto::dreamview::ControlData& control_data() const;
  ::jmc_auto::dreamview::ControlData* mutable_control_data();
  ::jmc_auto::dreamview::ControlData* release_control_data();
  void set_allocated_control_data(::jmc_auto::dreamview::ControlData* control_data);

  // optional .jmc_auto.dreamview.Object main_decision = 24;
  bool has_main_decision() const;
  void clear_main_decision();
  static const int kMainDecisionFieldNumber = 24;
  const ::jmc_auto::dreamview::Object& main_decision() const;
  ::jmc_auto::dreamview::Object* mutable_main_decision();
  ::jmc_auto::dreamview::Object* release_main_decision();
  void set_allocated_main_decision(::jmc_auto::dreamview::Object* main_decision);

  // optional double timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // optional double routing_time = 7;
  bool has_routing_time() const;
  void clear_routing_time();
  static const int kRoutingTimeFieldNumber = 7;
  double routing_time() const;
  void set_routing_time(double value);

  // optional double speed_limit = 10;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 10;
  double speed_limit() const;
  void set_speed_limit(double value);

  // optional uint64 map_hash = 16;
  bool has_map_hash() const;
  void clear_map_hash();
  static const int kMapHashFieldNumber = 16;
  ::google::protobuf::uint64 map_hash() const;
  void set_map_hash(::google::protobuf::uint64 value);

  // optional double map_radius = 17;
  bool has_map_radius() const;
  void clear_map_radius();
  static const int kMapRadiusFieldNumber = 17;
  double map_radius() const;
  void set_map_radius(double value);

  // optional double planning_time = 18;
  bool has_planning_time() const;
  void clear_planning_time();
  static const int kPlanningTimeFieldNumber = 18;
  double planning_time() const;
  void set_planning_time(double value);

  // optional uint32 sequence_num = 2;
  bool has_sequence_num() const;
  void clear_sequence_num();
  static const int kSequenceNumFieldNumber = 2;
  ::google::protobuf::uint32 sequence_num() const;
  void set_sequence_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.dreamview.SimulationWorld)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sequence_num();
  void clear_has_sequence_num();
  void set_has_auto_driving_car();
  void clear_has_auto_driving_car();
  void set_has_traffic_signal();
  void clear_has_traffic_signal();
  void set_has_routing_time();
  void clear_has_routing_time();
  void set_has_main_stop();
  void clear_has_main_stop();
  void set_has_main_decision();
  void clear_has_main_decision();
  void set_has_speed_limit();
  void clear_has_speed_limit();
  void set_has_delay();
  void clear_has_delay();
  void set_has_monitor();
  void clear_has_monitor();
  void set_has_engage_advice();
  void clear_has_engage_advice();
  void set_has_latency();
  void clear_has_latency();
  void set_has_map_element_ids();
  void clear_has_map_element_ids();
  void set_has_map_hash();
  void clear_has_map_hash();
  void set_has_map_radius();
  void clear_has_map_radius();
  void set_has_planning_time();
  void clear_has_planning_time();
  void set_has_planning_data();
  void clear_has_planning_data();
  void set_has_gps();
  void clear_has_gps();
  void set_has_lane_marker();
  void clear_has_lane_marker();
  void set_has_control_data();
  void clear_has_control_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object > object_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::RoutePath > route_path_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object > planning_trajectory_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Path > navigation_path_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Notification > notification_;
  ::google::protobuf::internal::ArenaStringPtr engage_advice_;
  ::jmc_auto::dreamview::Object* auto_driving_car_;
  ::jmc_auto::dreamview::Object* traffic_signal_;
  ::jmc_auto::dreamview::Object* main_stop_;
  ::jmc_auto::dreamview::DelaysInMs* delay_;
  ::jmc_auto::common::monitor::MonitorMessage* monitor_;
  ::jmc_auto::dreamview::Latency* latency_;
  ::jmc_auto::dreamview::MapElementIds* map_element_ids_;
  ::jmc_auto::planning_internal::PlanningData* planning_data_;
  ::jmc_auto::dreamview::Object* gps_;
  ::jmc_auto::perception::LaneMarkers* lane_marker_;
  ::jmc_auto::dreamview::ControlData* control_data_;
  ::jmc_auto::dreamview::Object* main_decision_;
  double timestamp_;
  double routing_time_;
  double speed_limit_;
  ::google::protobuf::uint64 map_hash_;
  double map_radius_;
  double planning_time_;
  ::google::protobuf::uint32 sequence_num_;
  friend struct protobuf_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PolygonPoint

// optional double x = 1;
inline bool PolygonPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolygonPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PolygonPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PolygonPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double PolygonPoint::x() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.PolygonPoint.x)
  return x_;
}
inline void PolygonPoint::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.PolygonPoint.x)
}

// optional double y = 2;
inline bool PolygonPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolygonPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PolygonPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PolygonPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double PolygonPoint::y() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.PolygonPoint.y)
  return y_;
}
inline void PolygonPoint::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.PolygonPoint.y)
}

// optional double z = 3 [default = 0];
inline bool PolygonPoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PolygonPoint::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PolygonPoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PolygonPoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double PolygonPoint::z() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.PolygonPoint.z)
  return z_;
}
inline void PolygonPoint::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.PolygonPoint.z)
}

// -------------------------------------------------------------------

// Prediction

// optional double probability = 1;
inline bool Prediction::has_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prediction::set_has_probability() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prediction::clear_has_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prediction::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline double Prediction::probability() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Prediction.probability)
  return probability_;
}
inline void Prediction::set_probability(double value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Prediction.probability)
}

// repeated .jmc_auto.dreamview.PolygonPoint predicted_trajectory = 2;
inline int Prediction::predicted_trajectory_size() const {
  return predicted_trajectory_.size();
}
inline void Prediction::clear_predicted_trajectory() {
  predicted_trajectory_.Clear();
}
inline const ::jmc_auto::dreamview::PolygonPoint& Prediction::predicted_trajectory(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Prediction.predicted_trajectory)
  return predicted_trajectory_.Get(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* Prediction::mutable_predicted_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Prediction.predicted_trajectory)
  return predicted_trajectory_.Mutable(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* Prediction::add_predicted_trajectory() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Prediction.predicted_trajectory)
  return predicted_trajectory_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
Prediction::mutable_predicted_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.Prediction.predicted_trajectory)
  return &predicted_trajectory_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
Prediction::predicted_trajectory() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.Prediction.predicted_trajectory)
  return predicted_trajectory_;
}

// -------------------------------------------------------------------

// Decision

// optional .jmc_auto.dreamview.Decision.Type type = 1 [default = IGNORE];
inline bool Decision::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Decision::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Decision::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Decision::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::jmc_auto::dreamview::Decision_Type Decision::type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.type)
  return static_cast< ::jmc_auto::dreamview::Decision_Type >(type_);
}
inline void Decision::set_type(::jmc_auto::dreamview::Decision_Type value) {
  assert(::jmc_auto::dreamview::Decision_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.type)
}

// repeated .jmc_auto.dreamview.PolygonPoint polygon_point = 2;
inline int Decision::polygon_point_size() const {
  return polygon_point_.size();
}
inline void Decision::clear_polygon_point() {
  polygon_point_.Clear();
}
inline const ::jmc_auto::dreamview::PolygonPoint& Decision::polygon_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.polygon_point)
  return polygon_point_.Get(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* Decision::mutable_polygon_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Decision.polygon_point)
  return polygon_point_.Mutable(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* Decision::add_polygon_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Decision.polygon_point)
  return polygon_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
Decision::mutable_polygon_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.Decision.polygon_point)
  return &polygon_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
Decision::polygon_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.Decision.polygon_point)
  return polygon_point_;
}

// optional double heading = 3;
inline bool Decision::has_heading() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Decision::set_has_heading() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Decision::clear_has_heading() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Decision::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double Decision::heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.heading)
  return heading_;
}
inline void Decision::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.heading)
}

// optional double latitude = 4;
inline bool Decision::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Decision::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Decision::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Decision::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Decision::latitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.latitude)
  return latitude_;
}
inline void Decision::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.latitude)
}

// optional double longitude = 5;
inline bool Decision::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Decision::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Decision::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Decision::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Decision::longitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.longitude)
  return longitude_;
}
inline void Decision::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.longitude)
}

// optional double position_x = 6;
inline bool Decision::has_position_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Decision::set_has_position_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Decision::clear_has_position_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Decision::clear_position_x() {
  position_x_ = 0;
  clear_has_position_x();
}
inline double Decision::position_x() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.position_x)
  return position_x_;
}
inline void Decision::set_position_x(double value) {
  set_has_position_x();
  position_x_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.position_x)
}

// optional double position_y = 7;
inline bool Decision::has_position_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Decision::set_has_position_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Decision::clear_has_position_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Decision::clear_position_y() {
  position_y_ = 0;
  clear_has_position_y();
}
inline double Decision::position_y() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.position_y)
  return position_y_;
}
inline void Decision::set_position_y(double value) {
  set_has_position_y();
  position_y_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.position_y)
}

// optional double length = 8 [default = 2.8];
inline bool Decision::has_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Decision::set_has_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Decision::clear_has_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Decision::clear_length() {
  length_ = 2.8;
  clear_has_length();
}
inline double Decision::length() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.length)
  return length_;
}
inline void Decision::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.length)
}

// optional double width = 9 [default = 1.4];
inline bool Decision::has_width() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Decision::set_has_width() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Decision::clear_has_width() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Decision::clear_width() {
  width_ = 1.4;
  clear_has_width();
}
inline double Decision::width() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.width)
  return width_;
}
inline void Decision::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.width)
}

// optional double height = 10 [default = 1.8];
inline bool Decision::has_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Decision::set_has_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Decision::clear_has_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Decision::clear_height() {
  height_ = 1.8;
  clear_has_height();
}
inline double Decision::height() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.height)
  return height_;
}
inline void Decision::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.height)
}

// optional .jmc_auto.dreamview.Decision.StopReasonCode stopReason = 11;
inline bool Decision::has_stopreason() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Decision::set_has_stopreason() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Decision::clear_has_stopreason() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Decision::clear_stopreason() {
  stopreason_ = 1;
  clear_has_stopreason();
}
inline ::jmc_auto::dreamview::Decision_StopReasonCode Decision::stopreason() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.stopReason)
  return static_cast< ::jmc_auto::dreamview::Decision_StopReasonCode >(stopreason_);
}
inline void Decision::set_stopreason(::jmc_auto::dreamview::Decision_StopReasonCode value) {
  assert(::jmc_auto::dreamview::Decision_StopReasonCode_IsValid(value));
  set_has_stopreason();
  stopreason_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.stopReason)
}

// optional .jmc_auto.routing.ChangeLaneType change_lane_type = 12;
inline bool Decision::has_change_lane_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Decision::set_has_change_lane_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Decision::clear_has_change_lane_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Decision::clear_change_lane_type() {
  change_lane_type_ = 0;
  clear_has_change_lane_type();
}
inline ::jmc_auto::routing::ChangeLaneType Decision::change_lane_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Decision.change_lane_type)
  return static_cast< ::jmc_auto::routing::ChangeLaneType >(change_lane_type_);
}
inline void Decision::set_change_lane_type(::jmc_auto::routing::ChangeLaneType value) {
  assert(::jmc_auto::routing::ChangeLaneType_IsValid(value));
  set_has_change_lane_type();
  change_lane_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Decision.change_lane_type)
}

// -------------------------------------------------------------------

// Object

// optional string id = 1;
inline bool Object::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.id)
  return id_.GetNoArena();
}
inline void Object::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.id)
}
#if LANG_CXX11
inline void Object::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.dreamview.Object.id)
}
#endif
inline void Object::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.Object.id)
}
inline void Object::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.Object.id)
}
inline ::std::string* Object::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Object.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.Object.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.Object.id)
}

// repeated .jmc_auto.dreamview.PolygonPoint polygon_point = 2;
inline int Object::polygon_point_size() const {
  return polygon_point_.size();
}
inline void Object::clear_polygon_point() {
  polygon_point_.Clear();
}
inline const ::jmc_auto::dreamview::PolygonPoint& Object::polygon_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.polygon_point)
  return polygon_point_.Get(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* Object::mutable_polygon_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Object.polygon_point)
  return polygon_point_.Mutable(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* Object::add_polygon_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Object.polygon_point)
  return polygon_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
Object::mutable_polygon_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.Object.polygon_point)
  return &polygon_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
Object::polygon_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.Object.polygon_point)
  return polygon_point_;
}

// optional double heading = 3;
inline bool Object::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Object::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Object::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Object::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double Object::heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.heading)
  return heading_;
}
inline void Object::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.heading)
}

// optional double latitude = 4;
inline bool Object::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Object::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Object::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Object::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Object::latitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.latitude)
  return latitude_;
}
inline void Object::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.latitude)
}

// optional double longitude = 5;
inline bool Object::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Object::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Object::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Object::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Object::longitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.longitude)
  return longitude_;
}
inline void Object::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.longitude)
}

// optional double position_x = 6;
inline bool Object::has_position_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Object::set_has_position_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Object::clear_has_position_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Object::clear_position_x() {
  position_x_ = 0;
  clear_has_position_x();
}
inline double Object::position_x() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.position_x)
  return position_x_;
}
inline void Object::set_position_x(double value) {
  set_has_position_x();
  position_x_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.position_x)
}

// optional double position_y = 7;
inline bool Object::has_position_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Object::set_has_position_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Object::clear_has_position_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Object::clear_position_y() {
  position_y_ = 0;
  clear_has_position_y();
}
inline double Object::position_y() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.position_y)
  return position_y_;
}
inline void Object::set_position_y(double value) {
  set_has_position_y();
  position_y_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.position_y)
}

// optional double length = 8 [default = 2.8];
inline bool Object::has_length() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Object::set_has_length() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Object::clear_has_length() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Object::clear_length() {
  length_ = 2.8;
  clear_has_length();
}
inline double Object::length() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.length)
  return length_;
}
inline void Object::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.length)
}

// optional double width = 9 [default = 1.4];
inline bool Object::has_width() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Object::set_has_width() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Object::clear_has_width() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Object::clear_width() {
  width_ = 1.4;
  clear_has_width();
}
inline double Object::width() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.width)
  return width_;
}
inline void Object::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.width)
}

// optional double height = 10 [default = 1.8];
inline bool Object::has_height() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Object::set_has_height() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Object::clear_has_height() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Object::clear_height() {
  height_ = 1.8;
  clear_has_height();
}
inline double Object::height() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.height)
  return height_;
}
inline void Object::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.height)
}

// optional double speed = 11;
inline bool Object::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Object::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Object::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Object::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Object::speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.speed)
  return speed_;
}
inline void Object::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.speed)
}

// optional double speed_acceleration = 12;
inline bool Object::has_speed_acceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Object::set_has_speed_acceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Object::clear_has_speed_acceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Object::clear_speed_acceleration() {
  speed_acceleration_ = 0;
  clear_has_speed_acceleration();
}
inline double Object::speed_acceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.speed_acceleration)
  return speed_acceleration_;
}
inline void Object::set_speed_acceleration(double value) {
  set_has_speed_acceleration();
  speed_acceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.speed_acceleration)
}

// optional double speed_jerk = 13;
inline bool Object::has_speed_jerk() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Object::set_has_speed_jerk() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Object::clear_has_speed_jerk() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Object::clear_speed_jerk() {
  speed_jerk_ = 0;
  clear_has_speed_jerk();
}
inline double Object::speed_jerk() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.speed_jerk)
  return speed_jerk_;
}
inline void Object::set_speed_jerk(double value) {
  set_has_speed_jerk();
  speed_jerk_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.speed_jerk)
}

// optional double spin = 14;
inline bool Object::has_spin() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Object::set_has_spin() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Object::clear_has_spin() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Object::clear_spin() {
  spin_ = 0;
  clear_has_spin();
}
inline double Object::spin() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.spin)
  return spin_;
}
inline void Object::set_spin(double value) {
  set_has_spin();
  spin_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.spin)
}

// optional double spin_acceleration = 15;
inline bool Object::has_spin_acceleration() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Object::set_has_spin_acceleration() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Object::clear_has_spin_acceleration() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Object::clear_spin_acceleration() {
  spin_acceleration_ = 0;
  clear_has_spin_acceleration();
}
inline double Object::spin_acceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.spin_acceleration)
  return spin_acceleration_;
}
inline void Object::set_spin_acceleration(double value) {
  set_has_spin_acceleration();
  spin_acceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.spin_acceleration)
}

// optional double spin_jerk = 16;
inline bool Object::has_spin_jerk() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Object::set_has_spin_jerk() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Object::clear_has_spin_jerk() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Object::clear_spin_jerk() {
  spin_jerk_ = 0;
  clear_has_spin_jerk();
}
inline double Object::spin_jerk() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.spin_jerk)
  return spin_jerk_;
}
inline void Object::set_spin_jerk(double value) {
  set_has_spin_jerk();
  spin_jerk_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.spin_jerk)
}

// optional double speed_heading = 17;
inline bool Object::has_speed_heading() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Object::set_has_speed_heading() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Object::clear_has_speed_heading() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Object::clear_speed_heading() {
  speed_heading_ = 0;
  clear_has_speed_heading();
}
inline double Object::speed_heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.speed_heading)
  return speed_heading_;
}
inline void Object::set_speed_heading(double value) {
  set_has_speed_heading();
  speed_heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.speed_heading)
}

// optional double kappa = 18;
inline bool Object::has_kappa() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Object::set_has_kappa() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Object::clear_has_kappa() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Object::clear_kappa() {
  kappa_ = 0;
  clear_has_kappa();
}
inline double Object::kappa() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.kappa)
  return kappa_;
}
inline void Object::set_kappa(double value) {
  set_has_kappa();
  kappa_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.kappa)
}

// repeated string signal_set = 19;
inline int Object::signal_set_size() const {
  return signal_set_.size();
}
inline void Object::clear_signal_set() {
  signal_set_.Clear();
}
inline const ::std::string& Object::signal_set(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.signal_set)
  return signal_set_.Get(index);
}
inline ::std::string* Object::mutable_signal_set(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Object.signal_set)
  return signal_set_.Mutable(index);
}
inline void Object::set_signal_set(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.signal_set)
  signal_set_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Object::set_signal_set(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.signal_set)
  signal_set_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Object::set_signal_set(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signal_set_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.Object.signal_set)
}
inline void Object::set_signal_set(int index, const char* value, size_t size) {
  signal_set_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.Object.signal_set)
}
inline ::std::string* Object::add_signal_set() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.Object.signal_set)
  return signal_set_.Add();
}
inline void Object::add_signal_set(const ::std::string& value) {
  signal_set_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Object.signal_set)
}
#if LANG_CXX11
inline void Object::add_signal_set(::std::string&& value) {
  signal_set_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Object.signal_set)
}
#endif
inline void Object::add_signal_set(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signal_set_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.Object.signal_set)
}
inline void Object::add_signal_set(const char* value, size_t size) {
  signal_set_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.Object.signal_set)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Object::signal_set() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.Object.signal_set)
  return signal_set_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Object::mutable_signal_set() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.Object.signal_set)
  return &signal_set_;
}

// optional string current_signal = 20;
inline bool Object::has_current_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object::set_has_current_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object::clear_has_current_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object::clear_current_signal() {
  current_signal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_signal();
}
inline const ::std::string& Object::current_signal() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.current_signal)
  return current_signal_.GetNoArena();
}
inline void Object::set_current_signal(const ::std::string& value) {
  set_has_current_signal();
  current_signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.current_signal)
}
#if LANG_CXX11
inline void Object::set_current_signal(::std::string&& value) {
  set_has_current_signal();
  current_signal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.dreamview.Object.current_signal)
}
#endif
inline void Object::set_current_signal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_current_signal();
  current_signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.Object.current_signal)
}
inline void Object::set_current_signal(const char* value, size_t size) {
  set_has_current_signal();
  current_signal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.Object.current_signal)
}
inline ::std::string* Object::mutable_current_signal() {
  set_has_current_signal();
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Object.current_signal)
  return current_signal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_current_signal() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.Object.current_signal)
  clear_has_current_signal();
  return current_signal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_current_signal(::std::string* current_signal) {
  if (current_signal != NULL) {
    set_has_current_signal();
  } else {
    clear_has_current_signal();
  }
  current_signal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_signal);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.Object.current_signal)
}

// optional double timestamp_sec = 21;
inline bool Object::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Object::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Object::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Object::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double Object::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.timestamp_sec)
  return timestamp_sec_;
}
inline void Object::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.timestamp_sec)
}

// repeated .jmc_auto.dreamview.Decision decision = 22;
inline int Object::decision_size() const {
  return decision_.size();
}
inline void Object::clear_decision() {
  decision_.Clear();
}
inline const ::jmc_auto::dreamview::Decision& Object::decision(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.decision)
  return decision_.Get(index);
}
inline ::jmc_auto::dreamview::Decision* Object::mutable_decision(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Object.decision)
  return decision_.Mutable(index);
}
inline ::jmc_auto::dreamview::Decision* Object::add_decision() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Object.decision)
  return decision_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Decision >*
Object::mutable_decision() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.Object.decision)
  return &decision_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Decision >&
Object::decision() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.Object.decision)
  return decision_;
}

// optional bool yielded_obstacle = 33 [default = false];
inline bool Object::has_yielded_obstacle() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Object::set_has_yielded_obstacle() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Object::clear_has_yielded_obstacle() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Object::clear_yielded_obstacle() {
  yielded_obstacle_ = false;
  clear_has_yielded_obstacle();
}
inline bool Object::yielded_obstacle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.yielded_obstacle)
  return yielded_obstacle_;
}
inline void Object::set_yielded_obstacle(bool value) {
  set_has_yielded_obstacle();
  yielded_obstacle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.yielded_obstacle)
}

// optional double throttle_percentage = 23;
inline bool Object::has_throttle_percentage() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Object::set_has_throttle_percentage() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Object::clear_has_throttle_percentage() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Object::clear_throttle_percentage() {
  throttle_percentage_ = 0;
  clear_has_throttle_percentage();
}
inline double Object::throttle_percentage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.throttle_percentage)
  return throttle_percentage_;
}
inline void Object::set_throttle_percentage(double value) {
  set_has_throttle_percentage();
  throttle_percentage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.throttle_percentage)
}

// optional double brake_percentage = 24;
inline bool Object::has_brake_percentage() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Object::set_has_brake_percentage() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Object::clear_has_brake_percentage() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Object::clear_brake_percentage() {
  brake_percentage_ = 0;
  clear_has_brake_percentage();
}
inline double Object::brake_percentage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.brake_percentage)
  return brake_percentage_;
}
inline void Object::set_brake_percentage(double value) {
  set_has_brake_percentage();
  brake_percentage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.brake_percentage)
}

// optional double steering_percentage = 25;
inline bool Object::has_steering_percentage() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Object::set_has_steering_percentage() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Object::clear_has_steering_percentage() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Object::clear_steering_percentage() {
  steering_percentage_ = 0;
  clear_has_steering_percentage();
}
inline double Object::steering_percentage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.steering_percentage)
  return steering_percentage_;
}
inline void Object::set_steering_percentage(double value) {
  set_has_steering_percentage();
  steering_percentage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.steering_percentage)
}

// optional double steering_angle = 26;
inline bool Object::has_steering_angle() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Object::set_has_steering_angle() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Object::clear_has_steering_angle() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Object::clear_steering_angle() {
  steering_angle_ = 0;
  clear_has_steering_angle();
}
inline double Object::steering_angle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.steering_angle)
  return steering_angle_;
}
inline void Object::set_steering_angle(double value) {
  set_has_steering_angle();
  steering_angle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.steering_angle)
}

// optional double steering_ratio = 27;
inline bool Object::has_steering_ratio() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Object::set_has_steering_ratio() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Object::clear_has_steering_ratio() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Object::clear_steering_ratio() {
  steering_ratio_ = 0;
  clear_has_steering_ratio();
}
inline double Object::steering_ratio() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.steering_ratio)
  return steering_ratio_;
}
inline void Object::set_steering_ratio(double value) {
  set_has_steering_ratio();
  steering_ratio_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.steering_ratio)
}

// optional .jmc_auto.dreamview.Object.DisengageType disengage_type = 28;
inline bool Object::has_disengage_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Object::set_has_disengage_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Object::clear_has_disengage_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Object::clear_disengage_type() {
  disengage_type_ = 0;
  clear_has_disengage_type();
}
inline ::jmc_auto::dreamview::Object_DisengageType Object::disengage_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.disengage_type)
  return static_cast< ::jmc_auto::dreamview::Object_DisengageType >(disengage_type_);
}
inline void Object::set_disengage_type(::jmc_auto::dreamview::Object_DisengageType value) {
  assert(::jmc_auto::dreamview::Object_DisengageType_IsValid(value));
  set_has_disengage_type();
  disengage_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.disengage_type)
}

// optional .jmc_auto.dreamview.Object.Type type = 29;
inline bool Object::has_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Object::set_has_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Object::clear_has_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Object::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::jmc_auto::dreamview::Object_Type Object::type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.type)
  return static_cast< ::jmc_auto::dreamview::Object_Type >(type_);
}
inline void Object::set_type(::jmc_auto::dreamview::Object_Type value) {
  assert(::jmc_auto::dreamview::Object_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.type)
}

// repeated .jmc_auto.dreamview.Prediction prediction = 30;
inline int Object::prediction_size() const {
  return prediction_.size();
}
inline void Object::clear_prediction() {
  prediction_.Clear();
}
inline const ::jmc_auto::dreamview::Prediction& Object::prediction(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.prediction)
  return prediction_.Get(index);
}
inline ::jmc_auto::dreamview::Prediction* Object::mutable_prediction(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Object.prediction)
  return prediction_.Mutable(index);
}
inline ::jmc_auto::dreamview::Prediction* Object::add_prediction() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.Object.prediction)
  return prediction_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Prediction >*
Object::mutable_prediction() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.Object.prediction)
  return &prediction_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Prediction >&
Object::prediction() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.Object.prediction)
  return prediction_;
}

// optional double confidence = 31 [default = 1];
inline bool Object::has_confidence() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Object::set_has_confidence() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Object::clear_has_confidence() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Object::clear_confidence() {
  confidence_ = 1;
  clear_has_confidence();
}
inline double Object::confidence() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.confidence)
  return confidence_;
}
inline void Object::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.confidence)
}

// optional .jmc_auto.dreamview.Object.DisengageTypegear disengage_typegear = 32;
inline bool Object::has_disengage_typegear() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Object::set_has_disengage_typegear() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Object::clear_has_disengage_typegear() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Object::clear_disengage_typegear() {
  disengage_typegear_ = 0;
  clear_has_disengage_typegear();
}
inline ::jmc_auto::dreamview::Object_DisengageTypegear Object::disengage_typegear() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Object.disengage_typegear)
  return static_cast< ::jmc_auto::dreamview::Object_DisengageTypegear >(disengage_typegear_);
}
inline void Object::set_disengage_typegear(::jmc_auto::dreamview::Object_DisengageTypegear value) {
  assert(::jmc_auto::dreamview::Object_DisengageTypegear_IsValid(value));
  set_has_disengage_typegear();
  disengage_typegear_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Object.disengage_typegear)
}

// -------------------------------------------------------------------

// DelaysInMs

// optional double chassis = 1;
inline bool DelaysInMs::has_chassis() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelaysInMs::set_has_chassis() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelaysInMs::clear_has_chassis() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelaysInMs::clear_chassis() {
  chassis_ = 0;
  clear_has_chassis();
}
inline double DelaysInMs::chassis() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.chassis)
  return chassis_;
}
inline void DelaysInMs::set_chassis(double value) {
  set_has_chassis();
  chassis_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.chassis)
}

// optional double localization = 3;
inline bool DelaysInMs::has_localization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelaysInMs::set_has_localization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelaysInMs::clear_has_localization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelaysInMs::clear_localization() {
  localization_ = 0;
  clear_has_localization();
}
inline double DelaysInMs::localization() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.localization)
  return localization_;
}
inline void DelaysInMs::set_localization(double value) {
  set_has_localization();
  localization_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.localization)
}

// optional double perception_obstacle = 4;
inline bool DelaysInMs::has_perception_obstacle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DelaysInMs::set_has_perception_obstacle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DelaysInMs::clear_has_perception_obstacle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DelaysInMs::clear_perception_obstacle() {
  perception_obstacle_ = 0;
  clear_has_perception_obstacle();
}
inline double DelaysInMs::perception_obstacle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.perception_obstacle)
  return perception_obstacle_;
}
inline void DelaysInMs::set_perception_obstacle(double value) {
  set_has_perception_obstacle();
  perception_obstacle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.perception_obstacle)
}

// optional double planning = 5;
inline bool DelaysInMs::has_planning() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DelaysInMs::set_has_planning() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DelaysInMs::clear_has_planning() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DelaysInMs::clear_planning() {
  planning_ = 0;
  clear_has_planning();
}
inline double DelaysInMs::planning() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.planning)
  return planning_;
}
inline void DelaysInMs::set_planning(double value) {
  set_has_planning();
  planning_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.planning)
}

// optional double prediction = 7;
inline bool DelaysInMs::has_prediction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DelaysInMs::set_has_prediction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DelaysInMs::clear_has_prediction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DelaysInMs::clear_prediction() {
  prediction_ = 0;
  clear_has_prediction();
}
inline double DelaysInMs::prediction() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.prediction)
  return prediction_;
}
inline void DelaysInMs::set_prediction(double value) {
  set_has_prediction();
  prediction_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.prediction)
}

// optional double traffic_light = 8;
inline bool DelaysInMs::has_traffic_light() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DelaysInMs::set_has_traffic_light() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DelaysInMs::clear_has_traffic_light() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DelaysInMs::clear_traffic_light() {
  traffic_light_ = 0;
  clear_has_traffic_light();
}
inline double DelaysInMs::traffic_light() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.traffic_light)
  return traffic_light_;
}
inline void DelaysInMs::set_traffic_light(double value) {
  set_has_traffic_light();
  traffic_light_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.traffic_light)
}

// optional double control = 9;
inline bool DelaysInMs::has_control() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DelaysInMs::set_has_control() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DelaysInMs::clear_has_control() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DelaysInMs::clear_control() {
  control_ = 0;
  clear_has_control();
}
inline double DelaysInMs::control() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.DelaysInMs.control)
  return control_;
}
inline void DelaysInMs::set_control(double value) {
  set_has_control();
  control_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.DelaysInMs.control)
}

// -------------------------------------------------------------------

// RoutePath

// repeated .jmc_auto.dreamview.PolygonPoint point = 1;
inline int RoutePath::point_size() const {
  return point_.size();
}
inline void RoutePath::clear_point() {
  point_.Clear();
}
inline const ::jmc_auto::dreamview::PolygonPoint& RoutePath::point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.RoutePath.point)
  return point_.Get(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* RoutePath::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.RoutePath.point)
  return point_.Mutable(index);
}
inline ::jmc_auto::dreamview::PolygonPoint* RoutePath::add_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.RoutePath.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >*
RoutePath::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.RoutePath.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::PolygonPoint >&
RoutePath::point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.RoutePath.point)
  return point_;
}

// -------------------------------------------------------------------

// Latency

// optional double planning = 1;
inline bool Latency::has_planning() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Latency::set_has_planning() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Latency::clear_has_planning() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Latency::clear_planning() {
  planning_ = 0;
  clear_has_planning();
}
inline double Latency::planning() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Latency.planning)
  return planning_;
}
inline void Latency::set_planning(double value) {
  set_has_planning();
  planning_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Latency.planning)
}

// -------------------------------------------------------------------

// MapElementIds

// repeated string lane = 1;
inline int MapElementIds::lane_size() const {
  return lane_.size();
}
inline void MapElementIds::clear_lane() {
  lane_.Clear();
}
inline const ::std::string& MapElementIds::lane(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.lane)
  return lane_.Get(index);
}
inline ::std::string* MapElementIds::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.lane)
  return lane_.Mutable(index);
}
inline void MapElementIds::set_lane(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.lane)
  lane_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_lane(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.lane)
  lane_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_lane(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.lane)
}
inline void MapElementIds::set_lane(int index, const char* value, size_t size) {
  lane_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.lane)
}
inline ::std::string* MapElementIds::add_lane() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.lane)
  return lane_.Add();
}
inline void MapElementIds::add_lane(const ::std::string& value) {
  lane_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.lane)
}
#if LANG_CXX11
inline void MapElementIds::add_lane(::std::string&& value) {
  lane_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.lane)
}
#endif
inline void MapElementIds::add_lane(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.lane)
}
inline void MapElementIds::add_lane(const char* value, size_t size) {
  lane_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.lane)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::lane() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.lane)
  return lane_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.lane)
  return &lane_;
}

// repeated string crosswalk = 2;
inline int MapElementIds::crosswalk_size() const {
  return crosswalk_.size();
}
inline void MapElementIds::clear_crosswalk() {
  crosswalk_.Clear();
}
inline const ::std::string& MapElementIds::crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.crosswalk)
  return crosswalk_.Get(index);
}
inline ::std::string* MapElementIds::mutable_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.crosswalk)
  return crosswalk_.Mutable(index);
}
inline void MapElementIds::set_crosswalk(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.crosswalk)
  crosswalk_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_crosswalk(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.crosswalk)
  crosswalk_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_crosswalk(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  crosswalk_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.crosswalk)
}
inline void MapElementIds::set_crosswalk(int index, const char* value, size_t size) {
  crosswalk_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.crosswalk)
}
inline ::std::string* MapElementIds::add_crosswalk() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.crosswalk)
  return crosswalk_.Add();
}
inline void MapElementIds::add_crosswalk(const ::std::string& value) {
  crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.crosswalk)
}
#if LANG_CXX11
inline void MapElementIds::add_crosswalk(::std::string&& value) {
  crosswalk_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.crosswalk)
}
#endif
inline void MapElementIds::add_crosswalk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.crosswalk)
}
inline void MapElementIds::add_crosswalk(const char* value, size_t size) {
  crosswalk_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.crosswalk)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::crosswalk() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.crosswalk)
  return crosswalk_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.crosswalk)
  return &crosswalk_;
}

// repeated string junction = 3;
inline int MapElementIds::junction_size() const {
  return junction_.size();
}
inline void MapElementIds::clear_junction() {
  junction_.Clear();
}
inline const ::std::string& MapElementIds::junction(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.junction)
  return junction_.Get(index);
}
inline ::std::string* MapElementIds::mutable_junction(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.junction)
  return junction_.Mutable(index);
}
inline void MapElementIds::set_junction(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.junction)
  junction_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_junction(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.junction)
  junction_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_junction(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  junction_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.junction)
}
inline void MapElementIds::set_junction(int index, const char* value, size_t size) {
  junction_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.junction)
}
inline ::std::string* MapElementIds::add_junction() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.junction)
  return junction_.Add();
}
inline void MapElementIds::add_junction(const ::std::string& value) {
  junction_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.junction)
}
#if LANG_CXX11
inline void MapElementIds::add_junction(::std::string&& value) {
  junction_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.junction)
}
#endif
inline void MapElementIds::add_junction(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  junction_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.junction)
}
inline void MapElementIds::add_junction(const char* value, size_t size) {
  junction_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.junction)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::junction() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.junction)
  return junction_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.junction)
  return &junction_;
}

// repeated string signal = 4;
inline int MapElementIds::signal_size() const {
  return signal_.size();
}
inline void MapElementIds::clear_signal() {
  signal_.Clear();
}
inline const ::std::string& MapElementIds::signal(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.signal)
  return signal_.Get(index);
}
inline ::std::string* MapElementIds::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.signal)
  return signal_.Mutable(index);
}
inline void MapElementIds::set_signal(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.signal)
  signal_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_signal(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.signal)
  signal_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_signal(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signal_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.signal)
}
inline void MapElementIds::set_signal(int index, const char* value, size_t size) {
  signal_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.signal)
}
inline ::std::string* MapElementIds::add_signal() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.signal)
  return signal_.Add();
}
inline void MapElementIds::add_signal(const ::std::string& value) {
  signal_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.signal)
}
#if LANG_CXX11
inline void MapElementIds::add_signal(::std::string&& value) {
  signal_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.signal)
}
#endif
inline void MapElementIds::add_signal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signal_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.signal)
}
inline void MapElementIds::add_signal(const char* value, size_t size) {
  signal_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.signal)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::signal() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.signal)
  return signal_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.signal)
  return &signal_;
}

// repeated string stop_sign = 5;
inline int MapElementIds::stop_sign_size() const {
  return stop_sign_.size();
}
inline void MapElementIds::clear_stop_sign() {
  stop_sign_.Clear();
}
inline const ::std::string& MapElementIds::stop_sign(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.stop_sign)
  return stop_sign_.Get(index);
}
inline ::std::string* MapElementIds::mutable_stop_sign(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.stop_sign)
  return stop_sign_.Mutable(index);
}
inline void MapElementIds::set_stop_sign(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.stop_sign)
  stop_sign_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_stop_sign(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.stop_sign)
  stop_sign_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_stop_sign(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  stop_sign_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.stop_sign)
}
inline void MapElementIds::set_stop_sign(int index, const char* value, size_t size) {
  stop_sign_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.stop_sign)
}
inline ::std::string* MapElementIds::add_stop_sign() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.stop_sign)
  return stop_sign_.Add();
}
inline void MapElementIds::add_stop_sign(const ::std::string& value) {
  stop_sign_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.stop_sign)
}
#if LANG_CXX11
inline void MapElementIds::add_stop_sign(::std::string&& value) {
  stop_sign_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.stop_sign)
}
#endif
inline void MapElementIds::add_stop_sign(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  stop_sign_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.stop_sign)
}
inline void MapElementIds::add_stop_sign(const char* value, size_t size) {
  stop_sign_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.stop_sign)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::stop_sign() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.stop_sign)
  return stop_sign_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_stop_sign() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.stop_sign)
  return &stop_sign_;
}

// repeated string yield = 6;
inline int MapElementIds::yield_size() const {
  return yield_.size();
}
inline void MapElementIds::clear_yield() {
  yield_.Clear();
}
inline const ::std::string& MapElementIds::yield(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.yield)
  return yield_.Get(index);
}
inline ::std::string* MapElementIds::mutable_yield(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.yield)
  return yield_.Mutable(index);
}
inline void MapElementIds::set_yield(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.yield)
  yield_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_yield(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.yield)
  yield_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_yield(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  yield_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.yield)
}
inline void MapElementIds::set_yield(int index, const char* value, size_t size) {
  yield_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.yield)
}
inline ::std::string* MapElementIds::add_yield() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.yield)
  return yield_.Add();
}
inline void MapElementIds::add_yield(const ::std::string& value) {
  yield_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.yield)
}
#if LANG_CXX11
inline void MapElementIds::add_yield(::std::string&& value) {
  yield_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.yield)
}
#endif
inline void MapElementIds::add_yield(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  yield_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.yield)
}
inline void MapElementIds::add_yield(const char* value, size_t size) {
  yield_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.yield)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::yield() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.yield)
  return yield_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_yield() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.yield)
  return &yield_;
}

// repeated string overlap = 7;
inline int MapElementIds::overlap_size() const {
  return overlap_.size();
}
inline void MapElementIds::clear_overlap() {
  overlap_.Clear();
}
inline const ::std::string& MapElementIds::overlap(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.overlap)
  return overlap_.Get(index);
}
inline ::std::string* MapElementIds::mutable_overlap(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.overlap)
  return overlap_.Mutable(index);
}
inline void MapElementIds::set_overlap(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.overlap)
  overlap_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_overlap(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.overlap)
  overlap_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_overlap(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  overlap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.overlap)
}
inline void MapElementIds::set_overlap(int index, const char* value, size_t size) {
  overlap_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.overlap)
}
inline ::std::string* MapElementIds::add_overlap() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.overlap)
  return overlap_.Add();
}
inline void MapElementIds::add_overlap(const ::std::string& value) {
  overlap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.overlap)
}
#if LANG_CXX11
inline void MapElementIds::add_overlap(::std::string&& value) {
  overlap_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.overlap)
}
#endif
inline void MapElementIds::add_overlap(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  overlap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.overlap)
}
inline void MapElementIds::add_overlap(const char* value, size_t size) {
  overlap_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.overlap)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::overlap() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.overlap)
  return overlap_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_overlap() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.overlap)
  return &overlap_;
}

// repeated string road = 8;
inline int MapElementIds::road_size() const {
  return road_.size();
}
inline void MapElementIds::clear_road() {
  road_.Clear();
}
inline const ::std::string& MapElementIds::road(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.road)
  return road_.Get(index);
}
inline ::std::string* MapElementIds::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.road)
  return road_.Mutable(index);
}
inline void MapElementIds::set_road(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.road)
  road_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_road(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.road)
  road_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_road(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  road_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.road)
}
inline void MapElementIds::set_road(int index, const char* value, size_t size) {
  road_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.road)
}
inline ::std::string* MapElementIds::add_road() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.road)
  return road_.Add();
}
inline void MapElementIds::add_road(const ::std::string& value) {
  road_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.road)
}
#if LANG_CXX11
inline void MapElementIds::add_road(::std::string&& value) {
  road_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.road)
}
#endif
inline void MapElementIds::add_road(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  road_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.road)
}
inline void MapElementIds::add_road(const char* value, size_t size) {
  road_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.road)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::road() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.road)
  return road_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.road)
  return &road_;
}

// repeated string clear_area = 9;
inline int MapElementIds::clear_area_size() const {
  return clear_area_.size();
}
inline void MapElementIds::clear_clear_area() {
  clear_area_.Clear();
}
inline const ::std::string& MapElementIds::clear_area(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.MapElementIds.clear_area)
  return clear_area_.Get(index);
}
inline ::std::string* MapElementIds::mutable_clear_area(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.MapElementIds.clear_area)
  return clear_area_.Mutable(index);
}
inline void MapElementIds::set_clear_area(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.clear_area)
  clear_area_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MapElementIds::set_clear_area(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.MapElementIds.clear_area)
  clear_area_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MapElementIds::set_clear_area(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  clear_area_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.MapElementIds.clear_area)
}
inline void MapElementIds::set_clear_area(int index, const char* value, size_t size) {
  clear_area_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.MapElementIds.clear_area)
}
inline ::std::string* MapElementIds::add_clear_area() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.dreamview.MapElementIds.clear_area)
  return clear_area_.Add();
}
inline void MapElementIds::add_clear_area(const ::std::string& value) {
  clear_area_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.clear_area)
}
#if LANG_CXX11
inline void MapElementIds::add_clear_area(::std::string&& value) {
  clear_area_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.MapElementIds.clear_area)
}
#endif
inline void MapElementIds::add_clear_area(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  clear_area_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.dreamview.MapElementIds.clear_area)
}
inline void MapElementIds::add_clear_area(const char* value, size_t size) {
  clear_area_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.dreamview.MapElementIds.clear_area)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapElementIds::clear_area() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.MapElementIds.clear_area)
  return clear_area_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapElementIds::mutable_clear_area() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.MapElementIds.clear_area)
  return &clear_area_;
}

// -------------------------------------------------------------------

// ControlData

// optional double timestamp_sec = 1;
inline bool ControlData::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlData::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlData::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlData::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double ControlData::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.ControlData.timestamp_sec)
  return timestamp_sec_;
}
inline void ControlData::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.ControlData.timestamp_sec)
}

// optional double station_error = 2;
inline bool ControlData::has_station_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlData::set_has_station_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlData::clear_has_station_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlData::clear_station_error() {
  station_error_ = 0;
  clear_has_station_error();
}
inline double ControlData::station_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.ControlData.station_error)
  return station_error_;
}
inline void ControlData::set_station_error(double value) {
  set_has_station_error();
  station_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.ControlData.station_error)
}

// optional double lateral_error = 3;
inline bool ControlData::has_lateral_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlData::set_has_lateral_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlData::clear_has_lateral_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlData::clear_lateral_error() {
  lateral_error_ = 0;
  clear_has_lateral_error();
}
inline double ControlData::lateral_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.ControlData.lateral_error)
  return lateral_error_;
}
inline void ControlData::set_lateral_error(double value) {
  set_has_lateral_error();
  lateral_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.ControlData.lateral_error)
}

// optional double heading_error = 4;
inline bool ControlData::has_heading_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControlData::set_has_heading_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControlData::clear_has_heading_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControlData::clear_heading_error() {
  heading_error_ = 0;
  clear_has_heading_error();
}
inline double ControlData::heading_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.ControlData.heading_error)
  return heading_error_;
}
inline void ControlData::set_heading_error(double value) {
  set_has_heading_error();
  heading_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.ControlData.heading_error)
}

// -------------------------------------------------------------------

// Notification

// optional double timestamp_sec = 1;
inline bool Notification::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notification::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notification::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notification::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double Notification::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Notification.timestamp_sec)
  return timestamp_sec_;
}
inline void Notification::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.Notification.timestamp_sec)
}

// optional .jmc_auto.common.monitor.MonitorMessageItem item = 2;
inline bool Notification::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_item() {
  if (item_ != NULL) item_->::jmc_auto::common::monitor::MonitorMessageItem::Clear();
  clear_has_item();
}
inline const ::jmc_auto::common::monitor::MonitorMessageItem& Notification::item() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.Notification.item)
  return item_ != NULL ? *item_
                         : *::jmc_auto::common::monitor::MonitorMessageItem::internal_default_instance();
}
inline ::jmc_auto::common::monitor::MonitorMessageItem* Notification::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::jmc_auto::common::monitor::MonitorMessageItem;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.Notification.item)
  return item_;
}
inline ::jmc_auto::common::monitor::MonitorMessageItem* Notification::release_item() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.Notification.item)
  clear_has_item();
  ::jmc_auto::common::monitor::MonitorMessageItem* temp = item_;
  item_ = NULL;
  return temp;
}
inline void Notification::set_allocated_item(::jmc_auto::common::monitor::MonitorMessageItem* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.Notification.item)
}

// -------------------------------------------------------------------

// SimulationWorld

// optional double timestamp = 1;
inline bool SimulationWorld::has_timestamp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SimulationWorld::set_has_timestamp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SimulationWorld::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SimulationWorld::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double SimulationWorld::timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.timestamp)
  return timestamp_;
}
inline void SimulationWorld::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.timestamp)
}

// optional uint32 sequence_num = 2;
inline bool SimulationWorld::has_sequence_num() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SimulationWorld::set_has_sequence_num() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SimulationWorld::clear_has_sequence_num() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SimulationWorld::clear_sequence_num() {
  sequence_num_ = 0u;
  clear_has_sequence_num();
}
inline ::google::protobuf::uint32 SimulationWorld::sequence_num() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.sequence_num)
  return sequence_num_;
}
inline void SimulationWorld::set_sequence_num(::google::protobuf::uint32 value) {
  set_has_sequence_num();
  sequence_num_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.sequence_num)
}

// repeated .jmc_auto.dreamview.Object object = 3;
inline int SimulationWorld::object_size() const {
  return object_.size();
}
inline void SimulationWorld::clear_object() {
  object_.Clear();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::object(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.object)
  return object_.Get(index);
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.object)
  return object_.Mutable(index);
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::add_object() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.SimulationWorld.object)
  return object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >*
SimulationWorld::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.SimulationWorld.object)
  return &object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >&
SimulationWorld::object() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.SimulationWorld.object)
  return object_;
}

// optional .jmc_auto.dreamview.Object auto_driving_car = 4;
inline bool SimulationWorld::has_auto_driving_car() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulationWorld::set_has_auto_driving_car() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulationWorld::clear_has_auto_driving_car() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulationWorld::clear_auto_driving_car() {
  if (auto_driving_car_ != NULL) auto_driving_car_->::jmc_auto::dreamview::Object::Clear();
  clear_has_auto_driving_car();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::auto_driving_car() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.auto_driving_car)
  return auto_driving_car_ != NULL ? *auto_driving_car_
                         : *::jmc_auto::dreamview::Object::internal_default_instance();
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_auto_driving_car() {
  set_has_auto_driving_car();
  if (auto_driving_car_ == NULL) {
    auto_driving_car_ = new ::jmc_auto::dreamview::Object;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.auto_driving_car)
  return auto_driving_car_;
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::release_auto_driving_car() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.auto_driving_car)
  clear_has_auto_driving_car();
  ::jmc_auto::dreamview::Object* temp = auto_driving_car_;
  auto_driving_car_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_auto_driving_car(::jmc_auto::dreamview::Object* auto_driving_car) {
  delete auto_driving_car_;
  auto_driving_car_ = auto_driving_car;
  if (auto_driving_car) {
    set_has_auto_driving_car();
  } else {
    clear_has_auto_driving_car();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.auto_driving_car)
}

// optional .jmc_auto.dreamview.Object traffic_signal = 5;
inline bool SimulationWorld::has_traffic_signal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulationWorld::set_has_traffic_signal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulationWorld::clear_has_traffic_signal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulationWorld::clear_traffic_signal() {
  if (traffic_signal_ != NULL) traffic_signal_->::jmc_auto::dreamview::Object::Clear();
  clear_has_traffic_signal();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::traffic_signal() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.traffic_signal)
  return traffic_signal_ != NULL ? *traffic_signal_
                         : *::jmc_auto::dreamview::Object::internal_default_instance();
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_traffic_signal() {
  set_has_traffic_signal();
  if (traffic_signal_ == NULL) {
    traffic_signal_ = new ::jmc_auto::dreamview::Object;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.traffic_signal)
  return traffic_signal_;
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::release_traffic_signal() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.traffic_signal)
  clear_has_traffic_signal();
  ::jmc_auto::dreamview::Object* temp = traffic_signal_;
  traffic_signal_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_traffic_signal(::jmc_auto::dreamview::Object* traffic_signal) {
  delete traffic_signal_;
  traffic_signal_ = traffic_signal;
  if (traffic_signal) {
    set_has_traffic_signal();
  } else {
    clear_has_traffic_signal();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.traffic_signal)
}

// repeated .jmc_auto.dreamview.RoutePath route_path = 6;
inline int SimulationWorld::route_path_size() const {
  return route_path_.size();
}
inline void SimulationWorld::clear_route_path() {
  route_path_.Clear();
}
inline const ::jmc_auto::dreamview::RoutePath& SimulationWorld::route_path(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.route_path)
  return route_path_.Get(index);
}
inline ::jmc_auto::dreamview::RoutePath* SimulationWorld::mutable_route_path(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.route_path)
  return route_path_.Mutable(index);
}
inline ::jmc_auto::dreamview::RoutePath* SimulationWorld::add_route_path() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.SimulationWorld.route_path)
  return route_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::RoutePath >*
SimulationWorld::mutable_route_path() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.SimulationWorld.route_path)
  return &route_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::RoutePath >&
SimulationWorld::route_path() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.SimulationWorld.route_path)
  return route_path_;
}

// optional double routing_time = 7;
inline bool SimulationWorld::has_routing_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SimulationWorld::set_has_routing_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SimulationWorld::clear_has_routing_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SimulationWorld::clear_routing_time() {
  routing_time_ = 0;
  clear_has_routing_time();
}
inline double SimulationWorld::routing_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.routing_time)
  return routing_time_;
}
inline void SimulationWorld::set_routing_time(double value) {
  set_has_routing_time();
  routing_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.routing_time)
}

// repeated .jmc_auto.dreamview.Object planning_trajectory = 8;
inline int SimulationWorld::planning_trajectory_size() const {
  return planning_trajectory_.size();
}
inline void SimulationWorld::clear_planning_trajectory() {
  planning_trajectory_.Clear();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::planning_trajectory(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.planning_trajectory)
  return planning_trajectory_.Get(index);
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_planning_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.planning_trajectory)
  return planning_trajectory_.Mutable(index);
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::add_planning_trajectory() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.SimulationWorld.planning_trajectory)
  return planning_trajectory_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >*
SimulationWorld::mutable_planning_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.SimulationWorld.planning_trajectory)
  return &planning_trajectory_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Object >&
SimulationWorld::planning_trajectory() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.SimulationWorld.planning_trajectory)
  return planning_trajectory_;
}

// optional .jmc_auto.dreamview.Object main_stop = 9 [deprecated = true];
inline bool SimulationWorld::has_main_stop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimulationWorld::set_has_main_stop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimulationWorld::clear_has_main_stop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimulationWorld::clear_main_stop() {
  if (main_stop_ != NULL) main_stop_->::jmc_auto::dreamview::Object::Clear();
  clear_has_main_stop();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::main_stop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.main_stop)
  return main_stop_ != NULL ? *main_stop_
                         : *::jmc_auto::dreamview::Object::internal_default_instance();
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_main_stop() {
  set_has_main_stop();
  if (main_stop_ == NULL) {
    main_stop_ = new ::jmc_auto::dreamview::Object;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.main_stop)
  return main_stop_;
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::release_main_stop() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.main_stop)
  clear_has_main_stop();
  ::jmc_auto::dreamview::Object* temp = main_stop_;
  main_stop_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_main_stop(::jmc_auto::dreamview::Object* main_stop) {
  delete main_stop_;
  main_stop_ = main_stop;
  if (main_stop) {
    set_has_main_stop();
  } else {
    clear_has_main_stop();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.main_stop)
}

// optional .jmc_auto.dreamview.Object main_decision = 24;
inline bool SimulationWorld::has_main_decision() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SimulationWorld::set_has_main_decision() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SimulationWorld::clear_has_main_decision() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SimulationWorld::clear_main_decision() {
  if (main_decision_ != NULL) main_decision_->::jmc_auto::dreamview::Object::Clear();
  clear_has_main_decision();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::main_decision() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.main_decision)
  return main_decision_ != NULL ? *main_decision_
                         : *::jmc_auto::dreamview::Object::internal_default_instance();
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_main_decision() {
  set_has_main_decision();
  if (main_decision_ == NULL) {
    main_decision_ = new ::jmc_auto::dreamview::Object;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.main_decision)
  return main_decision_;
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::release_main_decision() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.main_decision)
  clear_has_main_decision();
  ::jmc_auto::dreamview::Object* temp = main_decision_;
  main_decision_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_main_decision(::jmc_auto::dreamview::Object* main_decision) {
  delete main_decision_;
  main_decision_ = main_decision;
  if (main_decision) {
    set_has_main_decision();
  } else {
    clear_has_main_decision();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.main_decision)
}

// optional double speed_limit = 10;
inline bool SimulationWorld::has_speed_limit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SimulationWorld::set_has_speed_limit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SimulationWorld::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SimulationWorld::clear_speed_limit() {
  speed_limit_ = 0;
  clear_has_speed_limit();
}
inline double SimulationWorld::speed_limit() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.speed_limit)
  return speed_limit_;
}
inline void SimulationWorld::set_speed_limit(double value) {
  set_has_speed_limit();
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.speed_limit)
}

// optional .jmc_auto.dreamview.DelaysInMs delay = 11;
inline bool SimulationWorld::has_delay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SimulationWorld::set_has_delay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SimulationWorld::clear_has_delay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SimulationWorld::clear_delay() {
  if (delay_ != NULL) delay_->::jmc_auto::dreamview::DelaysInMs::Clear();
  clear_has_delay();
}
inline const ::jmc_auto::dreamview::DelaysInMs& SimulationWorld::delay() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.delay)
  return delay_ != NULL ? *delay_
                         : *::jmc_auto::dreamview::DelaysInMs::internal_default_instance();
}
inline ::jmc_auto::dreamview::DelaysInMs* SimulationWorld::mutable_delay() {
  set_has_delay();
  if (delay_ == NULL) {
    delay_ = new ::jmc_auto::dreamview::DelaysInMs;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.delay)
  return delay_;
}
inline ::jmc_auto::dreamview::DelaysInMs* SimulationWorld::release_delay() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.delay)
  clear_has_delay();
  ::jmc_auto::dreamview::DelaysInMs* temp = delay_;
  delay_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_delay(::jmc_auto::dreamview::DelaysInMs* delay) {
  delete delay_;
  delay_ = delay;
  if (delay) {
    set_has_delay();
  } else {
    clear_has_delay();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.delay)
}

// optional .jmc_auto.common.monitor.MonitorMessage monitor = 12 [deprecated = true];
inline bool SimulationWorld::has_monitor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SimulationWorld::set_has_monitor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SimulationWorld::clear_has_monitor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SimulationWorld::clear_monitor() {
  if (monitor_ != NULL) monitor_->::jmc_auto::common::monitor::MonitorMessage::Clear();
  clear_has_monitor();
}
inline const ::jmc_auto::common::monitor::MonitorMessage& SimulationWorld::monitor() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.monitor)
  return monitor_ != NULL ? *monitor_
                         : *::jmc_auto::common::monitor::MonitorMessage::internal_default_instance();
}
inline ::jmc_auto::common::monitor::MonitorMessage* SimulationWorld::mutable_monitor() {
  set_has_monitor();
  if (monitor_ == NULL) {
    monitor_ = new ::jmc_auto::common::monitor::MonitorMessage;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.monitor)
  return monitor_;
}
inline ::jmc_auto::common::monitor::MonitorMessage* SimulationWorld::release_monitor() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.monitor)
  clear_has_monitor();
  ::jmc_auto::common::monitor::MonitorMessage* temp = monitor_;
  monitor_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_monitor(::jmc_auto::common::monitor::MonitorMessage* monitor) {
  delete monitor_;
  monitor_ = monitor;
  if (monitor) {
    set_has_monitor();
  } else {
    clear_has_monitor();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.monitor)
}

// repeated .jmc_auto.dreamview.Notification notification = 25;
inline int SimulationWorld::notification_size() const {
  return notification_.size();
}
inline void SimulationWorld::clear_notification() {
  notification_.Clear();
}
inline const ::jmc_auto::dreamview::Notification& SimulationWorld::notification(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.notification)
  return notification_.Get(index);
}
inline ::jmc_auto::dreamview::Notification* SimulationWorld::mutable_notification(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.notification)
  return notification_.Mutable(index);
}
inline ::jmc_auto::dreamview::Notification* SimulationWorld::add_notification() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.SimulationWorld.notification)
  return notification_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Notification >*
SimulationWorld::mutable_notification() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.SimulationWorld.notification)
  return &notification_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::dreamview::Notification >&
SimulationWorld::notification() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.SimulationWorld.notification)
  return notification_;
}

// optional string engage_advice = 13;
inline bool SimulationWorld::has_engage_advice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulationWorld::set_has_engage_advice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulationWorld::clear_has_engage_advice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimulationWorld::clear_engage_advice() {
  engage_advice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_engage_advice();
}
inline const ::std::string& SimulationWorld::engage_advice() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.engage_advice)
  return engage_advice_.GetNoArena();
}
inline void SimulationWorld::set_engage_advice(const ::std::string& value) {
  set_has_engage_advice();
  engage_advice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.engage_advice)
}
#if LANG_CXX11
inline void SimulationWorld::set_engage_advice(::std::string&& value) {
  set_has_engage_advice();
  engage_advice_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.dreamview.SimulationWorld.engage_advice)
}
#endif
inline void SimulationWorld::set_engage_advice(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_engage_advice();
  engage_advice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.dreamview.SimulationWorld.engage_advice)
}
inline void SimulationWorld::set_engage_advice(const char* value, size_t size) {
  set_has_engage_advice();
  engage_advice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.dreamview.SimulationWorld.engage_advice)
}
inline ::std::string* SimulationWorld::mutable_engage_advice() {
  set_has_engage_advice();
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.engage_advice)
  return engage_advice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimulationWorld::release_engage_advice() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.engage_advice)
  clear_has_engage_advice();
  return engage_advice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimulationWorld::set_allocated_engage_advice(::std::string* engage_advice) {
  if (engage_advice != NULL) {
    set_has_engage_advice();
  } else {
    clear_has_engage_advice();
  }
  engage_advice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), engage_advice);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.engage_advice)
}

// optional .jmc_auto.dreamview.Latency latency = 14;
inline bool SimulationWorld::has_latency() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SimulationWorld::set_has_latency() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SimulationWorld::clear_has_latency() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SimulationWorld::clear_latency() {
  if (latency_ != NULL) latency_->::jmc_auto::dreamview::Latency::Clear();
  clear_has_latency();
}
inline const ::jmc_auto::dreamview::Latency& SimulationWorld::latency() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.latency)
  return latency_ != NULL ? *latency_
                         : *::jmc_auto::dreamview::Latency::internal_default_instance();
}
inline ::jmc_auto::dreamview::Latency* SimulationWorld::mutable_latency() {
  set_has_latency();
  if (latency_ == NULL) {
    latency_ = new ::jmc_auto::dreamview::Latency;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.latency)
  return latency_;
}
inline ::jmc_auto::dreamview::Latency* SimulationWorld::release_latency() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.latency)
  clear_has_latency();
  ::jmc_auto::dreamview::Latency* temp = latency_;
  latency_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_latency(::jmc_auto::dreamview::Latency* latency) {
  delete latency_;
  latency_ = latency;
  if (latency) {
    set_has_latency();
  } else {
    clear_has_latency();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.latency)
}

// optional .jmc_auto.dreamview.MapElementIds map_element_ids = 15;
inline bool SimulationWorld::has_map_element_ids() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SimulationWorld::set_has_map_element_ids() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SimulationWorld::clear_has_map_element_ids() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SimulationWorld::clear_map_element_ids() {
  if (map_element_ids_ != NULL) map_element_ids_->::jmc_auto::dreamview::MapElementIds::Clear();
  clear_has_map_element_ids();
}
inline const ::jmc_auto::dreamview::MapElementIds& SimulationWorld::map_element_ids() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.map_element_ids)
  return map_element_ids_ != NULL ? *map_element_ids_
                         : *::jmc_auto::dreamview::MapElementIds::internal_default_instance();
}
inline ::jmc_auto::dreamview::MapElementIds* SimulationWorld::mutable_map_element_ids() {
  set_has_map_element_ids();
  if (map_element_ids_ == NULL) {
    map_element_ids_ = new ::jmc_auto::dreamview::MapElementIds;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.map_element_ids)
  return map_element_ids_;
}
inline ::jmc_auto::dreamview::MapElementIds* SimulationWorld::release_map_element_ids() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.map_element_ids)
  clear_has_map_element_ids();
  ::jmc_auto::dreamview::MapElementIds* temp = map_element_ids_;
  map_element_ids_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_map_element_ids(::jmc_auto::dreamview::MapElementIds* map_element_ids) {
  delete map_element_ids_;
  map_element_ids_ = map_element_ids;
  if (map_element_ids) {
    set_has_map_element_ids();
  } else {
    clear_has_map_element_ids();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.map_element_ids)
}

// optional uint64 map_hash = 16;
inline bool SimulationWorld::has_map_hash() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SimulationWorld::set_has_map_hash() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SimulationWorld::clear_has_map_hash() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SimulationWorld::clear_map_hash() {
  map_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_map_hash();
}
inline ::google::protobuf::uint64 SimulationWorld::map_hash() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.map_hash)
  return map_hash_;
}
inline void SimulationWorld::set_map_hash(::google::protobuf::uint64 value) {
  set_has_map_hash();
  map_hash_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.map_hash)
}

// optional double map_radius = 17;
inline bool SimulationWorld::has_map_radius() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SimulationWorld::set_has_map_radius() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SimulationWorld::clear_has_map_radius() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SimulationWorld::clear_map_radius() {
  map_radius_ = 0;
  clear_has_map_radius();
}
inline double SimulationWorld::map_radius() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.map_radius)
  return map_radius_;
}
inline void SimulationWorld::set_map_radius(double value) {
  set_has_map_radius();
  map_radius_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.map_radius)
}

// optional double planning_time = 18;
inline bool SimulationWorld::has_planning_time() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SimulationWorld::set_has_planning_time() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SimulationWorld::clear_has_planning_time() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SimulationWorld::clear_planning_time() {
  planning_time_ = 0;
  clear_has_planning_time();
}
inline double SimulationWorld::planning_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.planning_time)
  return planning_time_;
}
inline void SimulationWorld::set_planning_time(double value) {
  set_has_planning_time();
  planning_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.dreamview.SimulationWorld.planning_time)
}

// optional .jmc_auto.planning_internal.PlanningData planning_data = 19;
inline bool SimulationWorld::has_planning_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SimulationWorld::set_has_planning_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SimulationWorld::clear_has_planning_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SimulationWorld::clear_planning_data() {
  if (planning_data_ != NULL) planning_data_->::jmc_auto::planning_internal::PlanningData::Clear();
  clear_has_planning_data();
}
inline const ::jmc_auto::planning_internal::PlanningData& SimulationWorld::planning_data() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.planning_data)
  return planning_data_ != NULL ? *planning_data_
                         : *::jmc_auto::planning_internal::PlanningData::internal_default_instance();
}
inline ::jmc_auto::planning_internal::PlanningData* SimulationWorld::mutable_planning_data() {
  set_has_planning_data();
  if (planning_data_ == NULL) {
    planning_data_ = new ::jmc_auto::planning_internal::PlanningData;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.planning_data)
  return planning_data_;
}
inline ::jmc_auto::planning_internal::PlanningData* SimulationWorld::release_planning_data() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.planning_data)
  clear_has_planning_data();
  ::jmc_auto::planning_internal::PlanningData* temp = planning_data_;
  planning_data_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_planning_data(::jmc_auto::planning_internal::PlanningData* planning_data) {
  delete planning_data_;
  planning_data_ = planning_data;
  if (planning_data) {
    set_has_planning_data();
  } else {
    clear_has_planning_data();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.planning_data)
}

// optional .jmc_auto.dreamview.Object gps = 20;
inline bool SimulationWorld::has_gps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SimulationWorld::set_has_gps() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SimulationWorld::clear_has_gps() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SimulationWorld::clear_gps() {
  if (gps_ != NULL) gps_->::jmc_auto::dreamview::Object::Clear();
  clear_has_gps();
}
inline const ::jmc_auto::dreamview::Object& SimulationWorld::gps() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.gps)
  return gps_ != NULL ? *gps_
                         : *::jmc_auto::dreamview::Object::internal_default_instance();
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) {
    gps_ = new ::jmc_auto::dreamview::Object;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.gps)
  return gps_;
}
inline ::jmc_auto::dreamview::Object* SimulationWorld::release_gps() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.gps)
  clear_has_gps();
  ::jmc_auto::dreamview::Object* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_gps(::jmc_auto::dreamview::Object* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.gps)
}

// optional .jmc_auto.perception.LaneMarkers lane_marker = 21;
inline bool SimulationWorld::has_lane_marker() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SimulationWorld::set_has_lane_marker() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SimulationWorld::clear_has_lane_marker() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SimulationWorld::clear_lane_marker() {
  if (lane_marker_ != NULL) lane_marker_->::jmc_auto::perception::LaneMarkers::Clear();
  clear_has_lane_marker();
}
inline const ::jmc_auto::perception::LaneMarkers& SimulationWorld::lane_marker() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.lane_marker)
  return lane_marker_ != NULL ? *lane_marker_
                         : *::jmc_auto::perception::LaneMarkers::internal_default_instance();
}
inline ::jmc_auto::perception::LaneMarkers* SimulationWorld::mutable_lane_marker() {
  set_has_lane_marker();
  if (lane_marker_ == NULL) {
    lane_marker_ = new ::jmc_auto::perception::LaneMarkers;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.lane_marker)
  return lane_marker_;
}
inline ::jmc_auto::perception::LaneMarkers* SimulationWorld::release_lane_marker() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.lane_marker)
  clear_has_lane_marker();
  ::jmc_auto::perception::LaneMarkers* temp = lane_marker_;
  lane_marker_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_lane_marker(::jmc_auto::perception::LaneMarkers* lane_marker) {
  delete lane_marker_;
  lane_marker_ = lane_marker;
  if (lane_marker) {
    set_has_lane_marker();
  } else {
    clear_has_lane_marker();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.lane_marker)
}

// optional .jmc_auto.dreamview.ControlData control_data = 22;
inline bool SimulationWorld::has_control_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SimulationWorld::set_has_control_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SimulationWorld::clear_has_control_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SimulationWorld::clear_control_data() {
  if (control_data_ != NULL) control_data_->::jmc_auto::dreamview::ControlData::Clear();
  clear_has_control_data();
}
inline const ::jmc_auto::dreamview::ControlData& SimulationWorld::control_data() const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.control_data)
  return control_data_ != NULL ? *control_data_
                         : *::jmc_auto::dreamview::ControlData::internal_default_instance();
}
inline ::jmc_auto::dreamview::ControlData* SimulationWorld::mutable_control_data() {
  set_has_control_data();
  if (control_data_ == NULL) {
    control_data_ = new ::jmc_auto::dreamview::ControlData;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.control_data)
  return control_data_;
}
inline ::jmc_auto::dreamview::ControlData* SimulationWorld::release_control_data() {
  // @@protoc_insertion_point(field_release:jmc_auto.dreamview.SimulationWorld.control_data)
  clear_has_control_data();
  ::jmc_auto::dreamview::ControlData* temp = control_data_;
  control_data_ = NULL;
  return temp;
}
inline void SimulationWorld::set_allocated_control_data(::jmc_auto::dreamview::ControlData* control_data) {
  delete control_data_;
  control_data_ = control_data;
  if (control_data) {
    set_has_control_data();
  } else {
    clear_has_control_data();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.dreamview.SimulationWorld.control_data)
}

// repeated .jmc_auto.common.Path navigation_path = 23;
inline int SimulationWorld::navigation_path_size() const {
  return navigation_path_.size();
}
inline void SimulationWorld::clear_navigation_path() {
  navigation_path_.Clear();
}
inline const ::jmc_auto::common::Path& SimulationWorld::navigation_path(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.dreamview.SimulationWorld.navigation_path)
  return navigation_path_.Get(index);
}
inline ::jmc_auto::common::Path* SimulationWorld::mutable_navigation_path(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.dreamview.SimulationWorld.navigation_path)
  return navigation_path_.Mutable(index);
}
inline ::jmc_auto::common::Path* SimulationWorld::add_navigation_path() {
  // @@protoc_insertion_point(field_add:jmc_auto.dreamview.SimulationWorld.navigation_path)
  return navigation_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Path >*
SimulationWorld::mutable_navigation_path() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.dreamview.SimulationWorld.navigation_path)
  return &navigation_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Path >&
SimulationWorld::navigation_path() const {
  // @@protoc_insertion_point(field_list:jmc_auto.dreamview.SimulationWorld.navigation_path)
  return navigation_path_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dreamview
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::dreamview::Decision_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::dreamview::Decision_Type>() {
  return ::jmc_auto::dreamview::Decision_Type_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::dreamview::Decision_StopReasonCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::dreamview::Decision_StopReasonCode>() {
  return ::jmc_auto::dreamview::Decision_StopReasonCode_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::dreamview::Object_DisengageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::dreamview::Object_DisengageType>() {
  return ::jmc_auto::dreamview::Object_DisengageType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::dreamview::Object_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::dreamview::Object_Type>() {
  return ::jmc_auto::dreamview::Object_Type_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::dreamview::Object_DisengageTypegear> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::dreamview::Object_DisengageTypegear>() {
  return ::jmc_auto::dreamview::Object_DisengageTypegear_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fdreamview_2fproto_2fsimulation_5fworld_2eproto__INCLUDED
