// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/drivers/gnss/proto/config.proto

#ifndef PROTOBUF_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto__INCLUDED
#define PROTOBUF_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace drivers {
namespace gnss {
namespace config {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class NewtonM2Config;
class NewtonM2ConfigDefaultTypeInternal;
extern NewtonM2ConfigDefaultTypeInternal _NewtonM2Config_default_instance_;
class NovatelConfig;
class NovatelConfigDefaultTypeInternal;
extern NovatelConfigDefaultTypeInternal _NovatelConfig_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Stream_Ntrip;
class Stream_NtripDefaultTypeInternal;
extern Stream_NtripDefaultTypeInternal _Stream_Ntrip_default_instance_;
class Stream_Serial;
class Stream_SerialDefaultTypeInternal;
extern Stream_SerialDefaultTypeInternal _Stream_Serial_default_instance_;
class Stream_Tcp;
class Stream_TcpDefaultTypeInternal;
extern Stream_TcpDefaultTypeInternal _Stream_Tcp_default_instance_;
class Stream_Udp;
class Stream_UdpDefaultTypeInternal;
extern Stream_UdpDefaultTypeInternal _Stream_Udp_default_instance_;
class TF;
class TFDefaultTypeInternal;
extern TFDefaultTypeInternal _TF_default_instance_;
class UbloxConfig;
class UbloxConfigDefaultTypeInternal;
extern UbloxConfigDefaultTypeInternal _UbloxConfig_default_instance_;
}  // namespace config
}  // namespace gnss
}  // namespace drivers
}  // namespace jmc_auto

namespace jmc_auto {
namespace drivers {
namespace gnss {
namespace config {

namespace protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto

enum Stream_Format {
  Stream_Format_UNKNOWN = 0,
  Stream_Format_NMEA = 1,
  Stream_Format_RTCM_V2 = 2,
  Stream_Format_RTCM_V3 = 3,
  Stream_Format_NOVATEL_TEXT = 10,
  Stream_Format_NOVATEL_BINARY = 11,
  Stream_Format_UBLOX_TEXT = 20,
  Stream_Format_UBLOX_BINARY = 21,
  Stream_Format_NEWTONM2_TEXT = 30,
  Stream_Format_NEWTONM2_BINARY = 31
};
bool Stream_Format_IsValid(int value);
const Stream_Format Stream_Format_Format_MIN = Stream_Format_UNKNOWN;
const Stream_Format Stream_Format_Format_MAX = Stream_Format_NEWTONM2_BINARY;
const int Stream_Format_Format_ARRAYSIZE = Stream_Format_Format_MAX + 1;

const ::google::protobuf::EnumDescriptor* Stream_Format_descriptor();
inline const ::std::string& Stream_Format_Name(Stream_Format value) {
  return ::google::protobuf::internal::NameOfEnum(
    Stream_Format_descriptor(), value);
}
inline bool Stream_Format_Parse(
    const ::std::string& name, Stream_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Stream_Format>(
    Stream_Format_descriptor(), name, value);
}
enum Config_RtkSolutionType {
  Config_RtkSolutionType_RTK_RECEIVER_SOLUTION = 1,
  Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION = 2
};
bool Config_RtkSolutionType_IsValid(int value);
const Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MIN = Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
const Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MAX = Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
const int Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE = Config_RtkSolutionType_RtkSolutionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_RtkSolutionType_descriptor();
inline const ::std::string& Config_RtkSolutionType_Name(Config_RtkSolutionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_RtkSolutionType_descriptor(), value);
}
inline bool Config_RtkSolutionType_Parse(
    const ::std::string& name, Config_RtkSolutionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_RtkSolutionType>(
    Config_RtkSolutionType_descriptor(), name, value);
}
enum ImuType {
  IMAR_FSAS = 13,
  ISA100C = 26,
  ADIS16488 = 31,
  STIM300 = 32,
  ISA100 = 34,
  ISA100_400HZ = 38,
  ISA100C_400HZ = 39,
  G320N = 40,
  CPT_XW5651 = 41,
  UM442 = 42
};
bool ImuType_IsValid(int value);
const ImuType ImuType_MIN = IMAR_FSAS;
const ImuType ImuType_MAX = UM442;
const int ImuType_ARRAYSIZE = ImuType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImuType_descriptor();
inline const ::std::string& ImuType_Name(ImuType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImuType_descriptor(), value);
}
inline bool ImuType_Parse(
    const ::std::string& name, ImuType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImuType>(
    ImuType_descriptor(), name, value);
}
// ===================================================================

class Stream_Serial : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.Stream.Serial) */ {
 public:
  Stream_Serial();
  virtual ~Stream_Serial();

  Stream_Serial(const Stream_Serial& from);

  inline Stream_Serial& operator=(const Stream_Serial& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Serial& default_instance();

  static inline const Stream_Serial* internal_default_instance() {
    return reinterpret_cast<const Stream_Serial*>(
               &_Stream_Serial_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Stream_Serial* other);

  // implements Message ----------------------------------------------

  inline Stream_Serial* New() const PROTOBUF_FINAL { return New(NULL); }

  Stream_Serial* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stream_Serial& from);
  void MergeFrom(const Stream_Serial& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stream_Serial* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const void* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // optional int32 baud_rate = 2 [default = 9600];
  bool has_baud_rate() const;
  void clear_baud_rate();
  static const int kBaudRateFieldNumber = 2;
  ::google::protobuf::int32 baud_rate() const;
  void set_baud_rate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.Stream.Serial)
 private:
  void set_has_device();
  void clear_has_device();
  void set_has_baud_rate();
  void clear_has_baud_rate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::int32 baud_rate_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream_Tcp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.Stream.Tcp) */ {
 public:
  Stream_Tcp();
  virtual ~Stream_Tcp();

  Stream_Tcp(const Stream_Tcp& from);

  inline Stream_Tcp& operator=(const Stream_Tcp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Tcp& default_instance();

  static inline const Stream_Tcp* internal_default_instance() {
    return reinterpret_cast<const Stream_Tcp*>(
               &_Stream_Tcp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Stream_Tcp* other);

  // implements Message ----------------------------------------------

  inline Stream_Tcp* New() const PROTOBUF_FINAL { return New(NULL); }

  Stream_Tcp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stream_Tcp& from);
  void MergeFrom(const Stream_Tcp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stream_Tcp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional int32 port = 2 [default = 3001];
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.Stream.Tcp)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int32 port_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream_Udp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.Stream.Udp) */ {
 public:
  Stream_Udp();
  virtual ~Stream_Udp();

  Stream_Udp(const Stream_Udp& from);

  inline Stream_Udp& operator=(const Stream_Udp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Udp& default_instance();

  static inline const Stream_Udp* internal_default_instance() {
    return reinterpret_cast<const Stream_Udp*>(
               &_Stream_Udp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Stream_Udp* other);

  // implements Message ----------------------------------------------

  inline Stream_Udp* New() const PROTOBUF_FINAL { return New(NULL); }

  Stream_Udp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stream_Udp& from);
  void MergeFrom(const Stream_Udp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stream_Udp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional int32 port = 2 [default = 3001];
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.Stream.Udp)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int32 port_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream_Ntrip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.Stream.Ntrip) */ {
 public:
  Stream_Ntrip();
  virtual ~Stream_Ntrip();

  Stream_Ntrip(const Stream_Ntrip& from);

  inline Stream_Ntrip& operator=(const Stream_Ntrip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Ntrip& default_instance();

  static inline const Stream_Ntrip* internal_default_instance() {
    return reinterpret_cast<const Stream_Ntrip*>(
               &_Stream_Ntrip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Stream_Ntrip* other);

  // implements Message ----------------------------------------------

  inline Stream_Ntrip* New() const PROTOBUF_FINAL { return New(NULL); }

  Stream_Ntrip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stream_Ntrip& from);
  void MergeFrom(const Stream_Ntrip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stream_Ntrip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes mount_point = 3;
  bool has_mount_point() const;
  void clear_mount_point();
  static const int kMountPointFieldNumber = 3;
  const ::std::string& mount_point() const;
  void set_mount_point(const ::std::string& value);
  #if LANG_CXX11
  void set_mount_point(::std::string&& value);
  #endif
  void set_mount_point(const char* value);
  void set_mount_point(const void* value, size_t size);
  ::std::string* mutable_mount_point();
  ::std::string* release_mount_point();
  void set_allocated_mount_point(::std::string* mount_point);

  // optional bytes user = 4;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 4;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const void* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional bytes password = 5;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 5;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const void* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional int32 port = 2 [default = 2101];
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional uint32 timeout_s = 6 [default = 30];
  bool has_timeout_s() const;
  void clear_timeout_s();
  static const int kTimeoutSFieldNumber = 6;
  ::google::protobuf::uint32 timeout_s() const;
  void set_timeout_s(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.Stream.Ntrip)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_port();
  void clear_has_port();
  void set_has_mount_point();
  void clear_has_mount_point();
  void set_has_user();
  void clear_has_user();
  void set_has_password();
  void clear_has_password();
  void set_has_timeout_s();
  void clear_has_timeout_s();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr mount_point_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::uint32 timeout_s_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  enum TypeCase {
    kSerial = 2,
    kTcp = 3,
    kUdp = 4,
    kNtrip = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  inline Stream* New() const PROTOBUF_FINAL { return New(NULL); }

  Stream* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Stream_Serial Serial;
  typedef Stream_Tcp Tcp;
  typedef Stream_Udp Udp;
  typedef Stream_Ntrip Ntrip;

  typedef Stream_Format Format;
  static const Format UNKNOWN =
    Stream_Format_UNKNOWN;
  static const Format NMEA =
    Stream_Format_NMEA;
  static const Format RTCM_V2 =
    Stream_Format_RTCM_V2;
  static const Format RTCM_V3 =
    Stream_Format_RTCM_V3;
  static const Format NOVATEL_TEXT =
    Stream_Format_NOVATEL_TEXT;
  static const Format NOVATEL_BINARY =
    Stream_Format_NOVATEL_BINARY;
  static const Format UBLOX_TEXT =
    Stream_Format_UBLOX_TEXT;
  static const Format UBLOX_BINARY =
    Stream_Format_UBLOX_BINARY;
  static const Format NEWTONM2_TEXT =
    Stream_Format_NEWTONM2_TEXT;
  static const Format NEWTONM2_BINARY =
    Stream_Format_NEWTONM2_BINARY;
  static inline bool Format_IsValid(int value) {
    return Stream_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Stream_Format_Format_MIN;
  static const Format Format_MAX =
    Stream_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Stream_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Format_descriptor() {
    return Stream_Format_descriptor();
  }
  static inline const ::std::string& Format_Name(Format value) {
    return Stream_Format_Name(value);
  }
  static inline bool Format_Parse(const ::std::string& name,
      Format* value) {
    return Stream_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.drivers.gnss.config.Stream.Format format = 1;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  ::jmc_auto::drivers::gnss::config::Stream_Format format() const;
  void set_format(::jmc_auto::drivers::gnss::config::Stream_Format value);

  // optional bool push_location = 6;
  bool has_push_location() const;
  void clear_push_location();
  static const int kPushLocationFieldNumber = 6;
  bool push_location() const;
  void set_push_location(bool value);

  // optional .jmc_auto.drivers.gnss.config.Stream.Serial serial = 2;
  bool has_serial() const;
  void clear_serial();
  static const int kSerialFieldNumber = 2;
  const ::jmc_auto::drivers::gnss::config::Stream_Serial& serial() const;
  ::jmc_auto::drivers::gnss::config::Stream_Serial* mutable_serial();
  ::jmc_auto::drivers::gnss::config::Stream_Serial* release_serial();
  void set_allocated_serial(::jmc_auto::drivers::gnss::config::Stream_Serial* serial);

  // optional .jmc_auto.drivers.gnss.config.Stream.Tcp tcp = 3;
  bool has_tcp() const;
  void clear_tcp();
  static const int kTcpFieldNumber = 3;
  const ::jmc_auto::drivers::gnss::config::Stream_Tcp& tcp() const;
  ::jmc_auto::drivers::gnss::config::Stream_Tcp* mutable_tcp();
  ::jmc_auto::drivers::gnss::config::Stream_Tcp* release_tcp();
  void set_allocated_tcp(::jmc_auto::drivers::gnss::config::Stream_Tcp* tcp);

  // optional .jmc_auto.drivers.gnss.config.Stream.Udp udp = 4;
  bool has_udp() const;
  void clear_udp();
  static const int kUdpFieldNumber = 4;
  const ::jmc_auto::drivers::gnss::config::Stream_Udp& udp() const;
  ::jmc_auto::drivers::gnss::config::Stream_Udp* mutable_udp();
  ::jmc_auto::drivers::gnss::config::Stream_Udp* release_udp();
  void set_allocated_udp(::jmc_auto::drivers::gnss::config::Stream_Udp* udp);

  // optional .jmc_auto.drivers.gnss.config.Stream.Ntrip ntrip = 5;
  bool has_ntrip() const;
  void clear_ntrip();
  static const int kNtripFieldNumber = 5;
  const ::jmc_auto::drivers::gnss::config::Stream_Ntrip& ntrip() const;
  ::jmc_auto::drivers::gnss::config::Stream_Ntrip* mutable_ntrip();
  ::jmc_auto::drivers::gnss::config::Stream_Ntrip* release_ntrip();
  void set_allocated_ntrip(::jmc_auto::drivers::gnss::config::Stream_Ntrip* ntrip);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.Stream)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_serial();
  void set_has_tcp();
  void set_has_udp();
  void set_has_ntrip();
  void set_has_push_location();
  void clear_has_push_location();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int format_;
  bool push_location_;
  union TypeUnion {
    TypeUnion() {}
    ::jmc_auto::drivers::gnss::config::Stream_Serial* serial_;
    ::jmc_auto::drivers::gnss::config::Stream_Tcp* tcp_;
    ::jmc_auto::drivers::gnss::config::Stream_Udp* udp_;
    ::jmc_auto::drivers::gnss::config::Stream_Ntrip* ntrip_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NovatelConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.NovatelConfig) */ {
 public:
  NovatelConfig();
  virtual ~NovatelConfig();

  NovatelConfig(const NovatelConfig& from);

  inline NovatelConfig& operator=(const NovatelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NovatelConfig& default_instance();

  static inline const NovatelConfig* internal_default_instance() {
    return reinterpret_cast<const NovatelConfig*>(
               &_NovatelConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(NovatelConfig* other);

  // implements Message ----------------------------------------------

  inline NovatelConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  NovatelConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NovatelConfig& from);
  void MergeFrom(const NovatelConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NovatelConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 imu_orientation = 1 [default = 5];
  bool has_imu_orientation() const;
  void clear_imu_orientation();
  static const int kImuOrientationFieldNumber = 1;
  ::google::protobuf::int32 imu_orientation() const;
  void set_imu_orientation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.NovatelConfig)
 private:
  void set_has_imu_orientation();
  void clear_has_imu_orientation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 imu_orientation_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewtonM2Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.NewtonM2Config) */ {
 public:
  NewtonM2Config();
  virtual ~NewtonM2Config();

  NewtonM2Config(const NewtonM2Config& from);

  inline NewtonM2Config& operator=(const NewtonM2Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewtonM2Config& default_instance();

  static inline const NewtonM2Config* internal_default_instance() {
    return reinterpret_cast<const NewtonM2Config*>(
               &_NewtonM2Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(NewtonM2Config* other);

  // implements Message ----------------------------------------------

  inline NewtonM2Config* New() const PROTOBUF_FINAL { return New(NULL); }

  NewtonM2Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewtonM2Config& from);
  void MergeFrom(const NewtonM2Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewtonM2Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 imu_orientation = 1 [default = 5];
  bool has_imu_orientation() const;
  void clear_imu_orientation();
  static const int kImuOrientationFieldNumber = 1;
  ::google::protobuf::int32 imu_orientation() const;
  void set_imu_orientation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.NewtonM2Config)
 private:
  void set_has_imu_orientation();
  void clear_has_imu_orientation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 imu_orientation_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UbloxConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.UbloxConfig) */ {
 public:
  UbloxConfig();
  virtual ~UbloxConfig();

  UbloxConfig(const UbloxConfig& from);

  inline UbloxConfig& operator=(const UbloxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UbloxConfig& default_instance();

  static inline const UbloxConfig* internal_default_instance() {
    return reinterpret_cast<const UbloxConfig*>(
               &_UbloxConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(UbloxConfig* other);

  // implements Message ----------------------------------------------

  inline UbloxConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  UbloxConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UbloxConfig& from);
  void MergeFrom(const UbloxConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UbloxConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.UbloxConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TF : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.TF) */ {
 public:
  TF();
  virtual ~TF();

  TF(const TF& from);

  inline TF& operator=(const TF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TF& default_instance();

  static inline const TF* internal_default_instance() {
    return reinterpret_cast<const TF*>(
               &_TF_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TF* other);

  // implements Message ----------------------------------------------

  inline TF* New() const PROTOBUF_FINAL { return New(NULL); }

  TF* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TF& from);
  void MergeFrom(const TF& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TF* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string frame_id = 1 [default = "world"];
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 1;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // optional string child_frame_id = 2 [default = "novatel"];
  bool has_child_frame_id() const;
  void clear_child_frame_id();
  static const int kChildFrameIdFieldNumber = 2;
  const ::std::string& child_frame_id() const;
  void set_child_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_child_frame_id(::std::string&& value);
  #endif
  void set_child_frame_id(const char* value);
  void set_child_frame_id(const char* value, size_t size);
  ::std::string* mutable_child_frame_id();
  ::std::string* release_child_frame_id();
  void set_allocated_child_frame_id(::std::string* child_frame_id);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.TF)
 private:
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_child_frame_id();
  void clear_has_child_frame_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_frame_id_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_child_frame_id_;
  ::google::protobuf::internal::ArenaStringPtr child_frame_id_;
  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.gnss.config.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  enum DeviceConfigCase {
    kNovatelConfig = 7,
    kUbloxConfig = 8,
    kNewtonm2Config = 15,
    DEVICE_CONFIG_NOT_SET = 0,
  };

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  inline Config* New() const PROTOBUF_FINAL { return New(NULL); }

  Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Config_RtkSolutionType RtkSolutionType;
  static const RtkSolutionType RTK_RECEIVER_SOLUTION =
    Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
  static const RtkSolutionType RTK_SOFTWARE_SOLUTION =
    Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
  static inline bool RtkSolutionType_IsValid(int value) {
    return Config_RtkSolutionType_IsValid(value);
  }
  static const RtkSolutionType RtkSolutionType_MIN =
    Config_RtkSolutionType_RtkSolutionType_MIN;
  static const RtkSolutionType RtkSolutionType_MAX =
    Config_RtkSolutionType_RtkSolutionType_MAX;
  static const int RtkSolutionType_ARRAYSIZE =
    Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RtkSolutionType_descriptor() {
    return Config_RtkSolutionType_descriptor();
  }
  static inline const ::std::string& RtkSolutionType_Name(RtkSolutionType value) {
    return Config_RtkSolutionType_Name(value);
  }
  static inline bool RtkSolutionType_Parse(const ::std::string& name,
      RtkSolutionType* value) {
    return Config_RtkSolutionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes login_commands = 5;
  int login_commands_size() const;
  void clear_login_commands();
  static const int kLoginCommandsFieldNumber = 5;
  const ::std::string& login_commands(int index) const;
  ::std::string* mutable_login_commands(int index);
  void set_login_commands(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_login_commands(int index, ::std::string&& value);
  #endif
  void set_login_commands(int index, const char* value);
  void set_login_commands(int index, const void* value, size_t size);
  ::std::string* add_login_commands();
  void add_login_commands(const ::std::string& value);
  #if LANG_CXX11
  void add_login_commands(::std::string&& value);
  #endif
  void add_login_commands(const char* value);
  void add_login_commands(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& login_commands() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_login_commands();

  // repeated bytes logout_commands = 6;
  int logout_commands_size() const;
  void clear_logout_commands();
  static const int kLogoutCommandsFieldNumber = 6;
  const ::std::string& logout_commands(int index) const;
  ::std::string* mutable_logout_commands(int index);
  void set_logout_commands(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_logout_commands(int index, ::std::string&& value);
  #endif
  void set_logout_commands(int index, const char* value);
  void set_logout_commands(int index, const void* value, size_t size);
  ::std::string* add_logout_commands();
  void add_logout_commands(const ::std::string& value);
  #if LANG_CXX11
  void add_logout_commands(::std::string&& value);
  #endif
  void add_logout_commands(const char* value);
  void add_logout_commands(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& logout_commands() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_logout_commands();

  // optional string proj4_text = 11;
  bool has_proj4_text() const;
  void clear_proj4_text();
  static const int kProj4TextFieldNumber = 11;
  const ::std::string& proj4_text() const;
  void set_proj4_text(const ::std::string& value);
  #if LANG_CXX11
  void set_proj4_text(::std::string&& value);
  #endif
  void set_proj4_text(const char* value);
  void set_proj4_text(const char* value, size_t size);
  ::std::string* mutable_proj4_text();
  ::std::string* release_proj4_text();
  void set_allocated_proj4_text(::std::string* proj4_text);

  // optional string wheel_parameters = 13;
  bool has_wheel_parameters() const;
  void clear_wheel_parameters();
  static const int kWheelParametersFieldNumber = 13;
  const ::std::string& wheel_parameters() const;
  void set_wheel_parameters(const ::std::string& value);
  #if LANG_CXX11
  void set_wheel_parameters(::std::string&& value);
  #endif
  void set_wheel_parameters(const char* value);
  void set_wheel_parameters(const char* value, size_t size);
  ::std::string* mutable_wheel_parameters();
  ::std::string* release_wheel_parameters();
  void set_allocated_wheel_parameters(::std::string* wheel_parameters);

  // optional .jmc_auto.drivers.gnss.config.Stream data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::jmc_auto::drivers::gnss::config::Stream& data() const;
  ::jmc_auto::drivers::gnss::config::Stream* mutable_data();
  ::jmc_auto::drivers::gnss::config::Stream* release_data();
  void set_allocated_data(::jmc_auto::drivers::gnss::config::Stream* data);

  // optional .jmc_auto.drivers.gnss.config.Stream command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::jmc_auto::drivers::gnss::config::Stream& command() const;
  ::jmc_auto::drivers::gnss::config::Stream* mutable_command();
  ::jmc_auto::drivers::gnss::config::Stream* release_command();
  void set_allocated_command(::jmc_auto::drivers::gnss::config::Stream* command);

  // optional .jmc_auto.drivers.gnss.config.Stream rtk_from = 3;
  bool has_rtk_from() const;
  void clear_rtk_from();
  static const int kRtkFromFieldNumber = 3;
  const ::jmc_auto::drivers::gnss::config::Stream& rtk_from() const;
  ::jmc_auto::drivers::gnss::config::Stream* mutable_rtk_from();
  ::jmc_auto::drivers::gnss::config::Stream* release_rtk_from();
  void set_allocated_rtk_from(::jmc_auto::drivers::gnss::config::Stream* rtk_from);

  // optional .jmc_auto.drivers.gnss.config.Stream rtk_to = 4;
  bool has_rtk_to() const;
  void clear_rtk_to();
  static const int kRtkToFieldNumber = 4;
  const ::jmc_auto::drivers::gnss::config::Stream& rtk_to() const;
  ::jmc_auto::drivers::gnss::config::Stream* mutable_rtk_to();
  ::jmc_auto::drivers::gnss::config::Stream* release_rtk_to();
  void set_allocated_rtk_to(::jmc_auto::drivers::gnss::config::Stream* rtk_to);

  // optional .jmc_auto.drivers.gnss.config.TF tf = 12;
  bool has_tf() const;
  void clear_tf();
  static const int kTfFieldNumber = 12;
  const ::jmc_auto::drivers::gnss::config::TF& tf() const;
  ::jmc_auto::drivers::gnss::config::TF* mutable_tf();
  ::jmc_auto::drivers::gnss::config::TF* release_tf();
  void set_allocated_tf(::jmc_auto::drivers::gnss::config::TF* tf);

  // optional .jmc_auto.drivers.gnss.config.Config.RtkSolutionType rtk_solution_type = 9;
  bool has_rtk_solution_type() const;
  void clear_rtk_solution_type();
  static const int kRtkSolutionTypeFieldNumber = 9;
  ::jmc_auto::drivers::gnss::config::Config_RtkSolutionType rtk_solution_type() const;
  void set_rtk_solution_type(::jmc_auto::drivers::gnss::config::Config_RtkSolutionType value);

  // optional .jmc_auto.drivers.gnss.config.ImuType imu_type = 10;
  bool has_imu_type() const;
  void clear_imu_type();
  static const int kImuTypeFieldNumber = 10;
  ::jmc_auto::drivers::gnss::config::ImuType imu_type() const;
  void set_imu_type(::jmc_auto::drivers::gnss::config::ImuType value);

  // optional .jmc_auto.drivers.gnss.config.NovatelConfig novatel_config = 7;
  bool has_novatel_config() const;
  void clear_novatel_config();
  static const int kNovatelConfigFieldNumber = 7;
  const ::jmc_auto::drivers::gnss::config::NovatelConfig& novatel_config() const;
  ::jmc_auto::drivers::gnss::config::NovatelConfig* mutable_novatel_config();
  ::jmc_auto::drivers::gnss::config::NovatelConfig* release_novatel_config();
  void set_allocated_novatel_config(::jmc_auto::drivers::gnss::config::NovatelConfig* novatel_config);

  // optional .jmc_auto.drivers.gnss.config.UbloxConfig ublox_config = 8;
  bool has_ublox_config() const;
  void clear_ublox_config();
  static const int kUbloxConfigFieldNumber = 8;
  const ::jmc_auto::drivers::gnss::config::UbloxConfig& ublox_config() const;
  ::jmc_auto::drivers::gnss::config::UbloxConfig* mutable_ublox_config();
  ::jmc_auto::drivers::gnss::config::UbloxConfig* release_ublox_config();
  void set_allocated_ublox_config(::jmc_auto::drivers::gnss::config::UbloxConfig* ublox_config);

  // optional .jmc_auto.drivers.gnss.config.NewtonM2Config newtonm2_config = 15;
  bool has_newtonm2_config() const;
  void clear_newtonm2_config();
  static const int kNewtonm2ConfigFieldNumber = 15;
  const ::jmc_auto::drivers::gnss::config::NewtonM2Config& newtonm2_config() const;
  ::jmc_auto::drivers::gnss::config::NewtonM2Config* mutable_newtonm2_config();
  ::jmc_auto::drivers::gnss::config::NewtonM2Config* release_newtonm2_config();
  void set_allocated_newtonm2_config(::jmc_auto::drivers::gnss::config::NewtonM2Config* newtonm2_config);

  DeviceConfigCase device_config_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.gnss.config.Config)
 private:
  void set_has_data();
  void clear_has_data();
  void set_has_command();
  void clear_has_command();
  void set_has_rtk_from();
  void clear_has_rtk_from();
  void set_has_rtk_to();
  void clear_has_rtk_to();
  void set_has_novatel_config();
  void set_has_ublox_config();
  void set_has_newtonm2_config();
  void set_has_rtk_solution_type();
  void clear_has_rtk_solution_type();
  void set_has_imu_type();
  void clear_has_imu_type();
  void set_has_proj4_text();
  void clear_has_proj4_text();
  void set_has_tf();
  void clear_has_tf();
  void set_has_wheel_parameters();
  void clear_has_wheel_parameters();

  inline bool has_device_config() const;
  void clear_device_config();
  inline void clear_has_device_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> login_commands_;
  ::google::protobuf::RepeatedPtrField< ::std::string> logout_commands_;
  ::google::protobuf::internal::ArenaStringPtr proj4_text_;
  ::google::protobuf::internal::ArenaStringPtr wheel_parameters_;
  ::jmc_auto::drivers::gnss::config::Stream* data_;
  ::jmc_auto::drivers::gnss::config::Stream* command_;
  ::jmc_auto::drivers::gnss::config::Stream* rtk_from_;
  ::jmc_auto::drivers::gnss::config::Stream* rtk_to_;
  ::jmc_auto::drivers::gnss::config::TF* tf_;
  int rtk_solution_type_;
  int imu_type_;
  union DeviceConfigUnion {
    DeviceConfigUnion() {}
    ::jmc_auto::drivers::gnss::config::NovatelConfig* novatel_config_;
    ::jmc_auto::drivers::gnss::config::UbloxConfig* ublox_config_;
    ::jmc_auto::drivers::gnss::config::NewtonM2Config* newtonm2_config_;
  } device_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Stream_Serial

// optional bytes device = 1;
inline bool Stream_Serial::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Serial::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Serial::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Serial::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device();
}
inline const ::std::string& Stream_Serial::device() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Serial.device)
  return device_.GetNoArena();
}
inline void Stream_Serial::set_device(const ::std::string& value) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Serial.device)
}
#if LANG_CXX11
inline void Stream_Serial::set_device(::std::string&& value) {
  set_has_device();
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Serial.device)
}
#endif
inline void Stream_Serial::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Serial.device)
}
inline void Stream_Serial::set_device(const void* value, size_t size) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Serial.device)
}
inline ::std::string* Stream_Serial::mutable_device() {
  set_has_device();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Serial.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Serial::release_device() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Serial.device)
  clear_has_device();
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Serial::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    set_has_device();
  } else {
    clear_has_device();
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Serial.device)
}

// optional int32 baud_rate = 2 [default = 9600];
inline bool Stream_Serial::has_baud_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Serial::set_has_baud_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Serial::clear_has_baud_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Serial::clear_baud_rate() {
  baud_rate_ = 9600;
  clear_has_baud_rate();
}
inline ::google::protobuf::int32 Stream_Serial::baud_rate() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Serial.baud_rate)
  return baud_rate_;
}
inline void Stream_Serial::set_baud_rate(::google::protobuf::int32 value) {
  set_has_baud_rate();
  baud_rate_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Serial.baud_rate)
}

// -------------------------------------------------------------------

// Stream_Tcp

// optional bytes address = 1;
inline bool Stream_Tcp::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Tcp::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Tcp::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Tcp::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Stream_Tcp::address() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
  return address_.GetNoArena();
}
inline void Stream_Tcp::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
}
#if LANG_CXX11
inline void Stream_Tcp::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
}
#endif
inline void Stream_Tcp::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
}
inline void Stream_Tcp::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
}
inline ::std::string* Stream_Tcp::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Tcp::release_address() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Tcp::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Tcp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Tcp::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Tcp::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Tcp::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Tcp::clear_port() {
  port_ = 3001;
  clear_has_port();
}
inline ::google::protobuf::int32 Stream_Tcp::port() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Tcp.port)
  return port_;
}
inline void Stream_Tcp::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Tcp.port)
}

// -------------------------------------------------------------------

// Stream_Udp

// optional bytes address = 1;
inline bool Stream_Udp::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Udp::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Udp::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Udp::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Stream_Udp::address() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Udp.address)
  return address_.GetNoArena();
}
inline void Stream_Udp::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Udp.address)
}
#if LANG_CXX11
inline void Stream_Udp::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Udp.address)
}
#endif
inline void Stream_Udp::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Udp.address)
}
inline void Stream_Udp::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Udp.address)
}
inline ::std::string* Stream_Udp::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Udp.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Udp::release_address() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Udp.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Udp::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Udp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Udp::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Udp::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Udp::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Udp::clear_port() {
  port_ = 3001;
  clear_has_port();
}
inline ::google::protobuf::int32 Stream_Udp::port() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Udp.port)
  return port_;
}
inline void Stream_Udp::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Udp.port)
}

// -------------------------------------------------------------------

// Stream_Ntrip

// optional bytes address = 1;
inline bool Stream_Ntrip::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Ntrip::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Ntrip::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Ntrip::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Stream_Ntrip::address() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
  return address_.GetNoArena();
}
inline void Stream_Ntrip::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
}
#if LANG_CXX11
inline void Stream_Ntrip::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
}
#endif
inline void Stream_Ntrip::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
}
inline void Stream_Ntrip::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
}
inline ::std::string* Stream_Ntrip::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Ntrip::release_address() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Ntrip::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Ntrip.address)
}

// optional int32 port = 2 [default = 2101];
inline bool Stream_Ntrip::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Stream_Ntrip::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Stream_Ntrip::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Stream_Ntrip::clear_port() {
  port_ = 2101;
  clear_has_port();
}
inline ::google::protobuf::int32 Stream_Ntrip::port() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Ntrip.port)
  return port_;
}
inline void Stream_Ntrip::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Ntrip.port)
}

// optional bytes mount_point = 3;
inline bool Stream_Ntrip::has_mount_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Ntrip::set_has_mount_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Ntrip::clear_has_mount_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Ntrip::clear_mount_point() {
  mount_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mount_point();
}
inline const ::std::string& Stream_Ntrip::mount_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
  return mount_point_.GetNoArena();
}
inline void Stream_Ntrip::set_mount_point(const ::std::string& value) {
  set_has_mount_point();
  mount_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
}
#if LANG_CXX11
inline void Stream_Ntrip::set_mount_point(::std::string&& value) {
  set_has_mount_point();
  mount_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
}
#endif
inline void Stream_Ntrip::set_mount_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mount_point();
  mount_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
}
inline void Stream_Ntrip::set_mount_point(const void* value, size_t size) {
  set_has_mount_point();
  mount_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
}
inline ::std::string* Stream_Ntrip::mutable_mount_point() {
  set_has_mount_point();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
  return mount_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Ntrip::release_mount_point() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
  clear_has_mount_point();
  return mount_point_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Ntrip::set_allocated_mount_point(::std::string* mount_point) {
  if (mount_point != NULL) {
    set_has_mount_point();
  } else {
    clear_has_mount_point();
  }
  mount_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mount_point);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Ntrip.mount_point)
}

// optional bytes user = 4;
inline bool Stream_Ntrip::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stream_Ntrip::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stream_Ntrip::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stream_Ntrip::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& Stream_Ntrip::user() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
  return user_.GetNoArena();
}
inline void Stream_Ntrip::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
}
#if LANG_CXX11
inline void Stream_Ntrip::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
}
#endif
inline void Stream_Ntrip::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
}
inline void Stream_Ntrip::set_user(const void* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
}
inline ::std::string* Stream_Ntrip::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Ntrip::release_user() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Ntrip::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Ntrip.user)
}

// optional bytes password = 5;
inline bool Stream_Ntrip::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Stream_Ntrip::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Stream_Ntrip::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Stream_Ntrip::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& Stream_Ntrip::password() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
  return password_.GetNoArena();
}
inline void Stream_Ntrip::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
}
#if LANG_CXX11
inline void Stream_Ntrip::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
}
#endif
inline void Stream_Ntrip::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
}
inline void Stream_Ntrip::set_password(const void* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
}
inline ::std::string* Stream_Ntrip::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream_Ntrip::release_password() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream_Ntrip::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.Ntrip.password)
}

// optional uint32 timeout_s = 6 [default = 30];
inline bool Stream_Ntrip::has_timeout_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Stream_Ntrip::set_has_timeout_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Stream_Ntrip::clear_has_timeout_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Stream_Ntrip::clear_timeout_s() {
  timeout_s_ = 30u;
  clear_has_timeout_s();
}
inline ::google::protobuf::uint32 Stream_Ntrip::timeout_s() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.Ntrip.timeout_s)
  return timeout_s_;
}
inline void Stream_Ntrip::set_timeout_s(::google::protobuf::uint32 value) {
  set_has_timeout_s();
  timeout_s_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.Ntrip.timeout_s)
}

// -------------------------------------------------------------------

// Stream

// optional .jmc_auto.drivers.gnss.config.Stream.Format format = 1;
inline bool Stream::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::jmc_auto::drivers::gnss::config::Stream_Format Stream::format() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.format)
  return static_cast< ::jmc_auto::drivers::gnss::config::Stream_Format >(format_);
}
inline void Stream::set_format(::jmc_auto::drivers::gnss::config::Stream_Format value) {
  assert(::jmc_auto::drivers::gnss::config::Stream_Format_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.format)
}

// optional .jmc_auto.drivers.gnss.config.Stream.Serial serial = 2;
inline bool Stream::has_serial() const {
  return type_case() == kSerial;
}
inline void Stream::set_has_serial() {
  _oneof_case_[0] = kSerial;
}
inline void Stream::clear_serial() {
  if (has_serial()) {
    delete type_.serial_;
    clear_has_type();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::Stream_Serial& Stream::serial() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.serial)
  return has_serial()
      ? *type_.serial_
      : ::jmc_auto::drivers::gnss::config::Stream_Serial::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream_Serial* Stream::mutable_serial() {
  if (!has_serial()) {
    clear_type();
    set_has_serial();
    type_.serial_ = new ::jmc_auto::drivers::gnss::config::Stream_Serial;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.serial)
  return type_.serial_;
}
inline ::jmc_auto::drivers::gnss::config::Stream_Serial* Stream::release_serial() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.serial)
  if (has_serial()) {
    clear_has_type();
    ::jmc_auto::drivers::gnss::config::Stream_Serial* temp = type_.serial_;
    type_.serial_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_serial(::jmc_auto::drivers::gnss::config::Stream_Serial* serial) {
  clear_type();
  if (serial) {
    set_has_serial();
    type_.serial_ = serial;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.serial)
}

// optional .jmc_auto.drivers.gnss.config.Stream.Tcp tcp = 3;
inline bool Stream::has_tcp() const {
  return type_case() == kTcp;
}
inline void Stream::set_has_tcp() {
  _oneof_case_[0] = kTcp;
}
inline void Stream::clear_tcp() {
  if (has_tcp()) {
    delete type_.tcp_;
    clear_has_type();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::Stream_Tcp& Stream::tcp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.tcp)
  return has_tcp()
      ? *type_.tcp_
      : ::jmc_auto::drivers::gnss::config::Stream_Tcp::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream_Tcp* Stream::mutable_tcp() {
  if (!has_tcp()) {
    clear_type();
    set_has_tcp();
    type_.tcp_ = new ::jmc_auto::drivers::gnss::config::Stream_Tcp;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.tcp)
  return type_.tcp_;
}
inline ::jmc_auto::drivers::gnss::config::Stream_Tcp* Stream::release_tcp() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.tcp)
  if (has_tcp()) {
    clear_has_type();
    ::jmc_auto::drivers::gnss::config::Stream_Tcp* temp = type_.tcp_;
    type_.tcp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_tcp(::jmc_auto::drivers::gnss::config::Stream_Tcp* tcp) {
  clear_type();
  if (tcp) {
    set_has_tcp();
    type_.tcp_ = tcp;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.tcp)
}

// optional .jmc_auto.drivers.gnss.config.Stream.Udp udp = 4;
inline bool Stream::has_udp() const {
  return type_case() == kUdp;
}
inline void Stream::set_has_udp() {
  _oneof_case_[0] = kUdp;
}
inline void Stream::clear_udp() {
  if (has_udp()) {
    delete type_.udp_;
    clear_has_type();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::Stream_Udp& Stream::udp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.udp)
  return has_udp()
      ? *type_.udp_
      : ::jmc_auto::drivers::gnss::config::Stream_Udp::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream_Udp* Stream::mutable_udp() {
  if (!has_udp()) {
    clear_type();
    set_has_udp();
    type_.udp_ = new ::jmc_auto::drivers::gnss::config::Stream_Udp;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.udp)
  return type_.udp_;
}
inline ::jmc_auto::drivers::gnss::config::Stream_Udp* Stream::release_udp() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.udp)
  if (has_udp()) {
    clear_has_type();
    ::jmc_auto::drivers::gnss::config::Stream_Udp* temp = type_.udp_;
    type_.udp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_udp(::jmc_auto::drivers::gnss::config::Stream_Udp* udp) {
  clear_type();
  if (udp) {
    set_has_udp();
    type_.udp_ = udp;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.udp)
}

// optional .jmc_auto.drivers.gnss.config.Stream.Ntrip ntrip = 5;
inline bool Stream::has_ntrip() const {
  return type_case() == kNtrip;
}
inline void Stream::set_has_ntrip() {
  _oneof_case_[0] = kNtrip;
}
inline void Stream::clear_ntrip() {
  if (has_ntrip()) {
    delete type_.ntrip_;
    clear_has_type();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::Stream_Ntrip& Stream::ntrip() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.ntrip)
  return has_ntrip()
      ? *type_.ntrip_
      : ::jmc_auto::drivers::gnss::config::Stream_Ntrip::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream_Ntrip* Stream::mutable_ntrip() {
  if (!has_ntrip()) {
    clear_type();
    set_has_ntrip();
    type_.ntrip_ = new ::jmc_auto::drivers::gnss::config::Stream_Ntrip;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Stream.ntrip)
  return type_.ntrip_;
}
inline ::jmc_auto::drivers::gnss::config::Stream_Ntrip* Stream::release_ntrip() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Stream.ntrip)
  if (has_ntrip()) {
    clear_has_type();
    ::jmc_auto::drivers::gnss::config::Stream_Ntrip* temp = type_.ntrip_;
    type_.ntrip_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_ntrip(::jmc_auto::drivers::gnss::config::Stream_Ntrip* ntrip) {
  clear_type();
  if (ntrip) {
    set_has_ntrip();
    type_.ntrip_ = ntrip;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Stream.ntrip)
}

// optional bool push_location = 6;
inline bool Stream::has_push_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream::set_has_push_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream::clear_has_push_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream::clear_push_location() {
  push_location_ = false;
  clear_has_push_location();
}
inline bool Stream::push_location() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Stream.push_location)
  return push_location_;
}
inline void Stream::set_push_location(bool value) {
  set_has_push_location();
  push_location_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Stream.push_location)
}

inline bool Stream::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NovatelConfig

// optional int32 imu_orientation = 1 [default = 5];
inline bool NovatelConfig::has_imu_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NovatelConfig::set_has_imu_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NovatelConfig::clear_has_imu_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NovatelConfig::clear_imu_orientation() {
  imu_orientation_ = 5;
  clear_has_imu_orientation();
}
inline ::google::protobuf::int32 NovatelConfig::imu_orientation() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.NovatelConfig.imu_orientation)
  return imu_orientation_;
}
inline void NovatelConfig::set_imu_orientation(::google::protobuf::int32 value) {
  set_has_imu_orientation();
  imu_orientation_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.NovatelConfig.imu_orientation)
}

// -------------------------------------------------------------------

// NewtonM2Config

// optional int32 imu_orientation = 1 [default = 5];
inline bool NewtonM2Config::has_imu_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewtonM2Config::set_has_imu_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewtonM2Config::clear_has_imu_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewtonM2Config::clear_imu_orientation() {
  imu_orientation_ = 5;
  clear_has_imu_orientation();
}
inline ::google::protobuf::int32 NewtonM2Config::imu_orientation() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.NewtonM2Config.imu_orientation)
  return imu_orientation_;
}
inline void NewtonM2Config::set_imu_orientation(::google::protobuf::int32 value) {
  set_has_imu_orientation();
  imu_orientation_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.NewtonM2Config.imu_orientation)
}

// -------------------------------------------------------------------

// UbloxConfig

// -------------------------------------------------------------------

// TF

// optional string frame_id = 1 [default = "world"];
inline bool TF::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TF::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TF::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TF::clear_frame_id() {
  frame_id_.ClearToDefaultNoArena(&TF::_default_frame_id_.get());
  clear_has_frame_id();
}
inline const ::std::string& TF::frame_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.TF.frame_id)
  return frame_id_.GetNoArena();
}
inline void TF::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&TF::_default_frame_id_.get(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.TF.frame_id)
}
#if LANG_CXX11
inline void TF::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &TF::_default_frame_id_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.TF.frame_id)
}
#endif
inline void TF::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&TF::_default_frame_id_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.TF.frame_id)
}
inline void TF::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&TF::_default_frame_id_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.TF.frame_id)
}
inline ::std::string* TF::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.TF.frame_id)
  return frame_id_.MutableNoArena(&TF::_default_frame_id_.get());
}
inline ::std::string* TF::release_frame_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.TF.frame_id)
  clear_has_frame_id();
  return frame_id_.ReleaseNoArena(&TF::_default_frame_id_.get());
}
inline void TF::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&TF::_default_frame_id_.get(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.TF.frame_id)
}

// optional string child_frame_id = 2 [default = "novatel"];
inline bool TF::has_child_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TF::set_has_child_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TF::clear_has_child_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TF::clear_child_frame_id() {
  child_frame_id_.ClearToDefaultNoArena(&TF::_default_child_frame_id_.get());
  clear_has_child_frame_id();
}
inline const ::std::string& TF::child_frame_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.TF.child_frame_id)
  return child_frame_id_.GetNoArena();
}
inline void TF::set_child_frame_id(const ::std::string& value) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&TF::_default_child_frame_id_.get(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.TF.child_frame_id)
}
#if LANG_CXX11
inline void TF::set_child_frame_id(::std::string&& value) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(
    &TF::_default_child_frame_id_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.TF.child_frame_id)
}
#endif
inline void TF::set_child_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&TF::_default_child_frame_id_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.TF.child_frame_id)
}
inline void TF::set_child_frame_id(const char* value, size_t size) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&TF::_default_child_frame_id_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.TF.child_frame_id)
}
inline ::std::string* TF::mutable_child_frame_id() {
  set_has_child_frame_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.TF.child_frame_id)
  return child_frame_id_.MutableNoArena(&TF::_default_child_frame_id_.get());
}
inline ::std::string* TF::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.TF.child_frame_id)
  clear_has_child_frame_id();
  return child_frame_id_.ReleaseNoArena(&TF::_default_child_frame_id_.get());
}
inline void TF::set_allocated_child_frame_id(::std::string* child_frame_id) {
  if (child_frame_id != NULL) {
    set_has_child_frame_id();
  } else {
    clear_has_child_frame_id();
  }
  child_frame_id_.SetAllocatedNoArena(&TF::_default_child_frame_id_.get(), child_frame_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.TF.child_frame_id)
}

// -------------------------------------------------------------------

// Config

// optional .jmc_auto.drivers.gnss.config.Stream data = 1;
inline bool Config::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_data() {
  if (data_ != NULL) data_->::jmc_auto::drivers::gnss::config::Stream::Clear();
  clear_has_data();
}
inline const ::jmc_auto::drivers::gnss::config::Stream& Config::data() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.data)
  return data_ != NULL ? *data_
                         : *::jmc_auto::drivers::gnss::config::Stream::internal_default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::jmc_auto::drivers::gnss::config::Stream;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.data)
  return data_;
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::release_data() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.data)
  clear_has_data();
  ::jmc_auto::drivers::gnss::config::Stream* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Config::set_allocated_data(::jmc_auto::drivers::gnss::config::Stream* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.data)
}

// optional .jmc_auto.drivers.gnss.config.Stream command = 2;
inline bool Config::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_command() {
  if (command_ != NULL) command_->::jmc_auto::drivers::gnss::config::Stream::Clear();
  clear_has_command();
}
inline const ::jmc_auto::drivers::gnss::config::Stream& Config::command() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.command)
  return command_ != NULL ? *command_
                         : *::jmc_auto::drivers::gnss::config::Stream::internal_default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::jmc_auto::drivers::gnss::config::Stream;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.command)
  return command_;
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::release_command() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.command)
  clear_has_command();
  ::jmc_auto::drivers::gnss::config::Stream* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Config::set_allocated_command(::jmc_auto::drivers::gnss::config::Stream* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.command)
}

// optional .jmc_auto.drivers.gnss.config.Stream rtk_from = 3;
inline bool Config::has_rtk_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_rtk_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_rtk_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_rtk_from() {
  if (rtk_from_ != NULL) rtk_from_->::jmc_auto::drivers::gnss::config::Stream::Clear();
  clear_has_rtk_from();
}
inline const ::jmc_auto::drivers::gnss::config::Stream& Config::rtk_from() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.rtk_from)
  return rtk_from_ != NULL ? *rtk_from_
                         : *::jmc_auto::drivers::gnss::config::Stream::internal_default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::mutable_rtk_from() {
  set_has_rtk_from();
  if (rtk_from_ == NULL) {
    rtk_from_ = new ::jmc_auto::drivers::gnss::config::Stream;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.rtk_from)
  return rtk_from_;
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::release_rtk_from() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.rtk_from)
  clear_has_rtk_from();
  ::jmc_auto::drivers::gnss::config::Stream* temp = rtk_from_;
  rtk_from_ = NULL;
  return temp;
}
inline void Config::set_allocated_rtk_from(::jmc_auto::drivers::gnss::config::Stream* rtk_from) {
  delete rtk_from_;
  rtk_from_ = rtk_from;
  if (rtk_from) {
    set_has_rtk_from();
  } else {
    clear_has_rtk_from();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.rtk_from)
}

// optional .jmc_auto.drivers.gnss.config.Stream rtk_to = 4;
inline bool Config::has_rtk_to() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_rtk_to() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_rtk_to() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_rtk_to() {
  if (rtk_to_ != NULL) rtk_to_->::jmc_auto::drivers::gnss::config::Stream::Clear();
  clear_has_rtk_to();
}
inline const ::jmc_auto::drivers::gnss::config::Stream& Config::rtk_to() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.rtk_to)
  return rtk_to_ != NULL ? *rtk_to_
                         : *::jmc_auto::drivers::gnss::config::Stream::internal_default_instance();
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::mutable_rtk_to() {
  set_has_rtk_to();
  if (rtk_to_ == NULL) {
    rtk_to_ = new ::jmc_auto::drivers::gnss::config::Stream;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.rtk_to)
  return rtk_to_;
}
inline ::jmc_auto::drivers::gnss::config::Stream* Config::release_rtk_to() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.rtk_to)
  clear_has_rtk_to();
  ::jmc_auto::drivers::gnss::config::Stream* temp = rtk_to_;
  rtk_to_ = NULL;
  return temp;
}
inline void Config::set_allocated_rtk_to(::jmc_auto::drivers::gnss::config::Stream* rtk_to) {
  delete rtk_to_;
  rtk_to_ = rtk_to;
  if (rtk_to) {
    set_has_rtk_to();
  } else {
    clear_has_rtk_to();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.rtk_to)
}

// repeated bytes login_commands = 5;
inline int Config::login_commands_size() const {
  return login_commands_.size();
}
inline void Config::clear_login_commands() {
  login_commands_.Clear();
}
inline const ::std::string& Config::login_commands(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.login_commands)
  return login_commands_.Get(index);
}
inline ::std::string* Config::mutable_login_commands(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.login_commands)
  return login_commands_.Mutable(index);
}
inline void Config::set_login_commands(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.login_commands)
  login_commands_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Config::set_login_commands(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.login_commands)
  login_commands_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Config::set_login_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  login_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Config.login_commands)
}
inline void Config::set_login_commands(int index, const void* value, size_t size) {
  login_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Config.login_commands)
}
inline ::std::string* Config::add_login_commands() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.drivers.gnss.config.Config.login_commands)
  return login_commands_.Add();
}
inline void Config::add_login_commands(const ::std::string& value) {
  login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.drivers.gnss.config.Config.login_commands)
}
#if LANG_CXX11
inline void Config::add_login_commands(::std::string&& value) {
  login_commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.drivers.gnss.config.Config.login_commands)
}
#endif
inline void Config::add_login_commands(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.drivers.gnss.config.Config.login_commands)
}
inline void Config::add_login_commands(const void* value, size_t size) {
  login_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.drivers.gnss.config.Config.login_commands)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Config::login_commands() const {
  // @@protoc_insertion_point(field_list:jmc_auto.drivers.gnss.config.Config.login_commands)
  return login_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Config::mutable_login_commands() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.drivers.gnss.config.Config.login_commands)
  return &login_commands_;
}

// repeated bytes logout_commands = 6;
inline int Config::logout_commands_size() const {
  return logout_commands_.size();
}
inline void Config::clear_logout_commands() {
  logout_commands_.Clear();
}
inline const ::std::string& Config::logout_commands(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.logout_commands)
  return logout_commands_.Get(index);
}
inline ::std::string* Config::mutable_logout_commands(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.logout_commands)
  return logout_commands_.Mutable(index);
}
inline void Config::set_logout_commands(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.logout_commands)
  logout_commands_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Config::set_logout_commands(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.logout_commands)
  logout_commands_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Config::set_logout_commands(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  logout_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, const void* value, size_t size) {
  logout_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Config.logout_commands)
}
inline ::std::string* Config::add_logout_commands() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.drivers.gnss.config.Config.logout_commands)
  return logout_commands_.Add();
}
inline void Config::add_logout_commands(const ::std::string& value) {
  logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.drivers.gnss.config.Config.logout_commands)
}
#if LANG_CXX11
inline void Config::add_logout_commands(::std::string&& value) {
  logout_commands_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.drivers.gnss.config.Config.logout_commands)
}
#endif
inline void Config::add_logout_commands(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.drivers.gnss.config.Config.logout_commands)
}
inline void Config::add_logout_commands(const void* value, size_t size) {
  logout_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.drivers.gnss.config.Config.logout_commands)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Config::logout_commands() const {
  // @@protoc_insertion_point(field_list:jmc_auto.drivers.gnss.config.Config.logout_commands)
  return logout_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Config::mutable_logout_commands() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.drivers.gnss.config.Config.logout_commands)
  return &logout_commands_;
}

// optional .jmc_auto.drivers.gnss.config.NovatelConfig novatel_config = 7;
inline bool Config::has_novatel_config() const {
  return device_config_case() == kNovatelConfig;
}
inline void Config::set_has_novatel_config() {
  _oneof_case_[0] = kNovatelConfig;
}
inline void Config::clear_novatel_config() {
  if (has_novatel_config()) {
    delete device_config_.novatel_config_;
    clear_has_device_config();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::NovatelConfig& Config::novatel_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.novatel_config)
  return has_novatel_config()
      ? *device_config_.novatel_config_
      : ::jmc_auto::drivers::gnss::config::NovatelConfig::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::NovatelConfig* Config::mutable_novatel_config() {
  if (!has_novatel_config()) {
    clear_device_config();
    set_has_novatel_config();
    device_config_.novatel_config_ = new ::jmc_auto::drivers::gnss::config::NovatelConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.novatel_config)
  return device_config_.novatel_config_;
}
inline ::jmc_auto::drivers::gnss::config::NovatelConfig* Config::release_novatel_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.novatel_config)
  if (has_novatel_config()) {
    clear_has_device_config();
    ::jmc_auto::drivers::gnss::config::NovatelConfig* temp = device_config_.novatel_config_;
    device_config_.novatel_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Config::set_allocated_novatel_config(::jmc_auto::drivers::gnss::config::NovatelConfig* novatel_config) {
  clear_device_config();
  if (novatel_config) {
    set_has_novatel_config();
    device_config_.novatel_config_ = novatel_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.novatel_config)
}

// optional .jmc_auto.drivers.gnss.config.UbloxConfig ublox_config = 8;
inline bool Config::has_ublox_config() const {
  return device_config_case() == kUbloxConfig;
}
inline void Config::set_has_ublox_config() {
  _oneof_case_[0] = kUbloxConfig;
}
inline void Config::clear_ublox_config() {
  if (has_ublox_config()) {
    delete device_config_.ublox_config_;
    clear_has_device_config();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::UbloxConfig& Config::ublox_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.ublox_config)
  return has_ublox_config()
      ? *device_config_.ublox_config_
      : ::jmc_auto::drivers::gnss::config::UbloxConfig::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::UbloxConfig* Config::mutable_ublox_config() {
  if (!has_ublox_config()) {
    clear_device_config();
    set_has_ublox_config();
    device_config_.ublox_config_ = new ::jmc_auto::drivers::gnss::config::UbloxConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.ublox_config)
  return device_config_.ublox_config_;
}
inline ::jmc_auto::drivers::gnss::config::UbloxConfig* Config::release_ublox_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.ublox_config)
  if (has_ublox_config()) {
    clear_has_device_config();
    ::jmc_auto::drivers::gnss::config::UbloxConfig* temp = device_config_.ublox_config_;
    device_config_.ublox_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Config::set_allocated_ublox_config(::jmc_auto::drivers::gnss::config::UbloxConfig* ublox_config) {
  clear_device_config();
  if (ublox_config) {
    set_has_ublox_config();
    device_config_.ublox_config_ = ublox_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.ublox_config)
}

// optional .jmc_auto.drivers.gnss.config.NewtonM2Config newtonm2_config = 15;
inline bool Config::has_newtonm2_config() const {
  return device_config_case() == kNewtonm2Config;
}
inline void Config::set_has_newtonm2_config() {
  _oneof_case_[0] = kNewtonm2Config;
}
inline void Config::clear_newtonm2_config() {
  if (has_newtonm2_config()) {
    delete device_config_.newtonm2_config_;
    clear_has_device_config();
  }
}
inline  const ::jmc_auto::drivers::gnss::config::NewtonM2Config& Config::newtonm2_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.newtonm2_config)
  return has_newtonm2_config()
      ? *device_config_.newtonm2_config_
      : ::jmc_auto::drivers::gnss::config::NewtonM2Config::default_instance();
}
inline ::jmc_auto::drivers::gnss::config::NewtonM2Config* Config::mutable_newtonm2_config() {
  if (!has_newtonm2_config()) {
    clear_device_config();
    set_has_newtonm2_config();
    device_config_.newtonm2_config_ = new ::jmc_auto::drivers::gnss::config::NewtonM2Config;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.newtonm2_config)
  return device_config_.newtonm2_config_;
}
inline ::jmc_auto::drivers::gnss::config::NewtonM2Config* Config::release_newtonm2_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.newtonm2_config)
  if (has_newtonm2_config()) {
    clear_has_device_config();
    ::jmc_auto::drivers::gnss::config::NewtonM2Config* temp = device_config_.newtonm2_config_;
    device_config_.newtonm2_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Config::set_allocated_newtonm2_config(::jmc_auto::drivers::gnss::config::NewtonM2Config* newtonm2_config) {
  clear_device_config();
  if (newtonm2_config) {
    set_has_newtonm2_config();
    device_config_.newtonm2_config_ = newtonm2_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.newtonm2_config)
}

// optional .jmc_auto.drivers.gnss.config.Config.RtkSolutionType rtk_solution_type = 9;
inline bool Config::has_rtk_solution_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Config::set_has_rtk_solution_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Config::clear_has_rtk_solution_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Config::clear_rtk_solution_type() {
  rtk_solution_type_ = 1;
  clear_has_rtk_solution_type();
}
inline ::jmc_auto::drivers::gnss::config::Config_RtkSolutionType Config::rtk_solution_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.rtk_solution_type)
  return static_cast< ::jmc_auto::drivers::gnss::config::Config_RtkSolutionType >(rtk_solution_type_);
}
inline void Config::set_rtk_solution_type(::jmc_auto::drivers::gnss::config::Config_RtkSolutionType value) {
  assert(::jmc_auto::drivers::gnss::config::Config_RtkSolutionType_IsValid(value));
  set_has_rtk_solution_type();
  rtk_solution_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.rtk_solution_type)
}

// optional .jmc_auto.drivers.gnss.config.ImuType imu_type = 10;
inline bool Config::has_imu_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Config::set_has_imu_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Config::clear_has_imu_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Config::clear_imu_type() {
  imu_type_ = 13;
  clear_has_imu_type();
}
inline ::jmc_auto::drivers::gnss::config::ImuType Config::imu_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.imu_type)
  return static_cast< ::jmc_auto::drivers::gnss::config::ImuType >(imu_type_);
}
inline void Config::set_imu_type(::jmc_auto::drivers::gnss::config::ImuType value) {
  assert(::jmc_auto::drivers::gnss::config::ImuType_IsValid(value));
  set_has_imu_type();
  imu_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.imu_type)
}

// optional string proj4_text = 11;
inline bool Config::has_proj4_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_proj4_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_proj4_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_proj4_text() {
  proj4_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_proj4_text();
}
inline const ::std::string& Config::proj4_text() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.proj4_text)
  return proj4_text_.GetNoArena();
}
inline void Config::set_proj4_text(const ::std::string& value) {
  set_has_proj4_text();
  proj4_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.proj4_text)
}
#if LANG_CXX11
inline void Config::set_proj4_text(::std::string&& value) {
  set_has_proj4_text();
  proj4_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Config.proj4_text)
}
#endif
inline void Config::set_proj4_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_proj4_text();
  proj4_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Config.proj4_text)
}
inline void Config::set_proj4_text(const char* value, size_t size) {
  set_has_proj4_text();
  proj4_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Config.proj4_text)
}
inline ::std::string* Config::mutable_proj4_text() {
  set_has_proj4_text();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.proj4_text)
  return proj4_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_proj4_text() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.proj4_text)
  clear_has_proj4_text();
  return proj4_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_proj4_text(::std::string* proj4_text) {
  if (proj4_text != NULL) {
    set_has_proj4_text();
  } else {
    clear_has_proj4_text();
  }
  proj4_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proj4_text);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.proj4_text)
}

// optional .jmc_auto.drivers.gnss.config.TF tf = 12;
inline bool Config::has_tf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Config::set_has_tf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Config::clear_has_tf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Config::clear_tf() {
  if (tf_ != NULL) tf_->::jmc_auto::drivers::gnss::config::TF::Clear();
  clear_has_tf();
}
inline const ::jmc_auto::drivers::gnss::config::TF& Config::tf() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.tf)
  return tf_ != NULL ? *tf_
                         : *::jmc_auto::drivers::gnss::config::TF::internal_default_instance();
}
inline ::jmc_auto::drivers::gnss::config::TF* Config::mutable_tf() {
  set_has_tf();
  if (tf_ == NULL) {
    tf_ = new ::jmc_auto::drivers::gnss::config::TF;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.tf)
  return tf_;
}
inline ::jmc_auto::drivers::gnss::config::TF* Config::release_tf() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.tf)
  clear_has_tf();
  ::jmc_auto::drivers::gnss::config::TF* temp = tf_;
  tf_ = NULL;
  return temp;
}
inline void Config::set_allocated_tf(::jmc_auto::drivers::gnss::config::TF* tf) {
  delete tf_;
  tf_ = tf;
  if (tf) {
    set_has_tf();
  } else {
    clear_has_tf();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.tf)
}

// optional string wheel_parameters = 13;
inline bool Config::has_wheel_parameters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_wheel_parameters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_wheel_parameters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_wheel_parameters() {
  wheel_parameters_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wheel_parameters();
}
inline const ::std::string& Config::wheel_parameters() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
  return wheel_parameters_.GetNoArena();
}
inline void Config::set_wheel_parameters(const ::std::string& value) {
  set_has_wheel_parameters();
  wheel_parameters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
}
#if LANG_CXX11
inline void Config::set_wheel_parameters(::std::string&& value) {
  set_has_wheel_parameters();
  wheel_parameters_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
}
#endif
inline void Config::set_wheel_parameters(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_wheel_parameters();
  wheel_parameters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
}
inline void Config::set_wheel_parameters(const char* value, size_t size) {
  set_has_wheel_parameters();
  wheel_parameters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
}
inline ::std::string* Config::mutable_wheel_parameters() {
  set_has_wheel_parameters();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
  return wheel_parameters_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Config::release_wheel_parameters() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
  clear_has_wheel_parameters();
  return wheel_parameters_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Config::set_allocated_wheel_parameters(::std::string* wheel_parameters) {
  if (wheel_parameters != NULL) {
    set_has_wheel_parameters();
  } else {
    clear_has_wheel_parameters();
  }
  wheel_parameters_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wheel_parameters);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.gnss.config.Config.wheel_parameters)
}

inline bool Config::has_device_config() const {
  return device_config_case() != DEVICE_CONFIG_NOT_SET;
}
inline void Config::clear_has_device_config() {
  _oneof_case_[0] = DEVICE_CONFIG_NOT_SET;
}
inline Config::DeviceConfigCase Config::device_config_case() const {
  return Config::DeviceConfigCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace config
}  // namespace gnss
}  // namespace drivers
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::drivers::gnss::config::Stream_Format> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::drivers::gnss::config::Stream_Format>() {
  return ::jmc_auto::drivers::gnss::config::Stream_Format_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::drivers::gnss::config::Config_RtkSolutionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::drivers::gnss::config::Config_RtkSolutionType>() {
  return ::jmc_auto::drivers::gnss::config::Config_RtkSolutionType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::drivers::gnss::config::ImuType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::drivers::gnss::config::ImuType>() {
  return ::jmc_auto::drivers::gnss::config::ImuType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fdrivers_2fgnss_2fproto_2fconfig_2eproto__INCLUDED
