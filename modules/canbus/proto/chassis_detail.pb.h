// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/canbus/proto/chassis_detail.proto

#ifndef PROTOBUF_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto__INCLUDED
#define PROTOBUF_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/canbus/proto/ch.pb.h"
#include "modules/canbus/proto/teshun.pb.h"
#include "modules/canbus/proto/cx75.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace canbus {
class Abs_sts_0x221_221;
class Abs_sts_0x221_221DefaultTypeInternal;
extern Abs_sts_0x221_221DefaultTypeInternal _Abs_sts_0x221_221_default_instance_;
class Abs_whlspd_0x211_211;
class Abs_whlspd_0x211_211DefaultTypeInternal;
extern Abs_whlspd_0x211_211DefaultTypeInternal _Abs_whlspd_0x211_211_default_instance_;
class Accel_cmd_67;
class Accel_cmd_67DefaultTypeInternal;
extern Accel_cmd_67DefaultTypeInternal _Accel_cmd_67_default_instance_;
class Accel_rpt_68;
class Accel_rpt_68DefaultTypeInternal;
extern Accel_rpt_68DefaultTypeInternal _Accel_rpt_68_default_instance_;
class Adu_bodycontrol_0x333_333;
class Adu_bodycontrol_0x333_333DefaultTypeInternal;
extern Adu_bodycontrol_0x333_333DefaultTypeInternal _Adu_bodycontrol_0x333_333_default_instance_;
class Adu_controlbrake_0x110_110;
class Adu_controlbrake_0x110_110DefaultTypeInternal;
extern Adu_controlbrake_0x110_110DefaultTypeInternal _Adu_controlbrake_0x110_110_default_instance_;
class Adu_controldrive_0x120_120;
class Adu_controldrive_0x120_120DefaultTypeInternal;
extern Adu_controldrive_0x120_120DefaultTypeInternal _Adu_controldrive_0x120_120_default_instance_;
class Adu_controleps2_0x100_100;
class Adu_controleps2_0x100_100DefaultTypeInternal;
extern Adu_controleps2_0x100_100DefaultTypeInternal _Adu_controleps2_0x100_100_default_instance_;
class Afs_0x5a0_5a0;
class Afs_0x5a0_5a0DefaultTypeInternal;
extern Afs_0x5a0_5a0DefaultTypeInternal _Afs_0x5a0_5a0_default_instance_;
class BasicInfo;
class BasicInfoDefaultTypeInternal;
extern BasicInfoDefaultTypeInternal _BasicInfo_default_instance_;
class Battery;
class BatteryDefaultTypeInternal;
extern BatteryDefaultTypeInternal _Battery_default_instance_;
class Bcm_bodysts_0x344_344;
class Bcm_bodysts_0x344_344DefaultTypeInternal;
extern Bcm_bodysts_0x344_344DefaultTypeInternal _Bcm_bodysts_0x344_344_default_instance_;
class Bcm_door_0x310_310;
class Bcm_door_0x310_310DefaultTypeInternal;
extern Bcm_door_0x310_310DefaultTypeInternal _Bcm_door_0x310_310_default_instance_;
class Brake;
class BrakeDefaultTypeInternal;
extern BrakeDefaultTypeInternal _Brake_default_instance_;
class Brake_cmd_6b;
class Brake_cmd_6bDefaultTypeInternal;
extern Brake_cmd_6bDefaultTypeInternal _Brake_cmd_6b_default_instance_;
class Brake_command_111;
class Brake_command_111DefaultTypeInternal;
extern Brake_command_111DefaultTypeInternal _Brake_command_111_default_instance_;
class Brake_motor_rpt_1_70;
class Brake_motor_rpt_1_70DefaultTypeInternal;
extern Brake_motor_rpt_1_70DefaultTypeInternal _Brake_motor_rpt_1_70_default_instance_;
class Brake_motor_rpt_2_71;
class Brake_motor_rpt_2_71DefaultTypeInternal;
extern Brake_motor_rpt_2_71DefaultTypeInternal _Brake_motor_rpt_2_71_default_instance_;
class Brake_motor_rpt_3_72;
class Brake_motor_rpt_3_72DefaultTypeInternal;
extern Brake_motor_rpt_3_72DefaultTypeInternal _Brake_motor_rpt_3_72_default_instance_;
class Brake_rpt_6c;
class Brake_rpt_6cDefaultTypeInternal;
extern Brake_rpt_6cDefaultTypeInternal _Brake_rpt_6c_default_instance_;
class Brake_status__511;
class Brake_status__511DefaultTypeInternal;
extern Brake_status__511DefaultTypeInternal _Brake_status__511_default_instance_;
class Ch;
class ChDefaultTypeInternal;
extern ChDefaultTypeInternal _Ch_default_instance_;
class Chassis;
class ChassisDefaultTypeInternal;
extern ChassisDefaultTypeInternal _Chassis_default_instance_;
class ChassisDetail;
class ChassisDetailDefaultTypeInternal;
extern ChassisDetailDefaultTypeInternal _ChassisDetail_default_instance_;
class ChassisGPS;
class ChassisGPSDefaultTypeInternal;
extern ChassisGPSDefaultTypeInternal _ChassisGPS_default_instance_;
class CheckResponseSignal;
class CheckResponseSignalDefaultTypeInternal;
extern CheckResponseSignalDefaultTypeInternal _CheckResponseSignal_default_instance_;
class Control_command_115;
class Control_command_115DefaultTypeInternal;
extern Control_command_115DefaultTypeInternal _Control_command_115_default_instance_;
class Cx75;
class Cx75DefaultTypeInternal;
extern Cx75DefaultTypeInternal _Cx75_default_instance_;
class Date_time_rpt_83;
class Date_time_rpt_83DefaultTypeInternal;
extern Date_time_rpt_83DefaultTypeInternal _Date_time_rpt_83_default_instance_;
class Deceleration;
class DecelerationDefaultTypeInternal;
extern DecelerationDefaultTypeInternal _Deceleration_default_instance_;
class Ecu_status_1_515;
class Ecu_status_1_515DefaultTypeInternal;
extern Ecu_status_1_515DefaultTypeInternal _Ecu_status_1_515_default_instance_;
class Ecu_status_2_516;
class Ecu_status_2_516DefaultTypeInternal;
extern Ecu_status_2_516DefaultTypeInternal _Ecu_status_2_516_default_instance_;
class Ecu_status_3_517;
class Ecu_status_3_517DefaultTypeInternal;
extern Ecu_status_3_517DefaultTypeInternal _Ecu_status_3_517_default_instance_;
class Ems;
class EmsDefaultTypeInternal;
extern EmsDefaultTypeInternal _Ems_default_instance_;
class Epb;
class EpbDefaultTypeInternal;
extern EpbDefaultTypeInternal _Epb_default_instance_;
class Epb_status_0x152_152;
class Epb_status_0x152_152DefaultTypeInternal;
extern Epb_status_0x152_152DefaultTypeInternal _Epb_status_0x152_152_default_instance_;
class Eps;
class EpsDefaultTypeInternal;
extern EpsDefaultTypeInternal _Eps_default_instance_;
class Eps2_status_0x112_112;
class Eps2_status_0x112_112DefaultTypeInternal;
extern Eps2_status_0x112_112DefaultTypeInternal _Eps2_status_0x112_112_default_instance_;
class Eps_0x260_260;
class Eps_0x260_260DefaultTypeInternal;
extern Eps_0x260_260DefaultTypeInternal _Eps_0x260_260_default_instance_;
class Eps_advanced_0x176_176;
class Eps_advanced_0x176_176DefaultTypeInternal;
extern Eps_advanced_0x176_176DefaultTypeInternal _Eps_advanced_0x176_176_default_instance_;
class Esp;
class EspDefaultTypeInternal;
extern EspDefaultTypeInternal _Esp_default_instance_;
class Esp_advanced_0x234_234;
class Esp_advanced_0x234_234DefaultTypeInternal;
extern Esp_advanced_0x234_234DefaultTypeInternal _Esp_advanced_0x234_234_default_instance_;
class Esp_axay_0x242_242;
class Esp_axay_0x242_242DefaultTypeInternal;
extern Esp_axay_0x242_242DefaultTypeInternal _Esp_axay_0x242_242_default_instance_;
class Esp_direction_0x235_235;
class Esp_direction_0x235_235DefaultTypeInternal;
extern Esp_direction_0x235_235DefaultTypeInternal _Esp_direction_0x235_235_default_instance_;
class Esp_pressure_0x241_241;
class Esp_pressure_0x241_241DefaultTypeInternal;
extern Esp_pressure_0x241_241DefaultTypeInternal _Esp_pressure_0x241_241_default_instance_;
class Esp_raw_0x212_212;
class Esp_raw_0x212_212DefaultTypeInternal;
extern Esp_raw_0x212_212DefaultTypeInternal _Esp_raw_0x212_212_default_instance_;
class Esp_rpmf_0x213_213;
class Esp_rpmf_0x213_213DefaultTypeInternal;
extern Esp_rpmf_0x213_213DefaultTypeInternal _Esp_rpmf_0x213_213_default_instance_;
class Esp_status_0x243_243;
class Esp_status_0x243_243DefaultTypeInternal;
extern Esp_status_0x243_243DefaultTypeInternal _Esp_status_0x243_243_default_instance_;
class Esp_tq_0x217_217;
class Esp_tq_0x217_217DefaultTypeInternal;
extern Esp_tq_0x217_217DefaultTypeInternal _Esp_tq_0x217_217_default_instance_;
class Esp_vlc_0x223_223;
class Esp_vlc_0x223_223DefaultTypeInternal;
extern Esp_vlc_0x223_223DefaultTypeInternal _Esp_vlc_0x223_223_default_instance_;
class Esp_whlpulse_0x236_236;
class Esp_whlpulse_0x236_236DefaultTypeInternal;
extern Esp_whlpulse_0x236_236DefaultTypeInternal _Esp_whlpulse_0x236_236_default_instance_;
class Gas;
class GasDefaultTypeInternal;
extern GasDefaultTypeInternal _Gas_default_instance_;
class Gear;
class GearDefaultTypeInternal;
extern GearDefaultTypeInternal _Gear_default_instance_;
class Gear_command_114;
class Gear_command_114DefaultTypeInternal;
extern Gear_command_114DefaultTypeInternal _Gear_command_114_default_instance_;
class Gear_status_514;
class Gear_status_514DefaultTypeInternal;
extern Gear_status_514DefaultTypeInternal _Gear_status_514_default_instance_;
class Gem;
class GemDefaultTypeInternal;
extern GemDefaultTypeInternal _Gem_default_instance_;
class Global_cmd_69;
class Global_cmd_69DefaultTypeInternal;
extern Global_cmd_69DefaultTypeInternal _Global_cmd_69_default_instance_;
class Global_rpt_6a;
class Global_rpt_6aDefaultTypeInternal;
extern Global_rpt_6aDefaultTypeInternal _Global_rpt_6a_default_instance_;
class Gw_abs_0x211_211;
class Gw_abs_0x211_211DefaultTypeInternal;
extern Gw_abs_0x211_211DefaultTypeInternal _Gw_abs_0x211_211_default_instance_;
class Gw_abs_sts_0x221_221;
class Gw_abs_sts_0x221_221DefaultTypeInternal;
extern Gw_abs_sts_0x221_221DefaultTypeInternal _Gw_abs_sts_0x221_221_default_instance_;
class Gw_bcm_door_0x310_310;
class Gw_bcm_door_0x310_310DefaultTypeInternal;
extern Gw_bcm_door_0x310_310DefaultTypeInternal _Gw_bcm_door_0x310_310_default_instance_;
class Gw_bms_display_0x323_323;
class Gw_bms_display_0x323_323DefaultTypeInternal;
extern Gw_bms_display_0x323_323DefaultTypeInternal _Gw_bms_display_0x323_323_default_instance_;
class Gw_bms_sts_0x181_181;
class Gw_bms_sts_0x181_181DefaultTypeInternal;
extern Gw_bms_sts_0x181_181DefaultTypeInternal _Gw_bms_sts_0x181_181_default_instance_;
class Gw_body_0x321_321;
class Gw_body_0x321_321DefaultTypeInternal;
extern Gw_body_0x321_321DefaultTypeInternal _Gw_body_0x321_321_default_instance_;
class Gw_ems_engstatus_0x142_142;
class Gw_ems_engstatus_0x142_142DefaultTypeInternal;
extern Gw_ems_engstatus_0x142_142DefaultTypeInternal _Gw_ems_engstatus_0x142_142_default_instance_;
class Gw_ems_sts_0x151_151;
class Gw_ems_sts_0x151_151DefaultTypeInternal;
extern Gw_ems_sts_0x151_151DefaultTypeInternal _Gw_ems_sts_0x151_151_default_instance_;
class Gw_ems_tq_0x101_101;
class Gw_ems_tq_0x101_101DefaultTypeInternal;
extern Gw_ems_tq_0x101_101DefaultTypeInternal _Gw_ems_tq_0x101_101_default_instance_;
class Gw_ems_tqwhl_0x111_111;
class Gw_ems_tqwhl_0x111_111DefaultTypeInternal;
extern Gw_ems_tqwhl_0x111_111DefaultTypeInternal _Gw_ems_tqwhl_0x111_111_default_instance_;
class Gw_ems_whltq_0x107_107;
class Gw_ems_whltq_0x107_107DefaultTypeInternal;
extern Gw_ems_whltq_0x107_107DefaultTypeInternal _Gw_ems_whltq_0x107_107_default_instance_;
class Gw_ic_0x510_510;
class Gw_ic_0x510_510DefaultTypeInternal;
extern Gw_ic_0x510_510DefaultTypeInternal _Gw_ic_0x510_510_default_instance_;
class Gw_ic_time_0x581_581;
class Gw_ic_time_0x581_581DefaultTypeInternal;
extern Gw_ic_time_0x581_581DefaultTypeInternal _Gw_ic_time_0x581_581_default_instance_;
class Gw_mcu_output_0x225_225;
class Gw_mcu_output_0x225_225DefaultTypeInternal;
extern Gw_mcu_output_0x225_225DefaultTypeInternal _Gw_mcu_output_0x225_225_default_instance_;
class Gw_mcu_power_0x226_226;
class Gw_mcu_power_0x226_226DefaultTypeInternal;
extern Gw_mcu_power_0x226_226DefaultTypeInternal _Gw_mcu_power_0x226_226_default_instance_;
class Gw_mp5_0x530_530;
class Gw_mp5_0x530_530DefaultTypeInternal;
extern Gw_mp5_0x530_530DefaultTypeInternal _Gw_mp5_0x530_530_default_instance_;
class Gw_mp5_nav_0x533_533;
class Gw_mp5_nav_0x533_533DefaultTypeInternal;
extern Gw_mp5_nav_0x533_533DefaultTypeInternal _Gw_mp5_nav_0x533_533_default_instance_;
class Gw_nm_0x460_460;
class Gw_nm_0x460_460DefaultTypeInternal;
extern Gw_nm_0x460_460DefaultTypeInternal _Gw_nm_0x460_460_default_instance_;
class Gw_scu_shiftersts_0xc8_c8;
class Gw_scu_shiftersts_0xc8_c8DefaultTypeInternal;
extern Gw_scu_shiftersts_0xc8_c8DefaultTypeInternal _Gw_scu_shiftersts_0xc8_c8_default_instance_;
class Gw_swm_body_0x31a_31a;
class Gw_swm_body_0x31a_31aDefaultTypeInternal;
extern Gw_swm_body_0x31a_31aDefaultTypeInternal _Gw_swm_body_0x31a_31a_default_instance_;
class Gw_swm_mrr_0x31b_31b;
class Gw_swm_mrr_0x31b_31bDefaultTypeInternal;
extern Gw_swm_mrr_0x31b_31bDefaultTypeInternal _Gw_swm_mrr_0x31b_31b_default_instance_;
class Gw_tbox_location_0x580_580;
class Gw_tbox_location_0x580_580DefaultTypeInternal;
extern Gw_tbox_location_0x580_580DefaultTypeInternal _Gw_tbox_location_0x580_580_default_instance_;
class Gw_tcu_gearinfo_0x123_123;
class Gw_tcu_gearinfo_0x123_123DefaultTypeInternal;
extern Gw_tcu_gearinfo_0x123_123DefaultTypeInternal _Gw_tcu_gearinfo_0x123_123_default_instance_;
class Gw_tpms_tire_0x361_361;
class Gw_tpms_tire_0x361_361DefaultTypeInternal;
extern Gw_tpms_tire_0x361_361DefaultTypeInternal _Gw_tpms_tire_0x361_361_default_instance_;
class Gw_vcu_control2_0x131_131;
class Gw_vcu_control2_0x131_131DefaultTypeInternal;
extern Gw_vcu_control2_0x131_131DefaultTypeInternal _Gw_vcu_control2_0x131_131_default_instance_;
class Gw_vcu_control_0x185_185;
class Gw_vcu_control_0x185_185DefaultTypeInternal;
extern Gw_vcu_control_0x185_185DefaultTypeInternal _Gw_vcu_control_0x185_185_default_instance_;
class Gw_vcu_drivests_0x10a_10a;
class Gw_vcu_drivests_0x10a_10aDefaultTypeInternal;
extern Gw_vcu_drivests_0x10a_10aDefaultTypeInternal _Gw_vcu_drivests_0x10a_10a_default_instance_;
class Gw_vcu_hmi_0x358_358;
class Gw_vcu_hmi_0x358_358DefaultTypeInternal;
extern Gw_vcu_hmi_0x358_358DefaultTypeInternal _Gw_vcu_hmi_0x358_358_default_instance_;
class Gw_vcu_sts_0x218_218;
class Gw_vcu_sts_0x218_218DefaultTypeInternal;
extern Gw_vcu_sts_0x218_218DefaultTypeInternal _Gw_vcu_sts_0x218_218_default_instance_;
class Gw_vcu_whltq_0x107_107;
class Gw_vcu_whltq_0x107_107DefaultTypeInternal;
extern Gw_vcu_whltq_0x107_107DefaultTypeInternal _Gw_vcu_whltq_0x107_107_default_instance_;
class Headlight_cmd_76;
class Headlight_cmd_76DefaultTypeInternal;
extern Headlight_cmd_76DefaultTypeInternal _Headlight_cmd_76_default_instance_;
class Headlight_rpt_77;
class Headlight_rpt_77DefaultTypeInternal;
extern Headlight_rpt_77DefaultTypeInternal _Headlight_rpt_77_default_instance_;
class Horn_cmd_78;
class Horn_cmd_78DefaultTypeInternal;
extern Horn_cmd_78DefaultTypeInternal _Horn_cmd_78_default_instance_;
class Horn_rpt_79;
class Horn_rpt_79DefaultTypeInternal;
extern Horn_rpt_79DefaultTypeInternal _Horn_rpt_79_default_instance_;
class Ibc_status2_0x124_124;
class Ibc_status2_0x124_124DefaultTypeInternal;
extern Ibc_status2_0x124_124DefaultTypeInternal _Ibc_status2_0x124_124_default_instance_;
class Ibc_status_0x122_122;
class Ibc_status_0x122_122DefaultTypeInternal;
extern Ibc_status_0x122_122DefaultTypeInternal _Ibc_status_0x122_122_default_instance_;
class Ins_acc_500;
class Ins_acc_500DefaultTypeInternal;
extern Ins_acc_500DefaultTypeInternal _Ins_acc_500_default_instance_;
class Ins_datainfo_506;
class Ins_datainfo_506DefaultTypeInternal;
extern Ins_datainfo_506DefaultTypeInternal _Ins_datainfo_506_default_instance_;
class Ins_gyro_501;
class Ins_gyro_501DefaultTypeInternal;
extern Ins_gyro_501DefaultTypeInternal _Ins_gyro_501_default_instance_;
class Ins_headingpitchroll_502;
class Ins_headingpitchroll_502DefaultTypeInternal;
extern Ins_headingpitchroll_502DefaultTypeInternal _Ins_headingpitchroll_502_default_instance_;
class Ins_heightandtime_503;
class Ins_heightandtime_503DefaultTypeInternal;
extern Ins_heightandtime_503DefaultTypeInternal _Ins_heightandtime_503_default_instance_;
class Ins_latitudelongitude_504;
class Ins_latitudelongitude_504DefaultTypeInternal;
extern Ins_latitudelongitude_504DefaultTypeInternal _Ins_latitudelongitude_504_default_instance_;
class Ins_speed_505;
class Ins_speed_505DefaultTypeInternal;
extern Ins_speed_505DefaultTypeInternal _Ins_speed_505_default_instance_;
class Ins_std_507;
class Ins_std_507DefaultTypeInternal;
extern Ins_std_507DefaultTypeInternal _Ins_std_507_default_instance_;
class Ipm_0x245_245;
class Ipm_0x245_245DefaultTypeInternal;
extern Ipm_0x245_245DefaultTypeInternal _Ipm_0x245_245_default_instance_;
class Ipm_leftline_0x278_278;
class Ipm_leftline_0x278_278DefaultTypeInternal;
extern Ipm_leftline_0x278_278DefaultTypeInternal _Ipm_leftline_0x278_278_default_instance_;
class Ipm_rightline_0x490_490;
class Ipm_rightline_0x490_490DefaultTypeInternal;
extern Ipm_rightline_0x490_490DefaultTypeInternal _Ipm_rightline_0x490_490_default_instance_;
class Lat_lon_heading_rpt_82;
class Lat_lon_heading_rpt_82DefaultTypeInternal;
extern Lat_lon_heading_rpt_82DefaultTypeInternal _Lat_lon_heading_rpt_82_default_instance_;
class License;
class LicenseDefaultTypeInternal;
extern LicenseDefaultTypeInternal _License_default_instance_;
class Light;
class LightDefaultTypeInternal;
extern LightDefaultTypeInternal _Light_default_instance_;
class Mrr_0x238_238;
class Mrr_0x238_238DefaultTypeInternal;
extern Mrr_0x238_238DefaultTypeInternal _Mrr_0x238_238_default_instance_;
class Mrr_0x239_239;
class Mrr_0x239_239DefaultTypeInternal;
extern Mrr_0x239_239DefaultTypeInternal _Mrr_0x239_239_default_instance_;
class Mrr_0x246_246;
class Mrr_0x246_246DefaultTypeInternal;
extern Mrr_0x246_246DefaultTypeInternal _Mrr_0x246_246_default_instance_;
class Mrr_frobj_0x279_279;
class Mrr_frobj_0x279_279DefaultTypeInternal;
extern Mrr_frobj_0x279_279DefaultTypeInternal _Mrr_frobj_0x279_279_default_instance_;
class Mrr_frobj_0x480_480;
class Mrr_frobj_0x480_480DefaultTypeInternal;
extern Mrr_frobj_0x480_480DefaultTypeInternal _Mrr_frobj_0x480_480_default_instance_;
class Pam_0x270_270;
class Pam_0x270_270DefaultTypeInternal;
extern Pam_0x270_270DefaultTypeInternal _Pam_0x270_270_default_instance_;
class Pam_0x271_271;
class Pam_0x271_271DefaultTypeInternal;
extern Pam_0x271_271DefaultTypeInternal _Pam_0x271_271_default_instance_;
class Pam_0x272_272;
class Pam_0x272_272DefaultTypeInternal;
extern Pam_0x272_272DefaultTypeInternal _Pam_0x272_272_default_instance_;
class Parking_brake_status_rpt_80;
class Parking_brake_status_rpt_80DefaultTypeInternal;
extern Parking_brake_status_rpt_80DefaultTypeInternal _Parking_brake_status_rpt_80_default_instance_;
class Safety;
class SafetyDefaultTypeInternal;
extern SafetyDefaultTypeInternal _Safety_default_instance_;
class Sas_sensor_0x175_175;
class Sas_sensor_0x175_175DefaultTypeInternal;
extern Sas_sensor_0x175_175DefaultTypeInternal _Sas_sensor_0x175_175_default_instance_;
class Shift_cmd_65;
class Shift_cmd_65DefaultTypeInternal;
extern Shift_cmd_65DefaultTypeInternal _Shift_cmd_65_default_instance_;
class Shift_rpt_66;
class Shift_rpt_66DefaultTypeInternal;
extern Shift_rpt_66DefaultTypeInternal _Shift_rpt_66_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Sod_0x275_275;
class Sod_0x275_275DefaultTypeInternal;
extern Sod_0x275_275DefaultTypeInternal _Sod_0x275_275_default_instance_;
class Sod_nm_0x440_440;
class Sod_nm_0x440_440DefaultTypeInternal;
extern Sod_nm_0x440_440DefaultTypeInternal _Sod_nm_0x440_440_default_instance_;
class Sonar;
class SonarDefaultTypeInternal;
extern SonarDefaultTypeInternal _Sonar_default_instance_;
class Srs_0x350_350;
class Srs_0x350_350DefaultTypeInternal;
extern Srs_0x350_350DefaultTypeInternal _Srs_0x350_350_default_instance_;
class Steer_command_112;
class Steer_command_112DefaultTypeInternal;
extern Steer_command_112DefaultTypeInternal _Steer_command_112_default_instance_;
class Steer_status__512;
class Steer_status__512DefaultTypeInternal;
extern Steer_status__512DefaultTypeInternal _Steer_status__512_default_instance_;
class Steering_cmd_6d;
class Steering_cmd_6dDefaultTypeInternal;
extern Steering_cmd_6dDefaultTypeInternal _Steering_cmd_6d_default_instance_;
class Steering_motor_rpt_1_73;
class Steering_motor_rpt_1_73DefaultTypeInternal;
extern Steering_motor_rpt_1_73DefaultTypeInternal _Steering_motor_rpt_1_73_default_instance_;
class Steering_motor_rpt_2_74;
class Steering_motor_rpt_2_74DefaultTypeInternal;
extern Steering_motor_rpt_2_74DefaultTypeInternal _Steering_motor_rpt_2_74_default_instance_;
class Steering_motor_rpt_3_75;
class Steering_motor_rpt_3_75DefaultTypeInternal;
extern Steering_motor_rpt_3_75DefaultTypeInternal _Steering_motor_rpt_3_75_default_instance_;
class Steering_rpt_1_6e;
class Steering_rpt_1_6eDefaultTypeInternal;
extern Steering_rpt_1_6eDefaultTypeInternal _Steering_rpt_1_6e_default_instance_;
class Surround;
class SurroundDefaultTypeInternal;
extern SurroundDefaultTypeInternal _Surround_default_instance_;
class Teshun;
class TeshunDefaultTypeInternal;
extern TeshunDefaultTypeInternal _Teshun_default_instance_;
class Throttle_command_110;
class Throttle_command_110DefaultTypeInternal;
extern Throttle_command_110DefaultTypeInternal _Throttle_command_110_default_instance_;
class Throttle_status__510;
class Throttle_status__510DefaultTypeInternal;
extern Throttle_status__510DefaultTypeInternal _Throttle_status__510_default_instance_;
class Turn_cmd_63;
class Turn_cmd_63DefaultTypeInternal;
extern Turn_cmd_63DefaultTypeInternal _Turn_cmd_63_default_instance_;
class Turn_rpt_64;
class Turn_rpt_64DefaultTypeInternal;
extern Turn_rpt_64DefaultTypeInternal _Turn_rpt_64_default_instance_;
class Turnsignal_command_113;
class Turnsignal_command_113DefaultTypeInternal;
extern Turnsignal_command_113DefaultTypeInternal _Turnsignal_command_113_default_instance_;
class Turnsignal_status__513;
class Turnsignal_status__513DefaultTypeInternal;
extern Turnsignal_status__513DefaultTypeInternal _Turnsignal_status__513_default_instance_;
class VehicleSpd;
class VehicleSpdDefaultTypeInternal;
extern VehicleSpdDefaultTypeInternal _VehicleSpd_default_instance_;
class Vehicle_speed_rpt_6f;
class Vehicle_speed_rpt_6fDefaultTypeInternal;
extern Vehicle_speed_rpt_6fDefaultTypeInternal _Vehicle_speed_rpt_6f_default_instance_;
class WheelSpeed;
class WheelSpeedDefaultTypeInternal;
extern WheelSpeedDefaultTypeInternal _WheelSpeed_default_instance_;
class Wheel_speed_rpt_7a;
class Wheel_speed_rpt_7aDefaultTypeInternal;
extern Wheel_speed_rpt_7aDefaultTypeInternal _Wheel_speed_rpt_7a_default_instance_;
class Wiper_cmd_90;
class Wiper_cmd_90DefaultTypeInternal;
extern Wiper_cmd_90DefaultTypeInternal _Wiper_cmd_90_default_instance_;
class Wiper_rpt_91;
class Wiper_rpt_91DefaultTypeInternal;
extern Wiper_rpt_91DefaultTypeInternal _Wiper_rpt_91_default_instance_;
class Yaw_rate_rpt_81;
class Yaw_rate_rpt_81DefaultTypeInternal;
extern Yaw_rate_rpt_81DefaultTypeInternal _Yaw_rate_rpt_81_default_instance_;
}  // namespace canbus
}  // namespace jmc_auto

namespace jmc_auto {
namespace canbus {

namespace protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto

enum ChassisDetail_Type {
  ChassisDetail_Type_QIRUI_EQ_15 = 0,
  ChassisDetail_Type_CHANGAN_RUICHENG = 1
};
bool ChassisDetail_Type_IsValid(int value);
const ChassisDetail_Type ChassisDetail_Type_Type_MIN = ChassisDetail_Type_QIRUI_EQ_15;
const ChassisDetail_Type ChassisDetail_Type_Type_MAX = ChassisDetail_Type_CHANGAN_RUICHENG;
const int ChassisDetail_Type_Type_ARRAYSIZE = ChassisDetail_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChassisDetail_Type_descriptor();
inline const ::std::string& ChassisDetail_Type_Name(ChassisDetail_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChassisDetail_Type_descriptor(), value);
}
inline bool ChassisDetail_Type_Parse(
    const ::std::string& name, ChassisDetail_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChassisDetail_Type>(
    ChassisDetail_Type_descriptor(), name, value);
}
enum Light_TurnLightType {
  Light_TurnLightType_TURN_LIGHT_OFF = 0,
  Light_TurnLightType_TURN_LEFT_ON = 1,
  Light_TurnLightType_TURN_RIGHT_ON = 2,
  Light_TurnLightType_TURN_LIGHT_ON = 3
};
bool Light_TurnLightType_IsValid(int value);
const Light_TurnLightType Light_TurnLightType_TurnLightType_MIN = Light_TurnLightType_TURN_LIGHT_OFF;
const Light_TurnLightType Light_TurnLightType_TurnLightType_MAX = Light_TurnLightType_TURN_LIGHT_ON;
const int Light_TurnLightType_TurnLightType_ARRAYSIZE = Light_TurnLightType_TurnLightType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_TurnLightType_descriptor();
inline const ::std::string& Light_TurnLightType_Name(Light_TurnLightType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_TurnLightType_descriptor(), value);
}
inline bool Light_TurnLightType_Parse(
    const ::std::string& name, Light_TurnLightType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_TurnLightType>(
    Light_TurnLightType_descriptor(), name, value);
}
enum Light_BeamLampType {
  Light_BeamLampType_BEAM_OFF = 0,
  Light_BeamLampType_HIGH_BEAM_ON = 1,
  Light_BeamLampType_LOW_BEAM_ON = 2
};
bool Light_BeamLampType_IsValid(int value);
const Light_BeamLampType Light_BeamLampType_BeamLampType_MIN = Light_BeamLampType_BEAM_OFF;
const Light_BeamLampType Light_BeamLampType_BeamLampType_MAX = Light_BeamLampType_LOW_BEAM_ON;
const int Light_BeamLampType_BeamLampType_ARRAYSIZE = Light_BeamLampType_BeamLampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_BeamLampType_descriptor();
inline const ::std::string& Light_BeamLampType_Name(Light_BeamLampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_BeamLampType_descriptor(), value);
}
inline bool Light_BeamLampType_Parse(
    const ::std::string& name, Light_BeamLampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_BeamLampType>(
    Light_BeamLampType_descriptor(), name, value);
}
enum Light_LincolnLampType {
  Light_LincolnLampType_BEAM_NULL = 0,
  Light_LincolnLampType_BEAM_FLASH_TO_PASS = 1,
  Light_LincolnLampType_BEAM_HIGH = 2,
  Light_LincolnLampType_BEAM_INVALID = 3
};
bool Light_LincolnLampType_IsValid(int value);
const Light_LincolnLampType Light_LincolnLampType_LincolnLampType_MIN = Light_LincolnLampType_BEAM_NULL;
const Light_LincolnLampType Light_LincolnLampType_LincolnLampType_MAX = Light_LincolnLampType_BEAM_INVALID;
const int Light_LincolnLampType_LincolnLampType_ARRAYSIZE = Light_LincolnLampType_LincolnLampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LincolnLampType_descriptor();
inline const ::std::string& Light_LincolnLampType_Name(Light_LincolnLampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LincolnLampType_descriptor(), value);
}
inline bool Light_LincolnLampType_Parse(
    const ::std::string& name, Light_LincolnLampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LincolnLampType>(
    Light_LincolnLampType_descriptor(), name, value);
}
enum Light_LincolnWiperType {
  Light_LincolnWiperType_WIPER_OFF = 0,
  Light_LincolnWiperType_WIPER_AUTO_OFF = 1,
  Light_LincolnWiperType_WIPER_OFF_MOVING = 2,
  Light_LincolnWiperType_WIPER_MANUAL_OFF = 3,
  Light_LincolnWiperType_WIPER_MANUAL_ON = 4,
  Light_LincolnWiperType_WIPER_MANUAL_LOW = 5,
  Light_LincolnWiperType_WIPER_MANUAL_HIGH = 6,
  Light_LincolnWiperType_WIPER_MIST_FLICK = 7,
  Light_LincolnWiperType_WIPER_WASH = 8,
  Light_LincolnWiperType_WIPER_AUTO_LOW = 9,
  Light_LincolnWiperType_WIPER_AUTO_HIGH = 10,
  Light_LincolnWiperType_WIPER_COURTESY_WIPE = 11,
  Light_LincolnWiperType_WIPER_AUTO_ADJUST = 12,
  Light_LincolnWiperType_WIPER_RESERVED = 13,
  Light_LincolnWiperType_WIPER_STALLED = 14,
  Light_LincolnWiperType_WIPER_NO_DATA = 15
};
bool Light_LincolnWiperType_IsValid(int value);
const Light_LincolnWiperType Light_LincolnWiperType_LincolnWiperType_MIN = Light_LincolnWiperType_WIPER_OFF;
const Light_LincolnWiperType Light_LincolnWiperType_LincolnWiperType_MAX = Light_LincolnWiperType_WIPER_NO_DATA;
const int Light_LincolnWiperType_LincolnWiperType_ARRAYSIZE = Light_LincolnWiperType_LincolnWiperType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LincolnWiperType_descriptor();
inline const ::std::string& Light_LincolnWiperType_Name(Light_LincolnWiperType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LincolnWiperType_descriptor(), value);
}
inline bool Light_LincolnWiperType_Parse(
    const ::std::string& name, Light_LincolnWiperType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LincolnWiperType>(
    Light_LincolnWiperType_descriptor(), name, value);
}
enum Light_LincolnAmbientType {
  Light_LincolnAmbientType_AMBIENT_DARK = 0,
  Light_LincolnAmbientType_AMBIENT_LIGHT = 1,
  Light_LincolnAmbientType_AMBIENT_TWILIGHT = 2,
  Light_LincolnAmbientType_AMBIENT_TUNNEL_ON = 3,
  Light_LincolnAmbientType_AMBIENT_TUNNEL_OFF = 4,
  Light_LincolnAmbientType_AMBIENT_INVALID = 5,
  Light_LincolnAmbientType_AMBIENT_NO_DATA = 7
};
bool Light_LincolnAmbientType_IsValid(int value);
const Light_LincolnAmbientType Light_LincolnAmbientType_LincolnAmbientType_MIN = Light_LincolnAmbientType_AMBIENT_DARK;
const Light_LincolnAmbientType Light_LincolnAmbientType_LincolnAmbientType_MAX = Light_LincolnAmbientType_AMBIENT_NO_DATA;
const int Light_LincolnAmbientType_LincolnAmbientType_ARRAYSIZE = Light_LincolnAmbientType_LincolnAmbientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Light_LincolnAmbientType_descriptor();
inline const ::std::string& Light_LincolnAmbientType_Name(Light_LincolnAmbientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Light_LincolnAmbientType_descriptor(), value);
}
inline bool Light_LincolnAmbientType_Parse(
    const ::std::string& name, Light_LincolnAmbientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Light_LincolnAmbientType>(
    Light_LincolnAmbientType_descriptor(), name, value);
}
enum Eps_Type {
  Eps_Type_NOT_AVAILABLE = 0,
  Eps_Type_READY = 1,
  Eps_Type_ACTIVE = 2,
  Eps_Type_INVALID = 3
};
bool Eps_Type_IsValid(int value);
const Eps_Type Eps_Type_Type_MIN = Eps_Type_NOT_AVAILABLE;
const Eps_Type Eps_Type_Type_MAX = Eps_Type_INVALID;
const int Eps_Type_Type_ARRAYSIZE = Eps_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Eps_Type_descriptor();
inline const ::std::string& Eps_Type_Name(Eps_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Eps_Type_descriptor(), value);
}
inline bool Eps_Type_Parse(
    const ::std::string& name, Eps_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Eps_Type>(
    Eps_Type_descriptor(), name, value);
}
enum Brake_HSAStatusType {
  Brake_HSAStatusType_HSA_INACTIVE = 0,
  Brake_HSAStatusType_HSA_FINDING_GRADIENT = 1,
  Brake_HSAStatusType_HSA_ACTIVE_PRESSED = 2,
  Brake_HSAStatusType_HSA_ACTIVE_RELEASED = 3,
  Brake_HSAStatusType_HSA_FAST_RELEASE = 4,
  Brake_HSAStatusType_HSA_SLOW_RELEASE = 5,
  Brake_HSAStatusType_HSA_FAILED = 6,
  Brake_HSAStatusType_HSA_UNDEFINED = 7
};
bool Brake_HSAStatusType_IsValid(int value);
const Brake_HSAStatusType Brake_HSAStatusType_HSAStatusType_MIN = Brake_HSAStatusType_HSA_INACTIVE;
const Brake_HSAStatusType Brake_HSAStatusType_HSAStatusType_MAX = Brake_HSAStatusType_HSA_UNDEFINED;
const int Brake_HSAStatusType_HSAStatusType_ARRAYSIZE = Brake_HSAStatusType_HSAStatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Brake_HSAStatusType_descriptor();
inline const ::std::string& Brake_HSAStatusType_Name(Brake_HSAStatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Brake_HSAStatusType_descriptor(), value);
}
inline bool Brake_HSAStatusType_Parse(
    const ::std::string& name, Brake_HSAStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Brake_HSAStatusType>(
    Brake_HSAStatusType_descriptor(), name, value);
}
enum Brake_HSAModeType {
  Brake_HSAModeType_HSA_OFF = 0,
  Brake_HSAModeType_HSA_AUTO = 1,
  Brake_HSAModeType_HSA_MANUAL = 2,
  Brake_HSAModeType_HSA_MODE_UNDEFINED = 3
};
bool Brake_HSAModeType_IsValid(int value);
const Brake_HSAModeType Brake_HSAModeType_HSAModeType_MIN = Brake_HSAModeType_HSA_OFF;
const Brake_HSAModeType Brake_HSAModeType_HSAModeType_MAX = Brake_HSAModeType_HSA_MODE_UNDEFINED;
const int Brake_HSAModeType_HSAModeType_ARRAYSIZE = Brake_HSAModeType_HSAModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Brake_HSAModeType_descriptor();
inline const ::std::string& Brake_HSAModeType_Name(Brake_HSAModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Brake_HSAModeType_descriptor(), value);
}
inline bool Brake_HSAModeType_Parse(
    const ::std::string& name, Brake_HSAModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Brake_HSAModeType>(
    Brake_HSAModeType_descriptor(), name, value);
}
enum Epb_PBrakeType {
  Epb_PBrakeType_PBRAKE_OFF = 0,
  Epb_PBrakeType_PBRAKE_TRANSITION = 1,
  Epb_PBrakeType_PBRAKE_ON = 2,
  Epb_PBrakeType_PBRAKE_FAULT = 3
};
bool Epb_PBrakeType_IsValid(int value);
const Epb_PBrakeType Epb_PBrakeType_PBrakeType_MIN = Epb_PBrakeType_PBRAKE_OFF;
const Epb_PBrakeType Epb_PBrakeType_PBrakeType_MAX = Epb_PBrakeType_PBRAKE_FAULT;
const int Epb_PBrakeType_PBrakeType_ARRAYSIZE = Epb_PBrakeType_PBrakeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Epb_PBrakeType_descriptor();
inline const ::std::string& Epb_PBrakeType_Name(Epb_PBrakeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Epb_PBrakeType_descriptor(), value);
}
inline bool Epb_PBrakeType_Parse(
    const ::std::string& name, Epb_PBrakeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Epb_PBrakeType>(
    Epb_PBrakeType_descriptor(), name, value);
}
enum Ems_Type {
  Ems_Type_STOP = 0,
  Ems_Type_CRANK = 1,
  Ems_Type_RUNNING = 2,
  Ems_Type_INVALID = 3
};
bool Ems_Type_IsValid(int value);
const Ems_Type Ems_Type_Type_MIN = Ems_Type_STOP;
const Ems_Type Ems_Type_Type_MAX = Ems_Type_INVALID;
const int Ems_Type_Type_ARRAYSIZE = Ems_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ems_Type_descriptor();
inline const ::std::string& Ems_Type_Name(Ems_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ems_Type_descriptor(), value);
}
inline bool Ems_Type_Parse(
    const ::std::string& name, Ems_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ems_Type>(
    Ems_Type_descriptor(), name, value);
}
enum BasicInfo_Type {
  BasicInfo_Type_OFF = 0,
  BasicInfo_Type_ACC = 1,
  BasicInfo_Type_ON = 2,
  BasicInfo_Type_START = 3,
  BasicInfo_Type_INVALID = 4
};
bool BasicInfo_Type_IsValid(int value);
const BasicInfo_Type BasicInfo_Type_Type_MIN = BasicInfo_Type_OFF;
const BasicInfo_Type BasicInfo_Type_Type_MAX = BasicInfo_Type_INVALID;
const int BasicInfo_Type_Type_ARRAYSIZE = BasicInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BasicInfo_Type_descriptor();
inline const ::std::string& BasicInfo_Type_Name(BasicInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BasicInfo_Type_descriptor(), value);
}
inline bool BasicInfo_Type_Parse(
    const ::std::string& name, BasicInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BasicInfo_Type>(
    BasicInfo_Type_descriptor(), name, value);
}
enum Global_rpt_6a_Pacmod_statusType {
  Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_DISABLED = 0,
  Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_ENABLED = 1
};
bool Global_rpt_6a_Pacmod_statusType_IsValid(int value);
const Global_rpt_6a_Pacmod_statusType Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MIN = Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_DISABLED;
const Global_rpt_6a_Pacmod_statusType Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MAX = Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_ENABLED;
const int Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_ARRAYSIZE = Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global_rpt_6a_Pacmod_statusType_descriptor();
inline const ::std::string& Global_rpt_6a_Pacmod_statusType_Name(Global_rpt_6a_Pacmod_statusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global_rpt_6a_Pacmod_statusType_descriptor(), value);
}
inline bool Global_rpt_6a_Pacmod_statusType_Parse(
    const ::std::string& name, Global_rpt_6a_Pacmod_statusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global_rpt_6a_Pacmod_statusType>(
    Global_rpt_6a_Pacmod_statusType_descriptor(), name, value);
}
enum Global_rpt_6a_Override_statusType {
  Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_NOT_OVERRIDDEN = 0,
  Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_OVERRIDDEN = 1
};
bool Global_rpt_6a_Override_statusType_IsValid(int value);
const Global_rpt_6a_Override_statusType Global_rpt_6a_Override_statusType_Override_statusType_MIN = Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_NOT_OVERRIDDEN;
const Global_rpt_6a_Override_statusType Global_rpt_6a_Override_statusType_Override_statusType_MAX = Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_OVERRIDDEN;
const int Global_rpt_6a_Override_statusType_Override_statusType_ARRAYSIZE = Global_rpt_6a_Override_statusType_Override_statusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global_rpt_6a_Override_statusType_descriptor();
inline const ::std::string& Global_rpt_6a_Override_statusType_Name(Global_rpt_6a_Override_statusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global_rpt_6a_Override_statusType_descriptor(), value);
}
inline bool Global_rpt_6a_Override_statusType_Parse(
    const ::std::string& name, Global_rpt_6a_Override_statusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global_rpt_6a_Override_statusType>(
    Global_rpt_6a_Override_statusType_descriptor(), name, value);
}
enum Global_rpt_6a_Brk_can_timeoutType {
  Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT = 0,
  Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT = 1
};
bool Global_rpt_6a_Brk_can_timeoutType_IsValid(int value);
const Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MIN = Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT;
const Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MAX = Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT;
const int Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_ARRAYSIZE = Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global_rpt_6a_Brk_can_timeoutType_descriptor();
inline const ::std::string& Global_rpt_6a_Brk_can_timeoutType_Name(Global_rpt_6a_Brk_can_timeoutType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global_rpt_6a_Brk_can_timeoutType_descriptor(), value);
}
inline bool Global_rpt_6a_Brk_can_timeoutType_Parse(
    const ::std::string& name, Global_rpt_6a_Brk_can_timeoutType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global_rpt_6a_Brk_can_timeoutType>(
    Global_rpt_6a_Brk_can_timeoutType_descriptor(), name, value);
}
enum Brake_rpt_6c_Brake_on_offType {
  Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_OFF = 0,
  Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_ON = 1
};
bool Brake_rpt_6c_Brake_on_offType_IsValid(int value);
const Brake_rpt_6c_Brake_on_offType Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MIN = Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_OFF;
const Brake_rpt_6c_Brake_on_offType Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MAX = Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_ON;
const int Brake_rpt_6c_Brake_on_offType_Brake_on_offType_ARRAYSIZE = Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Brake_rpt_6c_Brake_on_offType_descriptor();
inline const ::std::string& Brake_rpt_6c_Brake_on_offType_Name(Brake_rpt_6c_Brake_on_offType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Brake_rpt_6c_Brake_on_offType_descriptor(), value);
}
inline bool Brake_rpt_6c_Brake_on_offType_Parse(
    const ::std::string& name, Brake_rpt_6c_Brake_on_offType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Brake_rpt_6c_Brake_on_offType>(
    Brake_rpt_6c_Brake_on_offType_descriptor(), name, value);
}
enum Headlight_rpt_77_Output_valueType {
  Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HEADLIGHTS_OFF = 0,
  Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_LOW_BEAMS = 1,
  Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HIGH_BEAMS = 2
};
bool Headlight_rpt_77_Output_valueType_IsValid(int value);
const Headlight_rpt_77_Output_valueType Headlight_rpt_77_Output_valueType_Output_valueType_MIN = Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HEADLIGHTS_OFF;
const Headlight_rpt_77_Output_valueType Headlight_rpt_77_Output_valueType_Output_valueType_MAX = Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HIGH_BEAMS;
const int Headlight_rpt_77_Output_valueType_Output_valueType_ARRAYSIZE = Headlight_rpt_77_Output_valueType_Output_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Headlight_rpt_77_Output_valueType_descriptor();
inline const ::std::string& Headlight_rpt_77_Output_valueType_Name(Headlight_rpt_77_Output_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Headlight_rpt_77_Output_valueType_descriptor(), value);
}
inline bool Headlight_rpt_77_Output_valueType_Parse(
    const ::std::string& name, Headlight_rpt_77_Output_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Headlight_rpt_77_Output_valueType>(
    Headlight_rpt_77_Output_valueType_descriptor(), name, value);
}
enum Headlight_rpt_77_Manual_inputType {
  Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HEADLIGHTS_OFF = 0,
  Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_LOW_BEAMS = 1,
  Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HIGH_BEAMS = 2
};
bool Headlight_rpt_77_Manual_inputType_IsValid(int value);
const Headlight_rpt_77_Manual_inputType Headlight_rpt_77_Manual_inputType_Manual_inputType_MIN = Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HEADLIGHTS_OFF;
const Headlight_rpt_77_Manual_inputType Headlight_rpt_77_Manual_inputType_Manual_inputType_MAX = Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HIGH_BEAMS;
const int Headlight_rpt_77_Manual_inputType_Manual_inputType_ARRAYSIZE = Headlight_rpt_77_Manual_inputType_Manual_inputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Headlight_rpt_77_Manual_inputType_descriptor();
inline const ::std::string& Headlight_rpt_77_Manual_inputType_Name(Headlight_rpt_77_Manual_inputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Headlight_rpt_77_Manual_inputType_descriptor(), value);
}
inline bool Headlight_rpt_77_Manual_inputType_Parse(
    const ::std::string& name, Headlight_rpt_77_Manual_inputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Headlight_rpt_77_Manual_inputType>(
    Headlight_rpt_77_Manual_inputType_descriptor(), name, value);
}
enum Headlight_rpt_77_Commanded_valueType {
  Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HEADLIGHTS_OFF = 0,
  Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_LOW_BEAMS = 1,
  Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HIGH_BEAMS = 2
};
bool Headlight_rpt_77_Commanded_valueType_IsValid(int value);
const Headlight_rpt_77_Commanded_valueType Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MIN = Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HEADLIGHTS_OFF;
const Headlight_rpt_77_Commanded_valueType Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MAX = Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HIGH_BEAMS;
const int Headlight_rpt_77_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Headlight_rpt_77_Commanded_valueType_descriptor();
inline const ::std::string& Headlight_rpt_77_Commanded_valueType_Name(Headlight_rpt_77_Commanded_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Headlight_rpt_77_Commanded_valueType_descriptor(), value);
}
inline bool Headlight_rpt_77_Commanded_valueType_Parse(
    const ::std::string& name, Headlight_rpt_77_Commanded_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Headlight_rpt_77_Commanded_valueType>(
    Headlight_rpt_77_Commanded_valueType_descriptor(), name, value);
}
enum Turn_cmd_63_Turn_signal_cmdType {
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_RIGHT = 0,
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_NONE = 1,
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_LEFT = 2,
  Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_HAZARD = 3
};
bool Turn_cmd_63_Turn_signal_cmdType_IsValid(int value);
const Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MIN = Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_RIGHT;
const Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MAX = Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_HAZARD;
const int Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_ARRAYSIZE = Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Turn_cmd_63_Turn_signal_cmdType_descriptor();
inline const ::std::string& Turn_cmd_63_Turn_signal_cmdType_Name(Turn_cmd_63_Turn_signal_cmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Turn_cmd_63_Turn_signal_cmdType_descriptor(), value);
}
inline bool Turn_cmd_63_Turn_signal_cmdType_Parse(
    const ::std::string& name, Turn_cmd_63_Turn_signal_cmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Turn_cmd_63_Turn_signal_cmdType>(
    Turn_cmd_63_Turn_signal_cmdType_descriptor(), name, value);
}
enum Turn_rpt_64_Manual_inputType {
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_RIGHT = 0,
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_NONE = 1,
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_LEFT = 2,
  Turn_rpt_64_Manual_inputType_MANUAL_INPUT_HAZARD = 3
};
bool Turn_rpt_64_Manual_inputType_IsValid(int value);
const Turn_rpt_64_Manual_inputType Turn_rpt_64_Manual_inputType_Manual_inputType_MIN = Turn_rpt_64_Manual_inputType_MANUAL_INPUT_RIGHT;
const Turn_rpt_64_Manual_inputType Turn_rpt_64_Manual_inputType_Manual_inputType_MAX = Turn_rpt_64_Manual_inputType_MANUAL_INPUT_HAZARD;
const int Turn_rpt_64_Manual_inputType_Manual_inputType_ARRAYSIZE = Turn_rpt_64_Manual_inputType_Manual_inputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Turn_rpt_64_Manual_inputType_descriptor();
inline const ::std::string& Turn_rpt_64_Manual_inputType_Name(Turn_rpt_64_Manual_inputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Turn_rpt_64_Manual_inputType_descriptor(), value);
}
inline bool Turn_rpt_64_Manual_inputType_Parse(
    const ::std::string& name, Turn_rpt_64_Manual_inputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Turn_rpt_64_Manual_inputType>(
    Turn_rpt_64_Manual_inputType_descriptor(), name, value);
}
enum Turn_rpt_64_Commanded_valueType {
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_RIGHT = 0,
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_NONE = 1,
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_LEFT = 2,
  Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_HAZARD = 3
};
bool Turn_rpt_64_Commanded_valueType_IsValid(int value);
const Turn_rpt_64_Commanded_valueType Turn_rpt_64_Commanded_valueType_Commanded_valueType_MIN = Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_RIGHT;
const Turn_rpt_64_Commanded_valueType Turn_rpt_64_Commanded_valueType_Commanded_valueType_MAX = Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_HAZARD;
const int Turn_rpt_64_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Turn_rpt_64_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Turn_rpt_64_Commanded_valueType_descriptor();
inline const ::std::string& Turn_rpt_64_Commanded_valueType_Name(Turn_rpt_64_Commanded_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Turn_rpt_64_Commanded_valueType_descriptor(), value);
}
inline bool Turn_rpt_64_Commanded_valueType_Parse(
    const ::std::string& name, Turn_rpt_64_Commanded_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Turn_rpt_64_Commanded_valueType>(
    Turn_rpt_64_Commanded_valueType_descriptor(), name, value);
}
enum Turn_rpt_64_Output_valueType {
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_RIGHT = 0,
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_NONE = 1,
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_LEFT = 2,
  Turn_rpt_64_Output_valueType_OUTPUT_VALUE_HAZARD = 3
};
bool Turn_rpt_64_Output_valueType_IsValid(int value);
const Turn_rpt_64_Output_valueType Turn_rpt_64_Output_valueType_Output_valueType_MIN = Turn_rpt_64_Output_valueType_OUTPUT_VALUE_RIGHT;
const Turn_rpt_64_Output_valueType Turn_rpt_64_Output_valueType_Output_valueType_MAX = Turn_rpt_64_Output_valueType_OUTPUT_VALUE_HAZARD;
const int Turn_rpt_64_Output_valueType_Output_valueType_ARRAYSIZE = Turn_rpt_64_Output_valueType_Output_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Turn_rpt_64_Output_valueType_descriptor();
inline const ::std::string& Turn_rpt_64_Output_valueType_Name(Turn_rpt_64_Output_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Turn_rpt_64_Output_valueType_descriptor(), value);
}
inline bool Turn_rpt_64_Output_valueType_Parse(
    const ::std::string& name, Turn_rpt_64_Output_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Turn_rpt_64_Output_valueType>(
    Turn_rpt_64_Output_valueType_descriptor(), name, value);
}
enum Shift_cmd_65_Shift_cmdType {
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_PARK = 0,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_REVERSE = 1,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_NEUTRAL = 2,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_FORWARD = 3,
  Shift_cmd_65_Shift_cmdType_SHIFT_CMD_LOW = 4
};
bool Shift_cmd_65_Shift_cmdType_IsValid(int value);
const Shift_cmd_65_Shift_cmdType Shift_cmd_65_Shift_cmdType_Shift_cmdType_MIN = Shift_cmd_65_Shift_cmdType_SHIFT_CMD_PARK;
const Shift_cmd_65_Shift_cmdType Shift_cmd_65_Shift_cmdType_Shift_cmdType_MAX = Shift_cmd_65_Shift_cmdType_SHIFT_CMD_LOW;
const int Shift_cmd_65_Shift_cmdType_Shift_cmdType_ARRAYSIZE = Shift_cmd_65_Shift_cmdType_Shift_cmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Shift_cmd_65_Shift_cmdType_descriptor();
inline const ::std::string& Shift_cmd_65_Shift_cmdType_Name(Shift_cmd_65_Shift_cmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Shift_cmd_65_Shift_cmdType_descriptor(), value);
}
inline bool Shift_cmd_65_Shift_cmdType_Parse(
    const ::std::string& name, Shift_cmd_65_Shift_cmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Shift_cmd_65_Shift_cmdType>(
    Shift_cmd_65_Shift_cmdType_descriptor(), name, value);
}
enum Shift_rpt_66_Manual_inputType {
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_PARK = 0,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_REVERSE = 1,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_NEUTRAL = 2,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_FORWARD = 3,
  Shift_rpt_66_Manual_inputType_MANUAL_INPUT_HIGH = 4
};
bool Shift_rpt_66_Manual_inputType_IsValid(int value);
const Shift_rpt_66_Manual_inputType Shift_rpt_66_Manual_inputType_Manual_inputType_MIN = Shift_rpt_66_Manual_inputType_MANUAL_INPUT_PARK;
const Shift_rpt_66_Manual_inputType Shift_rpt_66_Manual_inputType_Manual_inputType_MAX = Shift_rpt_66_Manual_inputType_MANUAL_INPUT_HIGH;
const int Shift_rpt_66_Manual_inputType_Manual_inputType_ARRAYSIZE = Shift_rpt_66_Manual_inputType_Manual_inputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Shift_rpt_66_Manual_inputType_descriptor();
inline const ::std::string& Shift_rpt_66_Manual_inputType_Name(Shift_rpt_66_Manual_inputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Shift_rpt_66_Manual_inputType_descriptor(), value);
}
inline bool Shift_rpt_66_Manual_inputType_Parse(
    const ::std::string& name, Shift_rpt_66_Manual_inputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Shift_rpt_66_Manual_inputType>(
    Shift_rpt_66_Manual_inputType_descriptor(), name, value);
}
enum Shift_rpt_66_Commanded_valueType {
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_PARK = 0,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_REVERSE = 1,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_NEUTRAL = 2,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_FORWARD = 3,
  Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_HIGH = 4
};
bool Shift_rpt_66_Commanded_valueType_IsValid(int value);
const Shift_rpt_66_Commanded_valueType Shift_rpt_66_Commanded_valueType_Commanded_valueType_MIN = Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_PARK;
const Shift_rpt_66_Commanded_valueType Shift_rpt_66_Commanded_valueType_Commanded_valueType_MAX = Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_HIGH;
const int Shift_rpt_66_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Shift_rpt_66_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Shift_rpt_66_Commanded_valueType_descriptor();
inline const ::std::string& Shift_rpt_66_Commanded_valueType_Name(Shift_rpt_66_Commanded_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Shift_rpt_66_Commanded_valueType_descriptor(), value);
}
inline bool Shift_rpt_66_Commanded_valueType_Parse(
    const ::std::string& name, Shift_rpt_66_Commanded_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Shift_rpt_66_Commanded_valueType>(
    Shift_rpt_66_Commanded_valueType_descriptor(), name, value);
}
enum Shift_rpt_66_Output_valueType {
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_PARK = 0,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_REVERSE = 1,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_NEUTRAL = 2,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_FORWARD = 3,
  Shift_rpt_66_Output_valueType_OUTPUT_VALUE_HIGH = 4
};
bool Shift_rpt_66_Output_valueType_IsValid(int value);
const Shift_rpt_66_Output_valueType Shift_rpt_66_Output_valueType_Output_valueType_MIN = Shift_rpt_66_Output_valueType_OUTPUT_VALUE_PARK;
const Shift_rpt_66_Output_valueType Shift_rpt_66_Output_valueType_Output_valueType_MAX = Shift_rpt_66_Output_valueType_OUTPUT_VALUE_HIGH;
const int Shift_rpt_66_Output_valueType_Output_valueType_ARRAYSIZE = Shift_rpt_66_Output_valueType_Output_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Shift_rpt_66_Output_valueType_descriptor();
inline const ::std::string& Shift_rpt_66_Output_valueType_Name(Shift_rpt_66_Output_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Shift_rpt_66_Output_valueType_descriptor(), value);
}
inline bool Shift_rpt_66_Output_valueType_Parse(
    const ::std::string& name, Shift_rpt_66_Output_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Shift_rpt_66_Output_valueType>(
    Shift_rpt_66_Output_valueType_descriptor(), name, value);
}
enum Global_cmd_69_Pacmod_enableType {
  Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_DISABLED = 0,
  Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_ENABLED = 1
};
bool Global_cmd_69_Pacmod_enableType_IsValid(int value);
const Global_cmd_69_Pacmod_enableType Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MIN = Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_DISABLED;
const Global_cmd_69_Pacmod_enableType Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MAX = Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_ENABLED;
const int Global_cmd_69_Pacmod_enableType_Pacmod_enableType_ARRAYSIZE = Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global_cmd_69_Pacmod_enableType_descriptor();
inline const ::std::string& Global_cmd_69_Pacmod_enableType_Name(Global_cmd_69_Pacmod_enableType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global_cmd_69_Pacmod_enableType_descriptor(), value);
}
inline bool Global_cmd_69_Pacmod_enableType_Parse(
    const ::std::string& name, Global_cmd_69_Pacmod_enableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global_cmd_69_Pacmod_enableType>(
    Global_cmd_69_Pacmod_enableType_descriptor(), name, value);
}
enum Global_cmd_69_Clear_overrideType {
  Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES = 0,
  Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES = 1
};
bool Global_cmd_69_Clear_overrideType_IsValid(int value);
const Global_cmd_69_Clear_overrideType Global_cmd_69_Clear_overrideType_Clear_overrideType_MIN = Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES;
const Global_cmd_69_Clear_overrideType Global_cmd_69_Clear_overrideType_Clear_overrideType_MAX = Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES;
const int Global_cmd_69_Clear_overrideType_Clear_overrideType_ARRAYSIZE = Global_cmd_69_Clear_overrideType_Clear_overrideType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global_cmd_69_Clear_overrideType_descriptor();
inline const ::std::string& Global_cmd_69_Clear_overrideType_Name(Global_cmd_69_Clear_overrideType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global_cmd_69_Clear_overrideType_descriptor(), value);
}
inline bool Global_cmd_69_Clear_overrideType_Parse(
    const ::std::string& name, Global_cmd_69_Clear_overrideType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global_cmd_69_Clear_overrideType>(
    Global_cmd_69_Clear_overrideType_descriptor(), name, value);
}
enum Global_cmd_69_Ignore_overrideType {
  Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES = 0,
  Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES = 1
};
bool Global_cmd_69_Ignore_overrideType_IsValid(int value);
const Global_cmd_69_Ignore_overrideType Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MIN = Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES;
const Global_cmd_69_Ignore_overrideType Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MAX = Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES;
const int Global_cmd_69_Ignore_overrideType_Ignore_overrideType_ARRAYSIZE = Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global_cmd_69_Ignore_overrideType_descriptor();
inline const ::std::string& Global_cmd_69_Ignore_overrideType_Name(Global_cmd_69_Ignore_overrideType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global_cmd_69_Ignore_overrideType_descriptor(), value);
}
inline bool Global_cmd_69_Ignore_overrideType_Parse(
    const ::std::string& name, Global_cmd_69_Ignore_overrideType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global_cmd_69_Ignore_overrideType>(
    Global_cmd_69_Ignore_overrideType_descriptor(), name, value);
}
enum Parking_brake_status_rpt_80_Parking_brake_enabledType {
  Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_OFF = 0,
  Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_ON = 1
};
bool Parking_brake_status_rpt_80_Parking_brake_enabledType_IsValid(int value);
const Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MIN = Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_OFF;
const Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MAX = Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_ON;
const int Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_ARRAYSIZE = Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor();
inline const ::std::string& Parking_brake_status_rpt_80_Parking_brake_enabledType_Name(Parking_brake_status_rpt_80_Parking_brake_enabledType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor(), value);
}
inline bool Parking_brake_status_rpt_80_Parking_brake_enabledType_Parse(
    const ::std::string& name, Parking_brake_status_rpt_80_Parking_brake_enabledType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Parking_brake_status_rpt_80_Parking_brake_enabledType>(
    Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor(), name, value);
}
enum Horn_rpt_79_Output_valueType {
  Horn_rpt_79_Output_valueType_OUTPUT_VALUE_OFF = 0,
  Horn_rpt_79_Output_valueType_OUTPUT_VALUE_ON = 1
};
bool Horn_rpt_79_Output_valueType_IsValid(int value);
const Horn_rpt_79_Output_valueType Horn_rpt_79_Output_valueType_Output_valueType_MIN = Horn_rpt_79_Output_valueType_OUTPUT_VALUE_OFF;
const Horn_rpt_79_Output_valueType Horn_rpt_79_Output_valueType_Output_valueType_MAX = Horn_rpt_79_Output_valueType_OUTPUT_VALUE_ON;
const int Horn_rpt_79_Output_valueType_Output_valueType_ARRAYSIZE = Horn_rpt_79_Output_valueType_Output_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Horn_rpt_79_Output_valueType_descriptor();
inline const ::std::string& Horn_rpt_79_Output_valueType_Name(Horn_rpt_79_Output_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Horn_rpt_79_Output_valueType_descriptor(), value);
}
inline bool Horn_rpt_79_Output_valueType_Parse(
    const ::std::string& name, Horn_rpt_79_Output_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Horn_rpt_79_Output_valueType>(
    Horn_rpt_79_Output_valueType_descriptor(), name, value);
}
enum Horn_rpt_79_Commanded_valueType {
  Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_OFF = 0,
  Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_ON = 1
};
bool Horn_rpt_79_Commanded_valueType_IsValid(int value);
const Horn_rpt_79_Commanded_valueType Horn_rpt_79_Commanded_valueType_Commanded_valueType_MIN = Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_OFF;
const Horn_rpt_79_Commanded_valueType Horn_rpt_79_Commanded_valueType_Commanded_valueType_MAX = Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_ON;
const int Horn_rpt_79_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Horn_rpt_79_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Horn_rpt_79_Commanded_valueType_descriptor();
inline const ::std::string& Horn_rpt_79_Commanded_valueType_Name(Horn_rpt_79_Commanded_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Horn_rpt_79_Commanded_valueType_descriptor(), value);
}
inline bool Horn_rpt_79_Commanded_valueType_Parse(
    const ::std::string& name, Horn_rpt_79_Commanded_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Horn_rpt_79_Commanded_valueType>(
    Horn_rpt_79_Commanded_valueType_descriptor(), name, value);
}
enum Horn_rpt_79_Manual_inputType {
  Horn_rpt_79_Manual_inputType_MANUAL_INPUT_OFF = 0,
  Horn_rpt_79_Manual_inputType_MANUAL_INPUT_ON = 1
};
bool Horn_rpt_79_Manual_inputType_IsValid(int value);
const Horn_rpt_79_Manual_inputType Horn_rpt_79_Manual_inputType_Manual_inputType_MIN = Horn_rpt_79_Manual_inputType_MANUAL_INPUT_OFF;
const Horn_rpt_79_Manual_inputType Horn_rpt_79_Manual_inputType_Manual_inputType_MAX = Horn_rpt_79_Manual_inputType_MANUAL_INPUT_ON;
const int Horn_rpt_79_Manual_inputType_Manual_inputType_ARRAYSIZE = Horn_rpt_79_Manual_inputType_Manual_inputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Horn_rpt_79_Manual_inputType_descriptor();
inline const ::std::string& Horn_rpt_79_Manual_inputType_Name(Horn_rpt_79_Manual_inputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Horn_rpt_79_Manual_inputType_descriptor(), value);
}
inline bool Horn_rpt_79_Manual_inputType_Parse(
    const ::std::string& name, Horn_rpt_79_Manual_inputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Horn_rpt_79_Manual_inputType>(
    Horn_rpt_79_Manual_inputType_descriptor(), name, value);
}
enum Horn_cmd_78_Horn_cmdType {
  Horn_cmd_78_Horn_cmdType_HORN_CMD_OFF = 0,
  Horn_cmd_78_Horn_cmdType_HORN_CMD_ON = 1
};
bool Horn_cmd_78_Horn_cmdType_IsValid(int value);
const Horn_cmd_78_Horn_cmdType Horn_cmd_78_Horn_cmdType_Horn_cmdType_MIN = Horn_cmd_78_Horn_cmdType_HORN_CMD_OFF;
const Horn_cmd_78_Horn_cmdType Horn_cmd_78_Horn_cmdType_Horn_cmdType_MAX = Horn_cmd_78_Horn_cmdType_HORN_CMD_ON;
const int Horn_cmd_78_Horn_cmdType_Horn_cmdType_ARRAYSIZE = Horn_cmd_78_Horn_cmdType_Horn_cmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Horn_cmd_78_Horn_cmdType_descriptor();
inline const ::std::string& Horn_cmd_78_Horn_cmdType_Name(Horn_cmd_78_Horn_cmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Horn_cmd_78_Horn_cmdType_descriptor(), value);
}
inline bool Horn_cmd_78_Horn_cmdType_Parse(
    const ::std::string& name, Horn_cmd_78_Horn_cmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Horn_cmd_78_Horn_cmdType>(
    Horn_cmd_78_Horn_cmdType_descriptor(), name, value);
}
enum Wiper_rpt_91_Output_valueType {
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_WIPERS_OFF = 0,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_1 = 1,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_2 = 2,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_3 = 3,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_4 = 4,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_5 = 5,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_LOW = 6,
  Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_HIGH = 7
};
bool Wiper_rpt_91_Output_valueType_IsValid(int value);
const Wiper_rpt_91_Output_valueType Wiper_rpt_91_Output_valueType_Output_valueType_MIN = Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_WIPERS_OFF;
const Wiper_rpt_91_Output_valueType Wiper_rpt_91_Output_valueType_Output_valueType_MAX = Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_HIGH;
const int Wiper_rpt_91_Output_valueType_Output_valueType_ARRAYSIZE = Wiper_rpt_91_Output_valueType_Output_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Wiper_rpt_91_Output_valueType_descriptor();
inline const ::std::string& Wiper_rpt_91_Output_valueType_Name(Wiper_rpt_91_Output_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Wiper_rpt_91_Output_valueType_descriptor(), value);
}
inline bool Wiper_rpt_91_Output_valueType_Parse(
    const ::std::string& name, Wiper_rpt_91_Output_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Wiper_rpt_91_Output_valueType>(
    Wiper_rpt_91_Output_valueType_descriptor(), name, value);
}
enum Wiper_rpt_91_Commanded_valueType {
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_WIPERS_OFF = 0,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_1 = 1,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_2 = 2,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_3 = 3,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_4 = 4,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_5 = 5,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_LOW = 6,
  Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_HIGH = 7
};
bool Wiper_rpt_91_Commanded_valueType_IsValid(int value);
const Wiper_rpt_91_Commanded_valueType Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MIN = Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_WIPERS_OFF;
const Wiper_rpt_91_Commanded_valueType Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MAX = Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_HIGH;
const int Wiper_rpt_91_Commanded_valueType_Commanded_valueType_ARRAYSIZE = Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Wiper_rpt_91_Commanded_valueType_descriptor();
inline const ::std::string& Wiper_rpt_91_Commanded_valueType_Name(Wiper_rpt_91_Commanded_valueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Wiper_rpt_91_Commanded_valueType_descriptor(), value);
}
inline bool Wiper_rpt_91_Commanded_valueType_Parse(
    const ::std::string& name, Wiper_rpt_91_Commanded_valueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Wiper_rpt_91_Commanded_valueType>(
    Wiper_rpt_91_Commanded_valueType_descriptor(), name, value);
}
enum Wiper_rpt_91_Manual_inputType {
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_WIPERS_OFF = 0,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_1 = 1,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_2 = 2,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_3 = 3,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_4 = 4,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_5 = 5,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_LOW = 6,
  Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_HIGH = 7
};
bool Wiper_rpt_91_Manual_inputType_IsValid(int value);
const Wiper_rpt_91_Manual_inputType Wiper_rpt_91_Manual_inputType_Manual_inputType_MIN = Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_WIPERS_OFF;
const Wiper_rpt_91_Manual_inputType Wiper_rpt_91_Manual_inputType_Manual_inputType_MAX = Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_HIGH;
const int Wiper_rpt_91_Manual_inputType_Manual_inputType_ARRAYSIZE = Wiper_rpt_91_Manual_inputType_Manual_inputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Wiper_rpt_91_Manual_inputType_descriptor();
inline const ::std::string& Wiper_rpt_91_Manual_inputType_Name(Wiper_rpt_91_Manual_inputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Wiper_rpt_91_Manual_inputType_descriptor(), value);
}
inline bool Wiper_rpt_91_Manual_inputType_Parse(
    const ::std::string& name, Wiper_rpt_91_Manual_inputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Wiper_rpt_91_Manual_inputType>(
    Wiper_rpt_91_Manual_inputType_descriptor(), name, value);
}
enum Vehicle_speed_rpt_6f_Vehicle_speed_validType {
  Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_INVALID = 0,
  Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_VALID = 1
};
bool Vehicle_speed_rpt_6f_Vehicle_speed_validType_IsValid(int value);
const Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MIN = Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_INVALID;
const Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MAX = Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_VALID;
const int Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_ARRAYSIZE = Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor();
inline const ::std::string& Vehicle_speed_rpt_6f_Vehicle_speed_validType_Name(Vehicle_speed_rpt_6f_Vehicle_speed_validType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor(), value);
}
inline bool Vehicle_speed_rpt_6f_Vehicle_speed_validType_Parse(
    const ::std::string& name, Vehicle_speed_rpt_6f_Vehicle_speed_validType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Vehicle_speed_rpt_6f_Vehicle_speed_validType>(
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor(), name, value);
}
enum Headlight_cmd_76_Headlight_cmdType {
  Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HEADLIGHTS_OFF = 0,
  Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_LOW_BEAMS = 1,
  Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HIGH_BEAMS = 2
};
bool Headlight_cmd_76_Headlight_cmdType_IsValid(int value);
const Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MIN = Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HEADLIGHTS_OFF;
const Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MAX = Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HIGH_BEAMS;
const int Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_ARRAYSIZE = Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Headlight_cmd_76_Headlight_cmdType_descriptor();
inline const ::std::string& Headlight_cmd_76_Headlight_cmdType_Name(Headlight_cmd_76_Headlight_cmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Headlight_cmd_76_Headlight_cmdType_descriptor(), value);
}
inline bool Headlight_cmd_76_Headlight_cmdType_Parse(
    const ::std::string& name, Headlight_cmd_76_Headlight_cmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Headlight_cmd_76_Headlight_cmdType>(
    Headlight_cmd_76_Headlight_cmdType_descriptor(), name, value);
}
enum Wiper_cmd_90_Wiper_cmdType {
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_WIPERS_OFF = 0,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_1 = 1,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_2 = 2,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_3 = 3,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_4 = 4,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_5 = 5,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_LOW = 6,
  Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_HIGH = 7
};
bool Wiper_cmd_90_Wiper_cmdType_IsValid(int value);
const Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MIN = Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_WIPERS_OFF;
const Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MAX = Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_HIGH;
const int Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_ARRAYSIZE = Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Wiper_cmd_90_Wiper_cmdType_descriptor();
inline const ::std::string& Wiper_cmd_90_Wiper_cmdType_Name(Wiper_cmd_90_Wiper_cmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Wiper_cmd_90_Wiper_cmdType_descriptor(), value);
}
inline bool Wiper_cmd_90_Wiper_cmdType_Parse(
    const ::std::string& name, Wiper_cmd_90_Wiper_cmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Wiper_cmd_90_Wiper_cmdType>(
    Wiper_cmd_90_Wiper_cmdType_descriptor(), name, value);
}
// ===================================================================

class ChassisDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.ChassisDetail) */ {
 public:
  ChassisDetail();
  virtual ~ChassisDetail();

  ChassisDetail(const ChassisDetail& from);

  inline ChassisDetail& operator=(const ChassisDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChassisDetail& default_instance();

  static inline const ChassisDetail* internal_default_instance() {
    return reinterpret_cast<const ChassisDetail*>(
               &_ChassisDetail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ChassisDetail* other);

  // implements Message ----------------------------------------------

  inline ChassisDetail* New() const PROTOBUF_FINAL { return New(NULL); }

  ChassisDetail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChassisDetail& from);
  void MergeFrom(const ChassisDetail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChassisDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChassisDetail_Type Type;
  static const Type QIRUI_EQ_15 =
    ChassisDetail_Type_QIRUI_EQ_15;
  static const Type CHANGAN_RUICHENG =
    ChassisDetail_Type_CHANGAN_RUICHENG;
  static inline bool Type_IsValid(int value) {
    return ChassisDetail_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ChassisDetail_Type_Type_MIN;
  static const Type Type_MAX =
    ChassisDetail_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ChassisDetail_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ChassisDetail_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ChassisDetail_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ChassisDetail_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.BasicInfo basic = 2;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 2;
  const ::jmc_auto::canbus::BasicInfo& basic() const;
  ::jmc_auto::canbus::BasicInfo* mutable_basic();
  ::jmc_auto::canbus::BasicInfo* release_basic();
  void set_allocated_basic(::jmc_auto::canbus::BasicInfo* basic);

  // optional .jmc_auto.canbus.Safety safety = 3;
  bool has_safety() const;
  void clear_safety();
  static const int kSafetyFieldNumber = 3;
  const ::jmc_auto::canbus::Safety& safety() const;
  ::jmc_auto::canbus::Safety* mutable_safety();
  ::jmc_auto::canbus::Safety* release_safety();
  void set_allocated_safety(::jmc_auto::canbus::Safety* safety);

  // optional .jmc_auto.canbus.Gear gear = 4;
  bool has_gear() const;
  void clear_gear();
  static const int kGearFieldNumber = 4;
  const ::jmc_auto::canbus::Gear& gear() const;
  ::jmc_auto::canbus::Gear* mutable_gear();
  ::jmc_auto::canbus::Gear* release_gear();
  void set_allocated_gear(::jmc_auto::canbus::Gear* gear);

  // optional .jmc_auto.canbus.Ems ems = 5;
  bool has_ems() const;
  void clear_ems();
  static const int kEmsFieldNumber = 5;
  const ::jmc_auto::canbus::Ems& ems() const;
  ::jmc_auto::canbus::Ems* mutable_ems();
  ::jmc_auto::canbus::Ems* release_ems();
  void set_allocated_ems(::jmc_auto::canbus::Ems* ems);

  // optional .jmc_auto.canbus.Esp esp = 6;
  bool has_esp() const;
  void clear_esp();
  static const int kEspFieldNumber = 6;
  const ::jmc_auto::canbus::Esp& esp() const;
  ::jmc_auto::canbus::Esp* mutable_esp();
  ::jmc_auto::canbus::Esp* release_esp();
  void set_allocated_esp(::jmc_auto::canbus::Esp* esp);

  // optional .jmc_auto.canbus.Gas gas = 7;
  bool has_gas() const;
  void clear_gas();
  static const int kGasFieldNumber = 7;
  const ::jmc_auto::canbus::Gas& gas() const;
  ::jmc_auto::canbus::Gas* mutable_gas();
  ::jmc_auto::canbus::Gas* release_gas();
  void set_allocated_gas(::jmc_auto::canbus::Gas* gas);

  // optional .jmc_auto.canbus.Epb epb = 8;
  bool has_epb() const;
  void clear_epb();
  static const int kEpbFieldNumber = 8;
  const ::jmc_auto::canbus::Epb& epb() const;
  ::jmc_auto::canbus::Epb* mutable_epb();
  ::jmc_auto::canbus::Epb* release_epb();
  void set_allocated_epb(::jmc_auto::canbus::Epb* epb);

  // optional .jmc_auto.canbus.Brake brake = 9;
  bool has_brake() const;
  void clear_brake();
  static const int kBrakeFieldNumber = 9;
  const ::jmc_auto::canbus::Brake& brake() const;
  ::jmc_auto::canbus::Brake* mutable_brake();
  ::jmc_auto::canbus::Brake* release_brake();
  void set_allocated_brake(::jmc_auto::canbus::Brake* brake);

  // optional .jmc_auto.canbus.Deceleration deceleration = 10;
  bool has_deceleration() const;
  void clear_deceleration();
  static const int kDecelerationFieldNumber = 10;
  const ::jmc_auto::canbus::Deceleration& deceleration() const;
  ::jmc_auto::canbus::Deceleration* mutable_deceleration();
  ::jmc_auto::canbus::Deceleration* release_deceleration();
  void set_allocated_deceleration(::jmc_auto::canbus::Deceleration* deceleration);

  // optional .jmc_auto.canbus.VehicleSpd vehicle_spd = 11;
  bool has_vehicle_spd() const;
  void clear_vehicle_spd();
  static const int kVehicleSpdFieldNumber = 11;
  const ::jmc_auto::canbus::VehicleSpd& vehicle_spd() const;
  ::jmc_auto::canbus::VehicleSpd* mutable_vehicle_spd();
  ::jmc_auto::canbus::VehicleSpd* release_vehicle_spd();
  void set_allocated_vehicle_spd(::jmc_auto::canbus::VehicleSpd* vehicle_spd);

  // optional .jmc_auto.canbus.Eps eps = 12;
  bool has_eps() const;
  void clear_eps();
  static const int kEpsFieldNumber = 12;
  const ::jmc_auto::canbus::Eps& eps() const;
  ::jmc_auto::canbus::Eps* mutable_eps();
  ::jmc_auto::canbus::Eps* release_eps();
  void set_allocated_eps(::jmc_auto::canbus::Eps* eps);

  // optional .jmc_auto.canbus.Light light = 13;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 13;
  const ::jmc_auto::canbus::Light& light() const;
  ::jmc_auto::canbus::Light* mutable_light();
  ::jmc_auto::canbus::Light* release_light();
  void set_allocated_light(::jmc_auto::canbus::Light* light);

  // optional .jmc_auto.canbus.Battery battery = 14;
  bool has_battery() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 14;
  const ::jmc_auto::canbus::Battery& battery() const;
  ::jmc_auto::canbus::Battery* mutable_battery();
  ::jmc_auto::canbus::Battery* release_battery();
  void set_allocated_battery(::jmc_auto::canbus::Battery* battery);

  // optional .jmc_auto.canbus.CheckResponseSignal check_response = 15;
  bool has_check_response() const;
  void clear_check_response();
  static const int kCheckResponseFieldNumber = 15;
  const ::jmc_auto::canbus::CheckResponseSignal& check_response() const;
  ::jmc_auto::canbus::CheckResponseSignal* mutable_check_response();
  ::jmc_auto::canbus::CheckResponseSignal* release_check_response();
  void set_allocated_check_response(::jmc_auto::canbus::CheckResponseSignal* check_response);

  // optional .jmc_auto.canbus.License license = 16;
  bool has_license() const;
  void clear_license();
  static const int kLicenseFieldNumber = 16;
  const ::jmc_auto::canbus::License& license() const;
  ::jmc_auto::canbus::License* mutable_license();
  ::jmc_auto::canbus::License* release_license();
  void set_allocated_license(::jmc_auto::canbus::License* license);

  // optional .jmc_auto.canbus.Surround surround = 17;
  bool has_surround() const;
  void clear_surround();
  static const int kSurroundFieldNumber = 17;
  const ::jmc_auto::canbus::Surround& surround() const;
  ::jmc_auto::canbus::Surround* mutable_surround();
  ::jmc_auto::canbus::Surround* release_surround();
  void set_allocated_surround(::jmc_auto::canbus::Surround* surround);

  // optional .jmc_auto.canbus.Gem gem = 18;
  bool has_gem() const;
  void clear_gem();
  static const int kGemFieldNumber = 18;
  const ::jmc_auto::canbus::Gem& gem() const;
  ::jmc_auto::canbus::Gem* mutable_gem();
  ::jmc_auto::canbus::Gem* release_gem();
  void set_allocated_gem(::jmc_auto::canbus::Gem* gem);

  // optional .jmc_auto.canbus.Ch ch = 19;
  bool has_ch() const;
  void clear_ch();
  static const int kChFieldNumber = 19;
  const ::jmc_auto::canbus::Ch& ch() const;
  ::jmc_auto::canbus::Ch* mutable_ch();
  ::jmc_auto::canbus::Ch* release_ch();
  void set_allocated_ch(::jmc_auto::canbus::Ch* ch);

  // optional .jmc_auto.canbus.Teshun teshun = 20;
  bool has_teshun() const;
  void clear_teshun();
  static const int kTeshunFieldNumber = 20;
  const ::jmc_auto::canbus::Teshun& teshun() const;
  ::jmc_auto::canbus::Teshun* mutable_teshun();
  ::jmc_auto::canbus::Teshun* release_teshun();
  void set_allocated_teshun(::jmc_auto::canbus::Teshun* teshun);

  // optional .jmc_auto.canbus.Cx75 cx75 = 21;
  bool has_cx75() const;
  void clear_cx75();
  static const int kCx75FieldNumber = 21;
  const ::jmc_auto::canbus::Cx75& cx75() const;
  ::jmc_auto::canbus::Cx75* mutable_cx75();
  ::jmc_auto::canbus::Cx75* release_cx75();
  void set_allocated_cx75(::jmc_auto::canbus::Cx75* cx75);

  // optional .jmc_auto.canbus.ChassisDetail.Type car_type = 1;
  bool has_car_type() const;
  void clear_car_type();
  static const int kCarTypeFieldNumber = 1;
  ::jmc_auto::canbus::ChassisDetail_Type car_type() const;
  void set_car_type(::jmc_auto::canbus::ChassisDetail_Type value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.ChassisDetail)
 private:
  void set_has_car_type();
  void clear_has_car_type();
  void set_has_basic();
  void clear_has_basic();
  void set_has_safety();
  void clear_has_safety();
  void set_has_gear();
  void clear_has_gear();
  void set_has_ems();
  void clear_has_ems();
  void set_has_esp();
  void clear_has_esp();
  void set_has_gas();
  void clear_has_gas();
  void set_has_epb();
  void clear_has_epb();
  void set_has_brake();
  void clear_has_brake();
  void set_has_deceleration();
  void clear_has_deceleration();
  void set_has_vehicle_spd();
  void clear_has_vehicle_spd();
  void set_has_eps();
  void clear_has_eps();
  void set_has_light();
  void clear_has_light();
  void set_has_battery();
  void clear_has_battery();
  void set_has_check_response();
  void clear_has_check_response();
  void set_has_license();
  void clear_has_license();
  void set_has_surround();
  void clear_has_surround();
  void set_has_gem();
  void clear_has_gem();
  void set_has_ch();
  void clear_has_ch();
  void set_has_teshun();
  void clear_has_teshun();
  void set_has_cx75();
  void clear_has_cx75();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::canbus::BasicInfo* basic_;
  ::jmc_auto::canbus::Safety* safety_;
  ::jmc_auto::canbus::Gear* gear_;
  ::jmc_auto::canbus::Ems* ems_;
  ::jmc_auto::canbus::Esp* esp_;
  ::jmc_auto::canbus::Gas* gas_;
  ::jmc_auto::canbus::Epb* epb_;
  ::jmc_auto::canbus::Brake* brake_;
  ::jmc_auto::canbus::Deceleration* deceleration_;
  ::jmc_auto::canbus::VehicleSpd* vehicle_spd_;
  ::jmc_auto::canbus::Eps* eps_;
  ::jmc_auto::canbus::Light* light_;
  ::jmc_auto::canbus::Battery* battery_;
  ::jmc_auto::canbus::CheckResponseSignal* check_response_;
  ::jmc_auto::canbus::License* license_;
  ::jmc_auto::canbus::Surround* surround_;
  ::jmc_auto::canbus::Gem* gem_;
  ::jmc_auto::canbus::Ch* ch_;
  ::jmc_auto::canbus::Teshun* teshun_;
  ::jmc_auto::canbus::Cx75* cx75_;
  int car_type_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckResponseSignal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.CheckResponseSignal) */ {
 public:
  CheckResponseSignal();
  virtual ~CheckResponseSignal();

  CheckResponseSignal(const CheckResponseSignal& from);

  inline CheckResponseSignal& operator=(const CheckResponseSignal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckResponseSignal& default_instance();

  static inline const CheckResponseSignal* internal_default_instance() {
    return reinterpret_cast<const CheckResponseSignal*>(
               &_CheckResponseSignal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CheckResponseSignal* other);

  // implements Message ----------------------------------------------

  inline CheckResponseSignal* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckResponseSignal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckResponseSignal& from);
  void MergeFrom(const CheckResponseSignal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckResponseSignal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_eps_online = 1 [default = false];
  bool has_is_eps_online() const;
  void clear_is_eps_online();
  static const int kIsEpsOnlineFieldNumber = 1;
  bool is_eps_online() const;
  void set_is_eps_online(bool value);

  // optional bool is_epb_online = 2 [default = false];
  bool has_is_epb_online() const;
  void clear_is_epb_online();
  static const int kIsEpbOnlineFieldNumber = 2;
  bool is_epb_online() const;
  void set_is_epb_online(bool value);

  // optional bool is_esp_online = 3 [default = false];
  bool has_is_esp_online() const;
  void clear_is_esp_online();
  static const int kIsEspOnlineFieldNumber = 3;
  bool is_esp_online() const;
  void set_is_esp_online(bool value);

  // optional bool is_vtog_online = 4 [default = false];
  bool has_is_vtog_online() const;
  void clear_is_vtog_online();
  static const int kIsVtogOnlineFieldNumber = 4;
  bool is_vtog_online() const;
  void set_is_vtog_online(bool value);

  // optional bool is_scu_online = 5 [default = false];
  bool has_is_scu_online() const;
  void clear_is_scu_online();
  static const int kIsScuOnlineFieldNumber = 5;
  bool is_scu_online() const;
  void set_is_scu_online(bool value);

  // optional bool is_switch_online = 6 [default = false];
  bool has_is_switch_online() const;
  void clear_is_switch_online();
  static const int kIsSwitchOnlineFieldNumber = 6;
  bool is_switch_online() const;
  void set_is_switch_online(bool value);

  // optional bool is_vcu_online = 7 [default = false];
  bool has_is_vcu_online() const;
  void clear_is_vcu_online();
  static const int kIsVcuOnlineFieldNumber = 7;
  bool is_vcu_online() const;
  void set_is_vcu_online(bool value);

  // optional bool is_apa_online = 8 [default = false];
  bool has_is_apa_online() const;
  void clear_is_apa_online();
  static const int kIsApaOnlineFieldNumber = 8;
  bool is_apa_online() const;
  void set_is_apa_online(bool value);

  // optional bool is_epspam_online = 9 [default = false];
  bool has_is_epspam_online() const;
  void clear_is_epspam_online();
  static const int kIsEpspamOnlineFieldNumber = 9;
  bool is_epspam_online() const;
  void set_is_epspam_online(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.CheckResponseSignal)
 private:
  void set_has_is_eps_online();
  void clear_has_is_eps_online();
  void set_has_is_epb_online();
  void clear_has_is_epb_online();
  void set_has_is_esp_online();
  void clear_has_is_esp_online();
  void set_has_is_vtog_online();
  void clear_has_is_vtog_online();
  void set_has_is_scu_online();
  void clear_has_is_scu_online();
  void set_has_is_switch_online();
  void clear_has_is_switch_online();
  void set_has_is_vcu_online();
  void clear_has_is_vcu_online();
  void set_has_is_apa_online();
  void clear_has_is_apa_online();
  void set_has_is_epspam_online();
  void clear_has_is_epspam_online();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_eps_online_;
  bool is_epb_online_;
  bool is_esp_online_;
  bool is_vtog_online_;
  bool is_scu_online_;
  bool is_switch_online_;
  bool is_vcu_online_;
  bool is_apa_online_;
  bool is_epspam_online_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Battery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Battery) */ {
 public:
  Battery();
  virtual ~Battery();

  Battery(const Battery& from);

  inline Battery& operator=(const Battery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Battery& default_instance();

  static inline const Battery* internal_default_instance() {
    return reinterpret_cast<const Battery*>(
               &_Battery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Battery* other);

  // implements Message ----------------------------------------------

  inline Battery* New() const PROTOBUF_FINAL { return New(NULL); }

  Battery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Battery& from);
  void MergeFrom(const Battery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Battery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double battery_percent = 1;
  bool has_battery_percent() const;
  void clear_battery_percent();
  static const int kBatteryPercentFieldNumber = 1;
  double battery_percent() const;
  void set_battery_percent(double value);

  // optional double fuel_level = 2;
  bool has_fuel_level() const;
  void clear_fuel_level();
  static const int kFuelLevelFieldNumber = 2;
  double fuel_level() const;
  void set_fuel_level(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Battery)
 private:
  void set_has_battery_percent();
  void clear_has_battery_percent();
  void set_has_fuel_level();
  void clear_has_fuel_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double battery_percent_;
  double fuel_level_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Light : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Light) */ {
 public:
  Light();
  virtual ~Light();

  Light(const Light& from);

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light& default_instance();

  static inline const Light* internal_default_instance() {
    return reinterpret_cast<const Light*>(
               &_Light_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Light* other);

  // implements Message ----------------------------------------------

  inline Light* New() const PROTOBUF_FINAL { return New(NULL); }

  Light* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Light_TurnLightType TurnLightType;
  static const TurnLightType TURN_LIGHT_OFF =
    Light_TurnLightType_TURN_LIGHT_OFF;
  static const TurnLightType TURN_LEFT_ON =
    Light_TurnLightType_TURN_LEFT_ON;
  static const TurnLightType TURN_RIGHT_ON =
    Light_TurnLightType_TURN_RIGHT_ON;
  static const TurnLightType TURN_LIGHT_ON =
    Light_TurnLightType_TURN_LIGHT_ON;
  static inline bool TurnLightType_IsValid(int value) {
    return Light_TurnLightType_IsValid(value);
  }
  static const TurnLightType TurnLightType_MIN =
    Light_TurnLightType_TurnLightType_MIN;
  static const TurnLightType TurnLightType_MAX =
    Light_TurnLightType_TurnLightType_MAX;
  static const int TurnLightType_ARRAYSIZE =
    Light_TurnLightType_TurnLightType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TurnLightType_descriptor() {
    return Light_TurnLightType_descriptor();
  }
  static inline const ::std::string& TurnLightType_Name(TurnLightType value) {
    return Light_TurnLightType_Name(value);
  }
  static inline bool TurnLightType_Parse(const ::std::string& name,
      TurnLightType* value) {
    return Light_TurnLightType_Parse(name, value);
  }

  typedef Light_BeamLampType BeamLampType;
  static const BeamLampType BEAM_OFF =
    Light_BeamLampType_BEAM_OFF;
  static const BeamLampType HIGH_BEAM_ON =
    Light_BeamLampType_HIGH_BEAM_ON;
  static const BeamLampType LOW_BEAM_ON =
    Light_BeamLampType_LOW_BEAM_ON;
  static inline bool BeamLampType_IsValid(int value) {
    return Light_BeamLampType_IsValid(value);
  }
  static const BeamLampType BeamLampType_MIN =
    Light_BeamLampType_BeamLampType_MIN;
  static const BeamLampType BeamLampType_MAX =
    Light_BeamLampType_BeamLampType_MAX;
  static const int BeamLampType_ARRAYSIZE =
    Light_BeamLampType_BeamLampType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BeamLampType_descriptor() {
    return Light_BeamLampType_descriptor();
  }
  static inline const ::std::string& BeamLampType_Name(BeamLampType value) {
    return Light_BeamLampType_Name(value);
  }
  static inline bool BeamLampType_Parse(const ::std::string& name,
      BeamLampType* value) {
    return Light_BeamLampType_Parse(name, value);
  }

  typedef Light_LincolnLampType LincolnLampType;
  static const LincolnLampType BEAM_NULL =
    Light_LincolnLampType_BEAM_NULL;
  static const LincolnLampType BEAM_FLASH_TO_PASS =
    Light_LincolnLampType_BEAM_FLASH_TO_PASS;
  static const LincolnLampType BEAM_HIGH =
    Light_LincolnLampType_BEAM_HIGH;
  static const LincolnLampType BEAM_INVALID =
    Light_LincolnLampType_BEAM_INVALID;
  static inline bool LincolnLampType_IsValid(int value) {
    return Light_LincolnLampType_IsValid(value);
  }
  static const LincolnLampType LincolnLampType_MIN =
    Light_LincolnLampType_LincolnLampType_MIN;
  static const LincolnLampType LincolnLampType_MAX =
    Light_LincolnLampType_LincolnLampType_MAX;
  static const int LincolnLampType_ARRAYSIZE =
    Light_LincolnLampType_LincolnLampType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LincolnLampType_descriptor() {
    return Light_LincolnLampType_descriptor();
  }
  static inline const ::std::string& LincolnLampType_Name(LincolnLampType value) {
    return Light_LincolnLampType_Name(value);
  }
  static inline bool LincolnLampType_Parse(const ::std::string& name,
      LincolnLampType* value) {
    return Light_LincolnLampType_Parse(name, value);
  }

  typedef Light_LincolnWiperType LincolnWiperType;
  static const LincolnWiperType WIPER_OFF =
    Light_LincolnWiperType_WIPER_OFF;
  static const LincolnWiperType WIPER_AUTO_OFF =
    Light_LincolnWiperType_WIPER_AUTO_OFF;
  static const LincolnWiperType WIPER_OFF_MOVING =
    Light_LincolnWiperType_WIPER_OFF_MOVING;
  static const LincolnWiperType WIPER_MANUAL_OFF =
    Light_LincolnWiperType_WIPER_MANUAL_OFF;
  static const LincolnWiperType WIPER_MANUAL_ON =
    Light_LincolnWiperType_WIPER_MANUAL_ON;
  static const LincolnWiperType WIPER_MANUAL_LOW =
    Light_LincolnWiperType_WIPER_MANUAL_LOW;
  static const LincolnWiperType WIPER_MANUAL_HIGH =
    Light_LincolnWiperType_WIPER_MANUAL_HIGH;
  static const LincolnWiperType WIPER_MIST_FLICK =
    Light_LincolnWiperType_WIPER_MIST_FLICK;
  static const LincolnWiperType WIPER_WASH =
    Light_LincolnWiperType_WIPER_WASH;
  static const LincolnWiperType WIPER_AUTO_LOW =
    Light_LincolnWiperType_WIPER_AUTO_LOW;
  static const LincolnWiperType WIPER_AUTO_HIGH =
    Light_LincolnWiperType_WIPER_AUTO_HIGH;
  static const LincolnWiperType WIPER_COURTESY_WIPE =
    Light_LincolnWiperType_WIPER_COURTESY_WIPE;
  static const LincolnWiperType WIPER_AUTO_ADJUST =
    Light_LincolnWiperType_WIPER_AUTO_ADJUST;
  static const LincolnWiperType WIPER_RESERVED =
    Light_LincolnWiperType_WIPER_RESERVED;
  static const LincolnWiperType WIPER_STALLED =
    Light_LincolnWiperType_WIPER_STALLED;
  static const LincolnWiperType WIPER_NO_DATA =
    Light_LincolnWiperType_WIPER_NO_DATA;
  static inline bool LincolnWiperType_IsValid(int value) {
    return Light_LincolnWiperType_IsValid(value);
  }
  static const LincolnWiperType LincolnWiperType_MIN =
    Light_LincolnWiperType_LincolnWiperType_MIN;
  static const LincolnWiperType LincolnWiperType_MAX =
    Light_LincolnWiperType_LincolnWiperType_MAX;
  static const int LincolnWiperType_ARRAYSIZE =
    Light_LincolnWiperType_LincolnWiperType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LincolnWiperType_descriptor() {
    return Light_LincolnWiperType_descriptor();
  }
  static inline const ::std::string& LincolnWiperType_Name(LincolnWiperType value) {
    return Light_LincolnWiperType_Name(value);
  }
  static inline bool LincolnWiperType_Parse(const ::std::string& name,
      LincolnWiperType* value) {
    return Light_LincolnWiperType_Parse(name, value);
  }

  typedef Light_LincolnAmbientType LincolnAmbientType;
  static const LincolnAmbientType AMBIENT_DARK =
    Light_LincolnAmbientType_AMBIENT_DARK;
  static const LincolnAmbientType AMBIENT_LIGHT =
    Light_LincolnAmbientType_AMBIENT_LIGHT;
  static const LincolnAmbientType AMBIENT_TWILIGHT =
    Light_LincolnAmbientType_AMBIENT_TWILIGHT;
  static const LincolnAmbientType AMBIENT_TUNNEL_ON =
    Light_LincolnAmbientType_AMBIENT_TUNNEL_ON;
  static const LincolnAmbientType AMBIENT_TUNNEL_OFF =
    Light_LincolnAmbientType_AMBIENT_TUNNEL_OFF;
  static const LincolnAmbientType AMBIENT_INVALID =
    Light_LincolnAmbientType_AMBIENT_INVALID;
  static const LincolnAmbientType AMBIENT_NO_DATA =
    Light_LincolnAmbientType_AMBIENT_NO_DATA;
  static inline bool LincolnAmbientType_IsValid(int value) {
    return Light_LincolnAmbientType_IsValid(value);
  }
  static const LincolnAmbientType LincolnAmbientType_MIN =
    Light_LincolnAmbientType_LincolnAmbientType_MIN;
  static const LincolnAmbientType LincolnAmbientType_MAX =
    Light_LincolnAmbientType_LincolnAmbientType_MAX;
  static const int LincolnAmbientType_ARRAYSIZE =
    Light_LincolnAmbientType_LincolnAmbientType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LincolnAmbientType_descriptor() {
    return Light_LincolnAmbientType_descriptor();
  }
  static inline const ::std::string& LincolnAmbientType_Name(LincolnAmbientType value) {
    return Light_LincolnAmbientType_Name(value);
  }
  static inline bool LincolnAmbientType_Parse(const ::std::string& name,
      LincolnAmbientType* value) {
    return Light_LincolnAmbientType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Light.TurnLightType turn_light_type = 1;
  bool has_turn_light_type() const;
  void clear_turn_light_type();
  static const int kTurnLightTypeFieldNumber = 1;
  ::jmc_auto::canbus::Light_TurnLightType turn_light_type() const;
  void set_turn_light_type(::jmc_auto::canbus::Light_TurnLightType value);

  // optional .jmc_auto.canbus.Light.BeamLampType beam_lamp_type = 2;
  bool has_beam_lamp_type() const;
  void clear_beam_lamp_type();
  static const int kBeamLampTypeFieldNumber = 2;
  ::jmc_auto::canbus::Light_BeamLampType beam_lamp_type() const;
  void set_beam_lamp_type(::jmc_auto::canbus::Light_BeamLampType value);

  // optional bool is_brake_lamp_on = 3;
  bool has_is_brake_lamp_on() const;
  void clear_is_brake_lamp_on();
  static const int kIsBrakeLampOnFieldNumber = 3;
  bool is_brake_lamp_on() const;
  void set_is_brake_lamp_on(bool value);

  // optional bool is_auto_light = 4;
  bool has_is_auto_light() const;
  void clear_is_auto_light();
  static const int kIsAutoLightFieldNumber = 4;
  bool is_auto_light() const;
  void set_is_auto_light(bool value);

  // optional bool is_horn_on = 7;
  bool has_is_horn_on() const;
  void clear_is_horn_on();
  static const int kIsHornOnFieldNumber = 7;
  bool is_horn_on() const;
  void set_is_horn_on(bool value);

  // optional int32 wiper_gear = 5;
  bool has_wiper_gear() const;
  void clear_wiper_gear();
  static const int kWiperGearFieldNumber = 5;
  ::google::protobuf::int32 wiper_gear() const;
  void set_wiper_gear(::google::protobuf::int32 value);

  // optional int32 lotion_gear = 6;
  bool has_lotion_gear() const;
  void clear_lotion_gear();
  static const int kLotionGearFieldNumber = 6;
  ::google::protobuf::int32 lotion_gear() const;
  void set_lotion_gear(::google::protobuf::int32 value);

  // optional .jmc_auto.canbus.Light.LincolnLampType lincoln_lamp_type = 8;
  bool has_lincoln_lamp_type() const;
  void clear_lincoln_lamp_type();
  static const int kLincolnLampTypeFieldNumber = 8;
  ::jmc_auto::canbus::Light_LincolnLampType lincoln_lamp_type() const;
  void set_lincoln_lamp_type(::jmc_auto::canbus::Light_LincolnLampType value);

  // optional .jmc_auto.canbus.Light.LincolnWiperType lincoln_wiper = 9;
  bool has_lincoln_wiper() const;
  void clear_lincoln_wiper();
  static const int kLincolnWiperFieldNumber = 9;
  ::jmc_auto::canbus::Light_LincolnWiperType lincoln_wiper() const;
  void set_lincoln_wiper(::jmc_auto::canbus::Light_LincolnWiperType value);

  // optional .jmc_auto.canbus.Light.LincolnAmbientType lincoln_ambient = 10;
  bool has_lincoln_ambient() const;
  void clear_lincoln_ambient();
  static const int kLincolnAmbientFieldNumber = 10;
  ::jmc_auto::canbus::Light_LincolnAmbientType lincoln_ambient() const;
  void set_lincoln_ambient(::jmc_auto::canbus::Light_LincolnAmbientType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Light)
 private:
  void set_has_turn_light_type();
  void clear_has_turn_light_type();
  void set_has_beam_lamp_type();
  void clear_has_beam_lamp_type();
  void set_has_is_brake_lamp_on();
  void clear_has_is_brake_lamp_on();
  void set_has_is_auto_light();
  void clear_has_is_auto_light();
  void set_has_wiper_gear();
  void clear_has_wiper_gear();
  void set_has_lotion_gear();
  void clear_has_lotion_gear();
  void set_has_is_horn_on();
  void clear_has_is_horn_on();
  void set_has_lincoln_lamp_type();
  void clear_has_lincoln_lamp_type();
  void set_has_lincoln_wiper();
  void clear_has_lincoln_wiper();
  void set_has_lincoln_ambient();
  void clear_has_lincoln_ambient();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int turn_light_type_;
  int beam_lamp_type_;
  bool is_brake_lamp_on_;
  bool is_auto_light_;
  bool is_horn_on_;
  ::google::protobuf::int32 wiper_gear_;
  ::google::protobuf::int32 lotion_gear_;
  int lincoln_lamp_type_;
  int lincoln_wiper_;
  int lincoln_ambient_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Eps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Eps) */ {
 public:
  Eps();
  virtual ~Eps();

  Eps(const Eps& from);

  inline Eps& operator=(const Eps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Eps& default_instance();

  static inline const Eps* internal_default_instance() {
    return reinterpret_cast<const Eps*>(
               &_Eps_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Eps* other);

  // implements Message ----------------------------------------------

  inline Eps* New() const PROTOBUF_FINAL { return New(NULL); }

  Eps* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Eps& from);
  void MergeFrom(const Eps& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Eps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Eps_Type Type;
  static const Type NOT_AVAILABLE =
    Eps_Type_NOT_AVAILABLE;
  static const Type READY =
    Eps_Type_READY;
  static const Type ACTIVE =
    Eps_Type_ACTIVE;
  static const Type INVALID =
    Eps_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return Eps_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Eps_Type_Type_MIN;
  static const Type Type_MAX =
    Eps_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Eps_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Eps_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Eps_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Eps_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double eps_driver_hand_torq = 3;
  bool has_eps_driver_hand_torq() const;
  void clear_eps_driver_hand_torq();
  static const int kEpsDriverHandTorqFieldNumber = 3;
  double eps_driver_hand_torq() const;
  void set_eps_driver_hand_torq(double value);

  // optional .jmc_auto.canbus.Eps.Type eps_control_state = 2;
  bool has_eps_control_state() const;
  void clear_eps_control_state();
  static const int kEpsControlStateFieldNumber = 2;
  ::jmc_auto::canbus::Eps_Type eps_control_state() const;
  void set_eps_control_state(::jmc_auto::canbus::Eps_Type value);

  // optional bool is_eps_fail = 1;
  bool has_is_eps_fail() const;
  void clear_is_eps_fail();
  static const int kIsEpsFailFieldNumber = 1;
  bool is_eps_fail() const;
  void set_is_eps_fail(bool value);

  // optional bool is_steering_angle_valid = 4;
  bool has_is_steering_angle_valid() const;
  void clear_is_steering_angle_valid();
  static const int kIsSteeringAngleValidFieldNumber = 4;
  bool is_steering_angle_valid() const;
  void set_is_steering_angle_valid(bool value);

  // optional bool is_trimming_status = 7;
  bool has_is_trimming_status() const;
  void clear_is_trimming_status();
  static const int kIsTrimmingStatusFieldNumber = 7;
  bool is_trimming_status() const;
  void set_is_trimming_status(bool value);

  // optional bool is_calibration_status = 8;
  bool has_is_calibration_status() const;
  void clear_is_calibration_status();
  static const int kIsCalibrationStatusFieldNumber = 8;
  bool is_calibration_status() const;
  void set_is_calibration_status(bool value);

  // optional double steering_angle = 5;
  bool has_steering_angle() const;
  void clear_steering_angle();
  static const int kSteeringAngleFieldNumber = 5;
  double steering_angle() const;
  void set_steering_angle(double value);

  // optional double steering_angle_spd = 6;
  bool has_steering_angle_spd() const;
  void clear_steering_angle_spd();
  static const int kSteeringAngleSpdFieldNumber = 6;
  double steering_angle_spd() const;
  void set_steering_angle_spd(double value);

  // optional int32 allow_enter_autonomous_mode = 10;
  bool has_allow_enter_autonomous_mode() const;
  void clear_allow_enter_autonomous_mode();
  static const int kAllowEnterAutonomousModeFieldNumber = 10;
  ::google::protobuf::int32 allow_enter_autonomous_mode() const;
  void set_allow_enter_autonomous_mode(::google::protobuf::int32 value);

  // optional int32 current_driving_mode = 11;
  bool has_current_driving_mode() const;
  void clear_current_driving_mode();
  static const int kCurrentDrivingModeFieldNumber = 11;
  ::google::protobuf::int32 current_driving_mode() const;
  void set_current_driving_mode(::google::protobuf::int32 value);

  // optional double steering_angle_cmd = 12;
  bool has_steering_angle_cmd() const;
  void clear_steering_angle_cmd();
  static const int kSteeringAngleCmdFieldNumber = 12;
  double steering_angle_cmd() const;
  void set_steering_angle_cmd(double value);

  // optional double vehicle_speed = 13;
  bool has_vehicle_speed() const;
  void clear_vehicle_speed();
  static const int kVehicleSpeedFieldNumber = 13;
  double vehicle_speed() const;
  void set_vehicle_speed(double value);

  // optional double epas_torque = 14;
  bool has_epas_torque() const;
  void clear_epas_torque();
  static const int kEpasTorqueFieldNumber = 14;
  double epas_torque() const;
  void set_epas_torque(double value);

  // optional bool is_failure_status = 9;
  bool has_is_failure_status() const;
  void clear_is_failure_status();
  static const int kIsFailureStatusFieldNumber = 9;
  bool is_failure_status() const;
  void set_is_failure_status(bool value);

  // optional bool steering_enabled = 15;
  bool has_steering_enabled() const;
  void clear_steering_enabled();
  static const int kSteeringEnabledFieldNumber = 15;
  bool steering_enabled() const;
  void set_steering_enabled(bool value);

  // optional bool driver_override = 16;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 16;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool driver_activity = 17;
  bool has_driver_activity() const;
  void clear_driver_activity();
  static const int kDriverActivityFieldNumber = 17;
  bool driver_activity() const;
  void set_driver_activity(bool value);

  // optional bool watchdog_fault = 18;
  bool has_watchdog_fault() const;
  void clear_watchdog_fault();
  static const int kWatchdogFaultFieldNumber = 18;
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);

  // optional bool channel_1_fault = 19;
  bool has_channel_1_fault() const;
  void clear_channel_1_fault();
  static const int kChannel1FaultFieldNumber = 19;
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);

  // optional bool channel_2_fault = 20;
  bool has_channel_2_fault() const;
  void clear_channel_2_fault();
  static const int kChannel2FaultFieldNumber = 20;
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);

  // optional bool calibration_fault = 21;
  bool has_calibration_fault() const;
  void clear_calibration_fault();
  static const int kCalibrationFaultFieldNumber = 21;
  bool calibration_fault() const;
  void set_calibration_fault(bool value);

  // optional double timestamp_65 = 23;
  bool has_timestamp_65() const;
  void clear_timestamp_65();
  static const int kTimestamp65FieldNumber = 23;
  double timestamp_65() const;
  void set_timestamp_65(double value);

  // optional bool connector_fault = 22;
  bool has_connector_fault() const;
  void clear_connector_fault();
  static const int kConnectorFaultFieldNumber = 22;
  bool connector_fault() const;
  void set_connector_fault(bool value);

  // optional int32 major_version = 24;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 24;
  ::google::protobuf::int32 major_version() const;
  void set_major_version(::google::protobuf::int32 value);

  // optional int32 minor_version = 25;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 25;
  ::google::protobuf::int32 minor_version() const;
  void set_minor_version(::google::protobuf::int32 value);

  // optional int32 build_number = 26;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 26;
  ::google::protobuf::int32 build_number() const;
  void set_build_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Eps)
 private:
  void set_has_is_eps_fail();
  void clear_has_is_eps_fail();
  void set_has_eps_control_state();
  void clear_has_eps_control_state();
  void set_has_eps_driver_hand_torq();
  void clear_has_eps_driver_hand_torq();
  void set_has_is_steering_angle_valid();
  void clear_has_is_steering_angle_valid();
  void set_has_steering_angle();
  void clear_has_steering_angle();
  void set_has_steering_angle_spd();
  void clear_has_steering_angle_spd();
  void set_has_is_trimming_status();
  void clear_has_is_trimming_status();
  void set_has_is_calibration_status();
  void clear_has_is_calibration_status();
  void set_has_is_failure_status();
  void clear_has_is_failure_status();
  void set_has_allow_enter_autonomous_mode();
  void clear_has_allow_enter_autonomous_mode();
  void set_has_current_driving_mode();
  void clear_has_current_driving_mode();
  void set_has_steering_angle_cmd();
  void clear_has_steering_angle_cmd();
  void set_has_vehicle_speed();
  void clear_has_vehicle_speed();
  void set_has_epas_torque();
  void clear_has_epas_torque();
  void set_has_steering_enabled();
  void clear_has_steering_enabled();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_driver_activity();
  void clear_has_driver_activity();
  void set_has_watchdog_fault();
  void clear_has_watchdog_fault();
  void set_has_channel_1_fault();
  void clear_has_channel_1_fault();
  void set_has_channel_2_fault();
  void clear_has_channel_2_fault();
  void set_has_calibration_fault();
  void clear_has_calibration_fault();
  void set_has_connector_fault();
  void clear_has_connector_fault();
  void set_has_timestamp_65();
  void clear_has_timestamp_65();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_build_number();
  void clear_has_build_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double eps_driver_hand_torq_;
  int eps_control_state_;
  bool is_eps_fail_;
  bool is_steering_angle_valid_;
  bool is_trimming_status_;
  bool is_calibration_status_;
  double steering_angle_;
  double steering_angle_spd_;
  ::google::protobuf::int32 allow_enter_autonomous_mode_;
  ::google::protobuf::int32 current_driving_mode_;
  double steering_angle_cmd_;
  double vehicle_speed_;
  double epas_torque_;
  bool is_failure_status_;
  bool steering_enabled_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool calibration_fault_;
  double timestamp_65_;
  bool connector_fault_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 build_number_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleSpd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.VehicleSpd) */ {
 public:
  VehicleSpd();
  virtual ~VehicleSpd();

  VehicleSpd(const VehicleSpd& from);

  inline VehicleSpd& operator=(const VehicleSpd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleSpd& default_instance();

  static inline const VehicleSpd* internal_default_instance() {
    return reinterpret_cast<const VehicleSpd*>(
               &_VehicleSpd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(VehicleSpd* other);

  // implements Message ----------------------------------------------

  inline VehicleSpd* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleSpd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleSpd& from);
  void MergeFrom(const VehicleSpd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleSpd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double vehicle_spd = 3 [default = 0];
  bool has_vehicle_spd() const;
  void clear_vehicle_spd();
  static const int kVehicleSpdFieldNumber = 3;
  double vehicle_spd() const;
  void set_vehicle_spd(double value);

  // optional bool is_vehicle_standstill = 1;
  bool has_is_vehicle_standstill() const;
  void clear_is_vehicle_standstill();
  static const int kIsVehicleStandstillFieldNumber = 1;
  bool is_vehicle_standstill() const;
  void set_is_vehicle_standstill(bool value);

  // optional bool is_vehicle_spd_valid = 2;
  bool has_is_vehicle_spd_valid() const;
  void clear_is_vehicle_spd_valid();
  static const int kIsVehicleSpdValidFieldNumber = 2;
  bool is_vehicle_spd_valid() const;
  void set_is_vehicle_spd_valid(bool value);

  // optional bool is_wheel_spd_rr_valid = 4;
  bool has_is_wheel_spd_rr_valid() const;
  void clear_is_wheel_spd_rr_valid();
  static const int kIsWheelSpdRrValidFieldNumber = 4;
  bool is_wheel_spd_rr_valid() const;
  void set_is_wheel_spd_rr_valid(bool value);

  // optional bool is_wheel_spd_rl_valid = 7;
  bool has_is_wheel_spd_rl_valid() const;
  void clear_is_wheel_spd_rl_valid();
  static const int kIsWheelSpdRlValidFieldNumber = 7;
  bool is_wheel_spd_rl_valid() const;
  void set_is_wheel_spd_rl_valid(bool value);

  // optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 5;
  bool has_wheel_direction_rr() const;
  void clear_wheel_direction_rr();
  static const int kWheelDirectionRrFieldNumber = 5;
  ::jmc_auto::canbus::WheelSpeed_WheelSpeedType wheel_direction_rr() const;
  void set_wheel_direction_rr(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value);

  // optional double wheel_spd_rr = 6;
  bool has_wheel_spd_rr() const;
  void clear_wheel_spd_rr();
  static const int kWheelSpdRrFieldNumber = 6;
  double wheel_spd_rr() const;
  void set_wheel_spd_rr(double value);

  // optional double wheel_spd_rl = 9;
  bool has_wheel_spd_rl() const;
  void clear_wheel_spd_rl();
  static const int kWheelSpdRlFieldNumber = 9;
  double wheel_spd_rl() const;
  void set_wheel_spd_rl(double value);

  // optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 8;
  bool has_wheel_direction_rl() const;
  void clear_wheel_direction_rl();
  static const int kWheelDirectionRlFieldNumber = 8;
  ::jmc_auto::canbus::WheelSpeed_WheelSpeedType wheel_direction_rl() const;
  void set_wheel_direction_rl(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value);

  // optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 11;
  bool has_wheel_direction_fr() const;
  void clear_wheel_direction_fr();
  static const int kWheelDirectionFrFieldNumber = 11;
  ::jmc_auto::canbus::WheelSpeed_WheelSpeedType wheel_direction_fr() const;
  void set_wheel_direction_fr(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value);

  // optional double wheel_spd_fr = 12;
  bool has_wheel_spd_fr() const;
  void clear_wheel_spd_fr();
  static const int kWheelSpdFrFieldNumber = 12;
  double wheel_spd_fr() const;
  void set_wheel_spd_fr(double value);

  // optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 14;
  bool has_wheel_direction_fl() const;
  void clear_wheel_direction_fl();
  static const int kWheelDirectionFlFieldNumber = 14;
  ::jmc_auto::canbus::WheelSpeed_WheelSpeedType wheel_direction_fl() const;
  void set_wheel_direction_fl(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value);

  // optional bool is_wheel_spd_fr_valid = 10;
  bool has_is_wheel_spd_fr_valid() const;
  void clear_is_wheel_spd_fr_valid();
  static const int kIsWheelSpdFrValidFieldNumber = 10;
  bool is_wheel_spd_fr_valid() const;
  void set_is_wheel_spd_fr_valid(bool value);

  // optional bool is_wheel_spd_fl_valid = 13;
  bool has_is_wheel_spd_fl_valid() const;
  void clear_is_wheel_spd_fl_valid();
  static const int kIsWheelSpdFlValidFieldNumber = 13;
  bool is_wheel_spd_fl_valid() const;
  void set_is_wheel_spd_fl_valid(bool value);

  // optional bool is_yaw_rate_valid = 16;
  bool has_is_yaw_rate_valid() const;
  void clear_is_yaw_rate_valid();
  static const int kIsYawRateValidFieldNumber = 16;
  bool is_yaw_rate_valid() const;
  void set_is_yaw_rate_valid(bool value);

  // optional bool is_ax_valid = 19;
  bool has_is_ax_valid() const;
  void clear_is_ax_valid();
  static const int kIsAxValidFieldNumber = 19;
  bool is_ax_valid() const;
  void set_is_ax_valid(bool value);

  // optional double wheel_spd_fl = 15;
  bool has_wheel_spd_fl() const;
  void clear_wheel_spd_fl();
  static const int kWheelSpdFlFieldNumber = 15;
  double wheel_spd_fl() const;
  void set_wheel_spd_fl(double value);

  // optional double yaw_rate = 17;
  bool has_yaw_rate() const;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 17;
  double yaw_rate() const;
  void set_yaw_rate(double value);

  // optional double yaw_rate_offset = 18;
  bool has_yaw_rate_offset() const;
  void clear_yaw_rate_offset();
  static const int kYawRateOffsetFieldNumber = 18;
  double yaw_rate_offset() const;
  void set_yaw_rate_offset(double value);

  // optional double ax = 20;
  bool has_ax() const;
  void clear_ax();
  static const int kAxFieldNumber = 20;
  double ax() const;
  void set_ax(double value);

  // optional double ax_offset = 21;
  bool has_ax_offset() const;
  void clear_ax_offset();
  static const int kAxOffsetFieldNumber = 21;
  double ax_offset() const;
  void set_ax_offset(double value);

  // optional double ay = 23;
  bool has_ay() const;
  void clear_ay();
  static const int kAyFieldNumber = 23;
  double ay() const;
  void set_ay(double value);

  // optional double ay_offset = 24;
  bool has_ay_offset() const;
  void clear_ay_offset();
  static const int kAyOffsetFieldNumber = 24;
  double ay_offset() const;
  void set_ay_offset(double value);

  // optional double lat_acc = 25;
  bool has_lat_acc() const;
  void clear_lat_acc();
  static const int kLatAccFieldNumber = 25;
  double lat_acc() const;
  void set_lat_acc(double value);

  // optional double long_acc = 26;
  bool has_long_acc() const;
  void clear_long_acc();
  static const int kLongAccFieldNumber = 26;
  double long_acc() const;
  void set_long_acc(double value);

  // optional double vert_acc = 27;
  bool has_vert_acc() const;
  void clear_vert_acc();
  static const int kVertAccFieldNumber = 27;
  double vert_acc() const;
  void set_vert_acc(double value);

  // optional double roll_rate = 28;
  bool has_roll_rate() const;
  void clear_roll_rate();
  static const int kRollRateFieldNumber = 28;
  double roll_rate() const;
  void set_roll_rate(double value);

  // optional double acc_est = 29;
  bool has_acc_est() const;
  void clear_acc_est();
  static const int kAccEstFieldNumber = 29;
  double acc_est() const;
  void set_acc_est(double value);

  // optional double timestamp_sec = 30;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 30;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional bool is_ay_valid = 22;
  bool has_is_ay_valid() const;
  void clear_is_ay_valid();
  static const int kIsAyValidFieldNumber = 22;
  bool is_ay_valid() const;
  void set_is_ay_valid(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.VehicleSpd)
 private:
  void set_has_is_vehicle_standstill();
  void clear_has_is_vehicle_standstill();
  void set_has_is_vehicle_spd_valid();
  void clear_has_is_vehicle_spd_valid();
  void set_has_vehicle_spd();
  void clear_has_vehicle_spd();
  void set_has_is_wheel_spd_rr_valid();
  void clear_has_is_wheel_spd_rr_valid();
  void set_has_wheel_direction_rr();
  void clear_has_wheel_direction_rr();
  void set_has_wheel_spd_rr();
  void clear_has_wheel_spd_rr();
  void set_has_is_wheel_spd_rl_valid();
  void clear_has_is_wheel_spd_rl_valid();
  void set_has_wheel_direction_rl();
  void clear_has_wheel_direction_rl();
  void set_has_wheel_spd_rl();
  void clear_has_wheel_spd_rl();
  void set_has_is_wheel_spd_fr_valid();
  void clear_has_is_wheel_spd_fr_valid();
  void set_has_wheel_direction_fr();
  void clear_has_wheel_direction_fr();
  void set_has_wheel_spd_fr();
  void clear_has_wheel_spd_fr();
  void set_has_is_wheel_spd_fl_valid();
  void clear_has_is_wheel_spd_fl_valid();
  void set_has_wheel_direction_fl();
  void clear_has_wheel_direction_fl();
  void set_has_wheel_spd_fl();
  void clear_has_wheel_spd_fl();
  void set_has_is_yaw_rate_valid();
  void clear_has_is_yaw_rate_valid();
  void set_has_yaw_rate();
  void clear_has_yaw_rate();
  void set_has_yaw_rate_offset();
  void clear_has_yaw_rate_offset();
  void set_has_is_ax_valid();
  void clear_has_is_ax_valid();
  void set_has_ax();
  void clear_has_ax();
  void set_has_ax_offset();
  void clear_has_ax_offset();
  void set_has_is_ay_valid();
  void clear_has_is_ay_valid();
  void set_has_ay();
  void clear_has_ay();
  void set_has_ay_offset();
  void clear_has_ay_offset();
  void set_has_lat_acc();
  void clear_has_lat_acc();
  void set_has_long_acc();
  void clear_has_long_acc();
  void set_has_vert_acc();
  void clear_has_vert_acc();
  void set_has_roll_rate();
  void clear_has_roll_rate();
  void set_has_acc_est();
  void clear_has_acc_est();
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double vehicle_spd_;
  bool is_vehicle_standstill_;
  bool is_vehicle_spd_valid_;
  bool is_wheel_spd_rr_valid_;
  bool is_wheel_spd_rl_valid_;
  int wheel_direction_rr_;
  double wheel_spd_rr_;
  double wheel_spd_rl_;
  int wheel_direction_rl_;
  int wheel_direction_fr_;
  double wheel_spd_fr_;
  int wheel_direction_fl_;
  bool is_wheel_spd_fr_valid_;
  bool is_wheel_spd_fl_valid_;
  bool is_yaw_rate_valid_;
  bool is_ax_valid_;
  double wheel_spd_fl_;
  double yaw_rate_;
  double yaw_rate_offset_;
  double ax_;
  double ax_offset_;
  double ay_;
  double ay_offset_;
  double lat_acc_;
  double long_acc_;
  double vert_acc_;
  double roll_rate_;
  double acc_est_;
  double timestamp_sec_;
  bool is_ay_valid_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Deceleration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Deceleration) */ {
 public:
  Deceleration();
  virtual ~Deceleration();

  Deceleration(const Deceleration& from);

  inline Deceleration& operator=(const Deceleration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Deceleration& default_instance();

  static inline const Deceleration* internal_default_instance() {
    return reinterpret_cast<const Deceleration*>(
               &_Deceleration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Deceleration* other);

  // implements Message ----------------------------------------------

  inline Deceleration* New() const PROTOBUF_FINAL { return New(NULL); }

  Deceleration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Deceleration& from);
  void MergeFrom(const Deceleration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Deceleration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double deceleration = 3 [default = 0];
  bool has_deceleration() const;
  void clear_deceleration();
  static const int kDecelerationFieldNumber = 3;
  double deceleration() const;
  void set_deceleration(double value);

  // optional double is_evb_fail = 4;
  bool has_is_evb_fail() const;
  void clear_is_evb_fail();
  static const int kIsEvbFailFieldNumber = 4;
  double is_evb_fail() const;
  void set_is_evb_fail(double value);

  // optional double evb_pressure = 5 [default = 0];
  bool has_evb_pressure() const;
  void clear_evb_pressure();
  static const int kEvbPressureFieldNumber = 5;
  double evb_pressure() const;
  void set_evb_pressure(double value);

  // optional double brake_pressure = 6 [default = 0];
  bool has_brake_pressure() const;
  void clear_brake_pressure();
  static const int kBrakePressureFieldNumber = 6;
  double brake_pressure() const;
  void set_brake_pressure(double value);

  // optional double brake_pressure_spd = 7 [default = 0];
  bool has_brake_pressure_spd() const;
  void clear_brake_pressure_spd();
  static const int kBrakePressureSpdFieldNumber = 7;
  double brake_pressure_spd() const;
  void set_brake_pressure_spd(double value);

  // optional bool is_deceleration_available = 1;
  bool has_is_deceleration_available() const;
  void clear_is_deceleration_available();
  static const int kIsDecelerationAvailableFieldNumber = 1;
  bool is_deceleration_available() const;
  void set_is_deceleration_available(bool value);

  // optional bool is_deceleration_active = 2;
  bool has_is_deceleration_active() const;
  void clear_is_deceleration_active();
  static const int kIsDecelerationActiveFieldNumber = 2;
  bool is_deceleration_active() const;
  void set_is_deceleration_active(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Deceleration)
 private:
  void set_has_is_deceleration_available();
  void clear_has_is_deceleration_available();
  void set_has_is_deceleration_active();
  void clear_has_is_deceleration_active();
  void set_has_deceleration();
  void clear_has_deceleration();
  void set_has_is_evb_fail();
  void clear_has_is_evb_fail();
  void set_has_evb_pressure();
  void clear_has_evb_pressure();
  void set_has_brake_pressure();
  void clear_has_brake_pressure();
  void set_has_brake_pressure_spd();
  void clear_has_brake_pressure_spd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double deceleration_;
  double is_evb_fail_;
  double evb_pressure_;
  double brake_pressure_;
  double brake_pressure_spd_;
  bool is_deceleration_available_;
  bool is_deceleration_active_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Brake) */ {
 public:
  Brake();
  virtual ~Brake();

  Brake(const Brake& from);

  inline Brake& operator=(const Brake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake& default_instance();

  static inline const Brake* internal_default_instance() {
    return reinterpret_cast<const Brake*>(
               &_Brake_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Brake* other);

  // implements Message ----------------------------------------------

  inline Brake* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake& from);
  void MergeFrom(const Brake& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Brake_HSAStatusType HSAStatusType;
  static const HSAStatusType HSA_INACTIVE =
    Brake_HSAStatusType_HSA_INACTIVE;
  static const HSAStatusType HSA_FINDING_GRADIENT =
    Brake_HSAStatusType_HSA_FINDING_GRADIENT;
  static const HSAStatusType HSA_ACTIVE_PRESSED =
    Brake_HSAStatusType_HSA_ACTIVE_PRESSED;
  static const HSAStatusType HSA_ACTIVE_RELEASED =
    Brake_HSAStatusType_HSA_ACTIVE_RELEASED;
  static const HSAStatusType HSA_FAST_RELEASE =
    Brake_HSAStatusType_HSA_FAST_RELEASE;
  static const HSAStatusType HSA_SLOW_RELEASE =
    Brake_HSAStatusType_HSA_SLOW_RELEASE;
  static const HSAStatusType HSA_FAILED =
    Brake_HSAStatusType_HSA_FAILED;
  static const HSAStatusType HSA_UNDEFINED =
    Brake_HSAStatusType_HSA_UNDEFINED;
  static inline bool HSAStatusType_IsValid(int value) {
    return Brake_HSAStatusType_IsValid(value);
  }
  static const HSAStatusType HSAStatusType_MIN =
    Brake_HSAStatusType_HSAStatusType_MIN;
  static const HSAStatusType HSAStatusType_MAX =
    Brake_HSAStatusType_HSAStatusType_MAX;
  static const int HSAStatusType_ARRAYSIZE =
    Brake_HSAStatusType_HSAStatusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HSAStatusType_descriptor() {
    return Brake_HSAStatusType_descriptor();
  }
  static inline const ::std::string& HSAStatusType_Name(HSAStatusType value) {
    return Brake_HSAStatusType_Name(value);
  }
  static inline bool HSAStatusType_Parse(const ::std::string& name,
      HSAStatusType* value) {
    return Brake_HSAStatusType_Parse(name, value);
  }

  typedef Brake_HSAModeType HSAModeType;
  static const HSAModeType HSA_OFF =
    Brake_HSAModeType_HSA_OFF;
  static const HSAModeType HSA_AUTO =
    Brake_HSAModeType_HSA_AUTO;
  static const HSAModeType HSA_MANUAL =
    Brake_HSAModeType_HSA_MANUAL;
  static const HSAModeType HSA_MODE_UNDEFINED =
    Brake_HSAModeType_HSA_MODE_UNDEFINED;
  static inline bool HSAModeType_IsValid(int value) {
    return Brake_HSAModeType_IsValid(value);
  }
  static const HSAModeType HSAModeType_MIN =
    Brake_HSAModeType_HSAModeType_MIN;
  static const HSAModeType HSAModeType_MAX =
    Brake_HSAModeType_HSAModeType_MAX;
  static const int HSAModeType_ARRAYSIZE =
    Brake_HSAModeType_HSAModeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HSAModeType_descriptor() {
    return Brake_HSAModeType_descriptor();
  }
  static inline const ::std::string& HSAModeType_Name(HSAModeType value) {
    return Brake_HSAModeType_Name(value);
  }
  static inline bool HSAModeType_Parse(const ::std::string& name,
      HSAModeType* value) {
    return Brake_HSAModeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double brake_pedal_position = 5;
  bool has_brake_pedal_position() const;
  void clear_brake_pedal_position();
  static const int kBrakePedalPositionFieldNumber = 5;
  double brake_pedal_position() const;
  void set_brake_pedal_position(double value);

  // optional bool is_brake_pedal_pressed = 1 [default = false];
  bool has_is_brake_pedal_pressed() const;
  void clear_is_brake_pedal_pressed();
  static const int kIsBrakePedalPressedFieldNumber = 1;
  bool is_brake_pedal_pressed() const;
  void set_is_brake_pedal_pressed(bool value);

  // optional bool is_brake_force_exist = 2;
  bool has_is_brake_force_exist() const;
  void clear_is_brake_force_exist();
  static const int kIsBrakeForceExistFieldNumber = 2;
  bool is_brake_force_exist() const;
  void set_is_brake_force_exist(bool value);

  // optional bool is_brake_over_heat = 3;
  bool has_is_brake_over_heat() const;
  void clear_is_brake_over_heat();
  static const int kIsBrakeOverHeatFieldNumber = 3;
  bool is_brake_over_heat() const;
  void set_is_brake_over_heat(bool value);

  // optional bool is_hand_brake_on = 4;
  bool has_is_hand_brake_on() const;
  void clear_is_hand_brake_on();
  static const int kIsHandBrakeOnFieldNumber = 4;
  bool is_hand_brake_on() const;
  void set_is_hand_brake_on(bool value);

  // optional bool is_brake_valid = 6;
  bool has_is_brake_valid() const;
  void clear_is_brake_valid();
  static const int kIsBrakeValidFieldNumber = 6;
  bool is_brake_valid() const;
  void set_is_brake_valid(bool value);

  // optional bool boo_input = 10;
  bool has_boo_input() const;
  void clear_boo_input();
  static const int kBooInputFieldNumber = 10;
  bool boo_input() const;
  void set_boo_input(bool value);

  // optional bool boo_cmd = 11;
  bool has_boo_cmd() const;
  void clear_boo_cmd();
  static const int kBooCmdFieldNumber = 11;
  bool boo_cmd() const;
  void set_boo_cmd(bool value);

  // optional bool boo_output = 12;
  bool has_boo_output() const;
  void clear_boo_output();
  static const int kBooOutputFieldNumber = 12;
  bool boo_output() const;
  void set_boo_output(bool value);

  // optional double brake_input = 7;
  bool has_brake_input() const;
  void clear_brake_input();
  static const int kBrakeInputFieldNumber = 7;
  double brake_input() const;
  void set_brake_input(double value);

  // optional double brake_cmd = 8;
  bool has_brake_cmd() const;
  void clear_brake_cmd();
  static const int kBrakeCmdFieldNumber = 8;
  double brake_cmd() const;
  void set_brake_cmd(double value);

  // optional double brake_output = 9;
  bool has_brake_output() const;
  void clear_brake_output();
  static const int kBrakeOutputFieldNumber = 9;
  double brake_output() const;
  void set_brake_output(double value);

  // optional int32 watchdog_source = 14;
  bool has_watchdog_source() const;
  void clear_watchdog_source();
  static const int kWatchdogSourceFieldNumber = 14;
  ::google::protobuf::int32 watchdog_source() const;
  void set_watchdog_source(::google::protobuf::int32 value);

  // optional bool watchdog_applying_brakes = 13;
  bool has_watchdog_applying_brakes() const;
  void clear_watchdog_applying_brakes();
  static const int kWatchdogApplyingBrakesFieldNumber = 13;
  bool watchdog_applying_brakes() const;
  void set_watchdog_applying_brakes(bool value);

  // optional bool brake_enabled = 15;
  bool has_brake_enabled() const;
  void clear_brake_enabled();
  static const int kBrakeEnabledFieldNumber = 15;
  bool brake_enabled() const;
  void set_brake_enabled(bool value);

  // optional bool driver_override = 16;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 16;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool driver_activity = 17;
  bool has_driver_activity() const;
  void clear_driver_activity();
  static const int kDriverActivityFieldNumber = 17;
  bool driver_activity() const;
  void set_driver_activity(bool value);

  // optional bool watchdog_fault = 18;
  bool has_watchdog_fault() const;
  void clear_watchdog_fault();
  static const int kWatchdogFaultFieldNumber = 18;
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);

  // optional bool channel_1_fault = 19;
  bool has_channel_1_fault() const;
  void clear_channel_1_fault();
  static const int kChannel1FaultFieldNumber = 19;
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);

  // optional bool channel_2_fault = 20;
  bool has_channel_2_fault() const;
  void clear_channel_2_fault();
  static const int kChannel2FaultFieldNumber = 20;
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);

  // optional bool boo_fault = 21;
  bool has_boo_fault() const;
  void clear_boo_fault();
  static const int kBooFaultFieldNumber = 21;
  bool boo_fault() const;
  void set_boo_fault(bool value);

  // optional bool connector_fault = 22;
  bool has_connector_fault() const;
  void clear_connector_fault();
  static const int kConnectorFaultFieldNumber = 22;
  bool connector_fault() const;
  void set_connector_fault(bool value);

  // optional double brake_torque_req = 23;
  bool has_brake_torque_req() const;
  void clear_brake_torque_req();
  static const int kBrakeTorqueReqFieldNumber = 23;
  double brake_torque_req() const;
  void set_brake_torque_req(double value);

  // optional double brake_torque_act = 25;
  bool has_brake_torque_act() const;
  void clear_brake_torque_act();
  static const int kBrakeTorqueActFieldNumber = 25;
  double brake_torque_act() const;
  void set_brake_torque_act(double value);

  // optional .jmc_auto.canbus.Brake.HSAStatusType hsa_status = 24;
  bool has_hsa_status() const;
  void clear_hsa_status();
  static const int kHsaStatusFieldNumber = 24;
  ::jmc_auto::canbus::Brake_HSAStatusType hsa_status() const;
  void set_hsa_status(::jmc_auto::canbus::Brake_HSAStatusType value);

  // optional .jmc_auto.canbus.Brake.HSAModeType hsa_mode = 26;
  bool has_hsa_mode() const;
  void clear_hsa_mode();
  static const int kHsaModeFieldNumber = 26;
  ::jmc_auto::canbus::Brake_HSAModeType hsa_mode() const;
  void set_hsa_mode(::jmc_auto::canbus::Brake_HSAModeType value);

  // optional double wheel_torque_act = 27;
  bool has_wheel_torque_act() const;
  void clear_wheel_torque_act();
  static const int kWheelTorqueActFieldNumber = 27;
  double wheel_torque_act() const;
  void set_wheel_torque_act(double value);

  // optional int32 major_version = 28;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 28;
  ::google::protobuf::int32 major_version() const;
  void set_major_version(::google::protobuf::int32 value);

  // optional int32 minor_version = 29;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 29;
  ::google::protobuf::int32 minor_version() const;
  void set_minor_version(::google::protobuf::int32 value);

  // optional int32 build_number = 30;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 30;
  ::google::protobuf::int32 build_number() const;
  void set_build_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Brake)
 private:
  void set_has_is_brake_pedal_pressed();
  void clear_has_is_brake_pedal_pressed();
  void set_has_is_brake_force_exist();
  void clear_has_is_brake_force_exist();
  void set_has_is_brake_over_heat();
  void clear_has_is_brake_over_heat();
  void set_has_is_hand_brake_on();
  void clear_has_is_hand_brake_on();
  void set_has_brake_pedal_position();
  void clear_has_brake_pedal_position();
  void set_has_is_brake_valid();
  void clear_has_is_brake_valid();
  void set_has_brake_input();
  void clear_has_brake_input();
  void set_has_brake_cmd();
  void clear_has_brake_cmd();
  void set_has_brake_output();
  void clear_has_brake_output();
  void set_has_boo_input();
  void clear_has_boo_input();
  void set_has_boo_cmd();
  void clear_has_boo_cmd();
  void set_has_boo_output();
  void clear_has_boo_output();
  void set_has_watchdog_applying_brakes();
  void clear_has_watchdog_applying_brakes();
  void set_has_watchdog_source();
  void clear_has_watchdog_source();
  void set_has_brake_enabled();
  void clear_has_brake_enabled();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_driver_activity();
  void clear_has_driver_activity();
  void set_has_watchdog_fault();
  void clear_has_watchdog_fault();
  void set_has_channel_1_fault();
  void clear_has_channel_1_fault();
  void set_has_channel_2_fault();
  void clear_has_channel_2_fault();
  void set_has_boo_fault();
  void clear_has_boo_fault();
  void set_has_connector_fault();
  void clear_has_connector_fault();
  void set_has_brake_torque_req();
  void clear_has_brake_torque_req();
  void set_has_hsa_status();
  void clear_has_hsa_status();
  void set_has_brake_torque_act();
  void clear_has_brake_torque_act();
  void set_has_hsa_mode();
  void clear_has_hsa_mode();
  void set_has_wheel_torque_act();
  void clear_has_wheel_torque_act();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_build_number();
  void clear_has_build_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double brake_pedal_position_;
  bool is_brake_pedal_pressed_;
  bool is_brake_force_exist_;
  bool is_brake_over_heat_;
  bool is_hand_brake_on_;
  bool is_brake_valid_;
  bool boo_input_;
  bool boo_cmd_;
  bool boo_output_;
  double brake_input_;
  double brake_cmd_;
  double brake_output_;
  ::google::protobuf::int32 watchdog_source_;
  bool watchdog_applying_brakes_;
  bool brake_enabled_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool boo_fault_;
  bool connector_fault_;
  double brake_torque_req_;
  double brake_torque_act_;
  int hsa_status_;
  int hsa_mode_;
  double wheel_torque_act_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 build_number_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Epb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Epb) */ {
 public:
  Epb();
  virtual ~Epb();

  Epb(const Epb& from);

  inline Epb& operator=(const Epb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Epb& default_instance();

  static inline const Epb* internal_default_instance() {
    return reinterpret_cast<const Epb*>(
               &_Epb_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Epb* other);

  // implements Message ----------------------------------------------

  inline Epb* New() const PROTOBUF_FINAL { return New(NULL); }

  Epb* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Epb& from);
  void MergeFrom(const Epb& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Epb* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Epb_PBrakeType PBrakeType;
  static const PBrakeType PBRAKE_OFF =
    Epb_PBrakeType_PBRAKE_OFF;
  static const PBrakeType PBRAKE_TRANSITION =
    Epb_PBrakeType_PBRAKE_TRANSITION;
  static const PBrakeType PBRAKE_ON =
    Epb_PBrakeType_PBRAKE_ON;
  static const PBrakeType PBRAKE_FAULT =
    Epb_PBrakeType_PBRAKE_FAULT;
  static inline bool PBrakeType_IsValid(int value) {
    return Epb_PBrakeType_IsValid(value);
  }
  static const PBrakeType PBrakeType_MIN =
    Epb_PBrakeType_PBrakeType_MIN;
  static const PBrakeType PBrakeType_MAX =
    Epb_PBrakeType_PBrakeType_MAX;
  static const int PBrakeType_ARRAYSIZE =
    Epb_PBrakeType_PBrakeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PBrakeType_descriptor() {
    return Epb_PBrakeType_descriptor();
  }
  static inline const ::std::string& PBrakeType_Name(PBrakeType value) {
    return Epb_PBrakeType_Name(value);
  }
  static inline bool PBrakeType_Parse(const ::std::string& name,
      PBrakeType* value) {
    return Epb_PBrakeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool is_epb_error = 1;
  bool has_is_epb_error() const;
  void clear_is_epb_error();
  static const int kIsEpbErrorFieldNumber = 1;
  bool is_epb_error() const;
  void set_is_epb_error(bool value);

  // optional bool is_epb_released = 2;
  bool has_is_epb_released() const;
  void clear_is_epb_released();
  static const int kIsEpbReleasedFieldNumber = 2;
  bool is_epb_released() const;
  void set_is_epb_released(bool value);

  // optional int32 epb_status = 3;
  bool has_epb_status() const;
  void clear_epb_status();
  static const int kEpbStatusFieldNumber = 3;
  ::google::protobuf::int32 epb_status() const;
  void set_epb_status(::google::protobuf::int32 value);

  // optional .jmc_auto.canbus.Epb.PBrakeType parking_brake_status = 4;
  bool has_parking_brake_status() const;
  void clear_parking_brake_status();
  static const int kParkingBrakeStatusFieldNumber = 4;
  ::jmc_auto::canbus::Epb_PBrakeType parking_brake_status() const;
  void set_parking_brake_status(::jmc_auto::canbus::Epb_PBrakeType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Epb)
 private:
  void set_has_is_epb_error();
  void clear_has_is_epb_error();
  void set_has_is_epb_released();
  void clear_has_is_epb_released();
  void set_has_epb_status();
  void clear_has_epb_status();
  void set_has_parking_brake_status();
  void clear_has_parking_brake_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_epb_error_;
  bool is_epb_released_;
  ::google::protobuf::int32 epb_status_;
  int parking_brake_status_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gas : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Gas) */ {
 public:
  Gas();
  virtual ~Gas();

  Gas(const Gas& from);

  inline Gas& operator=(const Gas& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gas& default_instance();

  static inline const Gas* internal_default_instance() {
    return reinterpret_cast<const Gas*>(
               &_Gas_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Gas* other);

  // implements Message ----------------------------------------------

  inline Gas* New() const PROTOBUF_FINAL { return New(NULL); }

  Gas* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gas& from);
  void MergeFrom(const Gas& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gas* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double gas_pedal_position = 3 [default = 0];
  bool has_gas_pedal_position() const;
  void clear_gas_pedal_position();
  static const int kGasPedalPositionFieldNumber = 3;
  double gas_pedal_position() const;
  void set_gas_pedal_position(double value);

  // optional bool is_gas_pedal_error = 1;
  bool has_is_gas_pedal_error() const;
  void clear_is_gas_pedal_error();
  static const int kIsGasPedalErrorFieldNumber = 1;
  bool is_gas_pedal_error() const;
  void set_is_gas_pedal_error(bool value);

  // optional bool is_gas_pedal_pressed_more = 2;
  bool has_is_gas_pedal_pressed_more() const;
  void clear_is_gas_pedal_pressed_more();
  static const int kIsGasPedalPressedMoreFieldNumber = 2;
  bool is_gas_pedal_pressed_more() const;
  void set_is_gas_pedal_pressed_more(bool value);

  // optional bool is_gas_valid = 4 [default = false];
  bool has_is_gas_valid() const;
  void clear_is_gas_valid();
  static const int kIsGasValidFieldNumber = 4;
  bool is_gas_valid() const;
  void set_is_gas_valid(bool value);

  // optional bool throttle_enabled = 9;
  bool has_throttle_enabled() const;
  void clear_throttle_enabled();
  static const int kThrottleEnabledFieldNumber = 9;
  bool throttle_enabled() const;
  void set_throttle_enabled(bool value);

  // optional int32 watchdog_source = 8;
  bool has_watchdog_source() const;
  void clear_watchdog_source();
  static const int kWatchdogSourceFieldNumber = 8;
  ::google::protobuf::int32 watchdog_source() const;
  void set_watchdog_source(::google::protobuf::int32 value);

  // optional double throttle_input = 5;
  bool has_throttle_input() const;
  void clear_throttle_input();
  static const int kThrottleInputFieldNumber = 5;
  double throttle_input() const;
  void set_throttle_input(double value);

  // optional double throttle_cmd = 6;
  bool has_throttle_cmd() const;
  void clear_throttle_cmd();
  static const int kThrottleCmdFieldNumber = 6;
  double throttle_cmd() const;
  void set_throttle_cmd(double value);

  // optional double throttle_output = 7;
  bool has_throttle_output() const;
  void clear_throttle_output();
  static const int kThrottleOutputFieldNumber = 7;
  double throttle_output() const;
  void set_throttle_output(double value);

  // optional bool driver_override = 10;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 10;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool driver_activity = 11;
  bool has_driver_activity() const;
  void clear_driver_activity();
  static const int kDriverActivityFieldNumber = 11;
  bool driver_activity() const;
  void set_driver_activity(bool value);

  // optional bool watchdog_fault = 12;
  bool has_watchdog_fault() const;
  void clear_watchdog_fault();
  static const int kWatchdogFaultFieldNumber = 12;
  bool watchdog_fault() const;
  void set_watchdog_fault(bool value);

  // optional bool channel_1_fault = 13;
  bool has_channel_1_fault() const;
  void clear_channel_1_fault();
  static const int kChannel1FaultFieldNumber = 13;
  bool channel_1_fault() const;
  void set_channel_1_fault(bool value);

  // optional bool channel_2_fault = 14;
  bool has_channel_2_fault() const;
  void clear_channel_2_fault();
  static const int kChannel2FaultFieldNumber = 14;
  bool channel_2_fault() const;
  void set_channel_2_fault(bool value);

  // optional bool connector_fault = 15;
  bool has_connector_fault() const;
  void clear_connector_fault();
  static const int kConnectorFaultFieldNumber = 15;
  bool connector_fault() const;
  void set_connector_fault(bool value);

  // optional double accelerator_pedal = 16;
  bool has_accelerator_pedal() const;
  void clear_accelerator_pedal();
  static const int kAcceleratorPedalFieldNumber = 16;
  double accelerator_pedal() const;
  void set_accelerator_pedal(double value);

  // optional double accelerator_pedal_rate = 17;
  bool has_accelerator_pedal_rate() const;
  void clear_accelerator_pedal_rate();
  static const int kAcceleratorPedalRateFieldNumber = 17;
  double accelerator_pedal_rate() const;
  void set_accelerator_pedal_rate(double value);

  // optional int32 major_version = 18;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 18;
  ::google::protobuf::int32 major_version() const;
  void set_major_version(::google::protobuf::int32 value);

  // optional int32 minor_version = 19;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 19;
  ::google::protobuf::int32 minor_version() const;
  void set_minor_version(::google::protobuf::int32 value);

  // optional int32 build_number = 20;
  bool has_build_number() const;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 20;
  ::google::protobuf::int32 build_number() const;
  void set_build_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Gas)
 private:
  void set_has_is_gas_pedal_error();
  void clear_has_is_gas_pedal_error();
  void set_has_is_gas_pedal_pressed_more();
  void clear_has_is_gas_pedal_pressed_more();
  void set_has_gas_pedal_position();
  void clear_has_gas_pedal_position();
  void set_has_is_gas_valid();
  void clear_has_is_gas_valid();
  void set_has_throttle_input();
  void clear_has_throttle_input();
  void set_has_throttle_cmd();
  void clear_has_throttle_cmd();
  void set_has_throttle_output();
  void clear_has_throttle_output();
  void set_has_watchdog_source();
  void clear_has_watchdog_source();
  void set_has_throttle_enabled();
  void clear_has_throttle_enabled();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_driver_activity();
  void clear_has_driver_activity();
  void set_has_watchdog_fault();
  void clear_has_watchdog_fault();
  void set_has_channel_1_fault();
  void clear_has_channel_1_fault();
  void set_has_channel_2_fault();
  void clear_has_channel_2_fault();
  void set_has_connector_fault();
  void clear_has_connector_fault();
  void set_has_accelerator_pedal();
  void clear_has_accelerator_pedal();
  void set_has_accelerator_pedal_rate();
  void clear_has_accelerator_pedal_rate();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_build_number();
  void clear_has_build_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double gas_pedal_position_;
  bool is_gas_pedal_error_;
  bool is_gas_pedal_pressed_more_;
  bool is_gas_valid_;
  bool throttle_enabled_;
  ::google::protobuf::int32 watchdog_source_;
  double throttle_input_;
  double throttle_cmd_;
  double throttle_output_;
  bool driver_override_;
  bool driver_activity_;
  bool watchdog_fault_;
  bool channel_1_fault_;
  bool channel_2_fault_;
  bool connector_fault_;
  double accelerator_pedal_;
  double accelerator_pedal_rate_;
  ::google::protobuf::int32 major_version_;
  ::google::protobuf::int32 minor_version_;
  ::google::protobuf::int32 build_number_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Esp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Esp) */ {
 public:
  Esp();
  virtual ~Esp();

  Esp(const Esp& from);

  inline Esp& operator=(const Esp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Esp& default_instance();

  static inline const Esp* internal_default_instance() {
    return reinterpret_cast<const Esp*>(
               &_Esp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Esp* other);

  // implements Message ----------------------------------------------

  inline Esp* New() const PROTOBUF_FINAL { return New(NULL); }

  Esp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Esp& from);
  void MergeFrom(const Esp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Esp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_esp_acc_error = 1;
  bool has_is_esp_acc_error() const;
  void clear_is_esp_acc_error();
  static const int kIsEspAccErrorFieldNumber = 1;
  bool is_esp_acc_error() const;
  void set_is_esp_acc_error(bool value);

  // optional bool is_esp_on = 2;
  bool has_is_esp_on() const;
  void clear_is_esp_on();
  static const int kIsEspOnFieldNumber = 2;
  bool is_esp_on() const;
  void set_is_esp_on(bool value);

  // optional bool is_esp_active = 3;
  bool has_is_esp_active() const;
  void clear_is_esp_active();
  static const int kIsEspActiveFieldNumber = 3;
  bool is_esp_active() const;
  void set_is_esp_active(bool value);

  // optional bool is_abs_error = 4;
  bool has_is_abs_error() const;
  void clear_is_abs_error();
  static const int kIsAbsErrorFieldNumber = 4;
  bool is_abs_error() const;
  void set_is_abs_error(bool value);

  // optional bool is_abs_active = 5;
  bool has_is_abs_active() const;
  void clear_is_abs_active();
  static const int kIsAbsActiveFieldNumber = 5;
  bool is_abs_active() const;
  void set_is_abs_active(bool value);

  // optional bool is_tcsvdc_fail = 6;
  bool has_is_tcsvdc_fail() const;
  void clear_is_tcsvdc_fail();
  static const int kIsTcsvdcFailFieldNumber = 6;
  bool is_tcsvdc_fail() const;
  void set_is_tcsvdc_fail(bool value);

  // optional bool is_abs_enabled = 7;
  bool has_is_abs_enabled() const;
  void clear_is_abs_enabled();
  static const int kIsAbsEnabledFieldNumber = 7;
  bool is_abs_enabled() const;
  void set_is_abs_enabled(bool value);

  // optional bool is_stab_active = 8;
  bool has_is_stab_active() const;
  void clear_is_stab_active();
  static const int kIsStabActiveFieldNumber = 8;
  bool is_stab_active() const;
  void set_is_stab_active(bool value);

  // optional bool is_stab_enabled = 9;
  bool has_is_stab_enabled() const;
  void clear_is_stab_enabled();
  static const int kIsStabEnabledFieldNumber = 9;
  bool is_stab_enabled() const;
  void set_is_stab_enabled(bool value);

  // optional bool is_trac_active = 10;
  bool has_is_trac_active() const;
  void clear_is_trac_active();
  static const int kIsTracActiveFieldNumber = 10;
  bool is_trac_active() const;
  void set_is_trac_active(bool value);

  // optional bool is_trac_enabled = 11;
  bool has_is_trac_enabled() const;
  void clear_is_trac_enabled();
  static const int kIsTracEnabledFieldNumber = 11;
  bool is_trac_enabled() const;
  void set_is_trac_enabled(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Esp)
 private:
  void set_has_is_esp_acc_error();
  void clear_has_is_esp_acc_error();
  void set_has_is_esp_on();
  void clear_has_is_esp_on();
  void set_has_is_esp_active();
  void clear_has_is_esp_active();
  void set_has_is_abs_error();
  void clear_has_is_abs_error();
  void set_has_is_abs_active();
  void clear_has_is_abs_active();
  void set_has_is_tcsvdc_fail();
  void clear_has_is_tcsvdc_fail();
  void set_has_is_abs_enabled();
  void clear_has_is_abs_enabled();
  void set_has_is_stab_active();
  void clear_has_is_stab_active();
  void set_has_is_stab_enabled();
  void clear_has_is_stab_enabled();
  void set_has_is_trac_active();
  void clear_has_is_trac_active();
  void set_has_is_trac_enabled();
  void clear_has_is_trac_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_esp_acc_error_;
  bool is_esp_on_;
  bool is_esp_active_;
  bool is_abs_error_;
  bool is_abs_active_;
  bool is_tcsvdc_fail_;
  bool is_abs_enabled_;
  bool is_stab_active_;
  bool is_stab_enabled_;
  bool is_trac_active_;
  bool is_trac_enabled_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ems : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Ems) */ {
 public:
  Ems();
  virtual ~Ems();

  Ems(const Ems& from);

  inline Ems& operator=(const Ems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ems& default_instance();

  static inline const Ems* internal_default_instance() {
    return reinterpret_cast<const Ems*>(
               &_Ems_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Ems* other);

  // implements Message ----------------------------------------------

  inline Ems* New() const PROTOBUF_FINAL { return New(NULL); }

  Ems* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ems& from);
  void MergeFrom(const Ems& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ems* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Ems_Type Type;
  static const Type STOP =
    Ems_Type_STOP;
  static const Type CRANK =
    Ems_Type_CRANK;
  static const Type RUNNING =
    Ems_Type_RUNNING;
  static const Type INVALID =
    Ems_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return Ems_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Ems_Type_Type_MIN;
  static const Type Type_MAX =
    Ems_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Ems_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Ems_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Ems_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Ems_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double max_engine_torq_percent = 4;
  bool has_max_engine_torq_percent() const;
  void clear_max_engine_torq_percent();
  static const int kMaxEngineTorqPercentFieldNumber = 4;
  double max_engine_torq_percent() const;
  void set_max_engine_torq_percent(double value);

  // optional .jmc_auto.canbus.Ems.Type engine_state = 3;
  bool has_engine_state() const;
  void clear_engine_state();
  static const int kEngineStateFieldNumber = 3;
  ::jmc_auto::canbus::Ems_Type engine_state() const;
  void set_engine_state(::jmc_auto::canbus::Ems_Type value);

  // optional bool is_engine_acc_available = 1;
  bool has_is_engine_acc_available() const;
  void clear_is_engine_acc_available();
  static const int kIsEngineAccAvailableFieldNumber = 1;
  bool is_engine_acc_available() const;
  void set_is_engine_acc_available(bool value);

  // optional bool is_engine_acc_error = 2;
  bool has_is_engine_acc_error() const;
  void clear_is_engine_acc_error();
  static const int kIsEngineAccErrorFieldNumber = 2;
  bool is_engine_acc_error() const;
  void set_is_engine_acc_error(bool value);

  // optional bool is_engine_speed_error = 7;
  bool has_is_engine_speed_error() const;
  void clear_is_engine_speed_error();
  static const int kIsEngineSpeedErrorFieldNumber = 7;
  bool is_engine_speed_error() const;
  void set_is_engine_speed_error(bool value);

  // optional bool is_over_engine_torque = 10;
  bool has_is_over_engine_torque() const;
  void clear_is_over_engine_torque();
  static const int kIsOverEngineTorqueFieldNumber = 10;
  bool is_over_engine_torque() const;
  void set_is_over_engine_torque(bool value);

  // optional double min_engine_torq_percent = 5;
  bool has_min_engine_torq_percent() const;
  void clear_min_engine_torq_percent();
  static const int kMinEngineTorqPercentFieldNumber = 5;
  double min_engine_torq_percent() const;
  void set_min_engine_torq_percent(double value);

  // optional int32 base_engine_torq_constant = 6;
  bool has_base_engine_torq_constant() const;
  void clear_base_engine_torq_constant();
  static const int kBaseEngineTorqConstantFieldNumber = 6;
  ::google::protobuf::int32 base_engine_torq_constant() const;
  void set_base_engine_torq_constant(::google::protobuf::int32 value);

  // optional int32 engine_torque = 9;
  bool has_engine_torque() const;
  void clear_engine_torque();
  static const int kEngineTorqueFieldNumber = 9;
  ::google::protobuf::int32 engine_torque() const;
  void set_engine_torque(::google::protobuf::int32 value);

  // optional double engine_speed = 8;
  bool has_engine_speed() const;
  void clear_engine_speed();
  static const int kEngineSpeedFieldNumber = 8;
  double engine_speed() const;
  void set_engine_speed(double value);

  // optional double engine_rpm = 11;
  bool has_engine_rpm() const;
  void clear_engine_rpm();
  static const int kEngineRpmFieldNumber = 11;
  double engine_rpm() const;
  void set_engine_rpm(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Ems)
 private:
  void set_has_is_engine_acc_available();
  void clear_has_is_engine_acc_available();
  void set_has_is_engine_acc_error();
  void clear_has_is_engine_acc_error();
  void set_has_engine_state();
  void clear_has_engine_state();
  void set_has_max_engine_torq_percent();
  void clear_has_max_engine_torq_percent();
  void set_has_min_engine_torq_percent();
  void clear_has_min_engine_torq_percent();
  void set_has_base_engine_torq_constant();
  void clear_has_base_engine_torq_constant();
  void set_has_is_engine_speed_error();
  void clear_has_is_engine_speed_error();
  void set_has_engine_speed();
  void clear_has_engine_speed();
  void set_has_engine_torque();
  void clear_has_engine_torque();
  void set_has_is_over_engine_torque();
  void clear_has_is_over_engine_torque();
  void set_has_engine_rpm();
  void clear_has_engine_rpm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_engine_torq_percent_;
  int engine_state_;
  bool is_engine_acc_available_;
  bool is_engine_acc_error_;
  bool is_engine_speed_error_;
  bool is_over_engine_torque_;
  double min_engine_torq_percent_;
  ::google::protobuf::int32 base_engine_torq_constant_;
  ::google::protobuf::int32 engine_torque_;
  double engine_speed_;
  double engine_rpm_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gear : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Gear) */ {
 public:
  Gear();
  virtual ~Gear();

  Gear(const Gear& from);

  inline Gear& operator=(const Gear& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gear& default_instance();

  static inline const Gear* internal_default_instance() {
    return reinterpret_cast<const Gear*>(
               &_Gear_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Gear* other);

  // implements Message ----------------------------------------------

  inline Gear* New() const PROTOBUF_FINAL { return New(NULL); }

  Gear* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gear& from);
  void MergeFrom(const Gear& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gear* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Chassis.GearPosition gear_state = 2;
  bool has_gear_state() const;
  void clear_gear_state();
  static const int kGearStateFieldNumber = 2;
  ::jmc_auto::canbus::Chassis_GearPosition gear_state() const;
  void set_gear_state(::jmc_auto::canbus::Chassis_GearPosition value);

  // optional bool is_shift_position_valid = 1;
  bool has_is_shift_position_valid() const;
  void clear_is_shift_position_valid();
  static const int kIsShiftPositionValidFieldNumber = 1;
  bool is_shift_position_valid() const;
  void set_is_shift_position_valid(bool value);

  // optional bool driver_override = 3;
  bool has_driver_override() const;
  void clear_driver_override();
  static const int kDriverOverrideFieldNumber = 3;
  bool driver_override() const;
  void set_driver_override(bool value);

  // optional bool canbus_fault = 5;
  bool has_canbus_fault() const;
  void clear_canbus_fault();
  static const int kCanbusFaultFieldNumber = 5;
  bool canbus_fault() const;
  void set_canbus_fault(bool value);

  // optional .jmc_auto.canbus.Chassis.GearPosition gear_cmd = 4;
  bool has_gear_cmd() const;
  void clear_gear_cmd();
  static const int kGearCmdFieldNumber = 4;
  ::jmc_auto::canbus::Chassis_GearPosition gear_cmd() const;
  void set_gear_cmd(::jmc_auto::canbus::Chassis_GearPosition value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Gear)
 private:
  void set_has_is_shift_position_valid();
  void clear_has_is_shift_position_valid();
  void set_has_gear_state();
  void clear_has_gear_state();
  void set_has_driver_override();
  void clear_has_driver_override();
  void set_has_gear_cmd();
  void clear_has_gear_cmd();
  void set_has_canbus_fault();
  void clear_has_canbus_fault();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int gear_state_;
  bool is_shift_position_valid_;
  bool driver_override_;
  bool canbus_fault_;
  int gear_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Safety : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Safety) */ {
 public:
  Safety();
  virtual ~Safety();

  Safety(const Safety& from);

  inline Safety& operator=(const Safety& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Safety& default_instance();

  static inline const Safety* internal_default_instance() {
    return reinterpret_cast<const Safety*>(
               &_Safety_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Safety* other);

  // implements Message ----------------------------------------------

  inline Safety* New() const PROTOBUF_FINAL { return New(NULL); }

  Safety* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Safety& from);
  void MergeFrom(const Safety& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Safety* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 emergency_button = 3;
  bool has_emergency_button() const;
  void clear_emergency_button();
  static const int kEmergencyButtonFieldNumber = 3;
  ::google::protobuf::int32 emergency_button() const;
  void set_emergency_button(::google::protobuf::int32 value);

  // optional bool is_driver_car_door_close = 1;
  bool has_is_driver_car_door_close() const;
  void clear_is_driver_car_door_close();
  static const int kIsDriverCarDoorCloseFieldNumber = 1;
  bool is_driver_car_door_close() const;
  void set_is_driver_car_door_close(bool value);

  // optional bool is_driver_buckled = 2;
  bool has_is_driver_buckled() const;
  void clear_is_driver_buckled();
  static const int kIsDriverBuckledFieldNumber = 2;
  bool is_driver_buckled() const;
  void set_is_driver_buckled(bool value);

  // optional bool has_error = 4 [default = false];
  bool has_has_error() const;
  void clear_has_error();
  static const int kHasErrorFieldNumber = 4;
  bool has_error() const;
  void set_has_error(bool value);

  // optional bool is_motor_invertor_fault = 5;
  bool has_is_motor_invertor_fault() const;
  void clear_is_motor_invertor_fault();
  static const int kIsMotorInvertorFaultFieldNumber = 5;
  bool is_motor_invertor_fault() const;
  void set_is_motor_invertor_fault(bool value);

  // optional bool is_system_fault = 6;
  bool has_is_system_fault() const;
  void clear_is_system_fault();
  static const int kIsSystemFaultFieldNumber = 6;
  bool is_system_fault() const;
  void set_is_system_fault(bool value);

  // optional bool is_power_battery_fault = 7;
  bool has_is_power_battery_fault() const;
  void clear_is_power_battery_fault();
  static const int kIsPowerBatteryFaultFieldNumber = 7;
  bool is_power_battery_fault() const;
  void set_is_power_battery_fault(bool value);

  // optional bool is_motor_invertor_over_temperature = 8;
  bool has_is_motor_invertor_over_temperature() const;
  void clear_is_motor_invertor_over_temperature();
  static const int kIsMotorInvertorOverTemperatureFieldNumber = 8;
  bool is_motor_invertor_over_temperature() const;
  void set_is_motor_invertor_over_temperature(bool value);

  // optional bool is_small_battery_charge_discharge_fault = 9;
  bool has_is_small_battery_charge_discharge_fault() const;
  void clear_is_small_battery_charge_discharge_fault();
  static const int kIsSmallBatteryChargeDischargeFaultFieldNumber = 9;
  bool is_small_battery_charge_discharge_fault() const;
  void set_is_small_battery_charge_discharge_fault(bool value);

  // optional int32 driving_mode = 10;
  bool has_driving_mode() const;
  void clear_driving_mode();
  static const int kDrivingModeFieldNumber = 10;
  ::google::protobuf::int32 driving_mode() const;
  void set_driving_mode(::google::protobuf::int32 value);

  // optional bool is_passenger_door_open = 11;
  bool has_is_passenger_door_open() const;
  void clear_is_passenger_door_open();
  static const int kIsPassengerDoorOpenFieldNumber = 11;
  bool is_passenger_door_open() const;
  void set_is_passenger_door_open(bool value);

  // optional bool is_rearleft_door_open = 12;
  bool has_is_rearleft_door_open() const;
  void clear_is_rearleft_door_open();
  static const int kIsRearleftDoorOpenFieldNumber = 12;
  bool is_rearleft_door_open() const;
  void set_is_rearleft_door_open(bool value);

  // optional bool is_rearright_door_open = 13;
  bool has_is_rearright_door_open() const;
  void clear_is_rearright_door_open();
  static const int kIsRearrightDoorOpenFieldNumber = 13;
  bool is_rearright_door_open() const;
  void set_is_rearright_door_open(bool value);

  // optional bool is_hood_open = 14;
  bool has_is_hood_open() const;
  void clear_is_hood_open();
  static const int kIsHoodOpenFieldNumber = 14;
  bool is_hood_open() const;
  void set_is_hood_open(bool value);

  // optional bool is_trunk_open = 15;
  bool has_is_trunk_open() const;
  void clear_is_trunk_open();
  static const int kIsTrunkOpenFieldNumber = 15;
  bool is_trunk_open() const;
  void set_is_trunk_open(bool value);

  // optional bool is_passenger_detected = 16;
  bool has_is_passenger_detected() const;
  void clear_is_passenger_detected();
  static const int kIsPassengerDetectedFieldNumber = 16;
  bool is_passenger_detected() const;
  void set_is_passenger_detected(bool value);

  // optional bool is_passenger_airbag_enabled = 17;
  bool has_is_passenger_airbag_enabled() const;
  void clear_is_passenger_airbag_enabled();
  static const int kIsPassengerAirbagEnabledFieldNumber = 17;
  bool is_passenger_airbag_enabled() const;
  void set_is_passenger_airbag_enabled(bool value);

  // optional bool is_passenger_buckled = 18;
  bool has_is_passenger_buckled() const;
  void clear_is_passenger_buckled();
  static const int kIsPassengerBuckledFieldNumber = 18;
  bool is_passenger_buckled() const;
  void set_is_passenger_buckled(bool value);

  // optional int32 front_left_tire_press = 19;
  bool has_front_left_tire_press() const;
  void clear_front_left_tire_press();
  static const int kFrontLeftTirePressFieldNumber = 19;
  ::google::protobuf::int32 front_left_tire_press() const;
  void set_front_left_tire_press(::google::protobuf::int32 value);

  // optional int32 front_right_tire_press = 20;
  bool has_front_right_tire_press() const;
  void clear_front_right_tire_press();
  static const int kFrontRightTirePressFieldNumber = 20;
  ::google::protobuf::int32 front_right_tire_press() const;
  void set_front_right_tire_press(::google::protobuf::int32 value);

  // optional int32 rear_left_tire_press = 21;
  bool has_rear_left_tire_press() const;
  void clear_rear_left_tire_press();
  static const int kRearLeftTirePressFieldNumber = 21;
  ::google::protobuf::int32 rear_left_tire_press() const;
  void set_rear_left_tire_press(::google::protobuf::int32 value);

  // optional int32 rear_right_tire_press = 22;
  bool has_rear_right_tire_press() const;
  void clear_rear_right_tire_press();
  static const int kRearRightTirePressFieldNumber = 22;
  ::google::protobuf::int32 rear_right_tire_press() const;
  void set_rear_right_tire_press(::google::protobuf::int32 value);

  // optional .jmc_auto.canbus.Chassis.DrivingMode car_driving_mode = 23;
  bool has_car_driving_mode() const;
  void clear_car_driving_mode();
  static const int kCarDrivingModeFieldNumber = 23;
  ::jmc_auto::canbus::Chassis_DrivingMode car_driving_mode() const;
  void set_car_driving_mode(::jmc_auto::canbus::Chassis_DrivingMode value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Safety)
 private:
  void set_has_is_driver_car_door_close();
  void clear_has_is_driver_car_door_close();
  void set_has_is_driver_buckled();
  void clear_has_is_driver_buckled();
  void set_has_emergency_button();
  void clear_has_emergency_button();
  void set_has_has_error();
  void clear_has_has_error();
  void set_has_is_motor_invertor_fault();
  void clear_has_is_motor_invertor_fault();
  void set_has_is_system_fault();
  void clear_has_is_system_fault();
  void set_has_is_power_battery_fault();
  void clear_has_is_power_battery_fault();
  void set_has_is_motor_invertor_over_temperature();
  void clear_has_is_motor_invertor_over_temperature();
  void set_has_is_small_battery_charge_discharge_fault();
  void clear_has_is_small_battery_charge_discharge_fault();
  void set_has_driving_mode();
  void clear_has_driving_mode();
  void set_has_is_passenger_door_open();
  void clear_has_is_passenger_door_open();
  void set_has_is_rearleft_door_open();
  void clear_has_is_rearleft_door_open();
  void set_has_is_rearright_door_open();
  void clear_has_is_rearright_door_open();
  void set_has_is_hood_open();
  void clear_has_is_hood_open();
  void set_has_is_trunk_open();
  void clear_has_is_trunk_open();
  void set_has_is_passenger_detected();
  void clear_has_is_passenger_detected();
  void set_has_is_passenger_airbag_enabled();
  void clear_has_is_passenger_airbag_enabled();
  void set_has_is_passenger_buckled();
  void clear_has_is_passenger_buckled();
  void set_has_front_left_tire_press();
  void clear_has_front_left_tire_press();
  void set_has_front_right_tire_press();
  void clear_has_front_right_tire_press();
  void set_has_rear_left_tire_press();
  void clear_has_rear_left_tire_press();
  void set_has_rear_right_tire_press();
  void clear_has_rear_right_tire_press();
  void set_has_car_driving_mode();
  void clear_has_car_driving_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 emergency_button_;
  bool is_driver_car_door_close_;
  bool is_driver_buckled_;
  bool has_error_;
  bool is_motor_invertor_fault_;
  bool is_system_fault_;
  bool is_power_battery_fault_;
  bool is_motor_invertor_over_temperature_;
  bool is_small_battery_charge_discharge_fault_;
  ::google::protobuf::int32 driving_mode_;
  bool is_passenger_door_open_;
  bool is_rearleft_door_open_;
  bool is_rearright_door_open_;
  bool is_hood_open_;
  bool is_trunk_open_;
  bool is_passenger_detected_;
  bool is_passenger_airbag_enabled_;
  bool is_passenger_buckled_;
  ::google::protobuf::int32 front_left_tire_press_;
  ::google::protobuf::int32 front_right_tire_press_;
  ::google::protobuf::int32 rear_left_tire_press_;
  ::google::protobuf::int32 rear_right_tire_press_;
  int car_driving_mode_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BasicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.BasicInfo) */ {
 public:
  BasicInfo();
  virtual ~BasicInfo();

  BasicInfo(const BasicInfo& from);

  inline BasicInfo& operator=(const BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicInfo& default_instance();

  static inline const BasicInfo* internal_default_instance() {
    return reinterpret_cast<const BasicInfo*>(
               &_BasicInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(BasicInfo* other);

  // implements Message ----------------------------------------------

  inline BasicInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BasicInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BasicInfo& from);
  void MergeFrom(const BasicInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BasicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BasicInfo_Type Type;
  static const Type OFF =
    BasicInfo_Type_OFF;
  static const Type ACC =
    BasicInfo_Type_ACC;
  static const Type ON =
    BasicInfo_Type_ON;
  static const Type START =
    BasicInfo_Type_START;
  static const Type INVALID =
    BasicInfo_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return BasicInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BasicInfo_Type_Type_MIN;
  static const Type Type_MAX =
    BasicInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BasicInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BasicInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BasicInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BasicInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.BasicInfo.Type power_state = 2;
  bool has_power_state() const;
  void clear_power_state();
  static const int kPowerStateFieldNumber = 2;
  ::jmc_auto::canbus::BasicInfo_Type power_state() const;
  void set_power_state(::jmc_auto::canbus::BasicInfo_Type value);

  // optional bool is_auto_mode = 1;
  bool has_is_auto_mode() const;
  void clear_is_auto_mode();
  static const int kIsAutoModeFieldNumber = 1;
  bool is_auto_mode() const;
  void set_is_auto_mode(bool value);

  // optional bool is_air_bag_deployed = 3;
  bool has_is_air_bag_deployed() const;
  void clear_is_air_bag_deployed();
  static const int kIsAirBagDeployedFieldNumber = 3;
  bool is_air_bag_deployed() const;
  void set_is_air_bag_deployed(bool value);

  // optional bool is_system_error = 6;
  bool has_is_system_error() const;
  void clear_is_system_error();
  static const int kIsSystemErrorFieldNumber = 6;
  bool is_system_error() const;
  void set_is_system_error(bool value);

  // optional bool is_human_interrupt = 7;
  bool has_is_human_interrupt() const;
  void clear_is_human_interrupt();
  static const int kIsHumanInterruptFieldNumber = 7;
  bool is_human_interrupt() const;
  void set_is_human_interrupt(bool value);

  // optional double odo_meter = 4;
  bool has_odo_meter() const;
  void clear_odo_meter();
  static const int kOdoMeterFieldNumber = 4;
  double odo_meter() const;
  void set_odo_meter(double value);

  // optional double drive_range = 5;
  bool has_drive_range() const;
  void clear_drive_range();
  static const int kDriveRangeFieldNumber = 5;
  double drive_range() const;
  void set_drive_range(double value);

  // optional bool acc_on_button = 8;
  bool has_acc_on_button() const;
  void clear_acc_on_button();
  static const int kAccOnButtonFieldNumber = 8;
  bool acc_on_button() const;
  void set_acc_on_button(bool value);

  // optional bool acc_off_button = 9;
  bool has_acc_off_button() const;
  void clear_acc_off_button();
  static const int kAccOffButtonFieldNumber = 9;
  bool acc_off_button() const;
  void set_acc_off_button(bool value);

  // optional bool acc_res_button = 10;
  bool has_acc_res_button() const;
  void clear_acc_res_button();
  static const int kAccResButtonFieldNumber = 10;
  bool acc_res_button() const;
  void set_acc_res_button(bool value);

  // optional bool acc_cancel_button = 11;
  bool has_acc_cancel_button() const;
  void clear_acc_cancel_button();
  static const int kAccCancelButtonFieldNumber = 11;
  bool acc_cancel_button() const;
  void set_acc_cancel_button(bool value);

  // optional bool acc_on_off_button = 12;
  bool has_acc_on_off_button() const;
  void clear_acc_on_off_button();
  static const int kAccOnOffButtonFieldNumber = 12;
  bool acc_on_off_button() const;
  void set_acc_on_off_button(bool value);

  // optional bool acc_res_cancel_button = 13;
  bool has_acc_res_cancel_button() const;
  void clear_acc_res_cancel_button();
  static const int kAccResCancelButtonFieldNumber = 13;
  bool acc_res_cancel_button() const;
  void set_acc_res_cancel_button(bool value);

  // optional bool acc_inc_spd_button = 14;
  bool has_acc_inc_spd_button() const;
  void clear_acc_inc_spd_button();
  static const int kAccIncSpdButtonFieldNumber = 14;
  bool acc_inc_spd_button() const;
  void set_acc_inc_spd_button(bool value);

  // optional bool acc_dec_spd_button = 15;
  bool has_acc_dec_spd_button() const;
  void clear_acc_dec_spd_button();
  static const int kAccDecSpdButtonFieldNumber = 15;
  bool acc_dec_spd_button() const;
  void set_acc_dec_spd_button(bool value);

  // optional bool acc_inc_gap_button = 16;
  bool has_acc_inc_gap_button() const;
  void clear_acc_inc_gap_button();
  static const int kAccIncGapButtonFieldNumber = 16;
  bool acc_inc_gap_button() const;
  void set_acc_inc_gap_button(bool value);

  // optional bool acc_dec_gap_button = 17;
  bool has_acc_dec_gap_button() const;
  void clear_acc_dec_gap_button();
  static const int kAccDecGapButtonFieldNumber = 17;
  bool acc_dec_gap_button() const;
  void set_acc_dec_gap_button(bool value);

  // optional bool lka_button = 18;
  bool has_lka_button() const;
  void clear_lka_button();
  static const int kLkaButtonFieldNumber = 18;
  bool lka_button() const;
  void set_lka_button(bool value);

  // optional bool canbus_fault = 19;
  bool has_canbus_fault() const;
  void clear_canbus_fault();
  static const int kCanbusFaultFieldNumber = 19;
  bool canbus_fault() const;
  void set_canbus_fault(bool value);

  // optional int32 year = 23;
  bool has_year() const;
  void clear_year();
  static const int kYearFieldNumber = 23;
  ::google::protobuf::int32 year() const;
  void set_year(::google::protobuf::int32 value);

  // optional double latitude = 20;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 20;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 21;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 21;
  double longitude() const;
  void set_longitude(double value);

  // optional int32 month = 24;
  bool has_month() const;
  void clear_month();
  static const int kMonthFieldNumber = 24;
  ::google::protobuf::int32 month() const;
  void set_month(::google::protobuf::int32 value);

  // optional int32 day = 25;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 25;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // optional int32 hours = 26;
  bool has_hours() const;
  void clear_hours();
  static const int kHoursFieldNumber = 26;
  ::google::protobuf::int32 hours() const;
  void set_hours(::google::protobuf::int32 value);

  // optional int32 minutes = 27;
  bool has_minutes() const;
  void clear_minutes();
  static const int kMinutesFieldNumber = 27;
  ::google::protobuf::int32 minutes() const;
  void set_minutes(::google::protobuf::int32 value);

  // optional int32 seconds = 28;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 28;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // optional bool gps_valid = 22;
  bool has_gps_valid() const;
  void clear_gps_valid();
  static const int kGpsValidFieldNumber = 22;
  bool gps_valid() const;
  void set_gps_valid(bool value);

  // optional bool is_gps_fault = 31;
  bool has_is_gps_fault() const;
  void clear_is_gps_fault();
  static const int kIsGpsFaultFieldNumber = 31;
  bool is_gps_fault() const;
  void set_is_gps_fault(bool value);

  // optional bool is_inferred = 32;
  bool has_is_inferred() const;
  void clear_is_inferred();
  static const int kIsInferredFieldNumber = 32;
  bool is_inferred() const;
  void set_is_inferred(bool value);

  // optional double compass_direction = 29;
  bool has_compass_direction() const;
  void clear_compass_direction();
  static const int kCompassDirectionFieldNumber = 29;
  double compass_direction() const;
  void set_compass_direction(double value);

  // optional double pdop = 30;
  bool has_pdop() const;
  void clear_pdop();
  static const int kPdopFieldNumber = 30;
  double pdop() const;
  void set_pdop(double value);

  // optional double altitude = 33;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 33;
  double altitude() const;
  void set_altitude(double value);

  // optional double heading = 34;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 34;
  double heading() const;
  void set_heading(double value);

  // optional double hdop = 35;
  bool has_hdop() const;
  void clear_hdop();
  static const int kHdopFieldNumber = 35;
  double hdop() const;
  void set_hdop(double value);

  // optional double vdop = 36;
  bool has_vdop() const;
  void clear_vdop();
  static const int kVdopFieldNumber = 36;
  double vdop() const;
  void set_vdop(double value);

  // optional .jmc_auto.canbus.GpsQuality quality = 37;
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 37;
  ::jmc_auto::canbus::GpsQuality quality() const;
  void set_quality(::jmc_auto::canbus::GpsQuality value);

  // optional int32 num_satellites = 38;
  bool has_num_satellites() const;
  void clear_num_satellites();
  static const int kNumSatellitesFieldNumber = 38;
  ::google::protobuf::int32 num_satellites() const;
  void set_num_satellites(::google::protobuf::int32 value);

  // optional double gps_speed = 39;
  bool has_gps_speed() const;
  void clear_gps_speed();
  static const int kGpsSpeedFieldNumber = 39;
  double gps_speed() const;
  void set_gps_speed(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.BasicInfo)
 private:
  void set_has_is_auto_mode();
  void clear_has_is_auto_mode();
  void set_has_power_state();
  void clear_has_power_state();
  void set_has_is_air_bag_deployed();
  void clear_has_is_air_bag_deployed();
  void set_has_odo_meter();
  void clear_has_odo_meter();
  void set_has_drive_range();
  void clear_has_drive_range();
  void set_has_is_system_error();
  void clear_has_is_system_error();
  void set_has_is_human_interrupt();
  void clear_has_is_human_interrupt();
  void set_has_acc_on_button();
  void clear_has_acc_on_button();
  void set_has_acc_off_button();
  void clear_has_acc_off_button();
  void set_has_acc_res_button();
  void clear_has_acc_res_button();
  void set_has_acc_cancel_button();
  void clear_has_acc_cancel_button();
  void set_has_acc_on_off_button();
  void clear_has_acc_on_off_button();
  void set_has_acc_res_cancel_button();
  void clear_has_acc_res_cancel_button();
  void set_has_acc_inc_spd_button();
  void clear_has_acc_inc_spd_button();
  void set_has_acc_dec_spd_button();
  void clear_has_acc_dec_spd_button();
  void set_has_acc_inc_gap_button();
  void clear_has_acc_inc_gap_button();
  void set_has_acc_dec_gap_button();
  void clear_has_acc_dec_gap_button();
  void set_has_lka_button();
  void clear_has_lka_button();
  void set_has_canbus_fault();
  void clear_has_canbus_fault();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_gps_valid();
  void clear_has_gps_valid();
  void set_has_year();
  void clear_has_year();
  void set_has_month();
  void clear_has_month();
  void set_has_day();
  void clear_has_day();
  void set_has_hours();
  void clear_has_hours();
  void set_has_minutes();
  void clear_has_minutes();
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_compass_direction();
  void clear_has_compass_direction();
  void set_has_pdop();
  void clear_has_pdop();
  void set_has_is_gps_fault();
  void clear_has_is_gps_fault();
  void set_has_is_inferred();
  void clear_has_is_inferred();
  void set_has_altitude();
  void clear_has_altitude();
  void set_has_heading();
  void clear_has_heading();
  void set_has_hdop();
  void clear_has_hdop();
  void set_has_vdop();
  void clear_has_vdop();
  void set_has_quality();
  void clear_has_quality();
  void set_has_num_satellites();
  void clear_has_num_satellites();
  void set_has_gps_speed();
  void clear_has_gps_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  int power_state_;
  bool is_auto_mode_;
  bool is_air_bag_deployed_;
  bool is_system_error_;
  bool is_human_interrupt_;
  double odo_meter_;
  double drive_range_;
  bool acc_on_button_;
  bool acc_off_button_;
  bool acc_res_button_;
  bool acc_cancel_button_;
  bool acc_on_off_button_;
  bool acc_res_cancel_button_;
  bool acc_inc_spd_button_;
  bool acc_dec_spd_button_;
  bool acc_inc_gap_button_;
  bool acc_dec_gap_button_;
  bool lka_button_;
  bool canbus_fault_;
  ::google::protobuf::int32 year_;
  double latitude_;
  double longitude_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 hours_;
  ::google::protobuf::int32 minutes_;
  ::google::protobuf::int32 seconds_;
  bool gps_valid_;
  bool is_gps_fault_;
  bool is_inferred_;
  double compass_direction_;
  double pdop_;
  double altitude_;
  double heading_;
  double hdop_;
  double vdop_;
  int quality_;
  ::google::protobuf::int32 num_satellites_;
  double gps_speed_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Global_rpt_6a : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Global_rpt_6a) */ {
 public:
  Global_rpt_6a();
  virtual ~Global_rpt_6a();

  Global_rpt_6a(const Global_rpt_6a& from);

  inline Global_rpt_6a& operator=(const Global_rpt_6a& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Global_rpt_6a& default_instance();

  static inline const Global_rpt_6a* internal_default_instance() {
    return reinterpret_cast<const Global_rpt_6a*>(
               &_Global_rpt_6a_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Global_rpt_6a* other);

  // implements Message ----------------------------------------------

  inline Global_rpt_6a* New() const PROTOBUF_FINAL { return New(NULL); }

  Global_rpt_6a* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Global_rpt_6a& from);
  void MergeFrom(const Global_rpt_6a& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Global_rpt_6a* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Global_rpt_6a_Pacmod_statusType Pacmod_statusType;
  static const Pacmod_statusType PACMOD_STATUS_CONTROL_DISABLED =
    Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_DISABLED;
  static const Pacmod_statusType PACMOD_STATUS_CONTROL_ENABLED =
    Global_rpt_6a_Pacmod_statusType_PACMOD_STATUS_CONTROL_ENABLED;
  static inline bool Pacmod_statusType_IsValid(int value) {
    return Global_rpt_6a_Pacmod_statusType_IsValid(value);
  }
  static const Pacmod_statusType Pacmod_statusType_MIN =
    Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MIN;
  static const Pacmod_statusType Pacmod_statusType_MAX =
    Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_MAX;
  static const int Pacmod_statusType_ARRAYSIZE =
    Global_rpt_6a_Pacmod_statusType_Pacmod_statusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Pacmod_statusType_descriptor() {
    return Global_rpt_6a_Pacmod_statusType_descriptor();
  }
  static inline const ::std::string& Pacmod_statusType_Name(Pacmod_statusType value) {
    return Global_rpt_6a_Pacmod_statusType_Name(value);
  }
  static inline bool Pacmod_statusType_Parse(const ::std::string& name,
      Pacmod_statusType* value) {
    return Global_rpt_6a_Pacmod_statusType_Parse(name, value);
  }

  typedef Global_rpt_6a_Override_statusType Override_statusType;
  static const Override_statusType OVERRIDE_STATUS_NOT_OVERRIDDEN =
    Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_NOT_OVERRIDDEN;
  static const Override_statusType OVERRIDE_STATUS_OVERRIDDEN =
    Global_rpt_6a_Override_statusType_OVERRIDE_STATUS_OVERRIDDEN;
  static inline bool Override_statusType_IsValid(int value) {
    return Global_rpt_6a_Override_statusType_IsValid(value);
  }
  static const Override_statusType Override_statusType_MIN =
    Global_rpt_6a_Override_statusType_Override_statusType_MIN;
  static const Override_statusType Override_statusType_MAX =
    Global_rpt_6a_Override_statusType_Override_statusType_MAX;
  static const int Override_statusType_ARRAYSIZE =
    Global_rpt_6a_Override_statusType_Override_statusType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Override_statusType_descriptor() {
    return Global_rpt_6a_Override_statusType_descriptor();
  }
  static inline const ::std::string& Override_statusType_Name(Override_statusType value) {
    return Global_rpt_6a_Override_statusType_Name(value);
  }
  static inline bool Override_statusType_Parse(const ::std::string& name,
      Override_statusType* value) {
    return Global_rpt_6a_Override_statusType_Parse(name, value);
  }

  typedef Global_rpt_6a_Brk_can_timeoutType Brk_can_timeoutType;
  static const Brk_can_timeoutType BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT =
    Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_NO_ACTIVE_CAN_TIMEOUT;
  static const Brk_can_timeoutType BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT =
    Global_rpt_6a_Brk_can_timeoutType_BRK_CAN_TIMEOUT_ACTIVE_CAN_TIMEOUT;
  static inline bool Brk_can_timeoutType_IsValid(int value) {
    return Global_rpt_6a_Brk_can_timeoutType_IsValid(value);
  }
  static const Brk_can_timeoutType Brk_can_timeoutType_MIN =
    Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MIN;
  static const Brk_can_timeoutType Brk_can_timeoutType_MAX =
    Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_MAX;
  static const int Brk_can_timeoutType_ARRAYSIZE =
    Global_rpt_6a_Brk_can_timeoutType_Brk_can_timeoutType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brk_can_timeoutType_descriptor() {
    return Global_rpt_6a_Brk_can_timeoutType_descriptor();
  }
  static inline const ::std::string& Brk_can_timeoutType_Name(Brk_can_timeoutType value) {
    return Global_rpt_6a_Brk_can_timeoutType_Name(value);
  }
  static inline bool Brk_can_timeoutType_Parse(const ::std::string& name,
      Brk_can_timeoutType* value) {
    return Global_rpt_6a_Brk_can_timeoutType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Global_rpt_6a.Pacmod_statusType pacmod_status = 1;
  bool has_pacmod_status() const;
  void clear_pacmod_status();
  static const int kPacmodStatusFieldNumber = 1;
  ::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType pacmod_status() const;
  void set_pacmod_status(::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType value);

  // optional .jmc_auto.canbus.Global_rpt_6a.Override_statusType override_status = 2;
  bool has_override_status() const;
  void clear_override_status();
  static const int kOverrideStatusFieldNumber = 2;
  ::jmc_auto::canbus::Global_rpt_6a_Override_statusType override_status() const;
  void set_override_status(::jmc_auto::canbus::Global_rpt_6a_Override_statusType value);

  // optional bool veh_can_timeout = 3;
  bool has_veh_can_timeout() const;
  void clear_veh_can_timeout();
  static const int kVehCanTimeoutFieldNumber = 3;
  bool veh_can_timeout() const;
  void set_veh_can_timeout(bool value);

  // optional bool str_can_timeout = 4;
  bool has_str_can_timeout() const;
  void clear_str_can_timeout();
  static const int kStrCanTimeoutFieldNumber = 4;
  bool str_can_timeout() const;
  void set_str_can_timeout(bool value);

  // optional bool usr_can_timeout = 6;
  bool has_usr_can_timeout() const;
  void clear_usr_can_timeout();
  static const int kUsrCanTimeoutFieldNumber = 6;
  bool usr_can_timeout() const;
  void set_usr_can_timeout(bool value);

  // optional .jmc_auto.canbus.Global_rpt_6a.Brk_can_timeoutType brk_can_timeout = 5;
  bool has_brk_can_timeout() const;
  void clear_brk_can_timeout();
  static const int kBrkCanTimeoutFieldNumber = 5;
  ::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType brk_can_timeout() const;
  void set_brk_can_timeout(::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType value);

  // optional int32 usr_can_read_errors = 7;
  bool has_usr_can_read_errors() const;
  void clear_usr_can_read_errors();
  static const int kUsrCanReadErrorsFieldNumber = 7;
  ::google::protobuf::int32 usr_can_read_errors() const;
  void set_usr_can_read_errors(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Global_rpt_6a)
 private:
  void set_has_pacmod_status();
  void clear_has_pacmod_status();
  void set_has_override_status();
  void clear_has_override_status();
  void set_has_veh_can_timeout();
  void clear_has_veh_can_timeout();
  void set_has_str_can_timeout();
  void clear_has_str_can_timeout();
  void set_has_brk_can_timeout();
  void clear_has_brk_can_timeout();
  void set_has_usr_can_timeout();
  void clear_has_usr_can_timeout();
  void set_has_usr_can_read_errors();
  void clear_has_usr_can_read_errors();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int pacmod_status_;
  int override_status_;
  bool veh_can_timeout_;
  bool str_can_timeout_;
  bool usr_can_timeout_;
  int brk_can_timeout_;
  ::google::protobuf::int32 usr_can_read_errors_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake_cmd_6b : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Brake_cmd_6b) */ {
 public:
  Brake_cmd_6b();
  virtual ~Brake_cmd_6b();

  Brake_cmd_6b(const Brake_cmd_6b& from);

  inline Brake_cmd_6b& operator=(const Brake_cmd_6b& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake_cmd_6b& default_instance();

  static inline const Brake_cmd_6b* internal_default_instance() {
    return reinterpret_cast<const Brake_cmd_6b*>(
               &_Brake_cmd_6b_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Brake_cmd_6b* other);

  // implements Message ----------------------------------------------

  inline Brake_cmd_6b* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake_cmd_6b* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake_cmd_6b& from);
  void MergeFrom(const Brake_cmd_6b& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake_cmd_6b* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double brake_cmd = 1;
  bool has_brake_cmd() const;
  void clear_brake_cmd();
  static const int kBrakeCmdFieldNumber = 1;
  double brake_cmd() const;
  void set_brake_cmd(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Brake_cmd_6b)
 private:
  void set_has_brake_cmd();
  void clear_has_brake_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double brake_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake_rpt_6c : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Brake_rpt_6c) */ {
 public:
  Brake_rpt_6c();
  virtual ~Brake_rpt_6c();

  Brake_rpt_6c(const Brake_rpt_6c& from);

  inline Brake_rpt_6c& operator=(const Brake_rpt_6c& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake_rpt_6c& default_instance();

  static inline const Brake_rpt_6c* internal_default_instance() {
    return reinterpret_cast<const Brake_rpt_6c*>(
               &_Brake_rpt_6c_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Brake_rpt_6c* other);

  // implements Message ----------------------------------------------

  inline Brake_rpt_6c* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake_rpt_6c* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake_rpt_6c& from);
  void MergeFrom(const Brake_rpt_6c& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake_rpt_6c* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Brake_rpt_6c_Brake_on_offType Brake_on_offType;
  static const Brake_on_offType BRAKE_ON_OFF_OFF =
    Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_OFF;
  static const Brake_on_offType BRAKE_ON_OFF_ON =
    Brake_rpt_6c_Brake_on_offType_BRAKE_ON_OFF_ON;
  static inline bool Brake_on_offType_IsValid(int value) {
    return Brake_rpt_6c_Brake_on_offType_IsValid(value);
  }
  static const Brake_on_offType Brake_on_offType_MIN =
    Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MIN;
  static const Brake_on_offType Brake_on_offType_MAX =
    Brake_rpt_6c_Brake_on_offType_Brake_on_offType_MAX;
  static const int Brake_on_offType_ARRAYSIZE =
    Brake_rpt_6c_Brake_on_offType_Brake_on_offType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brake_on_offType_descriptor() {
    return Brake_rpt_6c_Brake_on_offType_descriptor();
  }
  static inline const ::std::string& Brake_on_offType_Name(Brake_on_offType value) {
    return Brake_rpt_6c_Brake_on_offType_Name(value);
  }
  static inline bool Brake_on_offType_Parse(const ::std::string& name,
      Brake_on_offType* value) {
    return Brake_rpt_6c_Brake_on_offType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double manual_input = 1;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 1;
  double manual_input() const;
  void set_manual_input(double value);

  // optional double commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  double commanded_value() const;
  void set_commanded_value(double value);

  // optional double output_value = 3;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 3;
  double output_value() const;
  void set_output_value(double value);

  // optional .jmc_auto.canbus.Brake_rpt_6c.Brake_on_offType brake_on_off = 4;
  bool has_brake_on_off() const;
  void clear_brake_on_off();
  static const int kBrakeOnOffFieldNumber = 4;
  ::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType brake_on_off() const;
  void set_brake_on_off(::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Brake_rpt_6c)
 private:
  void set_has_manual_input();
  void clear_has_manual_input();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_output_value();
  void clear_has_output_value();
  void set_has_brake_on_off();
  void clear_has_brake_on_off();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double manual_input_;
  double commanded_value_;
  double output_value_;
  int brake_on_off_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Steering_cmd_6d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Steering_cmd_6d) */ {
 public:
  Steering_cmd_6d();
  virtual ~Steering_cmd_6d();

  Steering_cmd_6d(const Steering_cmd_6d& from);

  inline Steering_cmd_6d& operator=(const Steering_cmd_6d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Steering_cmd_6d& default_instance();

  static inline const Steering_cmd_6d* internal_default_instance() {
    return reinterpret_cast<const Steering_cmd_6d*>(
               &_Steering_cmd_6d_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Steering_cmd_6d* other);

  // implements Message ----------------------------------------------

  inline Steering_cmd_6d* New() const PROTOBUF_FINAL { return New(NULL); }

  Steering_cmd_6d* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Steering_cmd_6d& from);
  void MergeFrom(const Steering_cmd_6d& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Steering_cmd_6d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double position_value = 1;
  bool has_position_value() const;
  void clear_position_value();
  static const int kPositionValueFieldNumber = 1;
  double position_value() const;
  void set_position_value(double value);

  // optional double speed_limit = 2;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 2;
  double speed_limit() const;
  void set_speed_limit(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Steering_cmd_6d)
 private:
  void set_has_position_value();
  void clear_has_position_value();
  void set_has_speed_limit();
  void clear_has_speed_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double position_value_;
  double speed_limit_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Steering_rpt_1_6e : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Steering_rpt_1_6e) */ {
 public:
  Steering_rpt_1_6e();
  virtual ~Steering_rpt_1_6e();

  Steering_rpt_1_6e(const Steering_rpt_1_6e& from);

  inline Steering_rpt_1_6e& operator=(const Steering_rpt_1_6e& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Steering_rpt_1_6e& default_instance();

  static inline const Steering_rpt_1_6e* internal_default_instance() {
    return reinterpret_cast<const Steering_rpt_1_6e*>(
               &_Steering_rpt_1_6e_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Steering_rpt_1_6e* other);

  // implements Message ----------------------------------------------

  inline Steering_rpt_1_6e* New() const PROTOBUF_FINAL { return New(NULL); }

  Steering_rpt_1_6e* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Steering_rpt_1_6e& from);
  void MergeFrom(const Steering_rpt_1_6e& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Steering_rpt_1_6e* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double manual_input = 1;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 1;
  double manual_input() const;
  void set_manual_input(double value);

  // optional double commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  double commanded_value() const;
  void set_commanded_value(double value);

  // optional double output_value = 3;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 3;
  double output_value() const;
  void set_output_value(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Steering_rpt_1_6e)
 private:
  void set_has_manual_input();
  void clear_has_manual_input();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_output_value();
  void clear_has_output_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double manual_input_;
  double commanded_value_;
  double output_value_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Wheel_speed_rpt_7a : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Wheel_speed_rpt_7a) */ {
 public:
  Wheel_speed_rpt_7a();
  virtual ~Wheel_speed_rpt_7a();

  Wheel_speed_rpt_7a(const Wheel_speed_rpt_7a& from);

  inline Wheel_speed_rpt_7a& operator=(const Wheel_speed_rpt_7a& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wheel_speed_rpt_7a& default_instance();

  static inline const Wheel_speed_rpt_7a* internal_default_instance() {
    return reinterpret_cast<const Wheel_speed_rpt_7a*>(
               &_Wheel_speed_rpt_7a_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Wheel_speed_rpt_7a* other);

  // implements Message ----------------------------------------------

  inline Wheel_speed_rpt_7a* New() const PROTOBUF_FINAL { return New(NULL); }

  Wheel_speed_rpt_7a* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Wheel_speed_rpt_7a& from);
  void MergeFrom(const Wheel_speed_rpt_7a& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Wheel_speed_rpt_7a* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 wheel_spd_rear_right = 1;
  bool has_wheel_spd_rear_right() const;
  void clear_wheel_spd_rear_right();
  static const int kWheelSpdRearRightFieldNumber = 1;
  ::google::protobuf::int32 wheel_spd_rear_right() const;
  void set_wheel_spd_rear_right(::google::protobuf::int32 value);

  // optional int32 wheel_spd_rear_left = 2;
  bool has_wheel_spd_rear_left() const;
  void clear_wheel_spd_rear_left();
  static const int kWheelSpdRearLeftFieldNumber = 2;
  ::google::protobuf::int32 wheel_spd_rear_left() const;
  void set_wheel_spd_rear_left(::google::protobuf::int32 value);

  // optional int32 wheel_spd_front_right = 3;
  bool has_wheel_spd_front_right() const;
  void clear_wheel_spd_front_right();
  static const int kWheelSpdFrontRightFieldNumber = 3;
  ::google::protobuf::int32 wheel_spd_front_right() const;
  void set_wheel_spd_front_right(::google::protobuf::int32 value);

  // optional int32 wheel_spd_front_left = 4;
  bool has_wheel_spd_front_left() const;
  void clear_wheel_spd_front_left();
  static const int kWheelSpdFrontLeftFieldNumber = 4;
  ::google::protobuf::int32 wheel_spd_front_left() const;
  void set_wheel_spd_front_left(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Wheel_speed_rpt_7a)
 private:
  void set_has_wheel_spd_rear_right();
  void clear_has_wheel_spd_rear_right();
  void set_has_wheel_spd_rear_left();
  void clear_has_wheel_spd_rear_left();
  void set_has_wheel_spd_front_right();
  void clear_has_wheel_spd_front_right();
  void set_has_wheel_spd_front_left();
  void clear_has_wheel_spd_front_left();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 wheel_spd_rear_right_;
  ::google::protobuf::int32 wheel_spd_rear_left_;
  ::google::protobuf::int32 wheel_spd_front_right_;
  ::google::protobuf::int32 wheel_spd_front_left_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Date_time_rpt_83 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Date_time_rpt_83) */ {
 public:
  Date_time_rpt_83();
  virtual ~Date_time_rpt_83();

  Date_time_rpt_83(const Date_time_rpt_83& from);

  inline Date_time_rpt_83& operator=(const Date_time_rpt_83& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Date_time_rpt_83& default_instance();

  static inline const Date_time_rpt_83* internal_default_instance() {
    return reinterpret_cast<const Date_time_rpt_83*>(
               &_Date_time_rpt_83_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Date_time_rpt_83* other);

  // implements Message ----------------------------------------------

  inline Date_time_rpt_83* New() const PROTOBUF_FINAL { return New(NULL); }

  Date_time_rpt_83* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Date_time_rpt_83& from);
  void MergeFrom(const Date_time_rpt_83& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Date_time_rpt_83* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 time_second = 1;
  bool has_time_second() const;
  void clear_time_second();
  static const int kTimeSecondFieldNumber = 1;
  ::google::protobuf::int32 time_second() const;
  void set_time_second(::google::protobuf::int32 value);

  // optional int32 time_minute = 2;
  bool has_time_minute() const;
  void clear_time_minute();
  static const int kTimeMinuteFieldNumber = 2;
  ::google::protobuf::int32 time_minute() const;
  void set_time_minute(::google::protobuf::int32 value);

  // optional int32 time_hour = 3;
  bool has_time_hour() const;
  void clear_time_hour();
  static const int kTimeHourFieldNumber = 3;
  ::google::protobuf::int32 time_hour() const;
  void set_time_hour(::google::protobuf::int32 value);

  // optional int32 date_day = 4;
  bool has_date_day() const;
  void clear_date_day();
  static const int kDateDayFieldNumber = 4;
  ::google::protobuf::int32 date_day() const;
  void set_date_day(::google::protobuf::int32 value);

  // optional int32 date_month = 5;
  bool has_date_month() const;
  void clear_date_month();
  static const int kDateMonthFieldNumber = 5;
  ::google::protobuf::int32 date_month() const;
  void set_date_month(::google::protobuf::int32 value);

  // optional int32 date_year = 6;
  bool has_date_year() const;
  void clear_date_year();
  static const int kDateYearFieldNumber = 6;
  ::google::protobuf::int32 date_year() const;
  void set_date_year(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Date_time_rpt_83)
 private:
  void set_has_time_second();
  void clear_has_time_second();
  void set_has_time_minute();
  void clear_has_time_minute();
  void set_has_time_hour();
  void clear_has_time_hour();
  void set_has_date_day();
  void clear_has_date_day();
  void set_has_date_month();
  void clear_has_date_month();
  void set_has_date_year();
  void clear_has_date_year();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 time_second_;
  ::google::protobuf::int32 time_minute_;
  ::google::protobuf::int32 time_hour_;
  ::google::protobuf::int32 date_day_;
  ::google::protobuf::int32 date_month_;
  ::google::protobuf::int32 date_year_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake_motor_rpt_1_70 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Brake_motor_rpt_1_70) */ {
 public:
  Brake_motor_rpt_1_70();
  virtual ~Brake_motor_rpt_1_70();

  Brake_motor_rpt_1_70(const Brake_motor_rpt_1_70& from);

  inline Brake_motor_rpt_1_70& operator=(const Brake_motor_rpt_1_70& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake_motor_rpt_1_70& default_instance();

  static inline const Brake_motor_rpt_1_70* internal_default_instance() {
    return reinterpret_cast<const Brake_motor_rpt_1_70*>(
               &_Brake_motor_rpt_1_70_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Brake_motor_rpt_1_70* other);

  // implements Message ----------------------------------------------

  inline Brake_motor_rpt_1_70* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake_motor_rpt_1_70* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake_motor_rpt_1_70& from);
  void MergeFrom(const Brake_motor_rpt_1_70& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake_motor_rpt_1_70* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double motor_current = 1;
  bool has_motor_current() const;
  void clear_motor_current();
  static const int kMotorCurrentFieldNumber = 1;
  double motor_current() const;
  void set_motor_current(double value);

  // optional double shaft_position = 2;
  bool has_shaft_position() const;
  void clear_shaft_position();
  static const int kShaftPositionFieldNumber = 2;
  double shaft_position() const;
  void set_shaft_position(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Brake_motor_rpt_1_70)
 private:
  void set_has_motor_current();
  void clear_has_motor_current();
  void set_has_shaft_position();
  void clear_has_shaft_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double motor_current_;
  double shaft_position_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Headlight_rpt_77 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Headlight_rpt_77) */ {
 public:
  Headlight_rpt_77();
  virtual ~Headlight_rpt_77();

  Headlight_rpt_77(const Headlight_rpt_77& from);

  inline Headlight_rpt_77& operator=(const Headlight_rpt_77& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Headlight_rpt_77& default_instance();

  static inline const Headlight_rpt_77* internal_default_instance() {
    return reinterpret_cast<const Headlight_rpt_77*>(
               &_Headlight_rpt_77_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Headlight_rpt_77* other);

  // implements Message ----------------------------------------------

  inline Headlight_rpt_77* New() const PROTOBUF_FINAL { return New(NULL); }

  Headlight_rpt_77* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Headlight_rpt_77& from);
  void MergeFrom(const Headlight_rpt_77& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Headlight_rpt_77* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Headlight_rpt_77_Output_valueType Output_valueType;
  static const Output_valueType OUTPUT_VALUE_HEADLIGHTS_OFF =
    Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HEADLIGHTS_OFF;
  static const Output_valueType OUTPUT_VALUE_LOW_BEAMS =
    Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_LOW_BEAMS;
  static const Output_valueType OUTPUT_VALUE_HIGH_BEAMS =
    Headlight_rpt_77_Output_valueType_OUTPUT_VALUE_HIGH_BEAMS;
  static inline bool Output_valueType_IsValid(int value) {
    return Headlight_rpt_77_Output_valueType_IsValid(value);
  }
  static const Output_valueType Output_valueType_MIN =
    Headlight_rpt_77_Output_valueType_Output_valueType_MIN;
  static const Output_valueType Output_valueType_MAX =
    Headlight_rpt_77_Output_valueType_Output_valueType_MAX;
  static const int Output_valueType_ARRAYSIZE =
    Headlight_rpt_77_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Output_valueType_descriptor() {
    return Headlight_rpt_77_Output_valueType_descriptor();
  }
  static inline const ::std::string& Output_valueType_Name(Output_valueType value) {
    return Headlight_rpt_77_Output_valueType_Name(value);
  }
  static inline bool Output_valueType_Parse(const ::std::string& name,
      Output_valueType* value) {
    return Headlight_rpt_77_Output_valueType_Parse(name, value);
  }

  typedef Headlight_rpt_77_Manual_inputType Manual_inputType;
  static const Manual_inputType MANUAL_INPUT_HEADLIGHTS_OFF =
    Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HEADLIGHTS_OFF;
  static const Manual_inputType MANUAL_INPUT_LOW_BEAMS =
    Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_LOW_BEAMS;
  static const Manual_inputType MANUAL_INPUT_HIGH_BEAMS =
    Headlight_rpt_77_Manual_inputType_MANUAL_INPUT_HIGH_BEAMS;
  static inline bool Manual_inputType_IsValid(int value) {
    return Headlight_rpt_77_Manual_inputType_IsValid(value);
  }
  static const Manual_inputType Manual_inputType_MIN =
    Headlight_rpt_77_Manual_inputType_Manual_inputType_MIN;
  static const Manual_inputType Manual_inputType_MAX =
    Headlight_rpt_77_Manual_inputType_Manual_inputType_MAX;
  static const int Manual_inputType_ARRAYSIZE =
    Headlight_rpt_77_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Headlight_rpt_77_Manual_inputType_descriptor();
  }
  static inline const ::std::string& Manual_inputType_Name(Manual_inputType value) {
    return Headlight_rpt_77_Manual_inputType_Name(value);
  }
  static inline bool Manual_inputType_Parse(const ::std::string& name,
      Manual_inputType* value) {
    return Headlight_rpt_77_Manual_inputType_Parse(name, value);
  }

  typedef Headlight_rpt_77_Commanded_valueType Commanded_valueType;
  static const Commanded_valueType COMMANDED_VALUE_HEADLIGHTS_OFF =
    Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HEADLIGHTS_OFF;
  static const Commanded_valueType COMMANDED_VALUE_LOW_BEAMS =
    Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_LOW_BEAMS;
  static const Commanded_valueType COMMANDED_VALUE_HIGH_BEAMS =
    Headlight_rpt_77_Commanded_valueType_COMMANDED_VALUE_HIGH_BEAMS;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Headlight_rpt_77_Commanded_valueType_IsValid(value);
  }
  static const Commanded_valueType Commanded_valueType_MIN =
    Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MIN;
  static const Commanded_valueType Commanded_valueType_MAX =
    Headlight_rpt_77_Commanded_valueType_Commanded_valueType_MAX;
  static const int Commanded_valueType_ARRAYSIZE =
    Headlight_rpt_77_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Headlight_rpt_77_Commanded_valueType_descriptor();
  }
  static inline const ::std::string& Commanded_valueType_Name(Commanded_valueType value) {
    return Headlight_rpt_77_Commanded_valueType_Name(value);
  }
  static inline bool Commanded_valueType_Parse(const ::std::string& name,
      Commanded_valueType* value) {
    return Headlight_rpt_77_Commanded_valueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Headlight_rpt_77.Output_valueType output_value = 1;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 1;
  ::jmc_auto::canbus::Headlight_rpt_77_Output_valueType output_value() const;
  void set_output_value(::jmc_auto::canbus::Headlight_rpt_77_Output_valueType value);

  // optional .jmc_auto.canbus.Headlight_rpt_77.Manual_inputType manual_input = 2;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 2;
  ::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType manual_input() const;
  void set_manual_input(::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType value);

  // optional .jmc_auto.canbus.Headlight_rpt_77.Commanded_valueType commanded_value = 3;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 3;
  ::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType commanded_value() const;
  void set_commanded_value(::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Headlight_rpt_77)
 private:
  void set_has_output_value();
  void clear_has_output_value();
  void set_has_manual_input();
  void clear_has_manual_input();
  void set_has_commanded_value();
  void clear_has_commanded_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int output_value_;
  int manual_input_;
  int commanded_value_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Accel_rpt_68 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Accel_rpt_68) */ {
 public:
  Accel_rpt_68();
  virtual ~Accel_rpt_68();

  Accel_rpt_68(const Accel_rpt_68& from);

  inline Accel_rpt_68& operator=(const Accel_rpt_68& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Accel_rpt_68& default_instance();

  static inline const Accel_rpt_68* internal_default_instance() {
    return reinterpret_cast<const Accel_rpt_68*>(
               &_Accel_rpt_68_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Accel_rpt_68* other);

  // implements Message ----------------------------------------------

  inline Accel_rpt_68* New() const PROTOBUF_FINAL { return New(NULL); }

  Accel_rpt_68* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Accel_rpt_68& from);
  void MergeFrom(const Accel_rpt_68& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Accel_rpt_68* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double manual_input = 1;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 1;
  double manual_input() const;
  void set_manual_input(double value);

  // optional double commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  double commanded_value() const;
  void set_commanded_value(double value);

  // optional double output_value = 3;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 3;
  double output_value() const;
  void set_output_value(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Accel_rpt_68)
 private:
  void set_has_manual_input();
  void clear_has_manual_input();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_output_value();
  void clear_has_output_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double manual_input_;
  double commanded_value_;
  double output_value_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Steering_motor_rpt_3_75 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Steering_motor_rpt_3_75) */ {
 public:
  Steering_motor_rpt_3_75();
  virtual ~Steering_motor_rpt_3_75();

  Steering_motor_rpt_3_75(const Steering_motor_rpt_3_75& from);

  inline Steering_motor_rpt_3_75& operator=(const Steering_motor_rpt_3_75& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Steering_motor_rpt_3_75& default_instance();

  static inline const Steering_motor_rpt_3_75* internal_default_instance() {
    return reinterpret_cast<const Steering_motor_rpt_3_75*>(
               &_Steering_motor_rpt_3_75_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Steering_motor_rpt_3_75* other);

  // implements Message ----------------------------------------------

  inline Steering_motor_rpt_3_75* New() const PROTOBUF_FINAL { return New(NULL); }

  Steering_motor_rpt_3_75* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Steering_motor_rpt_3_75& from);
  void MergeFrom(const Steering_motor_rpt_3_75& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Steering_motor_rpt_3_75* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double torque_output = 1;
  bool has_torque_output() const;
  void clear_torque_output();
  static const int kTorqueOutputFieldNumber = 1;
  double torque_output() const;
  void set_torque_output(double value);

  // optional double torque_input = 2;
  bool has_torque_input() const;
  void clear_torque_input();
  static const int kTorqueInputFieldNumber = 2;
  double torque_input() const;
  void set_torque_input(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Steering_motor_rpt_3_75)
 private:
  void set_has_torque_output();
  void clear_has_torque_output();
  void set_has_torque_input();
  void clear_has_torque_input();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double torque_output_;
  double torque_input_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Turn_cmd_63 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Turn_cmd_63) */ {
 public:
  Turn_cmd_63();
  virtual ~Turn_cmd_63();

  Turn_cmd_63(const Turn_cmd_63& from);

  inline Turn_cmd_63& operator=(const Turn_cmd_63& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Turn_cmd_63& default_instance();

  static inline const Turn_cmd_63* internal_default_instance() {
    return reinterpret_cast<const Turn_cmd_63*>(
               &_Turn_cmd_63_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Turn_cmd_63* other);

  // implements Message ----------------------------------------------

  inline Turn_cmd_63* New() const PROTOBUF_FINAL { return New(NULL); }

  Turn_cmd_63* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Turn_cmd_63& from);
  void MergeFrom(const Turn_cmd_63& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Turn_cmd_63* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Turn_cmd_63_Turn_signal_cmdType Turn_signal_cmdType;
  static const Turn_signal_cmdType TURN_SIGNAL_CMD_RIGHT =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_RIGHT;
  static const Turn_signal_cmdType TURN_SIGNAL_CMD_NONE =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_NONE;
  static const Turn_signal_cmdType TURN_SIGNAL_CMD_LEFT =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_LEFT;
  static const Turn_signal_cmdType TURN_SIGNAL_CMD_HAZARD =
    Turn_cmd_63_Turn_signal_cmdType_TURN_SIGNAL_CMD_HAZARD;
  static inline bool Turn_signal_cmdType_IsValid(int value) {
    return Turn_cmd_63_Turn_signal_cmdType_IsValid(value);
  }
  static const Turn_signal_cmdType Turn_signal_cmdType_MIN =
    Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MIN;
  static const Turn_signal_cmdType Turn_signal_cmdType_MAX =
    Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_MAX;
  static const int Turn_signal_cmdType_ARRAYSIZE =
    Turn_cmd_63_Turn_signal_cmdType_Turn_signal_cmdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Turn_signal_cmdType_descriptor() {
    return Turn_cmd_63_Turn_signal_cmdType_descriptor();
  }
  static inline const ::std::string& Turn_signal_cmdType_Name(Turn_signal_cmdType value) {
    return Turn_cmd_63_Turn_signal_cmdType_Name(value);
  }
  static inline bool Turn_signal_cmdType_Parse(const ::std::string& name,
      Turn_signal_cmdType* value) {
    return Turn_cmd_63_Turn_signal_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Turn_cmd_63.Turn_signal_cmdType turn_signal_cmd = 1;
  bool has_turn_signal_cmd() const;
  void clear_turn_signal_cmd();
  static const int kTurnSignalCmdFieldNumber = 1;
  ::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType turn_signal_cmd() const;
  void set_turn_signal_cmd(::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Turn_cmd_63)
 private:
  void set_has_turn_signal_cmd();
  void clear_has_turn_signal_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int turn_signal_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Turn_rpt_64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Turn_rpt_64) */ {
 public:
  Turn_rpt_64();
  virtual ~Turn_rpt_64();

  Turn_rpt_64(const Turn_rpt_64& from);

  inline Turn_rpt_64& operator=(const Turn_rpt_64& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Turn_rpt_64& default_instance();

  static inline const Turn_rpt_64* internal_default_instance() {
    return reinterpret_cast<const Turn_rpt_64*>(
               &_Turn_rpt_64_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Turn_rpt_64* other);

  // implements Message ----------------------------------------------

  inline Turn_rpt_64* New() const PROTOBUF_FINAL { return New(NULL); }

  Turn_rpt_64* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Turn_rpt_64& from);
  void MergeFrom(const Turn_rpt_64& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Turn_rpt_64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Turn_rpt_64_Manual_inputType Manual_inputType;
  static const Manual_inputType MANUAL_INPUT_RIGHT =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_RIGHT;
  static const Manual_inputType MANUAL_INPUT_NONE =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_NONE;
  static const Manual_inputType MANUAL_INPUT_LEFT =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_LEFT;
  static const Manual_inputType MANUAL_INPUT_HAZARD =
    Turn_rpt_64_Manual_inputType_MANUAL_INPUT_HAZARD;
  static inline bool Manual_inputType_IsValid(int value) {
    return Turn_rpt_64_Manual_inputType_IsValid(value);
  }
  static const Manual_inputType Manual_inputType_MIN =
    Turn_rpt_64_Manual_inputType_Manual_inputType_MIN;
  static const Manual_inputType Manual_inputType_MAX =
    Turn_rpt_64_Manual_inputType_Manual_inputType_MAX;
  static const int Manual_inputType_ARRAYSIZE =
    Turn_rpt_64_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Turn_rpt_64_Manual_inputType_descriptor();
  }
  static inline const ::std::string& Manual_inputType_Name(Manual_inputType value) {
    return Turn_rpt_64_Manual_inputType_Name(value);
  }
  static inline bool Manual_inputType_Parse(const ::std::string& name,
      Manual_inputType* value) {
    return Turn_rpt_64_Manual_inputType_Parse(name, value);
  }

  typedef Turn_rpt_64_Commanded_valueType Commanded_valueType;
  static const Commanded_valueType COMMANDED_VALUE_RIGHT =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_RIGHT;
  static const Commanded_valueType COMMANDED_VALUE_NONE =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_NONE;
  static const Commanded_valueType COMMANDED_VALUE_LEFT =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_LEFT;
  static const Commanded_valueType COMMANDED_VALUE_HAZARD =
    Turn_rpt_64_Commanded_valueType_COMMANDED_VALUE_HAZARD;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Turn_rpt_64_Commanded_valueType_IsValid(value);
  }
  static const Commanded_valueType Commanded_valueType_MIN =
    Turn_rpt_64_Commanded_valueType_Commanded_valueType_MIN;
  static const Commanded_valueType Commanded_valueType_MAX =
    Turn_rpt_64_Commanded_valueType_Commanded_valueType_MAX;
  static const int Commanded_valueType_ARRAYSIZE =
    Turn_rpt_64_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Turn_rpt_64_Commanded_valueType_descriptor();
  }
  static inline const ::std::string& Commanded_valueType_Name(Commanded_valueType value) {
    return Turn_rpt_64_Commanded_valueType_Name(value);
  }
  static inline bool Commanded_valueType_Parse(const ::std::string& name,
      Commanded_valueType* value) {
    return Turn_rpt_64_Commanded_valueType_Parse(name, value);
  }

  typedef Turn_rpt_64_Output_valueType Output_valueType;
  static const Output_valueType OUTPUT_VALUE_RIGHT =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_RIGHT;
  static const Output_valueType OUTPUT_VALUE_NONE =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_NONE;
  static const Output_valueType OUTPUT_VALUE_LEFT =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_LEFT;
  static const Output_valueType OUTPUT_VALUE_HAZARD =
    Turn_rpt_64_Output_valueType_OUTPUT_VALUE_HAZARD;
  static inline bool Output_valueType_IsValid(int value) {
    return Turn_rpt_64_Output_valueType_IsValid(value);
  }
  static const Output_valueType Output_valueType_MIN =
    Turn_rpt_64_Output_valueType_Output_valueType_MIN;
  static const Output_valueType Output_valueType_MAX =
    Turn_rpt_64_Output_valueType_Output_valueType_MAX;
  static const int Output_valueType_ARRAYSIZE =
    Turn_rpt_64_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Output_valueType_descriptor() {
    return Turn_rpt_64_Output_valueType_descriptor();
  }
  static inline const ::std::string& Output_valueType_Name(Output_valueType value) {
    return Turn_rpt_64_Output_valueType_Name(value);
  }
  static inline bool Output_valueType_Parse(const ::std::string& name,
      Output_valueType* value) {
    return Turn_rpt_64_Output_valueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Turn_rpt_64.Manual_inputType manual_input = 1;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 1;
  ::jmc_auto::canbus::Turn_rpt_64_Manual_inputType manual_input() const;
  void set_manual_input(::jmc_auto::canbus::Turn_rpt_64_Manual_inputType value);

  // optional .jmc_auto.canbus.Turn_rpt_64.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  ::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType commanded_value() const;
  void set_commanded_value(::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType value);

  // optional .jmc_auto.canbus.Turn_rpt_64.Output_valueType output_value = 3;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 3;
  ::jmc_auto::canbus::Turn_rpt_64_Output_valueType output_value() const;
  void set_output_value(::jmc_auto::canbus::Turn_rpt_64_Output_valueType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Turn_rpt_64)
 private:
  void set_has_manual_input();
  void clear_has_manual_input();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_output_value();
  void clear_has_output_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int manual_input_;
  int commanded_value_;
  int output_value_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shift_cmd_65 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Shift_cmd_65) */ {
 public:
  Shift_cmd_65();
  virtual ~Shift_cmd_65();

  Shift_cmd_65(const Shift_cmd_65& from);

  inline Shift_cmd_65& operator=(const Shift_cmd_65& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shift_cmd_65& default_instance();

  static inline const Shift_cmd_65* internal_default_instance() {
    return reinterpret_cast<const Shift_cmd_65*>(
               &_Shift_cmd_65_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Shift_cmd_65* other);

  // implements Message ----------------------------------------------

  inline Shift_cmd_65* New() const PROTOBUF_FINAL { return New(NULL); }

  Shift_cmd_65* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Shift_cmd_65& from);
  void MergeFrom(const Shift_cmd_65& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Shift_cmd_65* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Shift_cmd_65_Shift_cmdType Shift_cmdType;
  static const Shift_cmdType SHIFT_CMD_PARK =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_PARK;
  static const Shift_cmdType SHIFT_CMD_REVERSE =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_REVERSE;
  static const Shift_cmdType SHIFT_CMD_NEUTRAL =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_NEUTRAL;
  static const Shift_cmdType SHIFT_CMD_FORWARD =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_FORWARD;
  static const Shift_cmdType SHIFT_CMD_LOW =
    Shift_cmd_65_Shift_cmdType_SHIFT_CMD_LOW;
  static inline bool Shift_cmdType_IsValid(int value) {
    return Shift_cmd_65_Shift_cmdType_IsValid(value);
  }
  static const Shift_cmdType Shift_cmdType_MIN =
    Shift_cmd_65_Shift_cmdType_Shift_cmdType_MIN;
  static const Shift_cmdType Shift_cmdType_MAX =
    Shift_cmd_65_Shift_cmdType_Shift_cmdType_MAX;
  static const int Shift_cmdType_ARRAYSIZE =
    Shift_cmd_65_Shift_cmdType_Shift_cmdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Shift_cmdType_descriptor() {
    return Shift_cmd_65_Shift_cmdType_descriptor();
  }
  static inline const ::std::string& Shift_cmdType_Name(Shift_cmdType value) {
    return Shift_cmd_65_Shift_cmdType_Name(value);
  }
  static inline bool Shift_cmdType_Parse(const ::std::string& name,
      Shift_cmdType* value) {
    return Shift_cmd_65_Shift_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Shift_cmd_65.Shift_cmdType shift_cmd = 1;
  bool has_shift_cmd() const;
  void clear_shift_cmd();
  static const int kShiftCmdFieldNumber = 1;
  ::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType shift_cmd() const;
  void set_shift_cmd(::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Shift_cmd_65)
 private:
  void set_has_shift_cmd();
  void clear_has_shift_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int shift_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shift_rpt_66 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Shift_rpt_66) */ {
 public:
  Shift_rpt_66();
  virtual ~Shift_rpt_66();

  Shift_rpt_66(const Shift_rpt_66& from);

  inline Shift_rpt_66& operator=(const Shift_rpt_66& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shift_rpt_66& default_instance();

  static inline const Shift_rpt_66* internal_default_instance() {
    return reinterpret_cast<const Shift_rpt_66*>(
               &_Shift_rpt_66_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(Shift_rpt_66* other);

  // implements Message ----------------------------------------------

  inline Shift_rpt_66* New() const PROTOBUF_FINAL { return New(NULL); }

  Shift_rpt_66* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Shift_rpt_66& from);
  void MergeFrom(const Shift_rpt_66& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Shift_rpt_66* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Shift_rpt_66_Manual_inputType Manual_inputType;
  static const Manual_inputType MANUAL_INPUT_PARK =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_PARK;
  static const Manual_inputType MANUAL_INPUT_REVERSE =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_REVERSE;
  static const Manual_inputType MANUAL_INPUT_NEUTRAL =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_NEUTRAL;
  static const Manual_inputType MANUAL_INPUT_FORWARD =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_FORWARD;
  static const Manual_inputType MANUAL_INPUT_HIGH =
    Shift_rpt_66_Manual_inputType_MANUAL_INPUT_HIGH;
  static inline bool Manual_inputType_IsValid(int value) {
    return Shift_rpt_66_Manual_inputType_IsValid(value);
  }
  static const Manual_inputType Manual_inputType_MIN =
    Shift_rpt_66_Manual_inputType_Manual_inputType_MIN;
  static const Manual_inputType Manual_inputType_MAX =
    Shift_rpt_66_Manual_inputType_Manual_inputType_MAX;
  static const int Manual_inputType_ARRAYSIZE =
    Shift_rpt_66_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Shift_rpt_66_Manual_inputType_descriptor();
  }
  static inline const ::std::string& Manual_inputType_Name(Manual_inputType value) {
    return Shift_rpt_66_Manual_inputType_Name(value);
  }
  static inline bool Manual_inputType_Parse(const ::std::string& name,
      Manual_inputType* value) {
    return Shift_rpt_66_Manual_inputType_Parse(name, value);
  }

  typedef Shift_rpt_66_Commanded_valueType Commanded_valueType;
  static const Commanded_valueType COMMANDED_VALUE_PARK =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_PARK;
  static const Commanded_valueType COMMANDED_VALUE_REVERSE =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_REVERSE;
  static const Commanded_valueType COMMANDED_VALUE_NEUTRAL =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_NEUTRAL;
  static const Commanded_valueType COMMANDED_VALUE_FORWARD =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_FORWARD;
  static const Commanded_valueType COMMANDED_VALUE_HIGH =
    Shift_rpt_66_Commanded_valueType_COMMANDED_VALUE_HIGH;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Shift_rpt_66_Commanded_valueType_IsValid(value);
  }
  static const Commanded_valueType Commanded_valueType_MIN =
    Shift_rpt_66_Commanded_valueType_Commanded_valueType_MIN;
  static const Commanded_valueType Commanded_valueType_MAX =
    Shift_rpt_66_Commanded_valueType_Commanded_valueType_MAX;
  static const int Commanded_valueType_ARRAYSIZE =
    Shift_rpt_66_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Shift_rpt_66_Commanded_valueType_descriptor();
  }
  static inline const ::std::string& Commanded_valueType_Name(Commanded_valueType value) {
    return Shift_rpt_66_Commanded_valueType_Name(value);
  }
  static inline bool Commanded_valueType_Parse(const ::std::string& name,
      Commanded_valueType* value) {
    return Shift_rpt_66_Commanded_valueType_Parse(name, value);
  }

  typedef Shift_rpt_66_Output_valueType Output_valueType;
  static const Output_valueType OUTPUT_VALUE_PARK =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_PARK;
  static const Output_valueType OUTPUT_VALUE_REVERSE =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_REVERSE;
  static const Output_valueType OUTPUT_VALUE_NEUTRAL =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_NEUTRAL;
  static const Output_valueType OUTPUT_VALUE_FORWARD =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_FORWARD;
  static const Output_valueType OUTPUT_VALUE_HIGH =
    Shift_rpt_66_Output_valueType_OUTPUT_VALUE_HIGH;
  static inline bool Output_valueType_IsValid(int value) {
    return Shift_rpt_66_Output_valueType_IsValid(value);
  }
  static const Output_valueType Output_valueType_MIN =
    Shift_rpt_66_Output_valueType_Output_valueType_MIN;
  static const Output_valueType Output_valueType_MAX =
    Shift_rpt_66_Output_valueType_Output_valueType_MAX;
  static const int Output_valueType_ARRAYSIZE =
    Shift_rpt_66_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Output_valueType_descriptor() {
    return Shift_rpt_66_Output_valueType_descriptor();
  }
  static inline const ::std::string& Output_valueType_Name(Output_valueType value) {
    return Shift_rpt_66_Output_valueType_Name(value);
  }
  static inline bool Output_valueType_Parse(const ::std::string& name,
      Output_valueType* value) {
    return Shift_rpt_66_Output_valueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Shift_rpt_66.Manual_inputType manual_input = 1;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 1;
  ::jmc_auto::canbus::Shift_rpt_66_Manual_inputType manual_input() const;
  void set_manual_input(::jmc_auto::canbus::Shift_rpt_66_Manual_inputType value);

  // optional .jmc_auto.canbus.Shift_rpt_66.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  ::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType commanded_value() const;
  void set_commanded_value(::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType value);

  // optional .jmc_auto.canbus.Shift_rpt_66.Output_valueType output_value = 3;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 3;
  ::jmc_auto::canbus::Shift_rpt_66_Output_valueType output_value() const;
  void set_output_value(::jmc_auto::canbus::Shift_rpt_66_Output_valueType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Shift_rpt_66)
 private:
  void set_has_manual_input();
  void clear_has_manual_input();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_output_value();
  void clear_has_output_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int manual_input_;
  int commanded_value_;
  int output_value_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Accel_cmd_67 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Accel_cmd_67) */ {
 public:
  Accel_cmd_67();
  virtual ~Accel_cmd_67();

  Accel_cmd_67(const Accel_cmd_67& from);

  inline Accel_cmd_67& operator=(const Accel_cmd_67& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Accel_cmd_67& default_instance();

  static inline const Accel_cmd_67* internal_default_instance() {
    return reinterpret_cast<const Accel_cmd_67*>(
               &_Accel_cmd_67_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Accel_cmd_67* other);

  // implements Message ----------------------------------------------

  inline Accel_cmd_67* New() const PROTOBUF_FINAL { return New(NULL); }

  Accel_cmd_67* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Accel_cmd_67& from);
  void MergeFrom(const Accel_cmd_67& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Accel_cmd_67* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double accel_cmd = 1;
  bool has_accel_cmd() const;
  void clear_accel_cmd();
  static const int kAccelCmdFieldNumber = 1;
  double accel_cmd() const;
  void set_accel_cmd(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Accel_cmd_67)
 private:
  void set_has_accel_cmd();
  void clear_has_accel_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double accel_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lat_lon_heading_rpt_82 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Lat_lon_heading_rpt_82) */ {
 public:
  Lat_lon_heading_rpt_82();
  virtual ~Lat_lon_heading_rpt_82();

  Lat_lon_heading_rpt_82(const Lat_lon_heading_rpt_82& from);

  inline Lat_lon_heading_rpt_82& operator=(const Lat_lon_heading_rpt_82& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lat_lon_heading_rpt_82& default_instance();

  static inline const Lat_lon_heading_rpt_82* internal_default_instance() {
    return reinterpret_cast<const Lat_lon_heading_rpt_82*>(
               &_Lat_lon_heading_rpt_82_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Lat_lon_heading_rpt_82* other);

  // implements Message ----------------------------------------------

  inline Lat_lon_heading_rpt_82* New() const PROTOBUF_FINAL { return New(NULL); }

  Lat_lon_heading_rpt_82* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Lat_lon_heading_rpt_82& from);
  void MergeFrom(const Lat_lon_heading_rpt_82& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Lat_lon_heading_rpt_82* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double heading = 1;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 1;
  double heading() const;
  void set_heading(double value);

  // optional int32 longitude_seconds = 2;
  bool has_longitude_seconds() const;
  void clear_longitude_seconds();
  static const int kLongitudeSecondsFieldNumber = 2;
  ::google::protobuf::int32 longitude_seconds() const;
  void set_longitude_seconds(::google::protobuf::int32 value);

  // optional int32 longitude_minutes = 3;
  bool has_longitude_minutes() const;
  void clear_longitude_minutes();
  static const int kLongitudeMinutesFieldNumber = 3;
  ::google::protobuf::int32 longitude_minutes() const;
  void set_longitude_minutes(::google::protobuf::int32 value);

  // optional int32 longitude_degrees = 4;
  bool has_longitude_degrees() const;
  void clear_longitude_degrees();
  static const int kLongitudeDegreesFieldNumber = 4;
  ::google::protobuf::int32 longitude_degrees() const;
  void set_longitude_degrees(::google::protobuf::int32 value);

  // optional int32 latitude_seconds = 5;
  bool has_latitude_seconds() const;
  void clear_latitude_seconds();
  static const int kLatitudeSecondsFieldNumber = 5;
  ::google::protobuf::int32 latitude_seconds() const;
  void set_latitude_seconds(::google::protobuf::int32 value);

  // optional int32 latitude_minutes = 6;
  bool has_latitude_minutes() const;
  void clear_latitude_minutes();
  static const int kLatitudeMinutesFieldNumber = 6;
  ::google::protobuf::int32 latitude_minutes() const;
  void set_latitude_minutes(::google::protobuf::int32 value);

  // optional int32 latitude_degrees = 7;
  bool has_latitude_degrees() const;
  void clear_latitude_degrees();
  static const int kLatitudeDegreesFieldNumber = 7;
  ::google::protobuf::int32 latitude_degrees() const;
  void set_latitude_degrees(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Lat_lon_heading_rpt_82)
 private:
  void set_has_heading();
  void clear_has_heading();
  void set_has_longitude_seconds();
  void clear_has_longitude_seconds();
  void set_has_longitude_minutes();
  void clear_has_longitude_minutes();
  void set_has_longitude_degrees();
  void clear_has_longitude_degrees();
  void set_has_latitude_seconds();
  void clear_has_latitude_seconds();
  void set_has_latitude_minutes();
  void clear_has_latitude_minutes();
  void set_has_latitude_degrees();
  void clear_has_latitude_degrees();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double heading_;
  ::google::protobuf::int32 longitude_seconds_;
  ::google::protobuf::int32 longitude_minutes_;
  ::google::protobuf::int32 longitude_degrees_;
  ::google::protobuf::int32 latitude_seconds_;
  ::google::protobuf::int32 latitude_minutes_;
  ::google::protobuf::int32 latitude_degrees_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Global_cmd_69 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Global_cmd_69) */ {
 public:
  Global_cmd_69();
  virtual ~Global_cmd_69();

  Global_cmd_69(const Global_cmd_69& from);

  inline Global_cmd_69& operator=(const Global_cmd_69& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Global_cmd_69& default_instance();

  static inline const Global_cmd_69* internal_default_instance() {
    return reinterpret_cast<const Global_cmd_69*>(
               &_Global_cmd_69_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(Global_cmd_69* other);

  // implements Message ----------------------------------------------

  inline Global_cmd_69* New() const PROTOBUF_FINAL { return New(NULL); }

  Global_cmd_69* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Global_cmd_69& from);
  void MergeFrom(const Global_cmd_69& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Global_cmd_69* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Global_cmd_69_Pacmod_enableType Pacmod_enableType;
  static const Pacmod_enableType PACMOD_ENABLE_CONTROL_DISABLED =
    Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_DISABLED;
  static const Pacmod_enableType PACMOD_ENABLE_CONTROL_ENABLED =
    Global_cmd_69_Pacmod_enableType_PACMOD_ENABLE_CONTROL_ENABLED;
  static inline bool Pacmod_enableType_IsValid(int value) {
    return Global_cmd_69_Pacmod_enableType_IsValid(value);
  }
  static const Pacmod_enableType Pacmod_enableType_MIN =
    Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MIN;
  static const Pacmod_enableType Pacmod_enableType_MAX =
    Global_cmd_69_Pacmod_enableType_Pacmod_enableType_MAX;
  static const int Pacmod_enableType_ARRAYSIZE =
    Global_cmd_69_Pacmod_enableType_Pacmod_enableType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Pacmod_enableType_descriptor() {
    return Global_cmd_69_Pacmod_enableType_descriptor();
  }
  static inline const ::std::string& Pacmod_enableType_Name(Pacmod_enableType value) {
    return Global_cmd_69_Pacmod_enableType_Name(value);
  }
  static inline bool Pacmod_enableType_Parse(const ::std::string& name,
      Pacmod_enableType* value) {
    return Global_cmd_69_Pacmod_enableType_Parse(name, value);
  }

  typedef Global_cmd_69_Clear_overrideType Clear_overrideType;
  static const Clear_overrideType CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES =
    Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_DON_T_CLEAR_ACTIVE_OVERRIDES;
  static const Clear_overrideType CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES =
    Global_cmd_69_Clear_overrideType_CLEAR_OVERRIDE_CLEAR_ACTIVE_OVERRIDES;
  static inline bool Clear_overrideType_IsValid(int value) {
    return Global_cmd_69_Clear_overrideType_IsValid(value);
  }
  static const Clear_overrideType Clear_overrideType_MIN =
    Global_cmd_69_Clear_overrideType_Clear_overrideType_MIN;
  static const Clear_overrideType Clear_overrideType_MAX =
    Global_cmd_69_Clear_overrideType_Clear_overrideType_MAX;
  static const int Clear_overrideType_ARRAYSIZE =
    Global_cmd_69_Clear_overrideType_Clear_overrideType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Clear_overrideType_descriptor() {
    return Global_cmd_69_Clear_overrideType_descriptor();
  }
  static inline const ::std::string& Clear_overrideType_Name(Clear_overrideType value) {
    return Global_cmd_69_Clear_overrideType_Name(value);
  }
  static inline bool Clear_overrideType_Parse(const ::std::string& name,
      Clear_overrideType* value) {
    return Global_cmd_69_Clear_overrideType_Parse(name, value);
  }

  typedef Global_cmd_69_Ignore_overrideType Ignore_overrideType;
  static const Ignore_overrideType IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES =
    Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_DON_T_IGNORE_USER_OVERRIDES;
  static const Ignore_overrideType IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES =
    Global_cmd_69_Ignore_overrideType_IGNORE_OVERRIDE_IGNORE_USER_OVERRIDES;
  static inline bool Ignore_overrideType_IsValid(int value) {
    return Global_cmd_69_Ignore_overrideType_IsValid(value);
  }
  static const Ignore_overrideType Ignore_overrideType_MIN =
    Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MIN;
  static const Ignore_overrideType Ignore_overrideType_MAX =
    Global_cmd_69_Ignore_overrideType_Ignore_overrideType_MAX;
  static const int Ignore_overrideType_ARRAYSIZE =
    Global_cmd_69_Ignore_overrideType_Ignore_overrideType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Ignore_overrideType_descriptor() {
    return Global_cmd_69_Ignore_overrideType_descriptor();
  }
  static inline const ::std::string& Ignore_overrideType_Name(Ignore_overrideType value) {
    return Global_cmd_69_Ignore_overrideType_Name(value);
  }
  static inline bool Ignore_overrideType_Parse(const ::std::string& name,
      Ignore_overrideType* value) {
    return Global_cmd_69_Ignore_overrideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Global_cmd_69.Pacmod_enableType pacmod_enable = 1;
  bool has_pacmod_enable() const;
  void clear_pacmod_enable();
  static const int kPacmodEnableFieldNumber = 1;
  ::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType pacmod_enable() const;
  void set_pacmod_enable(::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType value);

  // optional .jmc_auto.canbus.Global_cmd_69.Clear_overrideType clear_override = 2;
  bool has_clear_override() const;
  void clear_clear_override();
  static const int kClearOverrideFieldNumber = 2;
  ::jmc_auto::canbus::Global_cmd_69_Clear_overrideType clear_override() const;
  void set_clear_override(::jmc_auto::canbus::Global_cmd_69_Clear_overrideType value);

  // optional .jmc_auto.canbus.Global_cmd_69.Ignore_overrideType ignore_override = 3;
  bool has_ignore_override() const;
  void clear_ignore_override();
  static const int kIgnoreOverrideFieldNumber = 3;
  ::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType ignore_override() const;
  void set_ignore_override(::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Global_cmd_69)
 private:
  void set_has_pacmod_enable();
  void clear_has_pacmod_enable();
  void set_has_clear_override();
  void clear_has_clear_override();
  void set_has_ignore_override();
  void clear_has_ignore_override();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int pacmod_enable_;
  int clear_override_;
  int ignore_override_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Parking_brake_status_rpt_80 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Parking_brake_status_rpt_80) */ {
 public:
  Parking_brake_status_rpt_80();
  virtual ~Parking_brake_status_rpt_80();

  Parking_brake_status_rpt_80(const Parking_brake_status_rpt_80& from);

  inline Parking_brake_status_rpt_80& operator=(const Parking_brake_status_rpt_80& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parking_brake_status_rpt_80& default_instance();

  static inline const Parking_brake_status_rpt_80* internal_default_instance() {
    return reinterpret_cast<const Parking_brake_status_rpt_80*>(
               &_Parking_brake_status_rpt_80_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Parking_brake_status_rpt_80* other);

  // implements Message ----------------------------------------------

  inline Parking_brake_status_rpt_80* New() const PROTOBUF_FINAL { return New(NULL); }

  Parking_brake_status_rpt_80* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Parking_brake_status_rpt_80& from);
  void MergeFrom(const Parking_brake_status_rpt_80& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Parking_brake_status_rpt_80* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_enabledType;
  static const Parking_brake_enabledType PARKING_BRAKE_ENABLED_OFF =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_OFF;
  static const Parking_brake_enabledType PARKING_BRAKE_ENABLED_ON =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_PARKING_BRAKE_ENABLED_ON;
  static inline bool Parking_brake_enabledType_IsValid(int value) {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_IsValid(value);
  }
  static const Parking_brake_enabledType Parking_brake_enabledType_MIN =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MIN;
  static const Parking_brake_enabledType Parking_brake_enabledType_MAX =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_MAX;
  static const int Parking_brake_enabledType_ARRAYSIZE =
    Parking_brake_status_rpt_80_Parking_brake_enabledType_Parking_brake_enabledType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Parking_brake_enabledType_descriptor() {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor();
  }
  static inline const ::std::string& Parking_brake_enabledType_Name(Parking_brake_enabledType value) {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_Name(value);
  }
  static inline bool Parking_brake_enabledType_Parse(const ::std::string& name,
      Parking_brake_enabledType* value) {
    return Parking_brake_status_rpt_80_Parking_brake_enabledType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Parking_brake_status_rpt_80.Parking_brake_enabledType parking_brake_enabled = 1;
  bool has_parking_brake_enabled() const;
  void clear_parking_brake_enabled();
  static const int kParkingBrakeEnabledFieldNumber = 1;
  ::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType parking_brake_enabled() const;
  void set_parking_brake_enabled(::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Parking_brake_status_rpt_80)
 private:
  void set_has_parking_brake_enabled();
  void clear_has_parking_brake_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int parking_brake_enabled_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Yaw_rate_rpt_81 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Yaw_rate_rpt_81) */ {
 public:
  Yaw_rate_rpt_81();
  virtual ~Yaw_rate_rpt_81();

  Yaw_rate_rpt_81(const Yaw_rate_rpt_81& from);

  inline Yaw_rate_rpt_81& operator=(const Yaw_rate_rpt_81& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Yaw_rate_rpt_81& default_instance();

  static inline const Yaw_rate_rpt_81* internal_default_instance() {
    return reinterpret_cast<const Yaw_rate_rpt_81*>(
               &_Yaw_rate_rpt_81_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Yaw_rate_rpt_81* other);

  // implements Message ----------------------------------------------

  inline Yaw_rate_rpt_81* New() const PROTOBUF_FINAL { return New(NULL); }

  Yaw_rate_rpt_81* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Yaw_rate_rpt_81& from);
  void MergeFrom(const Yaw_rate_rpt_81& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Yaw_rate_rpt_81* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double yaw_rate = 1;
  bool has_yaw_rate() const;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 1;
  double yaw_rate() const;
  void set_yaw_rate(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Yaw_rate_rpt_81)
 private:
  void set_has_yaw_rate();
  void clear_has_yaw_rate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double yaw_rate_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Horn_rpt_79 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Horn_rpt_79) */ {
 public:
  Horn_rpt_79();
  virtual ~Horn_rpt_79();

  Horn_rpt_79(const Horn_rpt_79& from);

  inline Horn_rpt_79& operator=(const Horn_rpt_79& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Horn_rpt_79& default_instance();

  static inline const Horn_rpt_79* internal_default_instance() {
    return reinterpret_cast<const Horn_rpt_79*>(
               &_Horn_rpt_79_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Horn_rpt_79* other);

  // implements Message ----------------------------------------------

  inline Horn_rpt_79* New() const PROTOBUF_FINAL { return New(NULL); }

  Horn_rpt_79* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Horn_rpt_79& from);
  void MergeFrom(const Horn_rpt_79& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Horn_rpt_79* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Horn_rpt_79_Output_valueType Output_valueType;
  static const Output_valueType OUTPUT_VALUE_OFF =
    Horn_rpt_79_Output_valueType_OUTPUT_VALUE_OFF;
  static const Output_valueType OUTPUT_VALUE_ON =
    Horn_rpt_79_Output_valueType_OUTPUT_VALUE_ON;
  static inline bool Output_valueType_IsValid(int value) {
    return Horn_rpt_79_Output_valueType_IsValid(value);
  }
  static const Output_valueType Output_valueType_MIN =
    Horn_rpt_79_Output_valueType_Output_valueType_MIN;
  static const Output_valueType Output_valueType_MAX =
    Horn_rpt_79_Output_valueType_Output_valueType_MAX;
  static const int Output_valueType_ARRAYSIZE =
    Horn_rpt_79_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Output_valueType_descriptor() {
    return Horn_rpt_79_Output_valueType_descriptor();
  }
  static inline const ::std::string& Output_valueType_Name(Output_valueType value) {
    return Horn_rpt_79_Output_valueType_Name(value);
  }
  static inline bool Output_valueType_Parse(const ::std::string& name,
      Output_valueType* value) {
    return Horn_rpt_79_Output_valueType_Parse(name, value);
  }

  typedef Horn_rpt_79_Commanded_valueType Commanded_valueType;
  static const Commanded_valueType COMMANDED_VALUE_OFF =
    Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_OFF;
  static const Commanded_valueType COMMANDED_VALUE_ON =
    Horn_rpt_79_Commanded_valueType_COMMANDED_VALUE_ON;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Horn_rpt_79_Commanded_valueType_IsValid(value);
  }
  static const Commanded_valueType Commanded_valueType_MIN =
    Horn_rpt_79_Commanded_valueType_Commanded_valueType_MIN;
  static const Commanded_valueType Commanded_valueType_MAX =
    Horn_rpt_79_Commanded_valueType_Commanded_valueType_MAX;
  static const int Commanded_valueType_ARRAYSIZE =
    Horn_rpt_79_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Horn_rpt_79_Commanded_valueType_descriptor();
  }
  static inline const ::std::string& Commanded_valueType_Name(Commanded_valueType value) {
    return Horn_rpt_79_Commanded_valueType_Name(value);
  }
  static inline bool Commanded_valueType_Parse(const ::std::string& name,
      Commanded_valueType* value) {
    return Horn_rpt_79_Commanded_valueType_Parse(name, value);
  }

  typedef Horn_rpt_79_Manual_inputType Manual_inputType;
  static const Manual_inputType MANUAL_INPUT_OFF =
    Horn_rpt_79_Manual_inputType_MANUAL_INPUT_OFF;
  static const Manual_inputType MANUAL_INPUT_ON =
    Horn_rpt_79_Manual_inputType_MANUAL_INPUT_ON;
  static inline bool Manual_inputType_IsValid(int value) {
    return Horn_rpt_79_Manual_inputType_IsValid(value);
  }
  static const Manual_inputType Manual_inputType_MIN =
    Horn_rpt_79_Manual_inputType_Manual_inputType_MIN;
  static const Manual_inputType Manual_inputType_MAX =
    Horn_rpt_79_Manual_inputType_Manual_inputType_MAX;
  static const int Manual_inputType_ARRAYSIZE =
    Horn_rpt_79_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Horn_rpt_79_Manual_inputType_descriptor();
  }
  static inline const ::std::string& Manual_inputType_Name(Manual_inputType value) {
    return Horn_rpt_79_Manual_inputType_Name(value);
  }
  static inline bool Manual_inputType_Parse(const ::std::string& name,
      Manual_inputType* value) {
    return Horn_rpt_79_Manual_inputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Horn_rpt_79.Output_valueType output_value = 1;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 1;
  ::jmc_auto::canbus::Horn_rpt_79_Output_valueType output_value() const;
  void set_output_value(::jmc_auto::canbus::Horn_rpt_79_Output_valueType value);

  // optional .jmc_auto.canbus.Horn_rpt_79.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  ::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType commanded_value() const;
  void set_commanded_value(::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType value);

  // optional .jmc_auto.canbus.Horn_rpt_79.Manual_inputType manual_input = 3;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 3;
  ::jmc_auto::canbus::Horn_rpt_79_Manual_inputType manual_input() const;
  void set_manual_input(::jmc_auto::canbus::Horn_rpt_79_Manual_inputType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Horn_rpt_79)
 private:
  void set_has_output_value();
  void clear_has_output_value();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_manual_input();
  void clear_has_manual_input();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int output_value_;
  int commanded_value_;
  int manual_input_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Horn_cmd_78 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Horn_cmd_78) */ {
 public:
  Horn_cmd_78();
  virtual ~Horn_cmd_78();

  Horn_cmd_78(const Horn_cmd_78& from);

  inline Horn_cmd_78& operator=(const Horn_cmd_78& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Horn_cmd_78& default_instance();

  static inline const Horn_cmd_78* internal_default_instance() {
    return reinterpret_cast<const Horn_cmd_78*>(
               &_Horn_cmd_78_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(Horn_cmd_78* other);

  // implements Message ----------------------------------------------

  inline Horn_cmd_78* New() const PROTOBUF_FINAL { return New(NULL); }

  Horn_cmd_78* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Horn_cmd_78& from);
  void MergeFrom(const Horn_cmd_78& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Horn_cmd_78* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Horn_cmd_78_Horn_cmdType Horn_cmdType;
  static const Horn_cmdType HORN_CMD_OFF =
    Horn_cmd_78_Horn_cmdType_HORN_CMD_OFF;
  static const Horn_cmdType HORN_CMD_ON =
    Horn_cmd_78_Horn_cmdType_HORN_CMD_ON;
  static inline bool Horn_cmdType_IsValid(int value) {
    return Horn_cmd_78_Horn_cmdType_IsValid(value);
  }
  static const Horn_cmdType Horn_cmdType_MIN =
    Horn_cmd_78_Horn_cmdType_Horn_cmdType_MIN;
  static const Horn_cmdType Horn_cmdType_MAX =
    Horn_cmd_78_Horn_cmdType_Horn_cmdType_MAX;
  static const int Horn_cmdType_ARRAYSIZE =
    Horn_cmd_78_Horn_cmdType_Horn_cmdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Horn_cmdType_descriptor() {
    return Horn_cmd_78_Horn_cmdType_descriptor();
  }
  static inline const ::std::string& Horn_cmdType_Name(Horn_cmdType value) {
    return Horn_cmd_78_Horn_cmdType_Name(value);
  }
  static inline bool Horn_cmdType_Parse(const ::std::string& name,
      Horn_cmdType* value) {
    return Horn_cmd_78_Horn_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Horn_cmd_78.Horn_cmdType horn_cmd = 1;
  bool has_horn_cmd() const;
  void clear_horn_cmd();
  static const int kHornCmdFieldNumber = 1;
  ::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType horn_cmd() const;
  void set_horn_cmd(::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Horn_cmd_78)
 private:
  void set_has_horn_cmd();
  void clear_has_horn_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int horn_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Wiper_rpt_91 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Wiper_rpt_91) */ {
 public:
  Wiper_rpt_91();
  virtual ~Wiper_rpt_91();

  Wiper_rpt_91(const Wiper_rpt_91& from);

  inline Wiper_rpt_91& operator=(const Wiper_rpt_91& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wiper_rpt_91& default_instance();

  static inline const Wiper_rpt_91* internal_default_instance() {
    return reinterpret_cast<const Wiper_rpt_91*>(
               &_Wiper_rpt_91_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(Wiper_rpt_91* other);

  // implements Message ----------------------------------------------

  inline Wiper_rpt_91* New() const PROTOBUF_FINAL { return New(NULL); }

  Wiper_rpt_91* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Wiper_rpt_91& from);
  void MergeFrom(const Wiper_rpt_91& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Wiper_rpt_91* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Wiper_rpt_91_Output_valueType Output_valueType;
  static const Output_valueType OUTPUT_VALUE_WIPERS_OFF =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_WIPERS_OFF;
  static const Output_valueType OUTPUT_VALUE_INTERMITTENT_1 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_1;
  static const Output_valueType OUTPUT_VALUE_INTERMITTENT_2 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_2;
  static const Output_valueType OUTPUT_VALUE_INTERMITTENT_3 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_3;
  static const Output_valueType OUTPUT_VALUE_INTERMITTENT_4 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_4;
  static const Output_valueType OUTPUT_VALUE_INTERMITTENT_5 =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_INTERMITTENT_5;
  static const Output_valueType OUTPUT_VALUE_LOW =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_LOW;
  static const Output_valueType OUTPUT_VALUE_HIGH =
    Wiper_rpt_91_Output_valueType_OUTPUT_VALUE_HIGH;
  static inline bool Output_valueType_IsValid(int value) {
    return Wiper_rpt_91_Output_valueType_IsValid(value);
  }
  static const Output_valueType Output_valueType_MIN =
    Wiper_rpt_91_Output_valueType_Output_valueType_MIN;
  static const Output_valueType Output_valueType_MAX =
    Wiper_rpt_91_Output_valueType_Output_valueType_MAX;
  static const int Output_valueType_ARRAYSIZE =
    Wiper_rpt_91_Output_valueType_Output_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Output_valueType_descriptor() {
    return Wiper_rpt_91_Output_valueType_descriptor();
  }
  static inline const ::std::string& Output_valueType_Name(Output_valueType value) {
    return Wiper_rpt_91_Output_valueType_Name(value);
  }
  static inline bool Output_valueType_Parse(const ::std::string& name,
      Output_valueType* value) {
    return Wiper_rpt_91_Output_valueType_Parse(name, value);
  }

  typedef Wiper_rpt_91_Commanded_valueType Commanded_valueType;
  static const Commanded_valueType COMMANDED_VALUE_WIPERS_OFF =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_WIPERS_OFF;
  static const Commanded_valueType COMMANDED_VALUE_INTERMITTENT_1 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_1;
  static const Commanded_valueType COMMANDED_VALUE_INTERMITTENT_2 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_2;
  static const Commanded_valueType COMMANDED_VALUE_INTERMITTENT_3 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_3;
  static const Commanded_valueType COMMANDED_VALUE_INTERMITTENT_4 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_4;
  static const Commanded_valueType COMMANDED_VALUE_INTERMITTENT_5 =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_INTERMITTENT_5;
  static const Commanded_valueType COMMANDED_VALUE_LOW =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_LOW;
  static const Commanded_valueType COMMANDED_VALUE_HIGH =
    Wiper_rpt_91_Commanded_valueType_COMMANDED_VALUE_HIGH;
  static inline bool Commanded_valueType_IsValid(int value) {
    return Wiper_rpt_91_Commanded_valueType_IsValid(value);
  }
  static const Commanded_valueType Commanded_valueType_MIN =
    Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MIN;
  static const Commanded_valueType Commanded_valueType_MAX =
    Wiper_rpt_91_Commanded_valueType_Commanded_valueType_MAX;
  static const int Commanded_valueType_ARRAYSIZE =
    Wiper_rpt_91_Commanded_valueType_Commanded_valueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Commanded_valueType_descriptor() {
    return Wiper_rpt_91_Commanded_valueType_descriptor();
  }
  static inline const ::std::string& Commanded_valueType_Name(Commanded_valueType value) {
    return Wiper_rpt_91_Commanded_valueType_Name(value);
  }
  static inline bool Commanded_valueType_Parse(const ::std::string& name,
      Commanded_valueType* value) {
    return Wiper_rpt_91_Commanded_valueType_Parse(name, value);
  }

  typedef Wiper_rpt_91_Manual_inputType Manual_inputType;
  static const Manual_inputType MANUAL_INPUT_WIPERS_OFF =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_WIPERS_OFF;
  static const Manual_inputType MANUAL_INPUT_INTERMITTENT_1 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_1;
  static const Manual_inputType MANUAL_INPUT_INTERMITTENT_2 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_2;
  static const Manual_inputType MANUAL_INPUT_INTERMITTENT_3 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_3;
  static const Manual_inputType MANUAL_INPUT_INTERMITTENT_4 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_4;
  static const Manual_inputType MANUAL_INPUT_INTERMITTENT_5 =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_INTERMITTENT_5;
  static const Manual_inputType MANUAL_INPUT_LOW =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_LOW;
  static const Manual_inputType MANUAL_INPUT_HIGH =
    Wiper_rpt_91_Manual_inputType_MANUAL_INPUT_HIGH;
  static inline bool Manual_inputType_IsValid(int value) {
    return Wiper_rpt_91_Manual_inputType_IsValid(value);
  }
  static const Manual_inputType Manual_inputType_MIN =
    Wiper_rpt_91_Manual_inputType_Manual_inputType_MIN;
  static const Manual_inputType Manual_inputType_MAX =
    Wiper_rpt_91_Manual_inputType_Manual_inputType_MAX;
  static const int Manual_inputType_ARRAYSIZE =
    Wiper_rpt_91_Manual_inputType_Manual_inputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Manual_inputType_descriptor() {
    return Wiper_rpt_91_Manual_inputType_descriptor();
  }
  static inline const ::std::string& Manual_inputType_Name(Manual_inputType value) {
    return Wiper_rpt_91_Manual_inputType_Name(value);
  }
  static inline bool Manual_inputType_Parse(const ::std::string& name,
      Manual_inputType* value) {
    return Wiper_rpt_91_Manual_inputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Wiper_rpt_91.Output_valueType output_value = 1;
  bool has_output_value() const;
  void clear_output_value();
  static const int kOutputValueFieldNumber = 1;
  ::jmc_auto::canbus::Wiper_rpt_91_Output_valueType output_value() const;
  void set_output_value(::jmc_auto::canbus::Wiper_rpt_91_Output_valueType value);

  // optional .jmc_auto.canbus.Wiper_rpt_91.Commanded_valueType commanded_value = 2;
  bool has_commanded_value() const;
  void clear_commanded_value();
  static const int kCommandedValueFieldNumber = 2;
  ::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType commanded_value() const;
  void set_commanded_value(::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType value);

  // optional .jmc_auto.canbus.Wiper_rpt_91.Manual_inputType manual_input = 3;
  bool has_manual_input() const;
  void clear_manual_input();
  static const int kManualInputFieldNumber = 3;
  ::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType manual_input() const;
  void set_manual_input(::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Wiper_rpt_91)
 private:
  void set_has_output_value();
  void clear_has_output_value();
  void set_has_commanded_value();
  void clear_has_commanded_value();
  void set_has_manual_input();
  void clear_has_manual_input();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int output_value_;
  int commanded_value_;
  int manual_input_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_speed_rpt_6f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Vehicle_speed_rpt_6f) */ {
 public:
  Vehicle_speed_rpt_6f();
  virtual ~Vehicle_speed_rpt_6f();

  Vehicle_speed_rpt_6f(const Vehicle_speed_rpt_6f& from);

  inline Vehicle_speed_rpt_6f& operator=(const Vehicle_speed_rpt_6f& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_speed_rpt_6f& default_instance();

  static inline const Vehicle_speed_rpt_6f* internal_default_instance() {
    return reinterpret_cast<const Vehicle_speed_rpt_6f*>(
               &_Vehicle_speed_rpt_6f_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Vehicle_speed_rpt_6f* other);

  // implements Message ----------------------------------------------

  inline Vehicle_speed_rpt_6f* New() const PROTOBUF_FINAL { return New(NULL); }

  Vehicle_speed_rpt_6f* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vehicle_speed_rpt_6f& from);
  void MergeFrom(const Vehicle_speed_rpt_6f& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vehicle_speed_rpt_6f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_validType;
  static const Vehicle_speed_validType VEHICLE_SPEED_VALID_INVALID =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_INVALID;
  static const Vehicle_speed_validType VEHICLE_SPEED_VALID_VALID =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_VEHICLE_SPEED_VALID_VALID;
  static inline bool Vehicle_speed_validType_IsValid(int value) {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_IsValid(value);
  }
  static const Vehicle_speed_validType Vehicle_speed_validType_MIN =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MIN;
  static const Vehicle_speed_validType Vehicle_speed_validType_MAX =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_MAX;
  static const int Vehicle_speed_validType_ARRAYSIZE =
    Vehicle_speed_rpt_6f_Vehicle_speed_validType_Vehicle_speed_validType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Vehicle_speed_validType_descriptor() {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor();
  }
  static inline const ::std::string& Vehicle_speed_validType_Name(Vehicle_speed_validType value) {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_Name(value);
  }
  static inline bool Vehicle_speed_validType_Parse(const ::std::string& name,
      Vehicle_speed_validType* value) {
    return Vehicle_speed_rpt_6f_Vehicle_speed_validType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double vehicle_speed = 1;
  bool has_vehicle_speed() const;
  void clear_vehicle_speed();
  static const int kVehicleSpeedFieldNumber = 1;
  double vehicle_speed() const;
  void set_vehicle_speed(double value);

  // optional .jmc_auto.canbus.Vehicle_speed_rpt_6f.Vehicle_speed_validType vehicle_speed_valid = 2;
  bool has_vehicle_speed_valid() const;
  void clear_vehicle_speed_valid();
  static const int kVehicleSpeedValidFieldNumber = 2;
  ::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType vehicle_speed_valid() const;
  void set_vehicle_speed_valid(::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Vehicle_speed_rpt_6f)
 private:
  void set_has_vehicle_speed();
  void clear_has_vehicle_speed();
  void set_has_vehicle_speed_valid();
  void clear_has_vehicle_speed_valid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double vehicle_speed_;
  int vehicle_speed_valid_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Headlight_cmd_76 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Headlight_cmd_76) */ {
 public:
  Headlight_cmd_76();
  virtual ~Headlight_cmd_76();

  Headlight_cmd_76(const Headlight_cmd_76& from);

  inline Headlight_cmd_76& operator=(const Headlight_cmd_76& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Headlight_cmd_76& default_instance();

  static inline const Headlight_cmd_76* internal_default_instance() {
    return reinterpret_cast<const Headlight_cmd_76*>(
               &_Headlight_cmd_76_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Headlight_cmd_76* other);

  // implements Message ----------------------------------------------

  inline Headlight_cmd_76* New() const PROTOBUF_FINAL { return New(NULL); }

  Headlight_cmd_76* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Headlight_cmd_76& from);
  void MergeFrom(const Headlight_cmd_76& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Headlight_cmd_76* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Headlight_cmd_76_Headlight_cmdType Headlight_cmdType;
  static const Headlight_cmdType HEADLIGHT_CMD_HEADLIGHTS_OFF =
    Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HEADLIGHTS_OFF;
  static const Headlight_cmdType HEADLIGHT_CMD_LOW_BEAMS =
    Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_LOW_BEAMS;
  static const Headlight_cmdType HEADLIGHT_CMD_HIGH_BEAMS =
    Headlight_cmd_76_Headlight_cmdType_HEADLIGHT_CMD_HIGH_BEAMS;
  static inline bool Headlight_cmdType_IsValid(int value) {
    return Headlight_cmd_76_Headlight_cmdType_IsValid(value);
  }
  static const Headlight_cmdType Headlight_cmdType_MIN =
    Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MIN;
  static const Headlight_cmdType Headlight_cmdType_MAX =
    Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_MAX;
  static const int Headlight_cmdType_ARRAYSIZE =
    Headlight_cmd_76_Headlight_cmdType_Headlight_cmdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Headlight_cmdType_descriptor() {
    return Headlight_cmd_76_Headlight_cmdType_descriptor();
  }
  static inline const ::std::string& Headlight_cmdType_Name(Headlight_cmdType value) {
    return Headlight_cmd_76_Headlight_cmdType_Name(value);
  }
  static inline bool Headlight_cmdType_Parse(const ::std::string& name,
      Headlight_cmdType* value) {
    return Headlight_cmd_76_Headlight_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Headlight_cmd_76.Headlight_cmdType headlight_cmd = 1;
  bool has_headlight_cmd() const;
  void clear_headlight_cmd();
  static const int kHeadlightCmdFieldNumber = 1;
  ::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType headlight_cmd() const;
  void set_headlight_cmd(::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Headlight_cmd_76)
 private:
  void set_has_headlight_cmd();
  void clear_has_headlight_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int headlight_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Steering_motor_rpt_2_74 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Steering_motor_rpt_2_74) */ {
 public:
  Steering_motor_rpt_2_74();
  virtual ~Steering_motor_rpt_2_74();

  Steering_motor_rpt_2_74(const Steering_motor_rpt_2_74& from);

  inline Steering_motor_rpt_2_74& operator=(const Steering_motor_rpt_2_74& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Steering_motor_rpt_2_74& default_instance();

  static inline const Steering_motor_rpt_2_74* internal_default_instance() {
    return reinterpret_cast<const Steering_motor_rpt_2_74*>(
               &_Steering_motor_rpt_2_74_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Steering_motor_rpt_2_74* other);

  // implements Message ----------------------------------------------

  inline Steering_motor_rpt_2_74* New() const PROTOBUF_FINAL { return New(NULL); }

  Steering_motor_rpt_2_74* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Steering_motor_rpt_2_74& from);
  void MergeFrom(const Steering_motor_rpt_2_74& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Steering_motor_rpt_2_74* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 encoder_temperature = 1;
  bool has_encoder_temperature() const;
  void clear_encoder_temperature();
  static const int kEncoderTemperatureFieldNumber = 1;
  ::google::protobuf::int32 encoder_temperature() const;
  void set_encoder_temperature(::google::protobuf::int32 value);

  // optional int32 motor_temperature = 2;
  bool has_motor_temperature() const;
  void clear_motor_temperature();
  static const int kMotorTemperatureFieldNumber = 2;
  ::google::protobuf::int32 motor_temperature() const;
  void set_motor_temperature(::google::protobuf::int32 value);

  // optional double angular_speed = 3;
  bool has_angular_speed() const;
  void clear_angular_speed();
  static const int kAngularSpeedFieldNumber = 3;
  double angular_speed() const;
  void set_angular_speed(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Steering_motor_rpt_2_74)
 private:
  void set_has_encoder_temperature();
  void clear_has_encoder_temperature();
  void set_has_motor_temperature();
  void clear_has_motor_temperature();
  void set_has_angular_speed();
  void clear_has_angular_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 encoder_temperature_;
  ::google::protobuf::int32 motor_temperature_;
  double angular_speed_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake_motor_rpt_2_71 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Brake_motor_rpt_2_71) */ {
 public:
  Brake_motor_rpt_2_71();
  virtual ~Brake_motor_rpt_2_71();

  Brake_motor_rpt_2_71(const Brake_motor_rpt_2_71& from);

  inline Brake_motor_rpt_2_71& operator=(const Brake_motor_rpt_2_71& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake_motor_rpt_2_71& default_instance();

  static inline const Brake_motor_rpt_2_71* internal_default_instance() {
    return reinterpret_cast<const Brake_motor_rpt_2_71*>(
               &_Brake_motor_rpt_2_71_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(Brake_motor_rpt_2_71* other);

  // implements Message ----------------------------------------------

  inline Brake_motor_rpt_2_71* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake_motor_rpt_2_71* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake_motor_rpt_2_71& from);
  void MergeFrom(const Brake_motor_rpt_2_71& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake_motor_rpt_2_71* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 encoder_temperature = 1;
  bool has_encoder_temperature() const;
  void clear_encoder_temperature();
  static const int kEncoderTemperatureFieldNumber = 1;
  ::google::protobuf::int32 encoder_temperature() const;
  void set_encoder_temperature(::google::protobuf::int32 value);

  // optional int32 motor_temperature = 2;
  bool has_motor_temperature() const;
  void clear_motor_temperature();
  static const int kMotorTemperatureFieldNumber = 2;
  ::google::protobuf::int32 motor_temperature() const;
  void set_motor_temperature(::google::protobuf::int32 value);

  // optional double angular_speed = 3;
  bool has_angular_speed() const;
  void clear_angular_speed();
  static const int kAngularSpeedFieldNumber = 3;
  double angular_speed() const;
  void set_angular_speed(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Brake_motor_rpt_2_71)
 private:
  void set_has_encoder_temperature();
  void clear_has_encoder_temperature();
  void set_has_motor_temperature();
  void clear_has_motor_temperature();
  void set_has_angular_speed();
  void clear_has_angular_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 encoder_temperature_;
  ::google::protobuf::int32 motor_temperature_;
  double angular_speed_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Steering_motor_rpt_1_73 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Steering_motor_rpt_1_73) */ {
 public:
  Steering_motor_rpt_1_73();
  virtual ~Steering_motor_rpt_1_73();

  Steering_motor_rpt_1_73(const Steering_motor_rpt_1_73& from);

  inline Steering_motor_rpt_1_73& operator=(const Steering_motor_rpt_1_73& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Steering_motor_rpt_1_73& default_instance();

  static inline const Steering_motor_rpt_1_73* internal_default_instance() {
    return reinterpret_cast<const Steering_motor_rpt_1_73*>(
               &_Steering_motor_rpt_1_73_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(Steering_motor_rpt_1_73* other);

  // implements Message ----------------------------------------------

  inline Steering_motor_rpt_1_73* New() const PROTOBUF_FINAL { return New(NULL); }

  Steering_motor_rpt_1_73* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Steering_motor_rpt_1_73& from);
  void MergeFrom(const Steering_motor_rpt_1_73& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Steering_motor_rpt_1_73* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double motor_current = 1;
  bool has_motor_current() const;
  void clear_motor_current();
  static const int kMotorCurrentFieldNumber = 1;
  double motor_current() const;
  void set_motor_current(double value);

  // optional double shaft_position = 2;
  bool has_shaft_position() const;
  void clear_shaft_position();
  static const int kShaftPositionFieldNumber = 2;
  double shaft_position() const;
  void set_shaft_position(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Steering_motor_rpt_1_73)
 private:
  void set_has_motor_current();
  void clear_has_motor_current();
  void set_has_shaft_position();
  void clear_has_shaft_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double motor_current_;
  double shaft_position_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Wiper_cmd_90 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Wiper_cmd_90) */ {
 public:
  Wiper_cmd_90();
  virtual ~Wiper_cmd_90();

  Wiper_cmd_90(const Wiper_cmd_90& from);

  inline Wiper_cmd_90& operator=(const Wiper_cmd_90& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wiper_cmd_90& default_instance();

  static inline const Wiper_cmd_90* internal_default_instance() {
    return reinterpret_cast<const Wiper_cmd_90*>(
               &_Wiper_cmd_90_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(Wiper_cmd_90* other);

  // implements Message ----------------------------------------------

  inline Wiper_cmd_90* New() const PROTOBUF_FINAL { return New(NULL); }

  Wiper_cmd_90* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Wiper_cmd_90& from);
  void MergeFrom(const Wiper_cmd_90& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Wiper_cmd_90* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Wiper_cmd_90_Wiper_cmdType Wiper_cmdType;
  static const Wiper_cmdType WIPER_CMD_WIPERS_OFF =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_WIPERS_OFF;
  static const Wiper_cmdType WIPER_CMD_INTERMITTENT_1 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_1;
  static const Wiper_cmdType WIPER_CMD_INTERMITTENT_2 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_2;
  static const Wiper_cmdType WIPER_CMD_INTERMITTENT_3 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_3;
  static const Wiper_cmdType WIPER_CMD_INTERMITTENT_4 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_4;
  static const Wiper_cmdType WIPER_CMD_INTERMITTENT_5 =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_INTERMITTENT_5;
  static const Wiper_cmdType WIPER_CMD_LOW =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_LOW;
  static const Wiper_cmdType WIPER_CMD_HIGH =
    Wiper_cmd_90_Wiper_cmdType_WIPER_CMD_HIGH;
  static inline bool Wiper_cmdType_IsValid(int value) {
    return Wiper_cmd_90_Wiper_cmdType_IsValid(value);
  }
  static const Wiper_cmdType Wiper_cmdType_MIN =
    Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MIN;
  static const Wiper_cmdType Wiper_cmdType_MAX =
    Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_MAX;
  static const int Wiper_cmdType_ARRAYSIZE =
    Wiper_cmd_90_Wiper_cmdType_Wiper_cmdType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Wiper_cmdType_descriptor() {
    return Wiper_cmd_90_Wiper_cmdType_descriptor();
  }
  static inline const ::std::string& Wiper_cmdType_Name(Wiper_cmdType value) {
    return Wiper_cmd_90_Wiper_cmdType_Name(value);
  }
  static inline bool Wiper_cmdType_Parse(const ::std::string& name,
      Wiper_cmdType* value) {
    return Wiper_cmd_90_Wiper_cmdType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Wiper_cmd_90.Wiper_cmdType wiper_cmd = 1;
  bool has_wiper_cmd() const;
  void clear_wiper_cmd();
  static const int kWiperCmdFieldNumber = 1;
  ::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType wiper_cmd() const;
  void set_wiper_cmd(::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Wiper_cmd_90)
 private:
  void set_has_wiper_cmd();
  void clear_has_wiper_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int wiper_cmd_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake_motor_rpt_3_72 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Brake_motor_rpt_3_72) */ {
 public:
  Brake_motor_rpt_3_72();
  virtual ~Brake_motor_rpt_3_72();

  Brake_motor_rpt_3_72(const Brake_motor_rpt_3_72& from);

  inline Brake_motor_rpt_3_72& operator=(const Brake_motor_rpt_3_72& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake_motor_rpt_3_72& default_instance();

  static inline const Brake_motor_rpt_3_72* internal_default_instance() {
    return reinterpret_cast<const Brake_motor_rpt_3_72*>(
               &_Brake_motor_rpt_3_72_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(Brake_motor_rpt_3_72* other);

  // implements Message ----------------------------------------------

  inline Brake_motor_rpt_3_72* New() const PROTOBUF_FINAL { return New(NULL); }

  Brake_motor_rpt_3_72* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Brake_motor_rpt_3_72& from);
  void MergeFrom(const Brake_motor_rpt_3_72& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Brake_motor_rpt_3_72* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double torque_output = 1;
  bool has_torque_output() const;
  void clear_torque_output();
  static const int kTorqueOutputFieldNumber = 1;
  double torque_output() const;
  void set_torque_output(double value);

  // optional double torque_input = 2;
  bool has_torque_input() const;
  void clear_torque_input();
  static const int kTorqueInputFieldNumber = 2;
  double torque_input() const;
  void set_torque_input(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Brake_motor_rpt_3_72)
 private:
  void set_has_torque_output();
  void clear_has_torque_output();
  void set_has_torque_input();
  void clear_has_torque_input();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double torque_output_;
  double torque_input_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.canbus.Gem) */ {
 public:
  Gem();
  virtual ~Gem();

  Gem(const Gem& from);

  inline Gem& operator=(const Gem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gem& default_instance();

  static inline const Gem* internal_default_instance() {
    return reinterpret_cast<const Gem*>(
               &_Gem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(Gem* other);

  // implements Message ----------------------------------------------

  inline Gem* New() const PROTOBUF_FINAL { return New(NULL); }

  Gem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Gem& from);
  void MergeFrom(const Gem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Gem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.canbus.Global_rpt_6a global_rpt_6a = 1;
  bool has_global_rpt_6a() const;
  void clear_global_rpt_6a();
  static const int kGlobalRpt6AFieldNumber = 1;
  const ::jmc_auto::canbus::Global_rpt_6a& global_rpt_6a() const;
  ::jmc_auto::canbus::Global_rpt_6a* mutable_global_rpt_6a();
  ::jmc_auto::canbus::Global_rpt_6a* release_global_rpt_6a();
  void set_allocated_global_rpt_6a(::jmc_auto::canbus::Global_rpt_6a* global_rpt_6a);

  // optional .jmc_auto.canbus.Brake_cmd_6b brake_cmd_6b = 2;
  bool has_brake_cmd_6b() const;
  void clear_brake_cmd_6b();
  static const int kBrakeCmd6BFieldNumber = 2;
  const ::jmc_auto::canbus::Brake_cmd_6b& brake_cmd_6b() const;
  ::jmc_auto::canbus::Brake_cmd_6b* mutable_brake_cmd_6b();
  ::jmc_auto::canbus::Brake_cmd_6b* release_brake_cmd_6b();
  void set_allocated_brake_cmd_6b(::jmc_auto::canbus::Brake_cmd_6b* brake_cmd_6b);

  // optional .jmc_auto.canbus.Brake_rpt_6c brake_rpt_6c = 3;
  bool has_brake_rpt_6c() const;
  void clear_brake_rpt_6c();
  static const int kBrakeRpt6CFieldNumber = 3;
  const ::jmc_auto::canbus::Brake_rpt_6c& brake_rpt_6c() const;
  ::jmc_auto::canbus::Brake_rpt_6c* mutable_brake_rpt_6c();
  ::jmc_auto::canbus::Brake_rpt_6c* release_brake_rpt_6c();
  void set_allocated_brake_rpt_6c(::jmc_auto::canbus::Brake_rpt_6c* brake_rpt_6c);

  // optional .jmc_auto.canbus.Steering_cmd_6d steering_cmd_6d = 4;
  bool has_steering_cmd_6d() const;
  void clear_steering_cmd_6d();
  static const int kSteeringCmd6DFieldNumber = 4;
  const ::jmc_auto::canbus::Steering_cmd_6d& steering_cmd_6d() const;
  ::jmc_auto::canbus::Steering_cmd_6d* mutable_steering_cmd_6d();
  ::jmc_auto::canbus::Steering_cmd_6d* release_steering_cmd_6d();
  void set_allocated_steering_cmd_6d(::jmc_auto::canbus::Steering_cmd_6d* steering_cmd_6d);

  // optional .jmc_auto.canbus.Steering_rpt_1_6e steering_rpt_1_6e = 5;
  bool has_steering_rpt_1_6e() const;
  void clear_steering_rpt_1_6e();
  static const int kSteeringRpt16EFieldNumber = 5;
  const ::jmc_auto::canbus::Steering_rpt_1_6e& steering_rpt_1_6e() const;
  ::jmc_auto::canbus::Steering_rpt_1_6e* mutable_steering_rpt_1_6e();
  ::jmc_auto::canbus::Steering_rpt_1_6e* release_steering_rpt_1_6e();
  void set_allocated_steering_rpt_1_6e(::jmc_auto::canbus::Steering_rpt_1_6e* steering_rpt_1_6e);

  // optional .jmc_auto.canbus.Wheel_speed_rpt_7a wheel_speed_rpt_7a = 6;
  bool has_wheel_speed_rpt_7a() const;
  void clear_wheel_speed_rpt_7a();
  static const int kWheelSpeedRpt7AFieldNumber = 6;
  const ::jmc_auto::canbus::Wheel_speed_rpt_7a& wheel_speed_rpt_7a() const;
  ::jmc_auto::canbus::Wheel_speed_rpt_7a* mutable_wheel_speed_rpt_7a();
  ::jmc_auto::canbus::Wheel_speed_rpt_7a* release_wheel_speed_rpt_7a();
  void set_allocated_wheel_speed_rpt_7a(::jmc_auto::canbus::Wheel_speed_rpt_7a* wheel_speed_rpt_7a);

  // optional .jmc_auto.canbus.Date_time_rpt_83 date_time_rpt_83 = 7;
  bool has_date_time_rpt_83() const;
  void clear_date_time_rpt_83();
  static const int kDateTimeRpt83FieldNumber = 7;
  const ::jmc_auto::canbus::Date_time_rpt_83& date_time_rpt_83() const;
  ::jmc_auto::canbus::Date_time_rpt_83* mutable_date_time_rpt_83();
  ::jmc_auto::canbus::Date_time_rpt_83* release_date_time_rpt_83();
  void set_allocated_date_time_rpt_83(::jmc_auto::canbus::Date_time_rpt_83* date_time_rpt_83);

  // optional .jmc_auto.canbus.Brake_motor_rpt_1_70 brake_motor_rpt_1_70 = 8;
  bool has_brake_motor_rpt_1_70() const;
  void clear_brake_motor_rpt_1_70();
  static const int kBrakeMotorRpt170FieldNumber = 8;
  const ::jmc_auto::canbus::Brake_motor_rpt_1_70& brake_motor_rpt_1_70() const;
  ::jmc_auto::canbus::Brake_motor_rpt_1_70* mutable_brake_motor_rpt_1_70();
  ::jmc_auto::canbus::Brake_motor_rpt_1_70* release_brake_motor_rpt_1_70();
  void set_allocated_brake_motor_rpt_1_70(::jmc_auto::canbus::Brake_motor_rpt_1_70* brake_motor_rpt_1_70);

  // optional .jmc_auto.canbus.Headlight_rpt_77 headlight_rpt_77 = 9;
  bool has_headlight_rpt_77() const;
  void clear_headlight_rpt_77();
  static const int kHeadlightRpt77FieldNumber = 9;
  const ::jmc_auto::canbus::Headlight_rpt_77& headlight_rpt_77() const;
  ::jmc_auto::canbus::Headlight_rpt_77* mutable_headlight_rpt_77();
  ::jmc_auto::canbus::Headlight_rpt_77* release_headlight_rpt_77();
  void set_allocated_headlight_rpt_77(::jmc_auto::canbus::Headlight_rpt_77* headlight_rpt_77);

  // optional .jmc_auto.canbus.Accel_rpt_68 accel_rpt_68 = 10;
  bool has_accel_rpt_68() const;
  void clear_accel_rpt_68();
  static const int kAccelRpt68FieldNumber = 10;
  const ::jmc_auto::canbus::Accel_rpt_68& accel_rpt_68() const;
  ::jmc_auto::canbus::Accel_rpt_68* mutable_accel_rpt_68();
  ::jmc_auto::canbus::Accel_rpt_68* release_accel_rpt_68();
  void set_allocated_accel_rpt_68(::jmc_auto::canbus::Accel_rpt_68* accel_rpt_68);

  // optional .jmc_auto.canbus.Steering_motor_rpt_3_75 steering_motor_rpt_3_75 = 11;
  bool has_steering_motor_rpt_3_75() const;
  void clear_steering_motor_rpt_3_75();
  static const int kSteeringMotorRpt375FieldNumber = 11;
  const ::jmc_auto::canbus::Steering_motor_rpt_3_75& steering_motor_rpt_3_75() const;
  ::jmc_auto::canbus::Steering_motor_rpt_3_75* mutable_steering_motor_rpt_3_75();
  ::jmc_auto::canbus::Steering_motor_rpt_3_75* release_steering_motor_rpt_3_75();
  void set_allocated_steering_motor_rpt_3_75(::jmc_auto::canbus::Steering_motor_rpt_3_75* steering_motor_rpt_3_75);

  // optional .jmc_auto.canbus.Turn_cmd_63 turn_cmd_63 = 12;
  bool has_turn_cmd_63() const;
  void clear_turn_cmd_63();
  static const int kTurnCmd63FieldNumber = 12;
  const ::jmc_auto::canbus::Turn_cmd_63& turn_cmd_63() const;
  ::jmc_auto::canbus::Turn_cmd_63* mutable_turn_cmd_63();
  ::jmc_auto::canbus::Turn_cmd_63* release_turn_cmd_63();
  void set_allocated_turn_cmd_63(::jmc_auto::canbus::Turn_cmd_63* turn_cmd_63);

  // optional .jmc_auto.canbus.Turn_rpt_64 turn_rpt_64 = 13;
  bool has_turn_rpt_64() const;
  void clear_turn_rpt_64();
  static const int kTurnRpt64FieldNumber = 13;
  const ::jmc_auto::canbus::Turn_rpt_64& turn_rpt_64() const;
  ::jmc_auto::canbus::Turn_rpt_64* mutable_turn_rpt_64();
  ::jmc_auto::canbus::Turn_rpt_64* release_turn_rpt_64();
  void set_allocated_turn_rpt_64(::jmc_auto::canbus::Turn_rpt_64* turn_rpt_64);

  // optional .jmc_auto.canbus.Shift_cmd_65 shift_cmd_65 = 14;
  bool has_shift_cmd_65() const;
  void clear_shift_cmd_65();
  static const int kShiftCmd65FieldNumber = 14;
  const ::jmc_auto::canbus::Shift_cmd_65& shift_cmd_65() const;
  ::jmc_auto::canbus::Shift_cmd_65* mutable_shift_cmd_65();
  ::jmc_auto::canbus::Shift_cmd_65* release_shift_cmd_65();
  void set_allocated_shift_cmd_65(::jmc_auto::canbus::Shift_cmd_65* shift_cmd_65);

  // optional .jmc_auto.canbus.Shift_rpt_66 shift_rpt_66 = 15;
  bool has_shift_rpt_66() const;
  void clear_shift_rpt_66();
  static const int kShiftRpt66FieldNumber = 15;
  const ::jmc_auto::canbus::Shift_rpt_66& shift_rpt_66() const;
  ::jmc_auto::canbus::Shift_rpt_66* mutable_shift_rpt_66();
  ::jmc_auto::canbus::Shift_rpt_66* release_shift_rpt_66();
  void set_allocated_shift_rpt_66(::jmc_auto::canbus::Shift_rpt_66* shift_rpt_66);

  // optional .jmc_auto.canbus.Accel_cmd_67 accel_cmd_67 = 16;
  bool has_accel_cmd_67() const;
  void clear_accel_cmd_67();
  static const int kAccelCmd67FieldNumber = 16;
  const ::jmc_auto::canbus::Accel_cmd_67& accel_cmd_67() const;
  ::jmc_auto::canbus::Accel_cmd_67* mutable_accel_cmd_67();
  ::jmc_auto::canbus::Accel_cmd_67* release_accel_cmd_67();
  void set_allocated_accel_cmd_67(::jmc_auto::canbus::Accel_cmd_67* accel_cmd_67);

  // optional .jmc_auto.canbus.Lat_lon_heading_rpt_82 lat_lon_heading_rpt_82 = 17;
  bool has_lat_lon_heading_rpt_82() const;
  void clear_lat_lon_heading_rpt_82();
  static const int kLatLonHeadingRpt82FieldNumber = 17;
  const ::jmc_auto::canbus::Lat_lon_heading_rpt_82& lat_lon_heading_rpt_82() const;
  ::jmc_auto::canbus::Lat_lon_heading_rpt_82* mutable_lat_lon_heading_rpt_82();
  ::jmc_auto::canbus::Lat_lon_heading_rpt_82* release_lat_lon_heading_rpt_82();
  void set_allocated_lat_lon_heading_rpt_82(::jmc_auto::canbus::Lat_lon_heading_rpt_82* lat_lon_heading_rpt_82);

  // optional .jmc_auto.canbus.Global_cmd_69 global_cmd_69 = 18;
  bool has_global_cmd_69() const;
  void clear_global_cmd_69();
  static const int kGlobalCmd69FieldNumber = 18;
  const ::jmc_auto::canbus::Global_cmd_69& global_cmd_69() const;
  ::jmc_auto::canbus::Global_cmd_69* mutable_global_cmd_69();
  ::jmc_auto::canbus::Global_cmd_69* release_global_cmd_69();
  void set_allocated_global_cmd_69(::jmc_auto::canbus::Global_cmd_69* global_cmd_69);

  // optional .jmc_auto.canbus.Parking_brake_status_rpt_80 parking_brake_status_rpt_80 = 19;
  bool has_parking_brake_status_rpt_80() const;
  void clear_parking_brake_status_rpt_80();
  static const int kParkingBrakeStatusRpt80FieldNumber = 19;
  const ::jmc_auto::canbus::Parking_brake_status_rpt_80& parking_brake_status_rpt_80() const;
  ::jmc_auto::canbus::Parking_brake_status_rpt_80* mutable_parking_brake_status_rpt_80();
  ::jmc_auto::canbus::Parking_brake_status_rpt_80* release_parking_brake_status_rpt_80();
  void set_allocated_parking_brake_status_rpt_80(::jmc_auto::canbus::Parking_brake_status_rpt_80* parking_brake_status_rpt_80);

  // optional .jmc_auto.canbus.Yaw_rate_rpt_81 yaw_rate_rpt_81 = 20;
  bool has_yaw_rate_rpt_81() const;
  void clear_yaw_rate_rpt_81();
  static const int kYawRateRpt81FieldNumber = 20;
  const ::jmc_auto::canbus::Yaw_rate_rpt_81& yaw_rate_rpt_81() const;
  ::jmc_auto::canbus::Yaw_rate_rpt_81* mutable_yaw_rate_rpt_81();
  ::jmc_auto::canbus::Yaw_rate_rpt_81* release_yaw_rate_rpt_81();
  void set_allocated_yaw_rate_rpt_81(::jmc_auto::canbus::Yaw_rate_rpt_81* yaw_rate_rpt_81);

  // optional .jmc_auto.canbus.Horn_rpt_79 horn_rpt_79 = 21;
  bool has_horn_rpt_79() const;
  void clear_horn_rpt_79();
  static const int kHornRpt79FieldNumber = 21;
  const ::jmc_auto::canbus::Horn_rpt_79& horn_rpt_79() const;
  ::jmc_auto::canbus::Horn_rpt_79* mutable_horn_rpt_79();
  ::jmc_auto::canbus::Horn_rpt_79* release_horn_rpt_79();
  void set_allocated_horn_rpt_79(::jmc_auto::canbus::Horn_rpt_79* horn_rpt_79);

  // optional .jmc_auto.canbus.Horn_cmd_78 horn_cmd_78 = 22;
  bool has_horn_cmd_78() const;
  void clear_horn_cmd_78();
  static const int kHornCmd78FieldNumber = 22;
  const ::jmc_auto::canbus::Horn_cmd_78& horn_cmd_78() const;
  ::jmc_auto::canbus::Horn_cmd_78* mutable_horn_cmd_78();
  ::jmc_auto::canbus::Horn_cmd_78* release_horn_cmd_78();
  void set_allocated_horn_cmd_78(::jmc_auto::canbus::Horn_cmd_78* horn_cmd_78);

  // optional .jmc_auto.canbus.Wiper_rpt_91 wiper_rpt_91 = 23;
  bool has_wiper_rpt_91() const;
  void clear_wiper_rpt_91();
  static const int kWiperRpt91FieldNumber = 23;
  const ::jmc_auto::canbus::Wiper_rpt_91& wiper_rpt_91() const;
  ::jmc_auto::canbus::Wiper_rpt_91* mutable_wiper_rpt_91();
  ::jmc_auto::canbus::Wiper_rpt_91* release_wiper_rpt_91();
  void set_allocated_wiper_rpt_91(::jmc_auto::canbus::Wiper_rpt_91* wiper_rpt_91);

  // optional .jmc_auto.canbus.Vehicle_speed_rpt_6f vehicle_speed_rpt_6f = 24;
  bool has_vehicle_speed_rpt_6f() const;
  void clear_vehicle_speed_rpt_6f();
  static const int kVehicleSpeedRpt6FFieldNumber = 24;
  const ::jmc_auto::canbus::Vehicle_speed_rpt_6f& vehicle_speed_rpt_6f() const;
  ::jmc_auto::canbus::Vehicle_speed_rpt_6f* mutable_vehicle_speed_rpt_6f();
  ::jmc_auto::canbus::Vehicle_speed_rpt_6f* release_vehicle_speed_rpt_6f();
  void set_allocated_vehicle_speed_rpt_6f(::jmc_auto::canbus::Vehicle_speed_rpt_6f* vehicle_speed_rpt_6f);

  // optional .jmc_auto.canbus.Headlight_cmd_76 headlight_cmd_76 = 25;
  bool has_headlight_cmd_76() const;
  void clear_headlight_cmd_76();
  static const int kHeadlightCmd76FieldNumber = 25;
  const ::jmc_auto::canbus::Headlight_cmd_76& headlight_cmd_76() const;
  ::jmc_auto::canbus::Headlight_cmd_76* mutable_headlight_cmd_76();
  ::jmc_auto::canbus::Headlight_cmd_76* release_headlight_cmd_76();
  void set_allocated_headlight_cmd_76(::jmc_auto::canbus::Headlight_cmd_76* headlight_cmd_76);

  // optional .jmc_auto.canbus.Steering_motor_rpt_2_74 steering_motor_rpt_2_74 = 26;
  bool has_steering_motor_rpt_2_74() const;
  void clear_steering_motor_rpt_2_74();
  static const int kSteeringMotorRpt274FieldNumber = 26;
  const ::jmc_auto::canbus::Steering_motor_rpt_2_74& steering_motor_rpt_2_74() const;
  ::jmc_auto::canbus::Steering_motor_rpt_2_74* mutable_steering_motor_rpt_2_74();
  ::jmc_auto::canbus::Steering_motor_rpt_2_74* release_steering_motor_rpt_2_74();
  void set_allocated_steering_motor_rpt_2_74(::jmc_auto::canbus::Steering_motor_rpt_2_74* steering_motor_rpt_2_74);

  // optional .jmc_auto.canbus.Brake_motor_rpt_2_71 brake_motor_rpt_2_71 = 27;
  bool has_brake_motor_rpt_2_71() const;
  void clear_brake_motor_rpt_2_71();
  static const int kBrakeMotorRpt271FieldNumber = 27;
  const ::jmc_auto::canbus::Brake_motor_rpt_2_71& brake_motor_rpt_2_71() const;
  ::jmc_auto::canbus::Brake_motor_rpt_2_71* mutable_brake_motor_rpt_2_71();
  ::jmc_auto::canbus::Brake_motor_rpt_2_71* release_brake_motor_rpt_2_71();
  void set_allocated_brake_motor_rpt_2_71(::jmc_auto::canbus::Brake_motor_rpt_2_71* brake_motor_rpt_2_71);

  // optional .jmc_auto.canbus.Steering_motor_rpt_1_73 steering_motor_rpt_1_73 = 28;
  bool has_steering_motor_rpt_1_73() const;
  void clear_steering_motor_rpt_1_73();
  static const int kSteeringMotorRpt173FieldNumber = 28;
  const ::jmc_auto::canbus::Steering_motor_rpt_1_73& steering_motor_rpt_1_73() const;
  ::jmc_auto::canbus::Steering_motor_rpt_1_73* mutable_steering_motor_rpt_1_73();
  ::jmc_auto::canbus::Steering_motor_rpt_1_73* release_steering_motor_rpt_1_73();
  void set_allocated_steering_motor_rpt_1_73(::jmc_auto::canbus::Steering_motor_rpt_1_73* steering_motor_rpt_1_73);

  // optional .jmc_auto.canbus.Wiper_cmd_90 wiper_cmd_90 = 29;
  bool has_wiper_cmd_90() const;
  void clear_wiper_cmd_90();
  static const int kWiperCmd90FieldNumber = 29;
  const ::jmc_auto::canbus::Wiper_cmd_90& wiper_cmd_90() const;
  ::jmc_auto::canbus::Wiper_cmd_90* mutable_wiper_cmd_90();
  ::jmc_auto::canbus::Wiper_cmd_90* release_wiper_cmd_90();
  void set_allocated_wiper_cmd_90(::jmc_auto::canbus::Wiper_cmd_90* wiper_cmd_90);

  // optional .jmc_auto.canbus.Brake_motor_rpt_3_72 brake_motor_rpt_3_72 = 30;
  bool has_brake_motor_rpt_3_72() const;
  void clear_brake_motor_rpt_3_72();
  static const int kBrakeMotorRpt372FieldNumber = 30;
  const ::jmc_auto::canbus::Brake_motor_rpt_3_72& brake_motor_rpt_3_72() const;
  ::jmc_auto::canbus::Brake_motor_rpt_3_72* mutable_brake_motor_rpt_3_72();
  ::jmc_auto::canbus::Brake_motor_rpt_3_72* release_brake_motor_rpt_3_72();
  void set_allocated_brake_motor_rpt_3_72(::jmc_auto::canbus::Brake_motor_rpt_3_72* brake_motor_rpt_3_72);

  // @@protoc_insertion_point(class_scope:jmc_auto.canbus.Gem)
 private:
  void set_has_global_rpt_6a();
  void clear_has_global_rpt_6a();
  void set_has_brake_cmd_6b();
  void clear_has_brake_cmd_6b();
  void set_has_brake_rpt_6c();
  void clear_has_brake_rpt_6c();
  void set_has_steering_cmd_6d();
  void clear_has_steering_cmd_6d();
  void set_has_steering_rpt_1_6e();
  void clear_has_steering_rpt_1_6e();
  void set_has_wheel_speed_rpt_7a();
  void clear_has_wheel_speed_rpt_7a();
  void set_has_date_time_rpt_83();
  void clear_has_date_time_rpt_83();
  void set_has_brake_motor_rpt_1_70();
  void clear_has_brake_motor_rpt_1_70();
  void set_has_headlight_rpt_77();
  void clear_has_headlight_rpt_77();
  void set_has_accel_rpt_68();
  void clear_has_accel_rpt_68();
  void set_has_steering_motor_rpt_3_75();
  void clear_has_steering_motor_rpt_3_75();
  void set_has_turn_cmd_63();
  void clear_has_turn_cmd_63();
  void set_has_turn_rpt_64();
  void clear_has_turn_rpt_64();
  void set_has_shift_cmd_65();
  void clear_has_shift_cmd_65();
  void set_has_shift_rpt_66();
  void clear_has_shift_rpt_66();
  void set_has_accel_cmd_67();
  void clear_has_accel_cmd_67();
  void set_has_lat_lon_heading_rpt_82();
  void clear_has_lat_lon_heading_rpt_82();
  void set_has_global_cmd_69();
  void clear_has_global_cmd_69();
  void set_has_parking_brake_status_rpt_80();
  void clear_has_parking_brake_status_rpt_80();
  void set_has_yaw_rate_rpt_81();
  void clear_has_yaw_rate_rpt_81();
  void set_has_horn_rpt_79();
  void clear_has_horn_rpt_79();
  void set_has_horn_cmd_78();
  void clear_has_horn_cmd_78();
  void set_has_wiper_rpt_91();
  void clear_has_wiper_rpt_91();
  void set_has_vehicle_speed_rpt_6f();
  void clear_has_vehicle_speed_rpt_6f();
  void set_has_headlight_cmd_76();
  void clear_has_headlight_cmd_76();
  void set_has_steering_motor_rpt_2_74();
  void clear_has_steering_motor_rpt_2_74();
  void set_has_brake_motor_rpt_2_71();
  void clear_has_brake_motor_rpt_2_71();
  void set_has_steering_motor_rpt_1_73();
  void clear_has_steering_motor_rpt_1_73();
  void set_has_wiper_cmd_90();
  void clear_has_wiper_cmd_90();
  void set_has_brake_motor_rpt_3_72();
  void clear_has_brake_motor_rpt_3_72();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::canbus::Global_rpt_6a* global_rpt_6a_;
  ::jmc_auto::canbus::Brake_cmd_6b* brake_cmd_6b_;
  ::jmc_auto::canbus::Brake_rpt_6c* brake_rpt_6c_;
  ::jmc_auto::canbus::Steering_cmd_6d* steering_cmd_6d_;
  ::jmc_auto::canbus::Steering_rpt_1_6e* steering_rpt_1_6e_;
  ::jmc_auto::canbus::Wheel_speed_rpt_7a* wheel_speed_rpt_7a_;
  ::jmc_auto::canbus::Date_time_rpt_83* date_time_rpt_83_;
  ::jmc_auto::canbus::Brake_motor_rpt_1_70* brake_motor_rpt_1_70_;
  ::jmc_auto::canbus::Headlight_rpt_77* headlight_rpt_77_;
  ::jmc_auto::canbus::Accel_rpt_68* accel_rpt_68_;
  ::jmc_auto::canbus::Steering_motor_rpt_3_75* steering_motor_rpt_3_75_;
  ::jmc_auto::canbus::Turn_cmd_63* turn_cmd_63_;
  ::jmc_auto::canbus::Turn_rpt_64* turn_rpt_64_;
  ::jmc_auto::canbus::Shift_cmd_65* shift_cmd_65_;
  ::jmc_auto::canbus::Shift_rpt_66* shift_rpt_66_;
  ::jmc_auto::canbus::Accel_cmd_67* accel_cmd_67_;
  ::jmc_auto::canbus::Lat_lon_heading_rpt_82* lat_lon_heading_rpt_82_;
  ::jmc_auto::canbus::Global_cmd_69* global_cmd_69_;
  ::jmc_auto::canbus::Parking_brake_status_rpt_80* parking_brake_status_rpt_80_;
  ::jmc_auto::canbus::Yaw_rate_rpt_81* yaw_rate_rpt_81_;
  ::jmc_auto::canbus::Horn_rpt_79* horn_rpt_79_;
  ::jmc_auto::canbus::Horn_cmd_78* horn_cmd_78_;
  ::jmc_auto::canbus::Wiper_rpt_91* wiper_rpt_91_;
  ::jmc_auto::canbus::Vehicle_speed_rpt_6f* vehicle_speed_rpt_6f_;
  ::jmc_auto::canbus::Headlight_cmd_76* headlight_cmd_76_;
  ::jmc_auto::canbus::Steering_motor_rpt_2_74* steering_motor_rpt_2_74_;
  ::jmc_auto::canbus::Brake_motor_rpt_2_71* brake_motor_rpt_2_71_;
  ::jmc_auto::canbus::Steering_motor_rpt_1_73* steering_motor_rpt_1_73_;
  ::jmc_auto::canbus::Wiper_cmd_90* wiper_cmd_90_;
  ::jmc_auto::canbus::Brake_motor_rpt_3_72* brake_motor_rpt_3_72_;
  friend struct protobuf_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChassisDetail

// optional .jmc_auto.canbus.ChassisDetail.Type car_type = 1;
inline bool ChassisDetail::has_car_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ChassisDetail::set_has_car_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ChassisDetail::clear_has_car_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ChassisDetail::clear_car_type() {
  car_type_ = 0;
  clear_has_car_type();
}
inline ::jmc_auto::canbus::ChassisDetail_Type ChassisDetail::car_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.car_type)
  return static_cast< ::jmc_auto::canbus::ChassisDetail_Type >(car_type_);
}
inline void ChassisDetail::set_car_type(::jmc_auto::canbus::ChassisDetail_Type value) {
  assert(::jmc_auto::canbus::ChassisDetail_Type_IsValid(value));
  set_has_car_type();
  car_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.ChassisDetail.car_type)
}

// optional .jmc_auto.canbus.BasicInfo basic = 2;
inline bool ChassisDetail::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChassisDetail::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChassisDetail::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChassisDetail::clear_basic() {
  if (basic_ != NULL) basic_->::jmc_auto::canbus::BasicInfo::Clear();
  clear_has_basic();
}
inline const ::jmc_auto::canbus::BasicInfo& ChassisDetail::basic() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.basic)
  return basic_ != NULL ? *basic_
                         : *::jmc_auto::canbus::BasicInfo::internal_default_instance();
}
inline ::jmc_auto::canbus::BasicInfo* ChassisDetail::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    basic_ = new ::jmc_auto::canbus::BasicInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.basic)
  return basic_;
}
inline ::jmc_auto::canbus::BasicInfo* ChassisDetail::release_basic() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.basic)
  clear_has_basic();
  ::jmc_auto::canbus::BasicInfo* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_basic(::jmc_auto::canbus::BasicInfo* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.basic)
}

// optional .jmc_auto.canbus.Safety safety = 3;
inline bool ChassisDetail::has_safety() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChassisDetail::set_has_safety() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChassisDetail::clear_has_safety() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChassisDetail::clear_safety() {
  if (safety_ != NULL) safety_->::jmc_auto::canbus::Safety::Clear();
  clear_has_safety();
}
inline const ::jmc_auto::canbus::Safety& ChassisDetail::safety() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.safety)
  return safety_ != NULL ? *safety_
                         : *::jmc_auto::canbus::Safety::internal_default_instance();
}
inline ::jmc_auto::canbus::Safety* ChassisDetail::mutable_safety() {
  set_has_safety();
  if (safety_ == NULL) {
    safety_ = new ::jmc_auto::canbus::Safety;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.safety)
  return safety_;
}
inline ::jmc_auto::canbus::Safety* ChassisDetail::release_safety() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.safety)
  clear_has_safety();
  ::jmc_auto::canbus::Safety* temp = safety_;
  safety_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_safety(::jmc_auto::canbus::Safety* safety) {
  delete safety_;
  safety_ = safety;
  if (safety) {
    set_has_safety();
  } else {
    clear_has_safety();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.safety)
}

// optional .jmc_auto.canbus.Gear gear = 4;
inline bool ChassisDetail::has_gear() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChassisDetail::set_has_gear() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChassisDetail::clear_has_gear() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChassisDetail::clear_gear() {
  if (gear_ != NULL) gear_->::jmc_auto::canbus::Gear::Clear();
  clear_has_gear();
}
inline const ::jmc_auto::canbus::Gear& ChassisDetail::gear() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.gear)
  return gear_ != NULL ? *gear_
                         : *::jmc_auto::canbus::Gear::internal_default_instance();
}
inline ::jmc_auto::canbus::Gear* ChassisDetail::mutable_gear() {
  set_has_gear();
  if (gear_ == NULL) {
    gear_ = new ::jmc_auto::canbus::Gear;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.gear)
  return gear_;
}
inline ::jmc_auto::canbus::Gear* ChassisDetail::release_gear() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.gear)
  clear_has_gear();
  ::jmc_auto::canbus::Gear* temp = gear_;
  gear_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_gear(::jmc_auto::canbus::Gear* gear) {
  delete gear_;
  gear_ = gear;
  if (gear) {
    set_has_gear();
  } else {
    clear_has_gear();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.gear)
}

// optional .jmc_auto.canbus.Ems ems = 5;
inline bool ChassisDetail::has_ems() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChassisDetail::set_has_ems() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChassisDetail::clear_has_ems() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChassisDetail::clear_ems() {
  if (ems_ != NULL) ems_->::jmc_auto::canbus::Ems::Clear();
  clear_has_ems();
}
inline const ::jmc_auto::canbus::Ems& ChassisDetail::ems() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.ems)
  return ems_ != NULL ? *ems_
                         : *::jmc_auto::canbus::Ems::internal_default_instance();
}
inline ::jmc_auto::canbus::Ems* ChassisDetail::mutable_ems() {
  set_has_ems();
  if (ems_ == NULL) {
    ems_ = new ::jmc_auto::canbus::Ems;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.ems)
  return ems_;
}
inline ::jmc_auto::canbus::Ems* ChassisDetail::release_ems() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.ems)
  clear_has_ems();
  ::jmc_auto::canbus::Ems* temp = ems_;
  ems_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_ems(::jmc_auto::canbus::Ems* ems) {
  delete ems_;
  ems_ = ems;
  if (ems) {
    set_has_ems();
  } else {
    clear_has_ems();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.ems)
}

// optional .jmc_auto.canbus.Esp esp = 6;
inline bool ChassisDetail::has_esp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChassisDetail::set_has_esp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChassisDetail::clear_has_esp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChassisDetail::clear_esp() {
  if (esp_ != NULL) esp_->::jmc_auto::canbus::Esp::Clear();
  clear_has_esp();
}
inline const ::jmc_auto::canbus::Esp& ChassisDetail::esp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.esp)
  return esp_ != NULL ? *esp_
                         : *::jmc_auto::canbus::Esp::internal_default_instance();
}
inline ::jmc_auto::canbus::Esp* ChassisDetail::mutable_esp() {
  set_has_esp();
  if (esp_ == NULL) {
    esp_ = new ::jmc_auto::canbus::Esp;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.esp)
  return esp_;
}
inline ::jmc_auto::canbus::Esp* ChassisDetail::release_esp() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.esp)
  clear_has_esp();
  ::jmc_auto::canbus::Esp* temp = esp_;
  esp_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_esp(::jmc_auto::canbus::Esp* esp) {
  delete esp_;
  esp_ = esp;
  if (esp) {
    set_has_esp();
  } else {
    clear_has_esp();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.esp)
}

// optional .jmc_auto.canbus.Gas gas = 7;
inline bool ChassisDetail::has_gas() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChassisDetail::set_has_gas() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChassisDetail::clear_has_gas() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChassisDetail::clear_gas() {
  if (gas_ != NULL) gas_->::jmc_auto::canbus::Gas::Clear();
  clear_has_gas();
}
inline const ::jmc_auto::canbus::Gas& ChassisDetail::gas() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.gas)
  return gas_ != NULL ? *gas_
                         : *::jmc_auto::canbus::Gas::internal_default_instance();
}
inline ::jmc_auto::canbus::Gas* ChassisDetail::mutable_gas() {
  set_has_gas();
  if (gas_ == NULL) {
    gas_ = new ::jmc_auto::canbus::Gas;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.gas)
  return gas_;
}
inline ::jmc_auto::canbus::Gas* ChassisDetail::release_gas() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.gas)
  clear_has_gas();
  ::jmc_auto::canbus::Gas* temp = gas_;
  gas_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_gas(::jmc_auto::canbus::Gas* gas) {
  delete gas_;
  gas_ = gas;
  if (gas) {
    set_has_gas();
  } else {
    clear_has_gas();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.gas)
}

// optional .jmc_auto.canbus.Epb epb = 8;
inline bool ChassisDetail::has_epb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChassisDetail::set_has_epb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChassisDetail::clear_has_epb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChassisDetail::clear_epb() {
  if (epb_ != NULL) epb_->::jmc_auto::canbus::Epb::Clear();
  clear_has_epb();
}
inline const ::jmc_auto::canbus::Epb& ChassisDetail::epb() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.epb)
  return epb_ != NULL ? *epb_
                         : *::jmc_auto::canbus::Epb::internal_default_instance();
}
inline ::jmc_auto::canbus::Epb* ChassisDetail::mutable_epb() {
  set_has_epb();
  if (epb_ == NULL) {
    epb_ = new ::jmc_auto::canbus::Epb;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.epb)
  return epb_;
}
inline ::jmc_auto::canbus::Epb* ChassisDetail::release_epb() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.epb)
  clear_has_epb();
  ::jmc_auto::canbus::Epb* temp = epb_;
  epb_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_epb(::jmc_auto::canbus::Epb* epb) {
  delete epb_;
  epb_ = epb;
  if (epb) {
    set_has_epb();
  } else {
    clear_has_epb();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.epb)
}

// optional .jmc_auto.canbus.Brake brake = 9;
inline bool ChassisDetail::has_brake() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChassisDetail::set_has_brake() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChassisDetail::clear_has_brake() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChassisDetail::clear_brake() {
  if (brake_ != NULL) brake_->::jmc_auto::canbus::Brake::Clear();
  clear_has_brake();
}
inline const ::jmc_auto::canbus::Brake& ChassisDetail::brake() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.brake)
  return brake_ != NULL ? *brake_
                         : *::jmc_auto::canbus::Brake::internal_default_instance();
}
inline ::jmc_auto::canbus::Brake* ChassisDetail::mutable_brake() {
  set_has_brake();
  if (brake_ == NULL) {
    brake_ = new ::jmc_auto::canbus::Brake;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.brake)
  return brake_;
}
inline ::jmc_auto::canbus::Brake* ChassisDetail::release_brake() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.brake)
  clear_has_brake();
  ::jmc_auto::canbus::Brake* temp = brake_;
  brake_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_brake(::jmc_auto::canbus::Brake* brake) {
  delete brake_;
  brake_ = brake;
  if (brake) {
    set_has_brake();
  } else {
    clear_has_brake();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.brake)
}

// optional .jmc_auto.canbus.Deceleration deceleration = 10;
inline bool ChassisDetail::has_deceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChassisDetail::set_has_deceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChassisDetail::clear_has_deceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChassisDetail::clear_deceleration() {
  if (deceleration_ != NULL) deceleration_->::jmc_auto::canbus::Deceleration::Clear();
  clear_has_deceleration();
}
inline const ::jmc_auto::canbus::Deceleration& ChassisDetail::deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.deceleration)
  return deceleration_ != NULL ? *deceleration_
                         : *::jmc_auto::canbus::Deceleration::internal_default_instance();
}
inline ::jmc_auto::canbus::Deceleration* ChassisDetail::mutable_deceleration() {
  set_has_deceleration();
  if (deceleration_ == NULL) {
    deceleration_ = new ::jmc_auto::canbus::Deceleration;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.deceleration)
  return deceleration_;
}
inline ::jmc_auto::canbus::Deceleration* ChassisDetail::release_deceleration() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.deceleration)
  clear_has_deceleration();
  ::jmc_auto::canbus::Deceleration* temp = deceleration_;
  deceleration_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_deceleration(::jmc_auto::canbus::Deceleration* deceleration) {
  delete deceleration_;
  deceleration_ = deceleration;
  if (deceleration) {
    set_has_deceleration();
  } else {
    clear_has_deceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.deceleration)
}

// optional .jmc_auto.canbus.VehicleSpd vehicle_spd = 11;
inline bool ChassisDetail::has_vehicle_spd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ChassisDetail::set_has_vehicle_spd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ChassisDetail::clear_has_vehicle_spd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ChassisDetail::clear_vehicle_spd() {
  if (vehicle_spd_ != NULL) vehicle_spd_->::jmc_auto::canbus::VehicleSpd::Clear();
  clear_has_vehicle_spd();
}
inline const ::jmc_auto::canbus::VehicleSpd& ChassisDetail::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.vehicle_spd)
  return vehicle_spd_ != NULL ? *vehicle_spd_
                         : *::jmc_auto::canbus::VehicleSpd::internal_default_instance();
}
inline ::jmc_auto::canbus::VehicleSpd* ChassisDetail::mutable_vehicle_spd() {
  set_has_vehicle_spd();
  if (vehicle_spd_ == NULL) {
    vehicle_spd_ = new ::jmc_auto::canbus::VehicleSpd;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.vehicle_spd)
  return vehicle_spd_;
}
inline ::jmc_auto::canbus::VehicleSpd* ChassisDetail::release_vehicle_spd() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.vehicle_spd)
  clear_has_vehicle_spd();
  ::jmc_auto::canbus::VehicleSpd* temp = vehicle_spd_;
  vehicle_spd_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_vehicle_spd(::jmc_auto::canbus::VehicleSpd* vehicle_spd) {
  delete vehicle_spd_;
  vehicle_spd_ = vehicle_spd;
  if (vehicle_spd) {
    set_has_vehicle_spd();
  } else {
    clear_has_vehicle_spd();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.vehicle_spd)
}

// optional .jmc_auto.canbus.Eps eps = 12;
inline bool ChassisDetail::has_eps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ChassisDetail::set_has_eps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ChassisDetail::clear_has_eps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ChassisDetail::clear_eps() {
  if (eps_ != NULL) eps_->::jmc_auto::canbus::Eps::Clear();
  clear_has_eps();
}
inline const ::jmc_auto::canbus::Eps& ChassisDetail::eps() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.eps)
  return eps_ != NULL ? *eps_
                         : *::jmc_auto::canbus::Eps::internal_default_instance();
}
inline ::jmc_auto::canbus::Eps* ChassisDetail::mutable_eps() {
  set_has_eps();
  if (eps_ == NULL) {
    eps_ = new ::jmc_auto::canbus::Eps;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.eps)
  return eps_;
}
inline ::jmc_auto::canbus::Eps* ChassisDetail::release_eps() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.eps)
  clear_has_eps();
  ::jmc_auto::canbus::Eps* temp = eps_;
  eps_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_eps(::jmc_auto::canbus::Eps* eps) {
  delete eps_;
  eps_ = eps;
  if (eps) {
    set_has_eps();
  } else {
    clear_has_eps();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.eps)
}

// optional .jmc_auto.canbus.Light light = 13;
inline bool ChassisDetail::has_light() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ChassisDetail::set_has_light() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ChassisDetail::clear_has_light() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ChassisDetail::clear_light() {
  if (light_ != NULL) light_->::jmc_auto::canbus::Light::Clear();
  clear_has_light();
}
inline const ::jmc_auto::canbus::Light& ChassisDetail::light() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.light)
  return light_ != NULL ? *light_
                         : *::jmc_auto::canbus::Light::internal_default_instance();
}
inline ::jmc_auto::canbus::Light* ChassisDetail::mutable_light() {
  set_has_light();
  if (light_ == NULL) {
    light_ = new ::jmc_auto::canbus::Light;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.light)
  return light_;
}
inline ::jmc_auto::canbus::Light* ChassisDetail::release_light() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.light)
  clear_has_light();
  ::jmc_auto::canbus::Light* temp = light_;
  light_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_light(::jmc_auto::canbus::Light* light) {
  delete light_;
  light_ = light;
  if (light) {
    set_has_light();
  } else {
    clear_has_light();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.light)
}

// optional .jmc_auto.canbus.Battery battery = 14;
inline bool ChassisDetail::has_battery() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ChassisDetail::set_has_battery() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ChassisDetail::clear_has_battery() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ChassisDetail::clear_battery() {
  if (battery_ != NULL) battery_->::jmc_auto::canbus::Battery::Clear();
  clear_has_battery();
}
inline const ::jmc_auto::canbus::Battery& ChassisDetail::battery() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.battery)
  return battery_ != NULL ? *battery_
                         : *::jmc_auto::canbus::Battery::internal_default_instance();
}
inline ::jmc_auto::canbus::Battery* ChassisDetail::mutable_battery() {
  set_has_battery();
  if (battery_ == NULL) {
    battery_ = new ::jmc_auto::canbus::Battery;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.battery)
  return battery_;
}
inline ::jmc_auto::canbus::Battery* ChassisDetail::release_battery() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.battery)
  clear_has_battery();
  ::jmc_auto::canbus::Battery* temp = battery_;
  battery_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_battery(::jmc_auto::canbus::Battery* battery) {
  delete battery_;
  battery_ = battery;
  if (battery) {
    set_has_battery();
  } else {
    clear_has_battery();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.battery)
}

// optional .jmc_auto.canbus.CheckResponseSignal check_response = 15;
inline bool ChassisDetail::has_check_response() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ChassisDetail::set_has_check_response() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ChassisDetail::clear_has_check_response() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ChassisDetail::clear_check_response() {
  if (check_response_ != NULL) check_response_->::jmc_auto::canbus::CheckResponseSignal::Clear();
  clear_has_check_response();
}
inline const ::jmc_auto::canbus::CheckResponseSignal& ChassisDetail::check_response() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.check_response)
  return check_response_ != NULL ? *check_response_
                         : *::jmc_auto::canbus::CheckResponseSignal::internal_default_instance();
}
inline ::jmc_auto::canbus::CheckResponseSignal* ChassisDetail::mutable_check_response() {
  set_has_check_response();
  if (check_response_ == NULL) {
    check_response_ = new ::jmc_auto::canbus::CheckResponseSignal;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.check_response)
  return check_response_;
}
inline ::jmc_auto::canbus::CheckResponseSignal* ChassisDetail::release_check_response() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.check_response)
  clear_has_check_response();
  ::jmc_auto::canbus::CheckResponseSignal* temp = check_response_;
  check_response_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_check_response(::jmc_auto::canbus::CheckResponseSignal* check_response) {
  delete check_response_;
  check_response_ = check_response;
  if (check_response) {
    set_has_check_response();
  } else {
    clear_has_check_response();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.check_response)
}

// optional .jmc_auto.canbus.License license = 16;
inline bool ChassisDetail::has_license() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ChassisDetail::set_has_license() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ChassisDetail::clear_has_license() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ChassisDetail::clear_license() {
  if (license_ != NULL) license_->::jmc_auto::canbus::License::Clear();
  clear_has_license();
}
inline const ::jmc_auto::canbus::License& ChassisDetail::license() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.license)
  return license_ != NULL ? *license_
                         : *::jmc_auto::canbus::License::internal_default_instance();
}
inline ::jmc_auto::canbus::License* ChassisDetail::mutable_license() {
  set_has_license();
  if (license_ == NULL) {
    license_ = new ::jmc_auto::canbus::License;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.license)
  return license_;
}
inline ::jmc_auto::canbus::License* ChassisDetail::release_license() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.license)
  clear_has_license();
  ::jmc_auto::canbus::License* temp = license_;
  license_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_license(::jmc_auto::canbus::License* license) {
  delete license_;
  license_ = license;
  if (license) {
    set_has_license();
  } else {
    clear_has_license();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.license)
}

// optional .jmc_auto.canbus.Surround surround = 17;
inline bool ChassisDetail::has_surround() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ChassisDetail::set_has_surround() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ChassisDetail::clear_has_surround() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ChassisDetail::clear_surround() {
  if (surround_ != NULL) surround_->::jmc_auto::canbus::Surround::Clear();
  clear_has_surround();
}
inline const ::jmc_auto::canbus::Surround& ChassisDetail::surround() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.surround)
  return surround_ != NULL ? *surround_
                         : *::jmc_auto::canbus::Surround::internal_default_instance();
}
inline ::jmc_auto::canbus::Surround* ChassisDetail::mutable_surround() {
  set_has_surround();
  if (surround_ == NULL) {
    surround_ = new ::jmc_auto::canbus::Surround;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.surround)
  return surround_;
}
inline ::jmc_auto::canbus::Surround* ChassisDetail::release_surround() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.surround)
  clear_has_surround();
  ::jmc_auto::canbus::Surround* temp = surround_;
  surround_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_surround(::jmc_auto::canbus::Surround* surround) {
  delete surround_;
  surround_ = surround;
  if (surround) {
    set_has_surround();
  } else {
    clear_has_surround();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.surround)
}

// optional .jmc_auto.canbus.Gem gem = 18;
inline bool ChassisDetail::has_gem() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ChassisDetail::set_has_gem() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ChassisDetail::clear_has_gem() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ChassisDetail::clear_gem() {
  if (gem_ != NULL) gem_->::jmc_auto::canbus::Gem::Clear();
  clear_has_gem();
}
inline const ::jmc_auto::canbus::Gem& ChassisDetail::gem() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.gem)
  return gem_ != NULL ? *gem_
                         : *::jmc_auto::canbus::Gem::internal_default_instance();
}
inline ::jmc_auto::canbus::Gem* ChassisDetail::mutable_gem() {
  set_has_gem();
  if (gem_ == NULL) {
    gem_ = new ::jmc_auto::canbus::Gem;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.gem)
  return gem_;
}
inline ::jmc_auto::canbus::Gem* ChassisDetail::release_gem() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.gem)
  clear_has_gem();
  ::jmc_auto::canbus::Gem* temp = gem_;
  gem_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_gem(::jmc_auto::canbus::Gem* gem) {
  delete gem_;
  gem_ = gem;
  if (gem) {
    set_has_gem();
  } else {
    clear_has_gem();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.gem)
}

// optional .jmc_auto.canbus.Ch ch = 19;
inline bool ChassisDetail::has_ch() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ChassisDetail::set_has_ch() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ChassisDetail::clear_has_ch() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ChassisDetail::clear_ch() {
  if (ch_ != NULL) ch_->::jmc_auto::canbus::Ch::Clear();
  clear_has_ch();
}
inline const ::jmc_auto::canbus::Ch& ChassisDetail::ch() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.ch)
  return ch_ != NULL ? *ch_
                         : *::jmc_auto::canbus::Ch::internal_default_instance();
}
inline ::jmc_auto::canbus::Ch* ChassisDetail::mutable_ch() {
  set_has_ch();
  if (ch_ == NULL) {
    ch_ = new ::jmc_auto::canbus::Ch;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.ch)
  return ch_;
}
inline ::jmc_auto::canbus::Ch* ChassisDetail::release_ch() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.ch)
  clear_has_ch();
  ::jmc_auto::canbus::Ch* temp = ch_;
  ch_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_ch(::jmc_auto::canbus::Ch* ch) {
  delete ch_;
  ch_ = ch;
  if (ch) {
    set_has_ch();
  } else {
    clear_has_ch();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.ch)
}

// optional .jmc_auto.canbus.Teshun teshun = 20;
inline bool ChassisDetail::has_teshun() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ChassisDetail::set_has_teshun() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ChassisDetail::clear_has_teshun() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ChassisDetail::clear_teshun() {
  if (teshun_ != NULL) teshun_->::jmc_auto::canbus::Teshun::Clear();
  clear_has_teshun();
}
inline const ::jmc_auto::canbus::Teshun& ChassisDetail::teshun() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.teshun)
  return teshun_ != NULL ? *teshun_
                         : *::jmc_auto::canbus::Teshun::internal_default_instance();
}
inline ::jmc_auto::canbus::Teshun* ChassisDetail::mutable_teshun() {
  set_has_teshun();
  if (teshun_ == NULL) {
    teshun_ = new ::jmc_auto::canbus::Teshun;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.teshun)
  return teshun_;
}
inline ::jmc_auto::canbus::Teshun* ChassisDetail::release_teshun() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.teshun)
  clear_has_teshun();
  ::jmc_auto::canbus::Teshun* temp = teshun_;
  teshun_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_teshun(::jmc_auto::canbus::Teshun* teshun) {
  delete teshun_;
  teshun_ = teshun;
  if (teshun) {
    set_has_teshun();
  } else {
    clear_has_teshun();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.teshun)
}

// optional .jmc_auto.canbus.Cx75 cx75 = 21;
inline bool ChassisDetail::has_cx75() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ChassisDetail::set_has_cx75() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ChassisDetail::clear_has_cx75() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ChassisDetail::clear_cx75() {
  if (cx75_ != NULL) cx75_->::jmc_auto::canbus::Cx75::Clear();
  clear_has_cx75();
}
inline const ::jmc_auto::canbus::Cx75& ChassisDetail::cx75() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.ChassisDetail.cx75)
  return cx75_ != NULL ? *cx75_
                         : *::jmc_auto::canbus::Cx75::internal_default_instance();
}
inline ::jmc_auto::canbus::Cx75* ChassisDetail::mutable_cx75() {
  set_has_cx75();
  if (cx75_ == NULL) {
    cx75_ = new ::jmc_auto::canbus::Cx75;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.ChassisDetail.cx75)
  return cx75_;
}
inline ::jmc_auto::canbus::Cx75* ChassisDetail::release_cx75() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.ChassisDetail.cx75)
  clear_has_cx75();
  ::jmc_auto::canbus::Cx75* temp = cx75_;
  cx75_ = NULL;
  return temp;
}
inline void ChassisDetail::set_allocated_cx75(::jmc_auto::canbus::Cx75* cx75) {
  delete cx75_;
  cx75_ = cx75;
  if (cx75) {
    set_has_cx75();
  } else {
    clear_has_cx75();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.ChassisDetail.cx75)
}

// -------------------------------------------------------------------

// CheckResponseSignal

// optional bool is_eps_online = 1 [default = false];
inline bool CheckResponseSignal::has_is_eps_online() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckResponseSignal::set_has_is_eps_online() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckResponseSignal::clear_has_is_eps_online() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckResponseSignal::clear_is_eps_online() {
  is_eps_online_ = false;
  clear_has_is_eps_online();
}
inline bool CheckResponseSignal::is_eps_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_eps_online)
  return is_eps_online_;
}
inline void CheckResponseSignal::set_is_eps_online(bool value) {
  set_has_is_eps_online();
  is_eps_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_eps_online)
}

// optional bool is_epb_online = 2 [default = false];
inline bool CheckResponseSignal::has_is_epb_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckResponseSignal::set_has_is_epb_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckResponseSignal::clear_has_is_epb_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckResponseSignal::clear_is_epb_online() {
  is_epb_online_ = false;
  clear_has_is_epb_online();
}
inline bool CheckResponseSignal::is_epb_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_epb_online)
  return is_epb_online_;
}
inline void CheckResponseSignal::set_is_epb_online(bool value) {
  set_has_is_epb_online();
  is_epb_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_epb_online)
}

// optional bool is_esp_online = 3 [default = false];
inline bool CheckResponseSignal::has_is_esp_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckResponseSignal::set_has_is_esp_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckResponseSignal::clear_has_is_esp_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckResponseSignal::clear_is_esp_online() {
  is_esp_online_ = false;
  clear_has_is_esp_online();
}
inline bool CheckResponseSignal::is_esp_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_esp_online)
  return is_esp_online_;
}
inline void CheckResponseSignal::set_is_esp_online(bool value) {
  set_has_is_esp_online();
  is_esp_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_esp_online)
}

// optional bool is_vtog_online = 4 [default = false];
inline bool CheckResponseSignal::has_is_vtog_online() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckResponseSignal::set_has_is_vtog_online() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckResponseSignal::clear_has_is_vtog_online() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckResponseSignal::clear_is_vtog_online() {
  is_vtog_online_ = false;
  clear_has_is_vtog_online();
}
inline bool CheckResponseSignal::is_vtog_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_vtog_online)
  return is_vtog_online_;
}
inline void CheckResponseSignal::set_is_vtog_online(bool value) {
  set_has_is_vtog_online();
  is_vtog_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_vtog_online)
}

// optional bool is_scu_online = 5 [default = false];
inline bool CheckResponseSignal::has_is_scu_online() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckResponseSignal::set_has_is_scu_online() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckResponseSignal::clear_has_is_scu_online() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckResponseSignal::clear_is_scu_online() {
  is_scu_online_ = false;
  clear_has_is_scu_online();
}
inline bool CheckResponseSignal::is_scu_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_scu_online)
  return is_scu_online_;
}
inline void CheckResponseSignal::set_is_scu_online(bool value) {
  set_has_is_scu_online();
  is_scu_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_scu_online)
}

// optional bool is_switch_online = 6 [default = false];
inline bool CheckResponseSignal::has_is_switch_online() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckResponseSignal::set_has_is_switch_online() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckResponseSignal::clear_has_is_switch_online() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckResponseSignal::clear_is_switch_online() {
  is_switch_online_ = false;
  clear_has_is_switch_online();
}
inline bool CheckResponseSignal::is_switch_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_switch_online)
  return is_switch_online_;
}
inline void CheckResponseSignal::set_is_switch_online(bool value) {
  set_has_is_switch_online();
  is_switch_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_switch_online)
}

// optional bool is_vcu_online = 7 [default = false];
inline bool CheckResponseSignal::has_is_vcu_online() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckResponseSignal::set_has_is_vcu_online() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckResponseSignal::clear_has_is_vcu_online() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckResponseSignal::clear_is_vcu_online() {
  is_vcu_online_ = false;
  clear_has_is_vcu_online();
}
inline bool CheckResponseSignal::is_vcu_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_vcu_online)
  return is_vcu_online_;
}
inline void CheckResponseSignal::set_is_vcu_online(bool value) {
  set_has_is_vcu_online();
  is_vcu_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_vcu_online)
}

// optional bool is_apa_online = 8 [default = false];
inline bool CheckResponseSignal::has_is_apa_online() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CheckResponseSignal::set_has_is_apa_online() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CheckResponseSignal::clear_has_is_apa_online() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CheckResponseSignal::clear_is_apa_online() {
  is_apa_online_ = false;
  clear_has_is_apa_online();
}
inline bool CheckResponseSignal::is_apa_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_apa_online)
  return is_apa_online_;
}
inline void CheckResponseSignal::set_is_apa_online(bool value) {
  set_has_is_apa_online();
  is_apa_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_apa_online)
}

// optional bool is_epspam_online = 9 [default = false];
inline bool CheckResponseSignal::has_is_epspam_online() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CheckResponseSignal::set_has_is_epspam_online() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CheckResponseSignal::clear_has_is_epspam_online() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CheckResponseSignal::clear_is_epspam_online() {
  is_epspam_online_ = false;
  clear_has_is_epspam_online();
}
inline bool CheckResponseSignal::is_epspam_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.CheckResponseSignal.is_epspam_online)
  return is_epspam_online_;
}
inline void CheckResponseSignal::set_is_epspam_online(bool value) {
  set_has_is_epspam_online();
  is_epspam_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.CheckResponseSignal.is_epspam_online)
}

// -------------------------------------------------------------------

// Battery

// optional double battery_percent = 1;
inline bool Battery::has_battery_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Battery::set_has_battery_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Battery::clear_has_battery_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Battery::clear_battery_percent() {
  battery_percent_ = 0;
  clear_has_battery_percent();
}
inline double Battery::battery_percent() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Battery.battery_percent)
  return battery_percent_;
}
inline void Battery::set_battery_percent(double value) {
  set_has_battery_percent();
  battery_percent_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Battery.battery_percent)
}

// optional double fuel_level = 2;
inline bool Battery::has_fuel_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Battery::set_has_fuel_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Battery::clear_has_fuel_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Battery::clear_fuel_level() {
  fuel_level_ = 0;
  clear_has_fuel_level();
}
inline double Battery::fuel_level() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Battery.fuel_level)
  return fuel_level_;
}
inline void Battery::set_fuel_level(double value) {
  set_has_fuel_level();
  fuel_level_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Battery.fuel_level)
}

// -------------------------------------------------------------------

// Light

// optional .jmc_auto.canbus.Light.TurnLightType turn_light_type = 1;
inline bool Light::has_turn_light_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light::set_has_turn_light_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light::clear_has_turn_light_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light::clear_turn_light_type() {
  turn_light_type_ = 0;
  clear_has_turn_light_type();
}
inline ::jmc_auto::canbus::Light_TurnLightType Light::turn_light_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.turn_light_type)
  return static_cast< ::jmc_auto::canbus::Light_TurnLightType >(turn_light_type_);
}
inline void Light::set_turn_light_type(::jmc_auto::canbus::Light_TurnLightType value) {
  assert(::jmc_auto::canbus::Light_TurnLightType_IsValid(value));
  set_has_turn_light_type();
  turn_light_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.turn_light_type)
}

// optional .jmc_auto.canbus.Light.BeamLampType beam_lamp_type = 2;
inline bool Light::has_beam_lamp_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light::set_has_beam_lamp_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light::clear_has_beam_lamp_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light::clear_beam_lamp_type() {
  beam_lamp_type_ = 0;
  clear_has_beam_lamp_type();
}
inline ::jmc_auto::canbus::Light_BeamLampType Light::beam_lamp_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.beam_lamp_type)
  return static_cast< ::jmc_auto::canbus::Light_BeamLampType >(beam_lamp_type_);
}
inline void Light::set_beam_lamp_type(::jmc_auto::canbus::Light_BeamLampType value) {
  assert(::jmc_auto::canbus::Light_BeamLampType_IsValid(value));
  set_has_beam_lamp_type();
  beam_lamp_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.beam_lamp_type)
}

// optional bool is_brake_lamp_on = 3;
inline bool Light::has_is_brake_lamp_on() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light::set_has_is_brake_lamp_on() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light::clear_has_is_brake_lamp_on() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light::clear_is_brake_lamp_on() {
  is_brake_lamp_on_ = false;
  clear_has_is_brake_lamp_on();
}
inline bool Light::is_brake_lamp_on() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.is_brake_lamp_on)
  return is_brake_lamp_on_;
}
inline void Light::set_is_brake_lamp_on(bool value) {
  set_has_is_brake_lamp_on();
  is_brake_lamp_on_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.is_brake_lamp_on)
}

// optional bool is_auto_light = 4;
inline bool Light::has_is_auto_light() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Light::set_has_is_auto_light() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Light::clear_has_is_auto_light() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Light::clear_is_auto_light() {
  is_auto_light_ = false;
  clear_has_is_auto_light();
}
inline bool Light::is_auto_light() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.is_auto_light)
  return is_auto_light_;
}
inline void Light::set_is_auto_light(bool value) {
  set_has_is_auto_light();
  is_auto_light_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.is_auto_light)
}

// optional int32 wiper_gear = 5;
inline bool Light::has_wiper_gear() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Light::set_has_wiper_gear() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Light::clear_has_wiper_gear() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Light::clear_wiper_gear() {
  wiper_gear_ = 0;
  clear_has_wiper_gear();
}
inline ::google::protobuf::int32 Light::wiper_gear() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.wiper_gear)
  return wiper_gear_;
}
inline void Light::set_wiper_gear(::google::protobuf::int32 value) {
  set_has_wiper_gear();
  wiper_gear_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.wiper_gear)
}

// optional int32 lotion_gear = 6;
inline bool Light::has_lotion_gear() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Light::set_has_lotion_gear() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Light::clear_has_lotion_gear() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Light::clear_lotion_gear() {
  lotion_gear_ = 0;
  clear_has_lotion_gear();
}
inline ::google::protobuf::int32 Light::lotion_gear() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.lotion_gear)
  return lotion_gear_;
}
inline void Light::set_lotion_gear(::google::protobuf::int32 value) {
  set_has_lotion_gear();
  lotion_gear_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.lotion_gear)
}

// optional bool is_horn_on = 7;
inline bool Light::has_is_horn_on() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Light::set_has_is_horn_on() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Light::clear_has_is_horn_on() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Light::clear_is_horn_on() {
  is_horn_on_ = false;
  clear_has_is_horn_on();
}
inline bool Light::is_horn_on() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.is_horn_on)
  return is_horn_on_;
}
inline void Light::set_is_horn_on(bool value) {
  set_has_is_horn_on();
  is_horn_on_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.is_horn_on)
}

// optional .jmc_auto.canbus.Light.LincolnLampType lincoln_lamp_type = 8;
inline bool Light::has_lincoln_lamp_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Light::set_has_lincoln_lamp_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Light::clear_has_lincoln_lamp_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Light::clear_lincoln_lamp_type() {
  lincoln_lamp_type_ = 0;
  clear_has_lincoln_lamp_type();
}
inline ::jmc_auto::canbus::Light_LincolnLampType Light::lincoln_lamp_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.lincoln_lamp_type)
  return static_cast< ::jmc_auto::canbus::Light_LincolnLampType >(lincoln_lamp_type_);
}
inline void Light::set_lincoln_lamp_type(::jmc_auto::canbus::Light_LincolnLampType value) {
  assert(::jmc_auto::canbus::Light_LincolnLampType_IsValid(value));
  set_has_lincoln_lamp_type();
  lincoln_lamp_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.lincoln_lamp_type)
}

// optional .jmc_auto.canbus.Light.LincolnWiperType lincoln_wiper = 9;
inline bool Light::has_lincoln_wiper() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Light::set_has_lincoln_wiper() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Light::clear_has_lincoln_wiper() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Light::clear_lincoln_wiper() {
  lincoln_wiper_ = 0;
  clear_has_lincoln_wiper();
}
inline ::jmc_auto::canbus::Light_LincolnWiperType Light::lincoln_wiper() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.lincoln_wiper)
  return static_cast< ::jmc_auto::canbus::Light_LincolnWiperType >(lincoln_wiper_);
}
inline void Light::set_lincoln_wiper(::jmc_auto::canbus::Light_LincolnWiperType value) {
  assert(::jmc_auto::canbus::Light_LincolnWiperType_IsValid(value));
  set_has_lincoln_wiper();
  lincoln_wiper_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.lincoln_wiper)
}

// optional .jmc_auto.canbus.Light.LincolnAmbientType lincoln_ambient = 10;
inline bool Light::has_lincoln_ambient() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Light::set_has_lincoln_ambient() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Light::clear_has_lincoln_ambient() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Light::clear_lincoln_ambient() {
  lincoln_ambient_ = 0;
  clear_has_lincoln_ambient();
}
inline ::jmc_auto::canbus::Light_LincolnAmbientType Light::lincoln_ambient() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Light.lincoln_ambient)
  return static_cast< ::jmc_auto::canbus::Light_LincolnAmbientType >(lincoln_ambient_);
}
inline void Light::set_lincoln_ambient(::jmc_auto::canbus::Light_LincolnAmbientType value) {
  assert(::jmc_auto::canbus::Light_LincolnAmbientType_IsValid(value));
  set_has_lincoln_ambient();
  lincoln_ambient_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Light.lincoln_ambient)
}

// -------------------------------------------------------------------

// Eps

// optional bool is_eps_fail = 1;
inline bool Eps::has_is_eps_fail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Eps::set_has_is_eps_fail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Eps::clear_has_is_eps_fail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Eps::clear_is_eps_fail() {
  is_eps_fail_ = false;
  clear_has_is_eps_fail();
}
inline bool Eps::is_eps_fail() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.is_eps_fail)
  return is_eps_fail_;
}
inline void Eps::set_is_eps_fail(bool value) {
  set_has_is_eps_fail();
  is_eps_fail_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.is_eps_fail)
}

// optional .jmc_auto.canbus.Eps.Type eps_control_state = 2;
inline bool Eps::has_eps_control_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Eps::set_has_eps_control_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Eps::clear_has_eps_control_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Eps::clear_eps_control_state() {
  eps_control_state_ = 0;
  clear_has_eps_control_state();
}
inline ::jmc_auto::canbus::Eps_Type Eps::eps_control_state() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.eps_control_state)
  return static_cast< ::jmc_auto::canbus::Eps_Type >(eps_control_state_);
}
inline void Eps::set_eps_control_state(::jmc_auto::canbus::Eps_Type value) {
  assert(::jmc_auto::canbus::Eps_Type_IsValid(value));
  set_has_eps_control_state();
  eps_control_state_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.eps_control_state)
}

// optional double eps_driver_hand_torq = 3;
inline bool Eps::has_eps_driver_hand_torq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Eps::set_has_eps_driver_hand_torq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Eps::clear_has_eps_driver_hand_torq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Eps::clear_eps_driver_hand_torq() {
  eps_driver_hand_torq_ = 0;
  clear_has_eps_driver_hand_torq();
}
inline double Eps::eps_driver_hand_torq() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.eps_driver_hand_torq)
  return eps_driver_hand_torq_;
}
inline void Eps::set_eps_driver_hand_torq(double value) {
  set_has_eps_driver_hand_torq();
  eps_driver_hand_torq_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.eps_driver_hand_torq)
}

// optional bool is_steering_angle_valid = 4;
inline bool Eps::has_is_steering_angle_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Eps::set_has_is_steering_angle_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Eps::clear_has_is_steering_angle_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Eps::clear_is_steering_angle_valid() {
  is_steering_angle_valid_ = false;
  clear_has_is_steering_angle_valid();
}
inline bool Eps::is_steering_angle_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.is_steering_angle_valid)
  return is_steering_angle_valid_;
}
inline void Eps::set_is_steering_angle_valid(bool value) {
  set_has_is_steering_angle_valid();
  is_steering_angle_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.is_steering_angle_valid)
}

// optional double steering_angle = 5;
inline bool Eps::has_steering_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Eps::set_has_steering_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Eps::clear_has_steering_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Eps::clear_steering_angle() {
  steering_angle_ = 0;
  clear_has_steering_angle();
}
inline double Eps::steering_angle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.steering_angle)
  return steering_angle_;
}
inline void Eps::set_steering_angle(double value) {
  set_has_steering_angle();
  steering_angle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.steering_angle)
}

// optional double steering_angle_spd = 6;
inline bool Eps::has_steering_angle_spd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Eps::set_has_steering_angle_spd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Eps::clear_has_steering_angle_spd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Eps::clear_steering_angle_spd() {
  steering_angle_spd_ = 0;
  clear_has_steering_angle_spd();
}
inline double Eps::steering_angle_spd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.steering_angle_spd)
  return steering_angle_spd_;
}
inline void Eps::set_steering_angle_spd(double value) {
  set_has_steering_angle_spd();
  steering_angle_spd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.steering_angle_spd)
}

// optional bool is_trimming_status = 7;
inline bool Eps::has_is_trimming_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Eps::set_has_is_trimming_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Eps::clear_has_is_trimming_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Eps::clear_is_trimming_status() {
  is_trimming_status_ = false;
  clear_has_is_trimming_status();
}
inline bool Eps::is_trimming_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.is_trimming_status)
  return is_trimming_status_;
}
inline void Eps::set_is_trimming_status(bool value) {
  set_has_is_trimming_status();
  is_trimming_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.is_trimming_status)
}

// optional bool is_calibration_status = 8;
inline bool Eps::has_is_calibration_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Eps::set_has_is_calibration_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Eps::clear_has_is_calibration_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Eps::clear_is_calibration_status() {
  is_calibration_status_ = false;
  clear_has_is_calibration_status();
}
inline bool Eps::is_calibration_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.is_calibration_status)
  return is_calibration_status_;
}
inline void Eps::set_is_calibration_status(bool value) {
  set_has_is_calibration_status();
  is_calibration_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.is_calibration_status)
}

// optional bool is_failure_status = 9;
inline bool Eps::has_is_failure_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Eps::set_has_is_failure_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Eps::clear_has_is_failure_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Eps::clear_is_failure_status() {
  is_failure_status_ = false;
  clear_has_is_failure_status();
}
inline bool Eps::is_failure_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.is_failure_status)
  return is_failure_status_;
}
inline void Eps::set_is_failure_status(bool value) {
  set_has_is_failure_status();
  is_failure_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.is_failure_status)
}

// optional int32 allow_enter_autonomous_mode = 10;
inline bool Eps::has_allow_enter_autonomous_mode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Eps::set_has_allow_enter_autonomous_mode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Eps::clear_has_allow_enter_autonomous_mode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Eps::clear_allow_enter_autonomous_mode() {
  allow_enter_autonomous_mode_ = 0;
  clear_has_allow_enter_autonomous_mode();
}
inline ::google::protobuf::int32 Eps::allow_enter_autonomous_mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.allow_enter_autonomous_mode)
  return allow_enter_autonomous_mode_;
}
inline void Eps::set_allow_enter_autonomous_mode(::google::protobuf::int32 value) {
  set_has_allow_enter_autonomous_mode();
  allow_enter_autonomous_mode_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.allow_enter_autonomous_mode)
}

// optional int32 current_driving_mode = 11;
inline bool Eps::has_current_driving_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Eps::set_has_current_driving_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Eps::clear_has_current_driving_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Eps::clear_current_driving_mode() {
  current_driving_mode_ = 0;
  clear_has_current_driving_mode();
}
inline ::google::protobuf::int32 Eps::current_driving_mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.current_driving_mode)
  return current_driving_mode_;
}
inline void Eps::set_current_driving_mode(::google::protobuf::int32 value) {
  set_has_current_driving_mode();
  current_driving_mode_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.current_driving_mode)
}

// optional double steering_angle_cmd = 12;
inline bool Eps::has_steering_angle_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Eps::set_has_steering_angle_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Eps::clear_has_steering_angle_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Eps::clear_steering_angle_cmd() {
  steering_angle_cmd_ = 0;
  clear_has_steering_angle_cmd();
}
inline double Eps::steering_angle_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.steering_angle_cmd)
  return steering_angle_cmd_;
}
inline void Eps::set_steering_angle_cmd(double value) {
  set_has_steering_angle_cmd();
  steering_angle_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.steering_angle_cmd)
}

// optional double vehicle_speed = 13;
inline bool Eps::has_vehicle_speed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Eps::set_has_vehicle_speed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Eps::clear_has_vehicle_speed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Eps::clear_vehicle_speed() {
  vehicle_speed_ = 0;
  clear_has_vehicle_speed();
}
inline double Eps::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.vehicle_speed)
  return vehicle_speed_;
}
inline void Eps::set_vehicle_speed(double value) {
  set_has_vehicle_speed();
  vehicle_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.vehicle_speed)
}

// optional double epas_torque = 14;
inline bool Eps::has_epas_torque() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Eps::set_has_epas_torque() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Eps::clear_has_epas_torque() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Eps::clear_epas_torque() {
  epas_torque_ = 0;
  clear_has_epas_torque();
}
inline double Eps::epas_torque() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.epas_torque)
  return epas_torque_;
}
inline void Eps::set_epas_torque(double value) {
  set_has_epas_torque();
  epas_torque_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.epas_torque)
}

// optional bool steering_enabled = 15;
inline bool Eps::has_steering_enabled() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Eps::set_has_steering_enabled() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Eps::clear_has_steering_enabled() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Eps::clear_steering_enabled() {
  steering_enabled_ = false;
  clear_has_steering_enabled();
}
inline bool Eps::steering_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.steering_enabled)
  return steering_enabled_;
}
inline void Eps::set_steering_enabled(bool value) {
  set_has_steering_enabled();
  steering_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.steering_enabled)
}

// optional bool driver_override = 16;
inline bool Eps::has_driver_override() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Eps::set_has_driver_override() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Eps::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Eps::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Eps::driver_override() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.driver_override)
  return driver_override_;
}
inline void Eps::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.driver_override)
}

// optional bool driver_activity = 17;
inline bool Eps::has_driver_activity() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Eps::set_has_driver_activity() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Eps::clear_has_driver_activity() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Eps::clear_driver_activity() {
  driver_activity_ = false;
  clear_has_driver_activity();
}
inline bool Eps::driver_activity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.driver_activity)
  return driver_activity_;
}
inline void Eps::set_driver_activity(bool value) {
  set_has_driver_activity();
  driver_activity_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.driver_activity)
}

// optional bool watchdog_fault = 18;
inline bool Eps::has_watchdog_fault() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Eps::set_has_watchdog_fault() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Eps::clear_has_watchdog_fault() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Eps::clear_watchdog_fault() {
  watchdog_fault_ = false;
  clear_has_watchdog_fault();
}
inline bool Eps::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.watchdog_fault)
  return watchdog_fault_;
}
inline void Eps::set_watchdog_fault(bool value) {
  set_has_watchdog_fault();
  watchdog_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.watchdog_fault)
}

// optional bool channel_1_fault = 19;
inline bool Eps::has_channel_1_fault() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Eps::set_has_channel_1_fault() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Eps::clear_has_channel_1_fault() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Eps::clear_channel_1_fault() {
  channel_1_fault_ = false;
  clear_has_channel_1_fault();
}
inline bool Eps::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.channel_1_fault)
  return channel_1_fault_;
}
inline void Eps::set_channel_1_fault(bool value) {
  set_has_channel_1_fault();
  channel_1_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.channel_1_fault)
}

// optional bool channel_2_fault = 20;
inline bool Eps::has_channel_2_fault() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Eps::set_has_channel_2_fault() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Eps::clear_has_channel_2_fault() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Eps::clear_channel_2_fault() {
  channel_2_fault_ = false;
  clear_has_channel_2_fault();
}
inline bool Eps::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.channel_2_fault)
  return channel_2_fault_;
}
inline void Eps::set_channel_2_fault(bool value) {
  set_has_channel_2_fault();
  channel_2_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.channel_2_fault)
}

// optional bool calibration_fault = 21;
inline bool Eps::has_calibration_fault() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Eps::set_has_calibration_fault() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Eps::clear_has_calibration_fault() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Eps::clear_calibration_fault() {
  calibration_fault_ = false;
  clear_has_calibration_fault();
}
inline bool Eps::calibration_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.calibration_fault)
  return calibration_fault_;
}
inline void Eps::set_calibration_fault(bool value) {
  set_has_calibration_fault();
  calibration_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.calibration_fault)
}

// optional bool connector_fault = 22;
inline bool Eps::has_connector_fault() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Eps::set_has_connector_fault() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Eps::clear_has_connector_fault() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Eps::clear_connector_fault() {
  connector_fault_ = false;
  clear_has_connector_fault();
}
inline bool Eps::connector_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.connector_fault)
  return connector_fault_;
}
inline void Eps::set_connector_fault(bool value) {
  set_has_connector_fault();
  connector_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.connector_fault)
}

// optional double timestamp_65 = 23;
inline bool Eps::has_timestamp_65() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Eps::set_has_timestamp_65() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Eps::clear_has_timestamp_65() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Eps::clear_timestamp_65() {
  timestamp_65_ = 0;
  clear_has_timestamp_65();
}
inline double Eps::timestamp_65() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.timestamp_65)
  return timestamp_65_;
}
inline void Eps::set_timestamp_65(double value) {
  set_has_timestamp_65();
  timestamp_65_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.timestamp_65)
}

// optional int32 major_version = 24;
inline bool Eps::has_major_version() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Eps::set_has_major_version() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Eps::clear_has_major_version() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Eps::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 Eps::major_version() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.major_version)
  return major_version_;
}
inline void Eps::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.major_version)
}

// optional int32 minor_version = 25;
inline bool Eps::has_minor_version() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Eps::set_has_minor_version() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Eps::clear_has_minor_version() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Eps::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 Eps::minor_version() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.minor_version)
  return minor_version_;
}
inline void Eps::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.minor_version)
}

// optional int32 build_number = 26;
inline bool Eps::has_build_number() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Eps::set_has_build_number() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Eps::clear_has_build_number() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Eps::clear_build_number() {
  build_number_ = 0;
  clear_has_build_number();
}
inline ::google::protobuf::int32 Eps::build_number() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Eps.build_number)
  return build_number_;
}
inline void Eps::set_build_number(::google::protobuf::int32 value) {
  set_has_build_number();
  build_number_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Eps.build_number)
}

// -------------------------------------------------------------------

// VehicleSpd

// optional bool is_vehicle_standstill = 1;
inline bool VehicleSpd::has_is_vehicle_standstill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleSpd::set_has_is_vehicle_standstill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleSpd::clear_has_is_vehicle_standstill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleSpd::clear_is_vehicle_standstill() {
  is_vehicle_standstill_ = false;
  clear_has_is_vehicle_standstill();
}
inline bool VehicleSpd::is_vehicle_standstill() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_vehicle_standstill)
  return is_vehicle_standstill_;
}
inline void VehicleSpd::set_is_vehicle_standstill(bool value) {
  set_has_is_vehicle_standstill();
  is_vehicle_standstill_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_vehicle_standstill)
}

// optional bool is_vehicle_spd_valid = 2;
inline bool VehicleSpd::has_is_vehicle_spd_valid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleSpd::set_has_is_vehicle_spd_valid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleSpd::clear_has_is_vehicle_spd_valid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleSpd::clear_is_vehicle_spd_valid() {
  is_vehicle_spd_valid_ = false;
  clear_has_is_vehicle_spd_valid();
}
inline bool VehicleSpd::is_vehicle_spd_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_vehicle_spd_valid)
  return is_vehicle_spd_valid_;
}
inline void VehicleSpd::set_is_vehicle_spd_valid(bool value) {
  set_has_is_vehicle_spd_valid();
  is_vehicle_spd_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_vehicle_spd_valid)
}

// optional double vehicle_spd = 3 [default = 0];
inline bool VehicleSpd::has_vehicle_spd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleSpd::set_has_vehicle_spd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleSpd::clear_has_vehicle_spd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleSpd::clear_vehicle_spd() {
  vehicle_spd_ = 0;
  clear_has_vehicle_spd();
}
inline double VehicleSpd::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.vehicle_spd)
  return vehicle_spd_;
}
inline void VehicleSpd::set_vehicle_spd(double value) {
  set_has_vehicle_spd();
  vehicle_spd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.vehicle_spd)
}

// optional bool is_wheel_spd_rr_valid = 4;
inline bool VehicleSpd::has_is_wheel_spd_rr_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_rr_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_rr_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleSpd::clear_is_wheel_spd_rr_valid() {
  is_wheel_spd_rr_valid_ = false;
  clear_has_is_wheel_spd_rr_valid();
}
inline bool VehicleSpd::is_wheel_spd_rr_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_wheel_spd_rr_valid)
  return is_wheel_spd_rr_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_rr_valid(bool value) {
  set_has_is_wheel_spd_rr_valid();
  is_wheel_spd_rr_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_wheel_spd_rr_valid)
}

// optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_rr = 5;
inline bool VehicleSpd::has_wheel_direction_rr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_rr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleSpd::clear_has_wheel_direction_rr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleSpd::clear_wheel_direction_rr() {
  wheel_direction_rr_ = 0;
  clear_has_wheel_direction_rr();
}
inline ::jmc_auto::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_rr() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_direction_rr)
  return static_cast< ::jmc_auto::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_rr_);
}
inline void VehicleSpd::set_wheel_direction_rr(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::jmc_auto::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  set_has_wheel_direction_rr();
  wheel_direction_rr_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_direction_rr)
}

// optional double wheel_spd_rr = 6;
inline bool VehicleSpd::has_wheel_spd_rr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_rr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleSpd::clear_has_wheel_spd_rr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleSpd::clear_wheel_spd_rr() {
  wheel_spd_rr_ = 0;
  clear_has_wheel_spd_rr();
}
inline double VehicleSpd::wheel_spd_rr() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_spd_rr)
  return wheel_spd_rr_;
}
inline void VehicleSpd::set_wheel_spd_rr(double value) {
  set_has_wheel_spd_rr();
  wheel_spd_rr_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_spd_rr)
}

// optional bool is_wheel_spd_rl_valid = 7;
inline bool VehicleSpd::has_is_wheel_spd_rl_valid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_rl_valid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_rl_valid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleSpd::clear_is_wheel_spd_rl_valid() {
  is_wheel_spd_rl_valid_ = false;
  clear_has_is_wheel_spd_rl_valid();
}
inline bool VehicleSpd::is_wheel_spd_rl_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_wheel_spd_rl_valid)
  return is_wheel_spd_rl_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_rl_valid(bool value) {
  set_has_is_wheel_spd_rl_valid();
  is_wheel_spd_rl_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_wheel_spd_rl_valid)
}

// optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_rl = 8;
inline bool VehicleSpd::has_wheel_direction_rl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_rl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleSpd::clear_has_wheel_direction_rl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleSpd::clear_wheel_direction_rl() {
  wheel_direction_rl_ = 0;
  clear_has_wheel_direction_rl();
}
inline ::jmc_auto::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_rl() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_direction_rl)
  return static_cast< ::jmc_auto::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_rl_);
}
inline void VehicleSpd::set_wheel_direction_rl(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::jmc_auto::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  set_has_wheel_direction_rl();
  wheel_direction_rl_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_direction_rl)
}

// optional double wheel_spd_rl = 9;
inline bool VehicleSpd::has_wheel_spd_rl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_rl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleSpd::clear_has_wheel_spd_rl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleSpd::clear_wheel_spd_rl() {
  wheel_spd_rl_ = 0;
  clear_has_wheel_spd_rl();
}
inline double VehicleSpd::wheel_spd_rl() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_spd_rl)
  return wheel_spd_rl_;
}
inline void VehicleSpd::set_wheel_spd_rl(double value) {
  set_has_wheel_spd_rl();
  wheel_spd_rl_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_spd_rl)
}

// optional bool is_wheel_spd_fr_valid = 10;
inline bool VehicleSpd::has_is_wheel_spd_fr_valid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_fr_valid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_fr_valid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VehicleSpd::clear_is_wheel_spd_fr_valid() {
  is_wheel_spd_fr_valid_ = false;
  clear_has_is_wheel_spd_fr_valid();
}
inline bool VehicleSpd::is_wheel_spd_fr_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_wheel_spd_fr_valid)
  return is_wheel_spd_fr_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_fr_valid(bool value) {
  set_has_is_wheel_spd_fr_valid();
  is_wheel_spd_fr_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_wheel_spd_fr_valid)
}

// optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_fr = 11;
inline bool VehicleSpd::has_wheel_direction_fr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_fr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VehicleSpd::clear_has_wheel_direction_fr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VehicleSpd::clear_wheel_direction_fr() {
  wheel_direction_fr_ = 0;
  clear_has_wheel_direction_fr();
}
inline ::jmc_auto::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_fr() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_direction_fr)
  return static_cast< ::jmc_auto::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_fr_);
}
inline void VehicleSpd::set_wheel_direction_fr(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::jmc_auto::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  set_has_wheel_direction_fr();
  wheel_direction_fr_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_direction_fr)
}

// optional double wheel_spd_fr = 12;
inline bool VehicleSpd::has_wheel_spd_fr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_fr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VehicleSpd::clear_has_wheel_spd_fr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VehicleSpd::clear_wheel_spd_fr() {
  wheel_spd_fr_ = 0;
  clear_has_wheel_spd_fr();
}
inline double VehicleSpd::wheel_spd_fr() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_spd_fr)
  return wheel_spd_fr_;
}
inline void VehicleSpd::set_wheel_spd_fr(double value) {
  set_has_wheel_spd_fr();
  wheel_spd_fr_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_spd_fr)
}

// optional bool is_wheel_spd_fl_valid = 13;
inline bool VehicleSpd::has_is_wheel_spd_fl_valid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VehicleSpd::set_has_is_wheel_spd_fl_valid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VehicleSpd::clear_has_is_wheel_spd_fl_valid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VehicleSpd::clear_is_wheel_spd_fl_valid() {
  is_wheel_spd_fl_valid_ = false;
  clear_has_is_wheel_spd_fl_valid();
}
inline bool VehicleSpd::is_wheel_spd_fl_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_wheel_spd_fl_valid)
  return is_wheel_spd_fl_valid_;
}
inline void VehicleSpd::set_is_wheel_spd_fl_valid(bool value) {
  set_has_is_wheel_spd_fl_valid();
  is_wheel_spd_fl_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_wheel_spd_fl_valid)
}

// optional .jmc_auto.canbus.WheelSpeed.WheelSpeedType wheel_direction_fl = 14;
inline bool VehicleSpd::has_wheel_direction_fl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VehicleSpd::set_has_wheel_direction_fl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VehicleSpd::clear_has_wheel_direction_fl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VehicleSpd::clear_wheel_direction_fl() {
  wheel_direction_fl_ = 0;
  clear_has_wheel_direction_fl();
}
inline ::jmc_auto::canbus::WheelSpeed_WheelSpeedType VehicleSpd::wheel_direction_fl() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_direction_fl)
  return static_cast< ::jmc_auto::canbus::WheelSpeed_WheelSpeedType >(wheel_direction_fl_);
}
inline void VehicleSpd::set_wheel_direction_fl(::jmc_auto::canbus::WheelSpeed_WheelSpeedType value) {
  assert(::jmc_auto::canbus::WheelSpeed_WheelSpeedType_IsValid(value));
  set_has_wheel_direction_fl();
  wheel_direction_fl_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_direction_fl)
}

// optional double wheel_spd_fl = 15;
inline bool VehicleSpd::has_wheel_spd_fl() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VehicleSpd::set_has_wheel_spd_fl() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VehicleSpd::clear_has_wheel_spd_fl() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VehicleSpd::clear_wheel_spd_fl() {
  wheel_spd_fl_ = 0;
  clear_has_wheel_spd_fl();
}
inline double VehicleSpd::wheel_spd_fl() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.wheel_spd_fl)
  return wheel_spd_fl_;
}
inline void VehicleSpd::set_wheel_spd_fl(double value) {
  set_has_wheel_spd_fl();
  wheel_spd_fl_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.wheel_spd_fl)
}

// optional bool is_yaw_rate_valid = 16;
inline bool VehicleSpd::has_is_yaw_rate_valid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VehicleSpd::set_has_is_yaw_rate_valid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VehicleSpd::clear_has_is_yaw_rate_valid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VehicleSpd::clear_is_yaw_rate_valid() {
  is_yaw_rate_valid_ = false;
  clear_has_is_yaw_rate_valid();
}
inline bool VehicleSpd::is_yaw_rate_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_yaw_rate_valid)
  return is_yaw_rate_valid_;
}
inline void VehicleSpd::set_is_yaw_rate_valid(bool value) {
  set_has_is_yaw_rate_valid();
  is_yaw_rate_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_yaw_rate_valid)
}

// optional double yaw_rate = 17;
inline bool VehicleSpd::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VehicleSpd::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VehicleSpd::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VehicleSpd::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline double VehicleSpd::yaw_rate() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.yaw_rate)
  return yaw_rate_;
}
inline void VehicleSpd::set_yaw_rate(double value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.yaw_rate)
}

// optional double yaw_rate_offset = 18;
inline bool VehicleSpd::has_yaw_rate_offset() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VehicleSpd::set_has_yaw_rate_offset() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VehicleSpd::clear_has_yaw_rate_offset() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VehicleSpd::clear_yaw_rate_offset() {
  yaw_rate_offset_ = 0;
  clear_has_yaw_rate_offset();
}
inline double VehicleSpd::yaw_rate_offset() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.yaw_rate_offset)
  return yaw_rate_offset_;
}
inline void VehicleSpd::set_yaw_rate_offset(double value) {
  set_has_yaw_rate_offset();
  yaw_rate_offset_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.yaw_rate_offset)
}

// optional bool is_ax_valid = 19;
inline bool VehicleSpd::has_is_ax_valid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VehicleSpd::set_has_is_ax_valid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VehicleSpd::clear_has_is_ax_valid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VehicleSpd::clear_is_ax_valid() {
  is_ax_valid_ = false;
  clear_has_is_ax_valid();
}
inline bool VehicleSpd::is_ax_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_ax_valid)
  return is_ax_valid_;
}
inline void VehicleSpd::set_is_ax_valid(bool value) {
  set_has_is_ax_valid();
  is_ax_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_ax_valid)
}

// optional double ax = 20;
inline bool VehicleSpd::has_ax() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VehicleSpd::set_has_ax() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VehicleSpd::clear_has_ax() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VehicleSpd::clear_ax() {
  ax_ = 0;
  clear_has_ax();
}
inline double VehicleSpd::ax() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.ax)
  return ax_;
}
inline void VehicleSpd::set_ax(double value) {
  set_has_ax();
  ax_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.ax)
}

// optional double ax_offset = 21;
inline bool VehicleSpd::has_ax_offset() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VehicleSpd::set_has_ax_offset() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VehicleSpd::clear_has_ax_offset() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VehicleSpd::clear_ax_offset() {
  ax_offset_ = 0;
  clear_has_ax_offset();
}
inline double VehicleSpd::ax_offset() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.ax_offset)
  return ax_offset_;
}
inline void VehicleSpd::set_ax_offset(double value) {
  set_has_ax_offset();
  ax_offset_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.ax_offset)
}

// optional bool is_ay_valid = 22;
inline bool VehicleSpd::has_is_ay_valid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void VehicleSpd::set_has_is_ay_valid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void VehicleSpd::clear_has_is_ay_valid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void VehicleSpd::clear_is_ay_valid() {
  is_ay_valid_ = false;
  clear_has_is_ay_valid();
}
inline bool VehicleSpd::is_ay_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.is_ay_valid)
  return is_ay_valid_;
}
inline void VehicleSpd::set_is_ay_valid(bool value) {
  set_has_is_ay_valid();
  is_ay_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.is_ay_valid)
}

// optional double ay = 23;
inline bool VehicleSpd::has_ay() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void VehicleSpd::set_has_ay() {
  _has_bits_[0] |= 0x00200000u;
}
inline void VehicleSpd::clear_has_ay() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void VehicleSpd::clear_ay() {
  ay_ = 0;
  clear_has_ay();
}
inline double VehicleSpd::ay() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.ay)
  return ay_;
}
inline void VehicleSpd::set_ay(double value) {
  set_has_ay();
  ay_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.ay)
}

// optional double ay_offset = 24;
inline bool VehicleSpd::has_ay_offset() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void VehicleSpd::set_has_ay_offset() {
  _has_bits_[0] |= 0x00400000u;
}
inline void VehicleSpd::clear_has_ay_offset() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void VehicleSpd::clear_ay_offset() {
  ay_offset_ = 0;
  clear_has_ay_offset();
}
inline double VehicleSpd::ay_offset() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.ay_offset)
  return ay_offset_;
}
inline void VehicleSpd::set_ay_offset(double value) {
  set_has_ay_offset();
  ay_offset_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.ay_offset)
}

// optional double lat_acc = 25;
inline bool VehicleSpd::has_lat_acc() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void VehicleSpd::set_has_lat_acc() {
  _has_bits_[0] |= 0x00800000u;
}
inline void VehicleSpd::clear_has_lat_acc() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void VehicleSpd::clear_lat_acc() {
  lat_acc_ = 0;
  clear_has_lat_acc();
}
inline double VehicleSpd::lat_acc() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.lat_acc)
  return lat_acc_;
}
inline void VehicleSpd::set_lat_acc(double value) {
  set_has_lat_acc();
  lat_acc_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.lat_acc)
}

// optional double long_acc = 26;
inline bool VehicleSpd::has_long_acc() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void VehicleSpd::set_has_long_acc() {
  _has_bits_[0] |= 0x01000000u;
}
inline void VehicleSpd::clear_has_long_acc() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void VehicleSpd::clear_long_acc() {
  long_acc_ = 0;
  clear_has_long_acc();
}
inline double VehicleSpd::long_acc() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.long_acc)
  return long_acc_;
}
inline void VehicleSpd::set_long_acc(double value) {
  set_has_long_acc();
  long_acc_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.long_acc)
}

// optional double vert_acc = 27;
inline bool VehicleSpd::has_vert_acc() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void VehicleSpd::set_has_vert_acc() {
  _has_bits_[0] |= 0x02000000u;
}
inline void VehicleSpd::clear_has_vert_acc() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void VehicleSpd::clear_vert_acc() {
  vert_acc_ = 0;
  clear_has_vert_acc();
}
inline double VehicleSpd::vert_acc() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.vert_acc)
  return vert_acc_;
}
inline void VehicleSpd::set_vert_acc(double value) {
  set_has_vert_acc();
  vert_acc_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.vert_acc)
}

// optional double roll_rate = 28;
inline bool VehicleSpd::has_roll_rate() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void VehicleSpd::set_has_roll_rate() {
  _has_bits_[0] |= 0x04000000u;
}
inline void VehicleSpd::clear_has_roll_rate() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void VehicleSpd::clear_roll_rate() {
  roll_rate_ = 0;
  clear_has_roll_rate();
}
inline double VehicleSpd::roll_rate() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.roll_rate)
  return roll_rate_;
}
inline void VehicleSpd::set_roll_rate(double value) {
  set_has_roll_rate();
  roll_rate_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.roll_rate)
}

// optional double acc_est = 29;
inline bool VehicleSpd::has_acc_est() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void VehicleSpd::set_has_acc_est() {
  _has_bits_[0] |= 0x08000000u;
}
inline void VehicleSpd::clear_has_acc_est() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void VehicleSpd::clear_acc_est() {
  acc_est_ = 0;
  clear_has_acc_est();
}
inline double VehicleSpd::acc_est() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.acc_est)
  return acc_est_;
}
inline void VehicleSpd::set_acc_est(double value) {
  set_has_acc_est();
  acc_est_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.acc_est)
}

// optional double timestamp_sec = 30;
inline bool VehicleSpd::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void VehicleSpd::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x10000000u;
}
inline void VehicleSpd::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void VehicleSpd::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double VehicleSpd::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.VehicleSpd.timestamp_sec)
  return timestamp_sec_;
}
inline void VehicleSpd::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.VehicleSpd.timestamp_sec)
}

// -------------------------------------------------------------------

// Deceleration

// optional bool is_deceleration_available = 1;
inline bool Deceleration::has_is_deceleration_available() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Deceleration::set_has_is_deceleration_available() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Deceleration::clear_has_is_deceleration_available() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Deceleration::clear_is_deceleration_available() {
  is_deceleration_available_ = false;
  clear_has_is_deceleration_available();
}
inline bool Deceleration::is_deceleration_available() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.is_deceleration_available)
  return is_deceleration_available_;
}
inline void Deceleration::set_is_deceleration_available(bool value) {
  set_has_is_deceleration_available();
  is_deceleration_available_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.is_deceleration_available)
}

// optional bool is_deceleration_active = 2;
inline bool Deceleration::has_is_deceleration_active() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Deceleration::set_has_is_deceleration_active() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Deceleration::clear_has_is_deceleration_active() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Deceleration::clear_is_deceleration_active() {
  is_deceleration_active_ = false;
  clear_has_is_deceleration_active();
}
inline bool Deceleration::is_deceleration_active() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.is_deceleration_active)
  return is_deceleration_active_;
}
inline void Deceleration::set_is_deceleration_active(bool value) {
  set_has_is_deceleration_active();
  is_deceleration_active_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.is_deceleration_active)
}

// optional double deceleration = 3 [default = 0];
inline bool Deceleration::has_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Deceleration::set_has_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Deceleration::clear_has_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Deceleration::clear_deceleration() {
  deceleration_ = 0;
  clear_has_deceleration();
}
inline double Deceleration::deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.deceleration)
  return deceleration_;
}
inline void Deceleration::set_deceleration(double value) {
  set_has_deceleration();
  deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.deceleration)
}

// optional double is_evb_fail = 4;
inline bool Deceleration::has_is_evb_fail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Deceleration::set_has_is_evb_fail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Deceleration::clear_has_is_evb_fail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Deceleration::clear_is_evb_fail() {
  is_evb_fail_ = 0;
  clear_has_is_evb_fail();
}
inline double Deceleration::is_evb_fail() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.is_evb_fail)
  return is_evb_fail_;
}
inline void Deceleration::set_is_evb_fail(double value) {
  set_has_is_evb_fail();
  is_evb_fail_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.is_evb_fail)
}

// optional double evb_pressure = 5 [default = 0];
inline bool Deceleration::has_evb_pressure() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Deceleration::set_has_evb_pressure() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Deceleration::clear_has_evb_pressure() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Deceleration::clear_evb_pressure() {
  evb_pressure_ = 0;
  clear_has_evb_pressure();
}
inline double Deceleration::evb_pressure() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.evb_pressure)
  return evb_pressure_;
}
inline void Deceleration::set_evb_pressure(double value) {
  set_has_evb_pressure();
  evb_pressure_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.evb_pressure)
}

// optional double brake_pressure = 6 [default = 0];
inline bool Deceleration::has_brake_pressure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Deceleration::set_has_brake_pressure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Deceleration::clear_has_brake_pressure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Deceleration::clear_brake_pressure() {
  brake_pressure_ = 0;
  clear_has_brake_pressure();
}
inline double Deceleration::brake_pressure() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.brake_pressure)
  return brake_pressure_;
}
inline void Deceleration::set_brake_pressure(double value) {
  set_has_brake_pressure();
  brake_pressure_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.brake_pressure)
}

// optional double brake_pressure_spd = 7 [default = 0];
inline bool Deceleration::has_brake_pressure_spd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Deceleration::set_has_brake_pressure_spd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Deceleration::clear_has_brake_pressure_spd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Deceleration::clear_brake_pressure_spd() {
  brake_pressure_spd_ = 0;
  clear_has_brake_pressure_spd();
}
inline double Deceleration::brake_pressure_spd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Deceleration.brake_pressure_spd)
  return brake_pressure_spd_;
}
inline void Deceleration::set_brake_pressure_spd(double value) {
  set_has_brake_pressure_spd();
  brake_pressure_spd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Deceleration.brake_pressure_spd)
}

// -------------------------------------------------------------------

// Brake

// optional bool is_brake_pedal_pressed = 1 [default = false];
inline bool Brake::has_is_brake_pedal_pressed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake::set_has_is_brake_pedal_pressed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake::clear_has_is_brake_pedal_pressed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake::clear_is_brake_pedal_pressed() {
  is_brake_pedal_pressed_ = false;
  clear_has_is_brake_pedal_pressed();
}
inline bool Brake::is_brake_pedal_pressed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.is_brake_pedal_pressed)
  return is_brake_pedal_pressed_;
}
inline void Brake::set_is_brake_pedal_pressed(bool value) {
  set_has_is_brake_pedal_pressed();
  is_brake_pedal_pressed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.is_brake_pedal_pressed)
}

// optional bool is_brake_force_exist = 2;
inline bool Brake::has_is_brake_force_exist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Brake::set_has_is_brake_force_exist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Brake::clear_has_is_brake_force_exist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Brake::clear_is_brake_force_exist() {
  is_brake_force_exist_ = false;
  clear_has_is_brake_force_exist();
}
inline bool Brake::is_brake_force_exist() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.is_brake_force_exist)
  return is_brake_force_exist_;
}
inline void Brake::set_is_brake_force_exist(bool value) {
  set_has_is_brake_force_exist();
  is_brake_force_exist_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.is_brake_force_exist)
}

// optional bool is_brake_over_heat = 3;
inline bool Brake::has_is_brake_over_heat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Brake::set_has_is_brake_over_heat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Brake::clear_has_is_brake_over_heat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Brake::clear_is_brake_over_heat() {
  is_brake_over_heat_ = false;
  clear_has_is_brake_over_heat();
}
inline bool Brake::is_brake_over_heat() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.is_brake_over_heat)
  return is_brake_over_heat_;
}
inline void Brake::set_is_brake_over_heat(bool value) {
  set_has_is_brake_over_heat();
  is_brake_over_heat_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.is_brake_over_heat)
}

// optional bool is_hand_brake_on = 4;
inline bool Brake::has_is_hand_brake_on() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Brake::set_has_is_hand_brake_on() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Brake::clear_has_is_hand_brake_on() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Brake::clear_is_hand_brake_on() {
  is_hand_brake_on_ = false;
  clear_has_is_hand_brake_on();
}
inline bool Brake::is_hand_brake_on() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.is_hand_brake_on)
  return is_hand_brake_on_;
}
inline void Brake::set_is_hand_brake_on(bool value) {
  set_has_is_hand_brake_on();
  is_hand_brake_on_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.is_hand_brake_on)
}

// optional double brake_pedal_position = 5;
inline bool Brake::has_brake_pedal_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake::set_has_brake_pedal_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake::clear_has_brake_pedal_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake::clear_brake_pedal_position() {
  brake_pedal_position_ = 0;
  clear_has_brake_pedal_position();
}
inline double Brake::brake_pedal_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_pedal_position)
  return brake_pedal_position_;
}
inline void Brake::set_brake_pedal_position(double value) {
  set_has_brake_pedal_position();
  brake_pedal_position_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_pedal_position)
}

// optional bool is_brake_valid = 6;
inline bool Brake::has_is_brake_valid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Brake::set_has_is_brake_valid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Brake::clear_has_is_brake_valid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Brake::clear_is_brake_valid() {
  is_brake_valid_ = false;
  clear_has_is_brake_valid();
}
inline bool Brake::is_brake_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.is_brake_valid)
  return is_brake_valid_;
}
inline void Brake::set_is_brake_valid(bool value) {
  set_has_is_brake_valid();
  is_brake_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.is_brake_valid)
}

// optional double brake_input = 7;
inline bool Brake::has_brake_input() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Brake::set_has_brake_input() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Brake::clear_has_brake_input() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Brake::clear_brake_input() {
  brake_input_ = 0;
  clear_has_brake_input();
}
inline double Brake::brake_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_input)
  return brake_input_;
}
inline void Brake::set_brake_input(double value) {
  set_has_brake_input();
  brake_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_input)
}

// optional double brake_cmd = 8;
inline bool Brake::has_brake_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Brake::set_has_brake_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Brake::clear_has_brake_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Brake::clear_brake_cmd() {
  brake_cmd_ = 0;
  clear_has_brake_cmd();
}
inline double Brake::brake_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_cmd)
  return brake_cmd_;
}
inline void Brake::set_brake_cmd(double value) {
  set_has_brake_cmd();
  brake_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_cmd)
}

// optional double brake_output = 9;
inline bool Brake::has_brake_output() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Brake::set_has_brake_output() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Brake::clear_has_brake_output() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Brake::clear_brake_output() {
  brake_output_ = 0;
  clear_has_brake_output();
}
inline double Brake::brake_output() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_output)
  return brake_output_;
}
inline void Brake::set_brake_output(double value) {
  set_has_brake_output();
  brake_output_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_output)
}

// optional bool boo_input = 10;
inline bool Brake::has_boo_input() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Brake::set_has_boo_input() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Brake::clear_has_boo_input() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Brake::clear_boo_input() {
  boo_input_ = false;
  clear_has_boo_input();
}
inline bool Brake::boo_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.boo_input)
  return boo_input_;
}
inline void Brake::set_boo_input(bool value) {
  set_has_boo_input();
  boo_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.boo_input)
}

// optional bool boo_cmd = 11;
inline bool Brake::has_boo_cmd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Brake::set_has_boo_cmd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Brake::clear_has_boo_cmd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Brake::clear_boo_cmd() {
  boo_cmd_ = false;
  clear_has_boo_cmd();
}
inline bool Brake::boo_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.boo_cmd)
  return boo_cmd_;
}
inline void Brake::set_boo_cmd(bool value) {
  set_has_boo_cmd();
  boo_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.boo_cmd)
}

// optional bool boo_output = 12;
inline bool Brake::has_boo_output() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Brake::set_has_boo_output() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Brake::clear_has_boo_output() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Brake::clear_boo_output() {
  boo_output_ = false;
  clear_has_boo_output();
}
inline bool Brake::boo_output() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.boo_output)
  return boo_output_;
}
inline void Brake::set_boo_output(bool value) {
  set_has_boo_output();
  boo_output_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.boo_output)
}

// optional bool watchdog_applying_brakes = 13;
inline bool Brake::has_watchdog_applying_brakes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Brake::set_has_watchdog_applying_brakes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Brake::clear_has_watchdog_applying_brakes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Brake::clear_watchdog_applying_brakes() {
  watchdog_applying_brakes_ = false;
  clear_has_watchdog_applying_brakes();
}
inline bool Brake::watchdog_applying_brakes() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.watchdog_applying_brakes)
  return watchdog_applying_brakes_;
}
inline void Brake::set_watchdog_applying_brakes(bool value) {
  set_has_watchdog_applying_brakes();
  watchdog_applying_brakes_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.watchdog_applying_brakes)
}

// optional int32 watchdog_source = 14;
inline bool Brake::has_watchdog_source() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Brake::set_has_watchdog_source() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Brake::clear_has_watchdog_source() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Brake::clear_watchdog_source() {
  watchdog_source_ = 0;
  clear_has_watchdog_source();
}
inline ::google::protobuf::int32 Brake::watchdog_source() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.watchdog_source)
  return watchdog_source_;
}
inline void Brake::set_watchdog_source(::google::protobuf::int32 value) {
  set_has_watchdog_source();
  watchdog_source_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.watchdog_source)
}

// optional bool brake_enabled = 15;
inline bool Brake::has_brake_enabled() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Brake::set_has_brake_enabled() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Brake::clear_has_brake_enabled() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Brake::clear_brake_enabled() {
  brake_enabled_ = false;
  clear_has_brake_enabled();
}
inline bool Brake::brake_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_enabled)
  return brake_enabled_;
}
inline void Brake::set_brake_enabled(bool value) {
  set_has_brake_enabled();
  brake_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_enabled)
}

// optional bool driver_override = 16;
inline bool Brake::has_driver_override() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Brake::set_has_driver_override() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Brake::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Brake::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Brake::driver_override() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.driver_override)
  return driver_override_;
}
inline void Brake::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.driver_override)
}

// optional bool driver_activity = 17;
inline bool Brake::has_driver_activity() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Brake::set_has_driver_activity() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Brake::clear_has_driver_activity() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Brake::clear_driver_activity() {
  driver_activity_ = false;
  clear_has_driver_activity();
}
inline bool Brake::driver_activity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.driver_activity)
  return driver_activity_;
}
inline void Brake::set_driver_activity(bool value) {
  set_has_driver_activity();
  driver_activity_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.driver_activity)
}

// optional bool watchdog_fault = 18;
inline bool Brake::has_watchdog_fault() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Brake::set_has_watchdog_fault() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Brake::clear_has_watchdog_fault() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Brake::clear_watchdog_fault() {
  watchdog_fault_ = false;
  clear_has_watchdog_fault();
}
inline bool Brake::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.watchdog_fault)
  return watchdog_fault_;
}
inline void Brake::set_watchdog_fault(bool value) {
  set_has_watchdog_fault();
  watchdog_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.watchdog_fault)
}

// optional bool channel_1_fault = 19;
inline bool Brake::has_channel_1_fault() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Brake::set_has_channel_1_fault() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Brake::clear_has_channel_1_fault() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Brake::clear_channel_1_fault() {
  channel_1_fault_ = false;
  clear_has_channel_1_fault();
}
inline bool Brake::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.channel_1_fault)
  return channel_1_fault_;
}
inline void Brake::set_channel_1_fault(bool value) {
  set_has_channel_1_fault();
  channel_1_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.channel_1_fault)
}

// optional bool channel_2_fault = 20;
inline bool Brake::has_channel_2_fault() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Brake::set_has_channel_2_fault() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Brake::clear_has_channel_2_fault() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Brake::clear_channel_2_fault() {
  channel_2_fault_ = false;
  clear_has_channel_2_fault();
}
inline bool Brake::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.channel_2_fault)
  return channel_2_fault_;
}
inline void Brake::set_channel_2_fault(bool value) {
  set_has_channel_2_fault();
  channel_2_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.channel_2_fault)
}

// optional bool boo_fault = 21;
inline bool Brake::has_boo_fault() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Brake::set_has_boo_fault() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Brake::clear_has_boo_fault() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Brake::clear_boo_fault() {
  boo_fault_ = false;
  clear_has_boo_fault();
}
inline bool Brake::boo_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.boo_fault)
  return boo_fault_;
}
inline void Brake::set_boo_fault(bool value) {
  set_has_boo_fault();
  boo_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.boo_fault)
}

// optional bool connector_fault = 22;
inline bool Brake::has_connector_fault() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Brake::set_has_connector_fault() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Brake::clear_has_connector_fault() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Brake::clear_connector_fault() {
  connector_fault_ = false;
  clear_has_connector_fault();
}
inline bool Brake::connector_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.connector_fault)
  return connector_fault_;
}
inline void Brake::set_connector_fault(bool value) {
  set_has_connector_fault();
  connector_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.connector_fault)
}

// optional double brake_torque_req = 23;
inline bool Brake::has_brake_torque_req() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Brake::set_has_brake_torque_req() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Brake::clear_has_brake_torque_req() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Brake::clear_brake_torque_req() {
  brake_torque_req_ = 0;
  clear_has_brake_torque_req();
}
inline double Brake::brake_torque_req() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_torque_req)
  return brake_torque_req_;
}
inline void Brake::set_brake_torque_req(double value) {
  set_has_brake_torque_req();
  brake_torque_req_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_torque_req)
}

// optional .jmc_auto.canbus.Brake.HSAStatusType hsa_status = 24;
inline bool Brake::has_hsa_status() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Brake::set_has_hsa_status() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Brake::clear_has_hsa_status() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Brake::clear_hsa_status() {
  hsa_status_ = 0;
  clear_has_hsa_status();
}
inline ::jmc_auto::canbus::Brake_HSAStatusType Brake::hsa_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.hsa_status)
  return static_cast< ::jmc_auto::canbus::Brake_HSAStatusType >(hsa_status_);
}
inline void Brake::set_hsa_status(::jmc_auto::canbus::Brake_HSAStatusType value) {
  assert(::jmc_auto::canbus::Brake_HSAStatusType_IsValid(value));
  set_has_hsa_status();
  hsa_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.hsa_status)
}

// optional double brake_torque_act = 25;
inline bool Brake::has_brake_torque_act() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Brake::set_has_brake_torque_act() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Brake::clear_has_brake_torque_act() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Brake::clear_brake_torque_act() {
  brake_torque_act_ = 0;
  clear_has_brake_torque_act();
}
inline double Brake::brake_torque_act() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.brake_torque_act)
  return brake_torque_act_;
}
inline void Brake::set_brake_torque_act(double value) {
  set_has_brake_torque_act();
  brake_torque_act_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.brake_torque_act)
}

// optional .jmc_auto.canbus.Brake.HSAModeType hsa_mode = 26;
inline bool Brake::has_hsa_mode() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Brake::set_has_hsa_mode() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Brake::clear_has_hsa_mode() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Brake::clear_hsa_mode() {
  hsa_mode_ = 0;
  clear_has_hsa_mode();
}
inline ::jmc_auto::canbus::Brake_HSAModeType Brake::hsa_mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.hsa_mode)
  return static_cast< ::jmc_auto::canbus::Brake_HSAModeType >(hsa_mode_);
}
inline void Brake::set_hsa_mode(::jmc_auto::canbus::Brake_HSAModeType value) {
  assert(::jmc_auto::canbus::Brake_HSAModeType_IsValid(value));
  set_has_hsa_mode();
  hsa_mode_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.hsa_mode)
}

// optional double wheel_torque_act = 27;
inline bool Brake::has_wheel_torque_act() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Brake::set_has_wheel_torque_act() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Brake::clear_has_wheel_torque_act() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Brake::clear_wheel_torque_act() {
  wheel_torque_act_ = 0;
  clear_has_wheel_torque_act();
}
inline double Brake::wheel_torque_act() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.wheel_torque_act)
  return wheel_torque_act_;
}
inline void Brake::set_wheel_torque_act(double value) {
  set_has_wheel_torque_act();
  wheel_torque_act_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.wheel_torque_act)
}

// optional int32 major_version = 28;
inline bool Brake::has_major_version() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Brake::set_has_major_version() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Brake::clear_has_major_version() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Brake::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 Brake::major_version() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.major_version)
  return major_version_;
}
inline void Brake::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.major_version)
}

// optional int32 minor_version = 29;
inline bool Brake::has_minor_version() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Brake::set_has_minor_version() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Brake::clear_has_minor_version() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Brake::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 Brake::minor_version() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.minor_version)
  return minor_version_;
}
inline void Brake::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.minor_version)
}

// optional int32 build_number = 30;
inline bool Brake::has_build_number() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Brake::set_has_build_number() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Brake::clear_has_build_number() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Brake::clear_build_number() {
  build_number_ = 0;
  clear_has_build_number();
}
inline ::google::protobuf::int32 Brake::build_number() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake.build_number)
  return build_number_;
}
inline void Brake::set_build_number(::google::protobuf::int32 value) {
  set_has_build_number();
  build_number_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake.build_number)
}

// -------------------------------------------------------------------

// Epb

// optional bool is_epb_error = 1;
inline bool Epb::has_is_epb_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Epb::set_has_is_epb_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Epb::clear_has_is_epb_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Epb::clear_is_epb_error() {
  is_epb_error_ = false;
  clear_has_is_epb_error();
}
inline bool Epb::is_epb_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Epb.is_epb_error)
  return is_epb_error_;
}
inline void Epb::set_is_epb_error(bool value) {
  set_has_is_epb_error();
  is_epb_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Epb.is_epb_error)
}

// optional bool is_epb_released = 2;
inline bool Epb::has_is_epb_released() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Epb::set_has_is_epb_released() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Epb::clear_has_is_epb_released() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Epb::clear_is_epb_released() {
  is_epb_released_ = false;
  clear_has_is_epb_released();
}
inline bool Epb::is_epb_released() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Epb.is_epb_released)
  return is_epb_released_;
}
inline void Epb::set_is_epb_released(bool value) {
  set_has_is_epb_released();
  is_epb_released_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Epb.is_epb_released)
}

// optional int32 epb_status = 3;
inline bool Epb::has_epb_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Epb::set_has_epb_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Epb::clear_has_epb_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Epb::clear_epb_status() {
  epb_status_ = 0;
  clear_has_epb_status();
}
inline ::google::protobuf::int32 Epb::epb_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Epb.epb_status)
  return epb_status_;
}
inline void Epb::set_epb_status(::google::protobuf::int32 value) {
  set_has_epb_status();
  epb_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Epb.epb_status)
}

// optional .jmc_auto.canbus.Epb.PBrakeType parking_brake_status = 4;
inline bool Epb::has_parking_brake_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Epb::set_has_parking_brake_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Epb::clear_has_parking_brake_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Epb::clear_parking_brake_status() {
  parking_brake_status_ = 0;
  clear_has_parking_brake_status();
}
inline ::jmc_auto::canbus::Epb_PBrakeType Epb::parking_brake_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Epb.parking_brake_status)
  return static_cast< ::jmc_auto::canbus::Epb_PBrakeType >(parking_brake_status_);
}
inline void Epb::set_parking_brake_status(::jmc_auto::canbus::Epb_PBrakeType value) {
  assert(::jmc_auto::canbus::Epb_PBrakeType_IsValid(value));
  set_has_parking_brake_status();
  parking_brake_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Epb.parking_brake_status)
}

// -------------------------------------------------------------------

// Gas

// optional bool is_gas_pedal_error = 1;
inline bool Gas::has_is_gas_pedal_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gas::set_has_is_gas_pedal_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gas::clear_has_is_gas_pedal_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gas::clear_is_gas_pedal_error() {
  is_gas_pedal_error_ = false;
  clear_has_is_gas_pedal_error();
}
inline bool Gas::is_gas_pedal_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.is_gas_pedal_error)
  return is_gas_pedal_error_;
}
inline void Gas::set_is_gas_pedal_error(bool value) {
  set_has_is_gas_pedal_error();
  is_gas_pedal_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.is_gas_pedal_error)
}

// optional bool is_gas_pedal_pressed_more = 2;
inline bool Gas::has_is_gas_pedal_pressed_more() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gas::set_has_is_gas_pedal_pressed_more() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gas::clear_has_is_gas_pedal_pressed_more() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gas::clear_is_gas_pedal_pressed_more() {
  is_gas_pedal_pressed_more_ = false;
  clear_has_is_gas_pedal_pressed_more();
}
inline bool Gas::is_gas_pedal_pressed_more() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.is_gas_pedal_pressed_more)
  return is_gas_pedal_pressed_more_;
}
inline void Gas::set_is_gas_pedal_pressed_more(bool value) {
  set_has_is_gas_pedal_pressed_more();
  is_gas_pedal_pressed_more_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.is_gas_pedal_pressed_more)
}

// optional double gas_pedal_position = 3 [default = 0];
inline bool Gas::has_gas_pedal_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gas::set_has_gas_pedal_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gas::clear_has_gas_pedal_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gas::clear_gas_pedal_position() {
  gas_pedal_position_ = 0;
  clear_has_gas_pedal_position();
}
inline double Gas::gas_pedal_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.gas_pedal_position)
  return gas_pedal_position_;
}
inline void Gas::set_gas_pedal_position(double value) {
  set_has_gas_pedal_position();
  gas_pedal_position_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.gas_pedal_position)
}

// optional bool is_gas_valid = 4 [default = false];
inline bool Gas::has_is_gas_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gas::set_has_is_gas_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gas::clear_has_is_gas_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gas::clear_is_gas_valid() {
  is_gas_valid_ = false;
  clear_has_is_gas_valid();
}
inline bool Gas::is_gas_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.is_gas_valid)
  return is_gas_valid_;
}
inline void Gas::set_is_gas_valid(bool value) {
  set_has_is_gas_valid();
  is_gas_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.is_gas_valid)
}

// optional double throttle_input = 5;
inline bool Gas::has_throttle_input() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gas::set_has_throttle_input() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gas::clear_has_throttle_input() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gas::clear_throttle_input() {
  throttle_input_ = 0;
  clear_has_throttle_input();
}
inline double Gas::throttle_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.throttle_input)
  return throttle_input_;
}
inline void Gas::set_throttle_input(double value) {
  set_has_throttle_input();
  throttle_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.throttle_input)
}

// optional double throttle_cmd = 6;
inline bool Gas::has_throttle_cmd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Gas::set_has_throttle_cmd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Gas::clear_has_throttle_cmd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Gas::clear_throttle_cmd() {
  throttle_cmd_ = 0;
  clear_has_throttle_cmd();
}
inline double Gas::throttle_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.throttle_cmd)
  return throttle_cmd_;
}
inline void Gas::set_throttle_cmd(double value) {
  set_has_throttle_cmd();
  throttle_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.throttle_cmd)
}

// optional double throttle_output = 7;
inline bool Gas::has_throttle_output() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Gas::set_has_throttle_output() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Gas::clear_has_throttle_output() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Gas::clear_throttle_output() {
  throttle_output_ = 0;
  clear_has_throttle_output();
}
inline double Gas::throttle_output() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.throttle_output)
  return throttle_output_;
}
inline void Gas::set_throttle_output(double value) {
  set_has_throttle_output();
  throttle_output_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.throttle_output)
}

// optional int32 watchdog_source = 8;
inline bool Gas::has_watchdog_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Gas::set_has_watchdog_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Gas::clear_has_watchdog_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Gas::clear_watchdog_source() {
  watchdog_source_ = 0;
  clear_has_watchdog_source();
}
inline ::google::protobuf::int32 Gas::watchdog_source() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.watchdog_source)
  return watchdog_source_;
}
inline void Gas::set_watchdog_source(::google::protobuf::int32 value) {
  set_has_watchdog_source();
  watchdog_source_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.watchdog_source)
}

// optional bool throttle_enabled = 9;
inline bool Gas::has_throttle_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gas::set_has_throttle_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gas::clear_has_throttle_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gas::clear_throttle_enabled() {
  throttle_enabled_ = false;
  clear_has_throttle_enabled();
}
inline bool Gas::throttle_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.throttle_enabled)
  return throttle_enabled_;
}
inline void Gas::set_throttle_enabled(bool value) {
  set_has_throttle_enabled();
  throttle_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.throttle_enabled)
}

// optional bool driver_override = 10;
inline bool Gas::has_driver_override() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Gas::set_has_driver_override() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Gas::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Gas::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Gas::driver_override() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.driver_override)
  return driver_override_;
}
inline void Gas::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.driver_override)
}

// optional bool driver_activity = 11;
inline bool Gas::has_driver_activity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Gas::set_has_driver_activity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Gas::clear_has_driver_activity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Gas::clear_driver_activity() {
  driver_activity_ = false;
  clear_has_driver_activity();
}
inline bool Gas::driver_activity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.driver_activity)
  return driver_activity_;
}
inline void Gas::set_driver_activity(bool value) {
  set_has_driver_activity();
  driver_activity_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.driver_activity)
}

// optional bool watchdog_fault = 12;
inline bool Gas::has_watchdog_fault() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Gas::set_has_watchdog_fault() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Gas::clear_has_watchdog_fault() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Gas::clear_watchdog_fault() {
  watchdog_fault_ = false;
  clear_has_watchdog_fault();
}
inline bool Gas::watchdog_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.watchdog_fault)
  return watchdog_fault_;
}
inline void Gas::set_watchdog_fault(bool value) {
  set_has_watchdog_fault();
  watchdog_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.watchdog_fault)
}

// optional bool channel_1_fault = 13;
inline bool Gas::has_channel_1_fault() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Gas::set_has_channel_1_fault() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Gas::clear_has_channel_1_fault() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Gas::clear_channel_1_fault() {
  channel_1_fault_ = false;
  clear_has_channel_1_fault();
}
inline bool Gas::channel_1_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.channel_1_fault)
  return channel_1_fault_;
}
inline void Gas::set_channel_1_fault(bool value) {
  set_has_channel_1_fault();
  channel_1_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.channel_1_fault)
}

// optional bool channel_2_fault = 14;
inline bool Gas::has_channel_2_fault() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Gas::set_has_channel_2_fault() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Gas::clear_has_channel_2_fault() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Gas::clear_channel_2_fault() {
  channel_2_fault_ = false;
  clear_has_channel_2_fault();
}
inline bool Gas::channel_2_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.channel_2_fault)
  return channel_2_fault_;
}
inline void Gas::set_channel_2_fault(bool value) {
  set_has_channel_2_fault();
  channel_2_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.channel_2_fault)
}

// optional bool connector_fault = 15;
inline bool Gas::has_connector_fault() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Gas::set_has_connector_fault() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Gas::clear_has_connector_fault() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Gas::clear_connector_fault() {
  connector_fault_ = false;
  clear_has_connector_fault();
}
inline bool Gas::connector_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.connector_fault)
  return connector_fault_;
}
inline void Gas::set_connector_fault(bool value) {
  set_has_connector_fault();
  connector_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.connector_fault)
}

// optional double accelerator_pedal = 16;
inline bool Gas::has_accelerator_pedal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Gas::set_has_accelerator_pedal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Gas::clear_has_accelerator_pedal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Gas::clear_accelerator_pedal() {
  accelerator_pedal_ = 0;
  clear_has_accelerator_pedal();
}
inline double Gas::accelerator_pedal() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.accelerator_pedal)
  return accelerator_pedal_;
}
inline void Gas::set_accelerator_pedal(double value) {
  set_has_accelerator_pedal();
  accelerator_pedal_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.accelerator_pedal)
}

// optional double accelerator_pedal_rate = 17;
inline bool Gas::has_accelerator_pedal_rate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Gas::set_has_accelerator_pedal_rate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Gas::clear_has_accelerator_pedal_rate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Gas::clear_accelerator_pedal_rate() {
  accelerator_pedal_rate_ = 0;
  clear_has_accelerator_pedal_rate();
}
inline double Gas::accelerator_pedal_rate() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.accelerator_pedal_rate)
  return accelerator_pedal_rate_;
}
inline void Gas::set_accelerator_pedal_rate(double value) {
  set_has_accelerator_pedal_rate();
  accelerator_pedal_rate_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.accelerator_pedal_rate)
}

// optional int32 major_version = 18;
inline bool Gas::has_major_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Gas::set_has_major_version() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Gas::clear_has_major_version() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Gas::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
inline ::google::protobuf::int32 Gas::major_version() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.major_version)
  return major_version_;
}
inline void Gas::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.major_version)
}

// optional int32 minor_version = 19;
inline bool Gas::has_minor_version() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Gas::set_has_minor_version() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Gas::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Gas::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
inline ::google::protobuf::int32 Gas::minor_version() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.minor_version)
  return minor_version_;
}
inline void Gas::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.minor_version)
}

// optional int32 build_number = 20;
inline bool Gas::has_build_number() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Gas::set_has_build_number() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Gas::clear_has_build_number() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Gas::clear_build_number() {
  build_number_ = 0;
  clear_has_build_number();
}
inline ::google::protobuf::int32 Gas::build_number() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gas.build_number)
  return build_number_;
}
inline void Gas::set_build_number(::google::protobuf::int32 value) {
  set_has_build_number();
  build_number_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gas.build_number)
}

// -------------------------------------------------------------------

// Esp

// optional bool is_esp_acc_error = 1;
inline bool Esp::has_is_esp_acc_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Esp::set_has_is_esp_acc_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Esp::clear_has_is_esp_acc_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Esp::clear_is_esp_acc_error() {
  is_esp_acc_error_ = false;
  clear_has_is_esp_acc_error();
}
inline bool Esp::is_esp_acc_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_esp_acc_error)
  return is_esp_acc_error_;
}
inline void Esp::set_is_esp_acc_error(bool value) {
  set_has_is_esp_acc_error();
  is_esp_acc_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_esp_acc_error)
}

// optional bool is_esp_on = 2;
inline bool Esp::has_is_esp_on() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Esp::set_has_is_esp_on() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Esp::clear_has_is_esp_on() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Esp::clear_is_esp_on() {
  is_esp_on_ = false;
  clear_has_is_esp_on();
}
inline bool Esp::is_esp_on() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_esp_on)
  return is_esp_on_;
}
inline void Esp::set_is_esp_on(bool value) {
  set_has_is_esp_on();
  is_esp_on_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_esp_on)
}

// optional bool is_esp_active = 3;
inline bool Esp::has_is_esp_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Esp::set_has_is_esp_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Esp::clear_has_is_esp_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Esp::clear_is_esp_active() {
  is_esp_active_ = false;
  clear_has_is_esp_active();
}
inline bool Esp::is_esp_active() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_esp_active)
  return is_esp_active_;
}
inline void Esp::set_is_esp_active(bool value) {
  set_has_is_esp_active();
  is_esp_active_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_esp_active)
}

// optional bool is_abs_error = 4;
inline bool Esp::has_is_abs_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Esp::set_has_is_abs_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Esp::clear_has_is_abs_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Esp::clear_is_abs_error() {
  is_abs_error_ = false;
  clear_has_is_abs_error();
}
inline bool Esp::is_abs_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_abs_error)
  return is_abs_error_;
}
inline void Esp::set_is_abs_error(bool value) {
  set_has_is_abs_error();
  is_abs_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_abs_error)
}

// optional bool is_abs_active = 5;
inline bool Esp::has_is_abs_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Esp::set_has_is_abs_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Esp::clear_has_is_abs_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Esp::clear_is_abs_active() {
  is_abs_active_ = false;
  clear_has_is_abs_active();
}
inline bool Esp::is_abs_active() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_abs_active)
  return is_abs_active_;
}
inline void Esp::set_is_abs_active(bool value) {
  set_has_is_abs_active();
  is_abs_active_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_abs_active)
}

// optional bool is_tcsvdc_fail = 6;
inline bool Esp::has_is_tcsvdc_fail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Esp::set_has_is_tcsvdc_fail() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Esp::clear_has_is_tcsvdc_fail() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Esp::clear_is_tcsvdc_fail() {
  is_tcsvdc_fail_ = false;
  clear_has_is_tcsvdc_fail();
}
inline bool Esp::is_tcsvdc_fail() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_tcsvdc_fail)
  return is_tcsvdc_fail_;
}
inline void Esp::set_is_tcsvdc_fail(bool value) {
  set_has_is_tcsvdc_fail();
  is_tcsvdc_fail_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_tcsvdc_fail)
}

// optional bool is_abs_enabled = 7;
inline bool Esp::has_is_abs_enabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Esp::set_has_is_abs_enabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Esp::clear_has_is_abs_enabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Esp::clear_is_abs_enabled() {
  is_abs_enabled_ = false;
  clear_has_is_abs_enabled();
}
inline bool Esp::is_abs_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_abs_enabled)
  return is_abs_enabled_;
}
inline void Esp::set_is_abs_enabled(bool value) {
  set_has_is_abs_enabled();
  is_abs_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_abs_enabled)
}

// optional bool is_stab_active = 8;
inline bool Esp::has_is_stab_active() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Esp::set_has_is_stab_active() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Esp::clear_has_is_stab_active() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Esp::clear_is_stab_active() {
  is_stab_active_ = false;
  clear_has_is_stab_active();
}
inline bool Esp::is_stab_active() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_stab_active)
  return is_stab_active_;
}
inline void Esp::set_is_stab_active(bool value) {
  set_has_is_stab_active();
  is_stab_active_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_stab_active)
}

// optional bool is_stab_enabled = 9;
inline bool Esp::has_is_stab_enabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Esp::set_has_is_stab_enabled() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Esp::clear_has_is_stab_enabled() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Esp::clear_is_stab_enabled() {
  is_stab_enabled_ = false;
  clear_has_is_stab_enabled();
}
inline bool Esp::is_stab_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_stab_enabled)
  return is_stab_enabled_;
}
inline void Esp::set_is_stab_enabled(bool value) {
  set_has_is_stab_enabled();
  is_stab_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_stab_enabled)
}

// optional bool is_trac_active = 10;
inline bool Esp::has_is_trac_active() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Esp::set_has_is_trac_active() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Esp::clear_has_is_trac_active() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Esp::clear_is_trac_active() {
  is_trac_active_ = false;
  clear_has_is_trac_active();
}
inline bool Esp::is_trac_active() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_trac_active)
  return is_trac_active_;
}
inline void Esp::set_is_trac_active(bool value) {
  set_has_is_trac_active();
  is_trac_active_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_trac_active)
}

// optional bool is_trac_enabled = 11;
inline bool Esp::has_is_trac_enabled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Esp::set_has_is_trac_enabled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Esp::clear_has_is_trac_enabled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Esp::clear_is_trac_enabled() {
  is_trac_enabled_ = false;
  clear_has_is_trac_enabled();
}
inline bool Esp::is_trac_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Esp.is_trac_enabled)
  return is_trac_enabled_;
}
inline void Esp::set_is_trac_enabled(bool value) {
  set_has_is_trac_enabled();
  is_trac_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Esp.is_trac_enabled)
}

// -------------------------------------------------------------------

// Ems

// optional bool is_engine_acc_available = 1;
inline bool Ems::has_is_engine_acc_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ems::set_has_is_engine_acc_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ems::clear_has_is_engine_acc_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ems::clear_is_engine_acc_available() {
  is_engine_acc_available_ = false;
  clear_has_is_engine_acc_available();
}
inline bool Ems::is_engine_acc_available() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.is_engine_acc_available)
  return is_engine_acc_available_;
}
inline void Ems::set_is_engine_acc_available(bool value) {
  set_has_is_engine_acc_available();
  is_engine_acc_available_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.is_engine_acc_available)
}

// optional bool is_engine_acc_error = 2;
inline bool Ems::has_is_engine_acc_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ems::set_has_is_engine_acc_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ems::clear_has_is_engine_acc_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ems::clear_is_engine_acc_error() {
  is_engine_acc_error_ = false;
  clear_has_is_engine_acc_error();
}
inline bool Ems::is_engine_acc_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.is_engine_acc_error)
  return is_engine_acc_error_;
}
inline void Ems::set_is_engine_acc_error(bool value) {
  set_has_is_engine_acc_error();
  is_engine_acc_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.is_engine_acc_error)
}

// optional .jmc_auto.canbus.Ems.Type engine_state = 3;
inline bool Ems::has_engine_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ems::set_has_engine_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ems::clear_has_engine_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ems::clear_engine_state() {
  engine_state_ = 0;
  clear_has_engine_state();
}
inline ::jmc_auto::canbus::Ems_Type Ems::engine_state() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.engine_state)
  return static_cast< ::jmc_auto::canbus::Ems_Type >(engine_state_);
}
inline void Ems::set_engine_state(::jmc_auto::canbus::Ems_Type value) {
  assert(::jmc_auto::canbus::Ems_Type_IsValid(value));
  set_has_engine_state();
  engine_state_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.engine_state)
}

// optional double max_engine_torq_percent = 4;
inline bool Ems::has_max_engine_torq_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ems::set_has_max_engine_torq_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ems::clear_has_max_engine_torq_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ems::clear_max_engine_torq_percent() {
  max_engine_torq_percent_ = 0;
  clear_has_max_engine_torq_percent();
}
inline double Ems::max_engine_torq_percent() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.max_engine_torq_percent)
  return max_engine_torq_percent_;
}
inline void Ems::set_max_engine_torq_percent(double value) {
  set_has_max_engine_torq_percent();
  max_engine_torq_percent_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.max_engine_torq_percent)
}

// optional double min_engine_torq_percent = 5;
inline bool Ems::has_min_engine_torq_percent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ems::set_has_min_engine_torq_percent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ems::clear_has_min_engine_torq_percent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ems::clear_min_engine_torq_percent() {
  min_engine_torq_percent_ = 0;
  clear_has_min_engine_torq_percent();
}
inline double Ems::min_engine_torq_percent() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.min_engine_torq_percent)
  return min_engine_torq_percent_;
}
inline void Ems::set_min_engine_torq_percent(double value) {
  set_has_min_engine_torq_percent();
  min_engine_torq_percent_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.min_engine_torq_percent)
}

// optional int32 base_engine_torq_constant = 6;
inline bool Ems::has_base_engine_torq_constant() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ems::set_has_base_engine_torq_constant() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ems::clear_has_base_engine_torq_constant() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ems::clear_base_engine_torq_constant() {
  base_engine_torq_constant_ = 0;
  clear_has_base_engine_torq_constant();
}
inline ::google::protobuf::int32 Ems::base_engine_torq_constant() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.base_engine_torq_constant)
  return base_engine_torq_constant_;
}
inline void Ems::set_base_engine_torq_constant(::google::protobuf::int32 value) {
  set_has_base_engine_torq_constant();
  base_engine_torq_constant_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.base_engine_torq_constant)
}

// optional bool is_engine_speed_error = 7;
inline bool Ems::has_is_engine_speed_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ems::set_has_is_engine_speed_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ems::clear_has_is_engine_speed_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ems::clear_is_engine_speed_error() {
  is_engine_speed_error_ = false;
  clear_has_is_engine_speed_error();
}
inline bool Ems::is_engine_speed_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.is_engine_speed_error)
  return is_engine_speed_error_;
}
inline void Ems::set_is_engine_speed_error(bool value) {
  set_has_is_engine_speed_error();
  is_engine_speed_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.is_engine_speed_error)
}

// optional double engine_speed = 8;
inline bool Ems::has_engine_speed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ems::set_has_engine_speed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ems::clear_has_engine_speed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ems::clear_engine_speed() {
  engine_speed_ = 0;
  clear_has_engine_speed();
}
inline double Ems::engine_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.engine_speed)
  return engine_speed_;
}
inline void Ems::set_engine_speed(double value) {
  set_has_engine_speed();
  engine_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.engine_speed)
}

// optional int32 engine_torque = 9;
inline bool Ems::has_engine_torque() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ems::set_has_engine_torque() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ems::clear_has_engine_torque() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ems::clear_engine_torque() {
  engine_torque_ = 0;
  clear_has_engine_torque();
}
inline ::google::protobuf::int32 Ems::engine_torque() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.engine_torque)
  return engine_torque_;
}
inline void Ems::set_engine_torque(::google::protobuf::int32 value) {
  set_has_engine_torque();
  engine_torque_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.engine_torque)
}

// optional bool is_over_engine_torque = 10;
inline bool Ems::has_is_over_engine_torque() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ems::set_has_is_over_engine_torque() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ems::clear_has_is_over_engine_torque() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ems::clear_is_over_engine_torque() {
  is_over_engine_torque_ = false;
  clear_has_is_over_engine_torque();
}
inline bool Ems::is_over_engine_torque() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.is_over_engine_torque)
  return is_over_engine_torque_;
}
inline void Ems::set_is_over_engine_torque(bool value) {
  set_has_is_over_engine_torque();
  is_over_engine_torque_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.is_over_engine_torque)
}

// optional double engine_rpm = 11;
inline bool Ems::has_engine_rpm() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ems::set_has_engine_rpm() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ems::clear_has_engine_rpm() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ems::clear_engine_rpm() {
  engine_rpm_ = 0;
  clear_has_engine_rpm();
}
inline double Ems::engine_rpm() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Ems.engine_rpm)
  return engine_rpm_;
}
inline void Ems::set_engine_rpm(double value) {
  set_has_engine_rpm();
  engine_rpm_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Ems.engine_rpm)
}

// -------------------------------------------------------------------

// Gear

// optional bool is_shift_position_valid = 1;
inline bool Gear::has_is_shift_position_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gear::set_has_is_shift_position_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gear::clear_has_is_shift_position_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gear::clear_is_shift_position_valid() {
  is_shift_position_valid_ = false;
  clear_has_is_shift_position_valid();
}
inline bool Gear::is_shift_position_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gear.is_shift_position_valid)
  return is_shift_position_valid_;
}
inline void Gear::set_is_shift_position_valid(bool value) {
  set_has_is_shift_position_valid();
  is_shift_position_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gear.is_shift_position_valid)
}

// optional .jmc_auto.canbus.Chassis.GearPosition gear_state = 2;
inline bool Gear::has_gear_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gear::set_has_gear_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gear::clear_has_gear_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gear::clear_gear_state() {
  gear_state_ = 0;
  clear_has_gear_state();
}
inline ::jmc_auto::canbus::Chassis_GearPosition Gear::gear_state() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gear.gear_state)
  return static_cast< ::jmc_auto::canbus::Chassis_GearPosition >(gear_state_);
}
inline void Gear::set_gear_state(::jmc_auto::canbus::Chassis_GearPosition value) {
  assert(::jmc_auto::canbus::Chassis_GearPosition_IsValid(value));
  set_has_gear_state();
  gear_state_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gear.gear_state)
}

// optional bool driver_override = 3;
inline bool Gear::has_driver_override() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gear::set_has_driver_override() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gear::clear_has_driver_override() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gear::clear_driver_override() {
  driver_override_ = false;
  clear_has_driver_override();
}
inline bool Gear::driver_override() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gear.driver_override)
  return driver_override_;
}
inline void Gear::set_driver_override(bool value) {
  set_has_driver_override();
  driver_override_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gear.driver_override)
}

// optional .jmc_auto.canbus.Chassis.GearPosition gear_cmd = 4;
inline bool Gear::has_gear_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gear::set_has_gear_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gear::clear_has_gear_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gear::clear_gear_cmd() {
  gear_cmd_ = 0;
  clear_has_gear_cmd();
}
inline ::jmc_auto::canbus::Chassis_GearPosition Gear::gear_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gear.gear_cmd)
  return static_cast< ::jmc_auto::canbus::Chassis_GearPosition >(gear_cmd_);
}
inline void Gear::set_gear_cmd(::jmc_auto::canbus::Chassis_GearPosition value) {
  assert(::jmc_auto::canbus::Chassis_GearPosition_IsValid(value));
  set_has_gear_cmd();
  gear_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gear.gear_cmd)
}

// optional bool canbus_fault = 5;
inline bool Gear::has_canbus_fault() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gear::set_has_canbus_fault() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gear::clear_has_canbus_fault() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gear::clear_canbus_fault() {
  canbus_fault_ = false;
  clear_has_canbus_fault();
}
inline bool Gear::canbus_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gear.canbus_fault)
  return canbus_fault_;
}
inline void Gear::set_canbus_fault(bool value) {
  set_has_canbus_fault();
  canbus_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Gear.canbus_fault)
}

// -------------------------------------------------------------------

// Safety

// optional bool is_driver_car_door_close = 1;
inline bool Safety::has_is_driver_car_door_close() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Safety::set_has_is_driver_car_door_close() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Safety::clear_has_is_driver_car_door_close() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Safety::clear_is_driver_car_door_close() {
  is_driver_car_door_close_ = false;
  clear_has_is_driver_car_door_close();
}
inline bool Safety::is_driver_car_door_close() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_driver_car_door_close)
  return is_driver_car_door_close_;
}
inline void Safety::set_is_driver_car_door_close(bool value) {
  set_has_is_driver_car_door_close();
  is_driver_car_door_close_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_driver_car_door_close)
}

// optional bool is_driver_buckled = 2;
inline bool Safety::has_is_driver_buckled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Safety::set_has_is_driver_buckled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Safety::clear_has_is_driver_buckled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Safety::clear_is_driver_buckled() {
  is_driver_buckled_ = false;
  clear_has_is_driver_buckled();
}
inline bool Safety::is_driver_buckled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_driver_buckled)
  return is_driver_buckled_;
}
inline void Safety::set_is_driver_buckled(bool value) {
  set_has_is_driver_buckled();
  is_driver_buckled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_driver_buckled)
}

// optional int32 emergency_button = 3;
inline bool Safety::has_emergency_button() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Safety::set_has_emergency_button() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Safety::clear_has_emergency_button() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Safety::clear_emergency_button() {
  emergency_button_ = 0;
  clear_has_emergency_button();
}
inline ::google::protobuf::int32 Safety::emergency_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.emergency_button)
  return emergency_button_;
}
inline void Safety::set_emergency_button(::google::protobuf::int32 value) {
  set_has_emergency_button();
  emergency_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.emergency_button)
}

// optional bool has_error = 4 [default = false];
inline bool Safety::has_has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Safety::set_has_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Safety::clear_has_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Safety::clear_has_error() {
  has_error_ = false;
  clear_has_has_error();
}
inline bool Safety::has_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.has_error)
  return has_error_;
}
inline void Safety::set_has_error(bool value) {
  set_has_has_error();
  has_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.has_error)
}

// optional bool is_motor_invertor_fault = 5;
inline bool Safety::has_is_motor_invertor_fault() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Safety::set_has_is_motor_invertor_fault() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Safety::clear_has_is_motor_invertor_fault() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Safety::clear_is_motor_invertor_fault() {
  is_motor_invertor_fault_ = false;
  clear_has_is_motor_invertor_fault();
}
inline bool Safety::is_motor_invertor_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_motor_invertor_fault)
  return is_motor_invertor_fault_;
}
inline void Safety::set_is_motor_invertor_fault(bool value) {
  set_has_is_motor_invertor_fault();
  is_motor_invertor_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_motor_invertor_fault)
}

// optional bool is_system_fault = 6;
inline bool Safety::has_is_system_fault() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Safety::set_has_is_system_fault() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Safety::clear_has_is_system_fault() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Safety::clear_is_system_fault() {
  is_system_fault_ = false;
  clear_has_is_system_fault();
}
inline bool Safety::is_system_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_system_fault)
  return is_system_fault_;
}
inline void Safety::set_is_system_fault(bool value) {
  set_has_is_system_fault();
  is_system_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_system_fault)
}

// optional bool is_power_battery_fault = 7;
inline bool Safety::has_is_power_battery_fault() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Safety::set_has_is_power_battery_fault() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Safety::clear_has_is_power_battery_fault() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Safety::clear_is_power_battery_fault() {
  is_power_battery_fault_ = false;
  clear_has_is_power_battery_fault();
}
inline bool Safety::is_power_battery_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_power_battery_fault)
  return is_power_battery_fault_;
}
inline void Safety::set_is_power_battery_fault(bool value) {
  set_has_is_power_battery_fault();
  is_power_battery_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_power_battery_fault)
}

// optional bool is_motor_invertor_over_temperature = 8;
inline bool Safety::has_is_motor_invertor_over_temperature() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Safety::set_has_is_motor_invertor_over_temperature() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Safety::clear_has_is_motor_invertor_over_temperature() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Safety::clear_is_motor_invertor_over_temperature() {
  is_motor_invertor_over_temperature_ = false;
  clear_has_is_motor_invertor_over_temperature();
}
inline bool Safety::is_motor_invertor_over_temperature() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_motor_invertor_over_temperature)
  return is_motor_invertor_over_temperature_;
}
inline void Safety::set_is_motor_invertor_over_temperature(bool value) {
  set_has_is_motor_invertor_over_temperature();
  is_motor_invertor_over_temperature_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_motor_invertor_over_temperature)
}

// optional bool is_small_battery_charge_discharge_fault = 9;
inline bool Safety::has_is_small_battery_charge_discharge_fault() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Safety::set_has_is_small_battery_charge_discharge_fault() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Safety::clear_has_is_small_battery_charge_discharge_fault() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Safety::clear_is_small_battery_charge_discharge_fault() {
  is_small_battery_charge_discharge_fault_ = false;
  clear_has_is_small_battery_charge_discharge_fault();
}
inline bool Safety::is_small_battery_charge_discharge_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_small_battery_charge_discharge_fault)
  return is_small_battery_charge_discharge_fault_;
}
inline void Safety::set_is_small_battery_charge_discharge_fault(bool value) {
  set_has_is_small_battery_charge_discharge_fault();
  is_small_battery_charge_discharge_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_small_battery_charge_discharge_fault)
}

// optional int32 driving_mode = 10;
inline bool Safety::has_driving_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Safety::set_has_driving_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Safety::clear_has_driving_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Safety::clear_driving_mode() {
  driving_mode_ = 0;
  clear_has_driving_mode();
}
inline ::google::protobuf::int32 Safety::driving_mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.driving_mode)
  return driving_mode_;
}
inline void Safety::set_driving_mode(::google::protobuf::int32 value) {
  set_has_driving_mode();
  driving_mode_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.driving_mode)
}

// optional bool is_passenger_door_open = 11;
inline bool Safety::has_is_passenger_door_open() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Safety::set_has_is_passenger_door_open() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Safety::clear_has_is_passenger_door_open() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Safety::clear_is_passenger_door_open() {
  is_passenger_door_open_ = false;
  clear_has_is_passenger_door_open();
}
inline bool Safety::is_passenger_door_open() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_passenger_door_open)
  return is_passenger_door_open_;
}
inline void Safety::set_is_passenger_door_open(bool value) {
  set_has_is_passenger_door_open();
  is_passenger_door_open_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_passenger_door_open)
}

// optional bool is_rearleft_door_open = 12;
inline bool Safety::has_is_rearleft_door_open() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Safety::set_has_is_rearleft_door_open() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Safety::clear_has_is_rearleft_door_open() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Safety::clear_is_rearleft_door_open() {
  is_rearleft_door_open_ = false;
  clear_has_is_rearleft_door_open();
}
inline bool Safety::is_rearleft_door_open() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_rearleft_door_open)
  return is_rearleft_door_open_;
}
inline void Safety::set_is_rearleft_door_open(bool value) {
  set_has_is_rearleft_door_open();
  is_rearleft_door_open_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_rearleft_door_open)
}

// optional bool is_rearright_door_open = 13;
inline bool Safety::has_is_rearright_door_open() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Safety::set_has_is_rearright_door_open() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Safety::clear_has_is_rearright_door_open() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Safety::clear_is_rearright_door_open() {
  is_rearright_door_open_ = false;
  clear_has_is_rearright_door_open();
}
inline bool Safety::is_rearright_door_open() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_rearright_door_open)
  return is_rearright_door_open_;
}
inline void Safety::set_is_rearright_door_open(bool value) {
  set_has_is_rearright_door_open();
  is_rearright_door_open_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_rearright_door_open)
}

// optional bool is_hood_open = 14;
inline bool Safety::has_is_hood_open() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Safety::set_has_is_hood_open() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Safety::clear_has_is_hood_open() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Safety::clear_is_hood_open() {
  is_hood_open_ = false;
  clear_has_is_hood_open();
}
inline bool Safety::is_hood_open() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_hood_open)
  return is_hood_open_;
}
inline void Safety::set_is_hood_open(bool value) {
  set_has_is_hood_open();
  is_hood_open_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_hood_open)
}

// optional bool is_trunk_open = 15;
inline bool Safety::has_is_trunk_open() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Safety::set_has_is_trunk_open() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Safety::clear_has_is_trunk_open() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Safety::clear_is_trunk_open() {
  is_trunk_open_ = false;
  clear_has_is_trunk_open();
}
inline bool Safety::is_trunk_open() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_trunk_open)
  return is_trunk_open_;
}
inline void Safety::set_is_trunk_open(bool value) {
  set_has_is_trunk_open();
  is_trunk_open_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_trunk_open)
}

// optional bool is_passenger_detected = 16;
inline bool Safety::has_is_passenger_detected() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Safety::set_has_is_passenger_detected() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Safety::clear_has_is_passenger_detected() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Safety::clear_is_passenger_detected() {
  is_passenger_detected_ = false;
  clear_has_is_passenger_detected();
}
inline bool Safety::is_passenger_detected() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_passenger_detected)
  return is_passenger_detected_;
}
inline void Safety::set_is_passenger_detected(bool value) {
  set_has_is_passenger_detected();
  is_passenger_detected_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_passenger_detected)
}

// optional bool is_passenger_airbag_enabled = 17;
inline bool Safety::has_is_passenger_airbag_enabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Safety::set_has_is_passenger_airbag_enabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Safety::clear_has_is_passenger_airbag_enabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Safety::clear_is_passenger_airbag_enabled() {
  is_passenger_airbag_enabled_ = false;
  clear_has_is_passenger_airbag_enabled();
}
inline bool Safety::is_passenger_airbag_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_passenger_airbag_enabled)
  return is_passenger_airbag_enabled_;
}
inline void Safety::set_is_passenger_airbag_enabled(bool value) {
  set_has_is_passenger_airbag_enabled();
  is_passenger_airbag_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_passenger_airbag_enabled)
}

// optional bool is_passenger_buckled = 18;
inline bool Safety::has_is_passenger_buckled() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Safety::set_has_is_passenger_buckled() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Safety::clear_has_is_passenger_buckled() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Safety::clear_is_passenger_buckled() {
  is_passenger_buckled_ = false;
  clear_has_is_passenger_buckled();
}
inline bool Safety::is_passenger_buckled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.is_passenger_buckled)
  return is_passenger_buckled_;
}
inline void Safety::set_is_passenger_buckled(bool value) {
  set_has_is_passenger_buckled();
  is_passenger_buckled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.is_passenger_buckled)
}

// optional int32 front_left_tire_press = 19;
inline bool Safety::has_front_left_tire_press() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Safety::set_has_front_left_tire_press() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Safety::clear_has_front_left_tire_press() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Safety::clear_front_left_tire_press() {
  front_left_tire_press_ = 0;
  clear_has_front_left_tire_press();
}
inline ::google::protobuf::int32 Safety::front_left_tire_press() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.front_left_tire_press)
  return front_left_tire_press_;
}
inline void Safety::set_front_left_tire_press(::google::protobuf::int32 value) {
  set_has_front_left_tire_press();
  front_left_tire_press_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.front_left_tire_press)
}

// optional int32 front_right_tire_press = 20;
inline bool Safety::has_front_right_tire_press() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Safety::set_has_front_right_tire_press() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Safety::clear_has_front_right_tire_press() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Safety::clear_front_right_tire_press() {
  front_right_tire_press_ = 0;
  clear_has_front_right_tire_press();
}
inline ::google::protobuf::int32 Safety::front_right_tire_press() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.front_right_tire_press)
  return front_right_tire_press_;
}
inline void Safety::set_front_right_tire_press(::google::protobuf::int32 value) {
  set_has_front_right_tire_press();
  front_right_tire_press_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.front_right_tire_press)
}

// optional int32 rear_left_tire_press = 21;
inline bool Safety::has_rear_left_tire_press() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Safety::set_has_rear_left_tire_press() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Safety::clear_has_rear_left_tire_press() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Safety::clear_rear_left_tire_press() {
  rear_left_tire_press_ = 0;
  clear_has_rear_left_tire_press();
}
inline ::google::protobuf::int32 Safety::rear_left_tire_press() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.rear_left_tire_press)
  return rear_left_tire_press_;
}
inline void Safety::set_rear_left_tire_press(::google::protobuf::int32 value) {
  set_has_rear_left_tire_press();
  rear_left_tire_press_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.rear_left_tire_press)
}

// optional int32 rear_right_tire_press = 22;
inline bool Safety::has_rear_right_tire_press() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Safety::set_has_rear_right_tire_press() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Safety::clear_has_rear_right_tire_press() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Safety::clear_rear_right_tire_press() {
  rear_right_tire_press_ = 0;
  clear_has_rear_right_tire_press();
}
inline ::google::protobuf::int32 Safety::rear_right_tire_press() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.rear_right_tire_press)
  return rear_right_tire_press_;
}
inline void Safety::set_rear_right_tire_press(::google::protobuf::int32 value) {
  set_has_rear_right_tire_press();
  rear_right_tire_press_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.rear_right_tire_press)
}

// optional .jmc_auto.canbus.Chassis.DrivingMode car_driving_mode = 23;
inline bool Safety::has_car_driving_mode() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Safety::set_has_car_driving_mode() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Safety::clear_has_car_driving_mode() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Safety::clear_car_driving_mode() {
  car_driving_mode_ = 0;
  clear_has_car_driving_mode();
}
inline ::jmc_auto::canbus::Chassis_DrivingMode Safety::car_driving_mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Safety.car_driving_mode)
  return static_cast< ::jmc_auto::canbus::Chassis_DrivingMode >(car_driving_mode_);
}
inline void Safety::set_car_driving_mode(::jmc_auto::canbus::Chassis_DrivingMode value) {
  assert(::jmc_auto::canbus::Chassis_DrivingMode_IsValid(value));
  set_has_car_driving_mode();
  car_driving_mode_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Safety.car_driving_mode)
}

// -------------------------------------------------------------------

// BasicInfo

// optional bool is_auto_mode = 1;
inline bool BasicInfo::has_is_auto_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicInfo::set_has_is_auto_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicInfo::clear_has_is_auto_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicInfo::clear_is_auto_mode() {
  is_auto_mode_ = false;
  clear_has_is_auto_mode();
}
inline bool BasicInfo::is_auto_mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.is_auto_mode)
  return is_auto_mode_;
}
inline void BasicInfo::set_is_auto_mode(bool value) {
  set_has_is_auto_mode();
  is_auto_mode_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.is_auto_mode)
}

// optional .jmc_auto.canbus.BasicInfo.Type power_state = 2;
inline bool BasicInfo::has_power_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicInfo::set_has_power_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicInfo::clear_has_power_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicInfo::clear_power_state() {
  power_state_ = 0;
  clear_has_power_state();
}
inline ::jmc_auto::canbus::BasicInfo_Type BasicInfo::power_state() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.power_state)
  return static_cast< ::jmc_auto::canbus::BasicInfo_Type >(power_state_);
}
inline void BasicInfo::set_power_state(::jmc_auto::canbus::BasicInfo_Type value) {
  assert(::jmc_auto::canbus::BasicInfo_Type_IsValid(value));
  set_has_power_state();
  power_state_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.power_state)
}

// optional bool is_air_bag_deployed = 3;
inline bool BasicInfo::has_is_air_bag_deployed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicInfo::set_has_is_air_bag_deployed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicInfo::clear_has_is_air_bag_deployed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicInfo::clear_is_air_bag_deployed() {
  is_air_bag_deployed_ = false;
  clear_has_is_air_bag_deployed();
}
inline bool BasicInfo::is_air_bag_deployed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.is_air_bag_deployed)
  return is_air_bag_deployed_;
}
inline void BasicInfo::set_is_air_bag_deployed(bool value) {
  set_has_is_air_bag_deployed();
  is_air_bag_deployed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.is_air_bag_deployed)
}

// optional double odo_meter = 4;
inline bool BasicInfo::has_odo_meter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasicInfo::set_has_odo_meter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasicInfo::clear_has_odo_meter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasicInfo::clear_odo_meter() {
  odo_meter_ = 0;
  clear_has_odo_meter();
}
inline double BasicInfo::odo_meter() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.odo_meter)
  return odo_meter_;
}
inline void BasicInfo::set_odo_meter(double value) {
  set_has_odo_meter();
  odo_meter_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.odo_meter)
}

// optional double drive_range = 5;
inline bool BasicInfo::has_drive_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BasicInfo::set_has_drive_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BasicInfo::clear_has_drive_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BasicInfo::clear_drive_range() {
  drive_range_ = 0;
  clear_has_drive_range();
}
inline double BasicInfo::drive_range() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.drive_range)
  return drive_range_;
}
inline void BasicInfo::set_drive_range(double value) {
  set_has_drive_range();
  drive_range_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.drive_range)
}

// optional bool is_system_error = 6;
inline bool BasicInfo::has_is_system_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasicInfo::set_has_is_system_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasicInfo::clear_has_is_system_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasicInfo::clear_is_system_error() {
  is_system_error_ = false;
  clear_has_is_system_error();
}
inline bool BasicInfo::is_system_error() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.is_system_error)
  return is_system_error_;
}
inline void BasicInfo::set_is_system_error(bool value) {
  set_has_is_system_error();
  is_system_error_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.is_system_error)
}

// optional bool is_human_interrupt = 7;
inline bool BasicInfo::has_is_human_interrupt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BasicInfo::set_has_is_human_interrupt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BasicInfo::clear_has_is_human_interrupt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BasicInfo::clear_is_human_interrupt() {
  is_human_interrupt_ = false;
  clear_has_is_human_interrupt();
}
inline bool BasicInfo::is_human_interrupt() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.is_human_interrupt)
  return is_human_interrupt_;
}
inline void BasicInfo::set_is_human_interrupt(bool value) {
  set_has_is_human_interrupt();
  is_human_interrupt_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.is_human_interrupt)
}

// optional bool acc_on_button = 8;
inline bool BasicInfo::has_acc_on_button() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BasicInfo::set_has_acc_on_button() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BasicInfo::clear_has_acc_on_button() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BasicInfo::clear_acc_on_button() {
  acc_on_button_ = false;
  clear_has_acc_on_button();
}
inline bool BasicInfo::acc_on_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_on_button)
  return acc_on_button_;
}
inline void BasicInfo::set_acc_on_button(bool value) {
  set_has_acc_on_button();
  acc_on_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_on_button)
}

// optional bool acc_off_button = 9;
inline bool BasicInfo::has_acc_off_button() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BasicInfo::set_has_acc_off_button() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BasicInfo::clear_has_acc_off_button() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BasicInfo::clear_acc_off_button() {
  acc_off_button_ = false;
  clear_has_acc_off_button();
}
inline bool BasicInfo::acc_off_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_off_button)
  return acc_off_button_;
}
inline void BasicInfo::set_acc_off_button(bool value) {
  set_has_acc_off_button();
  acc_off_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_off_button)
}

// optional bool acc_res_button = 10;
inline bool BasicInfo::has_acc_res_button() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BasicInfo::set_has_acc_res_button() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BasicInfo::clear_has_acc_res_button() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BasicInfo::clear_acc_res_button() {
  acc_res_button_ = false;
  clear_has_acc_res_button();
}
inline bool BasicInfo::acc_res_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_res_button)
  return acc_res_button_;
}
inline void BasicInfo::set_acc_res_button(bool value) {
  set_has_acc_res_button();
  acc_res_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_res_button)
}

// optional bool acc_cancel_button = 11;
inline bool BasicInfo::has_acc_cancel_button() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BasicInfo::set_has_acc_cancel_button() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BasicInfo::clear_has_acc_cancel_button() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BasicInfo::clear_acc_cancel_button() {
  acc_cancel_button_ = false;
  clear_has_acc_cancel_button();
}
inline bool BasicInfo::acc_cancel_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_cancel_button)
  return acc_cancel_button_;
}
inline void BasicInfo::set_acc_cancel_button(bool value) {
  set_has_acc_cancel_button();
  acc_cancel_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_cancel_button)
}

// optional bool acc_on_off_button = 12;
inline bool BasicInfo::has_acc_on_off_button() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BasicInfo::set_has_acc_on_off_button() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BasicInfo::clear_has_acc_on_off_button() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BasicInfo::clear_acc_on_off_button() {
  acc_on_off_button_ = false;
  clear_has_acc_on_off_button();
}
inline bool BasicInfo::acc_on_off_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_on_off_button)
  return acc_on_off_button_;
}
inline void BasicInfo::set_acc_on_off_button(bool value) {
  set_has_acc_on_off_button();
  acc_on_off_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_on_off_button)
}

// optional bool acc_res_cancel_button = 13;
inline bool BasicInfo::has_acc_res_cancel_button() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BasicInfo::set_has_acc_res_cancel_button() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BasicInfo::clear_has_acc_res_cancel_button() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BasicInfo::clear_acc_res_cancel_button() {
  acc_res_cancel_button_ = false;
  clear_has_acc_res_cancel_button();
}
inline bool BasicInfo::acc_res_cancel_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_res_cancel_button)
  return acc_res_cancel_button_;
}
inline void BasicInfo::set_acc_res_cancel_button(bool value) {
  set_has_acc_res_cancel_button();
  acc_res_cancel_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_res_cancel_button)
}

// optional bool acc_inc_spd_button = 14;
inline bool BasicInfo::has_acc_inc_spd_button() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BasicInfo::set_has_acc_inc_spd_button() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BasicInfo::clear_has_acc_inc_spd_button() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BasicInfo::clear_acc_inc_spd_button() {
  acc_inc_spd_button_ = false;
  clear_has_acc_inc_spd_button();
}
inline bool BasicInfo::acc_inc_spd_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_inc_spd_button)
  return acc_inc_spd_button_;
}
inline void BasicInfo::set_acc_inc_spd_button(bool value) {
  set_has_acc_inc_spd_button();
  acc_inc_spd_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_inc_spd_button)
}

// optional bool acc_dec_spd_button = 15;
inline bool BasicInfo::has_acc_dec_spd_button() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BasicInfo::set_has_acc_dec_spd_button() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BasicInfo::clear_has_acc_dec_spd_button() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BasicInfo::clear_acc_dec_spd_button() {
  acc_dec_spd_button_ = false;
  clear_has_acc_dec_spd_button();
}
inline bool BasicInfo::acc_dec_spd_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_dec_spd_button)
  return acc_dec_spd_button_;
}
inline void BasicInfo::set_acc_dec_spd_button(bool value) {
  set_has_acc_dec_spd_button();
  acc_dec_spd_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_dec_spd_button)
}

// optional bool acc_inc_gap_button = 16;
inline bool BasicInfo::has_acc_inc_gap_button() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BasicInfo::set_has_acc_inc_gap_button() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BasicInfo::clear_has_acc_inc_gap_button() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BasicInfo::clear_acc_inc_gap_button() {
  acc_inc_gap_button_ = false;
  clear_has_acc_inc_gap_button();
}
inline bool BasicInfo::acc_inc_gap_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_inc_gap_button)
  return acc_inc_gap_button_;
}
inline void BasicInfo::set_acc_inc_gap_button(bool value) {
  set_has_acc_inc_gap_button();
  acc_inc_gap_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_inc_gap_button)
}

// optional bool acc_dec_gap_button = 17;
inline bool BasicInfo::has_acc_dec_gap_button() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BasicInfo::set_has_acc_dec_gap_button() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BasicInfo::clear_has_acc_dec_gap_button() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BasicInfo::clear_acc_dec_gap_button() {
  acc_dec_gap_button_ = false;
  clear_has_acc_dec_gap_button();
}
inline bool BasicInfo::acc_dec_gap_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.acc_dec_gap_button)
  return acc_dec_gap_button_;
}
inline void BasicInfo::set_acc_dec_gap_button(bool value) {
  set_has_acc_dec_gap_button();
  acc_dec_gap_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.acc_dec_gap_button)
}

// optional bool lka_button = 18;
inline bool BasicInfo::has_lka_button() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BasicInfo::set_has_lka_button() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BasicInfo::clear_has_lka_button() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BasicInfo::clear_lka_button() {
  lka_button_ = false;
  clear_has_lka_button();
}
inline bool BasicInfo::lka_button() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.lka_button)
  return lka_button_;
}
inline void BasicInfo::set_lka_button(bool value) {
  set_has_lka_button();
  lka_button_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.lka_button)
}

// optional bool canbus_fault = 19;
inline bool BasicInfo::has_canbus_fault() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BasicInfo::set_has_canbus_fault() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BasicInfo::clear_has_canbus_fault() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BasicInfo::clear_canbus_fault() {
  canbus_fault_ = false;
  clear_has_canbus_fault();
}
inline bool BasicInfo::canbus_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.canbus_fault)
  return canbus_fault_;
}
inline void BasicInfo::set_canbus_fault(bool value) {
  set_has_canbus_fault();
  canbus_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.canbus_fault)
}

// optional double latitude = 20;
inline bool BasicInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BasicInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BasicInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BasicInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double BasicInfo::latitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.latitude)
  return latitude_;
}
inline void BasicInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.latitude)
}

// optional double longitude = 21;
inline bool BasicInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BasicInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BasicInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BasicInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double BasicInfo::longitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.longitude)
  return longitude_;
}
inline void BasicInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.longitude)
}

// optional bool gps_valid = 22;
inline bool BasicInfo::has_gps_valid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BasicInfo::set_has_gps_valid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BasicInfo::clear_has_gps_valid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BasicInfo::clear_gps_valid() {
  gps_valid_ = false;
  clear_has_gps_valid();
}
inline bool BasicInfo::gps_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.gps_valid)
  return gps_valid_;
}
inline void BasicInfo::set_gps_valid(bool value) {
  set_has_gps_valid();
  gps_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.gps_valid)
}

// optional int32 year = 23;
inline bool BasicInfo::has_year() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BasicInfo::set_has_year() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BasicInfo::clear_has_year() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BasicInfo::clear_year() {
  year_ = 0;
  clear_has_year();
}
inline ::google::protobuf::int32 BasicInfo::year() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.year)
  return year_;
}
inline void BasicInfo::set_year(::google::protobuf::int32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.year)
}

// optional int32 month = 24;
inline bool BasicInfo::has_month() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BasicInfo::set_has_month() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BasicInfo::clear_has_month() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BasicInfo::clear_month() {
  month_ = 0;
  clear_has_month();
}
inline ::google::protobuf::int32 BasicInfo::month() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.month)
  return month_;
}
inline void BasicInfo::set_month(::google::protobuf::int32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.month)
}

// optional int32 day = 25;
inline bool BasicInfo::has_day() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BasicInfo::set_has_day() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BasicInfo::clear_has_day() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BasicInfo::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 BasicInfo::day() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.day)
  return day_;
}
inline void BasicInfo::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.day)
}

// optional int32 hours = 26;
inline bool BasicInfo::has_hours() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BasicInfo::set_has_hours() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BasicInfo::clear_has_hours() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BasicInfo::clear_hours() {
  hours_ = 0;
  clear_has_hours();
}
inline ::google::protobuf::int32 BasicInfo::hours() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.hours)
  return hours_;
}
inline void BasicInfo::set_hours(::google::protobuf::int32 value) {
  set_has_hours();
  hours_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.hours)
}

// optional int32 minutes = 27;
inline bool BasicInfo::has_minutes() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BasicInfo::set_has_minutes() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BasicInfo::clear_has_minutes() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BasicInfo::clear_minutes() {
  minutes_ = 0;
  clear_has_minutes();
}
inline ::google::protobuf::int32 BasicInfo::minutes() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.minutes)
  return minutes_;
}
inline void BasicInfo::set_minutes(::google::protobuf::int32 value) {
  set_has_minutes();
  minutes_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.minutes)
}

// optional int32 seconds = 28;
inline bool BasicInfo::has_seconds() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BasicInfo::set_has_seconds() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BasicInfo::clear_has_seconds() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BasicInfo::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 BasicInfo::seconds() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.seconds)
  return seconds_;
}
inline void BasicInfo::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.seconds)
}

// optional double compass_direction = 29;
inline bool BasicInfo::has_compass_direction() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BasicInfo::set_has_compass_direction() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BasicInfo::clear_has_compass_direction() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BasicInfo::clear_compass_direction() {
  compass_direction_ = 0;
  clear_has_compass_direction();
}
inline double BasicInfo::compass_direction() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.compass_direction)
  return compass_direction_;
}
inline void BasicInfo::set_compass_direction(double value) {
  set_has_compass_direction();
  compass_direction_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.compass_direction)
}

// optional double pdop = 30;
inline bool BasicInfo::has_pdop() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BasicInfo::set_has_pdop() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BasicInfo::clear_has_pdop() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BasicInfo::clear_pdop() {
  pdop_ = 0;
  clear_has_pdop();
}
inline double BasicInfo::pdop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.pdop)
  return pdop_;
}
inline void BasicInfo::set_pdop(double value) {
  set_has_pdop();
  pdop_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.pdop)
}

// optional bool is_gps_fault = 31;
inline bool BasicInfo::has_is_gps_fault() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BasicInfo::set_has_is_gps_fault() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BasicInfo::clear_has_is_gps_fault() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BasicInfo::clear_is_gps_fault() {
  is_gps_fault_ = false;
  clear_has_is_gps_fault();
}
inline bool BasicInfo::is_gps_fault() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.is_gps_fault)
  return is_gps_fault_;
}
inline void BasicInfo::set_is_gps_fault(bool value) {
  set_has_is_gps_fault();
  is_gps_fault_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.is_gps_fault)
}

// optional bool is_inferred = 32;
inline bool BasicInfo::has_is_inferred() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BasicInfo::set_has_is_inferred() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BasicInfo::clear_has_is_inferred() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BasicInfo::clear_is_inferred() {
  is_inferred_ = false;
  clear_has_is_inferred();
}
inline bool BasicInfo::is_inferred() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.is_inferred)
  return is_inferred_;
}
inline void BasicInfo::set_is_inferred(bool value) {
  set_has_is_inferred();
  is_inferred_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.is_inferred)
}

// optional double altitude = 33;
inline bool BasicInfo::has_altitude() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BasicInfo::set_has_altitude() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BasicInfo::clear_has_altitude() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BasicInfo::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double BasicInfo::altitude() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.altitude)
  return altitude_;
}
inline void BasicInfo::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.altitude)
}

// optional double heading = 34;
inline bool BasicInfo::has_heading() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BasicInfo::set_has_heading() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BasicInfo::clear_has_heading() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BasicInfo::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double BasicInfo::heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.heading)
  return heading_;
}
inline void BasicInfo::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.heading)
}

// optional double hdop = 35;
inline bool BasicInfo::has_hdop() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BasicInfo::set_has_hdop() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BasicInfo::clear_has_hdop() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BasicInfo::clear_hdop() {
  hdop_ = 0;
  clear_has_hdop();
}
inline double BasicInfo::hdop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.hdop)
  return hdop_;
}
inline void BasicInfo::set_hdop(double value) {
  set_has_hdop();
  hdop_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.hdop)
}

// optional double vdop = 36;
inline bool BasicInfo::has_vdop() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BasicInfo::set_has_vdop() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BasicInfo::clear_has_vdop() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BasicInfo::clear_vdop() {
  vdop_ = 0;
  clear_has_vdop();
}
inline double BasicInfo::vdop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.vdop)
  return vdop_;
}
inline void BasicInfo::set_vdop(double value) {
  set_has_vdop();
  vdop_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.vdop)
}

// optional .jmc_auto.canbus.GpsQuality quality = 37;
inline bool BasicInfo::has_quality() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BasicInfo::set_has_quality() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BasicInfo::clear_has_quality() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BasicInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::jmc_auto::canbus::GpsQuality BasicInfo::quality() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.quality)
  return static_cast< ::jmc_auto::canbus::GpsQuality >(quality_);
}
inline void BasicInfo::set_quality(::jmc_auto::canbus::GpsQuality value) {
  assert(::jmc_auto::canbus::GpsQuality_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.quality)
}

// optional int32 num_satellites = 38;
inline bool BasicInfo::has_num_satellites() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void BasicInfo::set_has_num_satellites() {
  _has_bits_[1] |= 0x00000020u;
}
inline void BasicInfo::clear_has_num_satellites() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void BasicInfo::clear_num_satellites() {
  num_satellites_ = 0;
  clear_has_num_satellites();
}
inline ::google::protobuf::int32 BasicInfo::num_satellites() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.num_satellites)
  return num_satellites_;
}
inline void BasicInfo::set_num_satellites(::google::protobuf::int32 value) {
  set_has_num_satellites();
  num_satellites_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.num_satellites)
}

// optional double gps_speed = 39;
inline bool BasicInfo::has_gps_speed() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BasicInfo::set_has_gps_speed() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BasicInfo::clear_has_gps_speed() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BasicInfo::clear_gps_speed() {
  gps_speed_ = 0;
  clear_has_gps_speed();
}
inline double BasicInfo::gps_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.BasicInfo.gps_speed)
  return gps_speed_;
}
inline void BasicInfo::set_gps_speed(double value) {
  set_has_gps_speed();
  gps_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.BasicInfo.gps_speed)
}

// -------------------------------------------------------------------

// Global_rpt_6a

// optional .jmc_auto.canbus.Global_rpt_6a.Pacmod_statusType pacmod_status = 1;
inline bool Global_rpt_6a::has_pacmod_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Global_rpt_6a::set_has_pacmod_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Global_rpt_6a::clear_has_pacmod_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Global_rpt_6a::clear_pacmod_status() {
  pacmod_status_ = 0;
  clear_has_pacmod_status();
}
inline ::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType Global_rpt_6a::pacmod_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.pacmod_status)
  return static_cast< ::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType >(pacmod_status_);
}
inline void Global_rpt_6a::set_pacmod_status(::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType value) {
  assert(::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType_IsValid(value));
  set_has_pacmod_status();
  pacmod_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.pacmod_status)
}

// optional .jmc_auto.canbus.Global_rpt_6a.Override_statusType override_status = 2;
inline bool Global_rpt_6a::has_override_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Global_rpt_6a::set_has_override_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Global_rpt_6a::clear_has_override_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Global_rpt_6a::clear_override_status() {
  override_status_ = 0;
  clear_has_override_status();
}
inline ::jmc_auto::canbus::Global_rpt_6a_Override_statusType Global_rpt_6a::override_status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.override_status)
  return static_cast< ::jmc_auto::canbus::Global_rpt_6a_Override_statusType >(override_status_);
}
inline void Global_rpt_6a::set_override_status(::jmc_auto::canbus::Global_rpt_6a_Override_statusType value) {
  assert(::jmc_auto::canbus::Global_rpt_6a_Override_statusType_IsValid(value));
  set_has_override_status();
  override_status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.override_status)
}

// optional bool veh_can_timeout = 3;
inline bool Global_rpt_6a::has_veh_can_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Global_rpt_6a::set_has_veh_can_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Global_rpt_6a::clear_has_veh_can_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Global_rpt_6a::clear_veh_can_timeout() {
  veh_can_timeout_ = false;
  clear_has_veh_can_timeout();
}
inline bool Global_rpt_6a::veh_can_timeout() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.veh_can_timeout)
  return veh_can_timeout_;
}
inline void Global_rpt_6a::set_veh_can_timeout(bool value) {
  set_has_veh_can_timeout();
  veh_can_timeout_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.veh_can_timeout)
}

// optional bool str_can_timeout = 4;
inline bool Global_rpt_6a::has_str_can_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Global_rpt_6a::set_has_str_can_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Global_rpt_6a::clear_has_str_can_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Global_rpt_6a::clear_str_can_timeout() {
  str_can_timeout_ = false;
  clear_has_str_can_timeout();
}
inline bool Global_rpt_6a::str_can_timeout() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.str_can_timeout)
  return str_can_timeout_;
}
inline void Global_rpt_6a::set_str_can_timeout(bool value) {
  set_has_str_can_timeout();
  str_can_timeout_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.str_can_timeout)
}

// optional .jmc_auto.canbus.Global_rpt_6a.Brk_can_timeoutType brk_can_timeout = 5;
inline bool Global_rpt_6a::has_brk_can_timeout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Global_rpt_6a::set_has_brk_can_timeout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Global_rpt_6a::clear_has_brk_can_timeout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Global_rpt_6a::clear_brk_can_timeout() {
  brk_can_timeout_ = 0;
  clear_has_brk_can_timeout();
}
inline ::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType Global_rpt_6a::brk_can_timeout() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.brk_can_timeout)
  return static_cast< ::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType >(brk_can_timeout_);
}
inline void Global_rpt_6a::set_brk_can_timeout(::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType value) {
  assert(::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType_IsValid(value));
  set_has_brk_can_timeout();
  brk_can_timeout_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.brk_can_timeout)
}

// optional bool usr_can_timeout = 6;
inline bool Global_rpt_6a::has_usr_can_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Global_rpt_6a::set_has_usr_can_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Global_rpt_6a::clear_has_usr_can_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Global_rpt_6a::clear_usr_can_timeout() {
  usr_can_timeout_ = false;
  clear_has_usr_can_timeout();
}
inline bool Global_rpt_6a::usr_can_timeout() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.usr_can_timeout)
  return usr_can_timeout_;
}
inline void Global_rpt_6a::set_usr_can_timeout(bool value) {
  set_has_usr_can_timeout();
  usr_can_timeout_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.usr_can_timeout)
}

// optional int32 usr_can_read_errors = 7;
inline bool Global_rpt_6a::has_usr_can_read_errors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Global_rpt_6a::set_has_usr_can_read_errors() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Global_rpt_6a::clear_has_usr_can_read_errors() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Global_rpt_6a::clear_usr_can_read_errors() {
  usr_can_read_errors_ = 0;
  clear_has_usr_can_read_errors();
}
inline ::google::protobuf::int32 Global_rpt_6a::usr_can_read_errors() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_rpt_6a.usr_can_read_errors)
  return usr_can_read_errors_;
}
inline void Global_rpt_6a::set_usr_can_read_errors(::google::protobuf::int32 value) {
  set_has_usr_can_read_errors();
  usr_can_read_errors_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_rpt_6a.usr_can_read_errors)
}

// -------------------------------------------------------------------

// Brake_cmd_6b

// optional double brake_cmd = 1;
inline bool Brake_cmd_6b::has_brake_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake_cmd_6b::set_has_brake_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake_cmd_6b::clear_has_brake_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake_cmd_6b::clear_brake_cmd() {
  brake_cmd_ = 0;
  clear_has_brake_cmd();
}
inline double Brake_cmd_6b::brake_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_cmd_6b.brake_cmd)
  return brake_cmd_;
}
inline void Brake_cmd_6b::set_brake_cmd(double value) {
  set_has_brake_cmd();
  brake_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_cmd_6b.brake_cmd)
}

// -------------------------------------------------------------------

// Brake_rpt_6c

// optional double manual_input = 1;
inline bool Brake_rpt_6c::has_manual_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake_rpt_6c::set_has_manual_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake_rpt_6c::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake_rpt_6c::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline double Brake_rpt_6c::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_rpt_6c.manual_input)
  return manual_input_;
}
inline void Brake_rpt_6c::set_manual_input(double value) {
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_rpt_6c.manual_input)
}

// optional double commanded_value = 2;
inline bool Brake_rpt_6c::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake_rpt_6c::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake_rpt_6c::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake_rpt_6c::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline double Brake_rpt_6c::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_rpt_6c.commanded_value)
  return commanded_value_;
}
inline void Brake_rpt_6c::set_commanded_value(double value) {
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_rpt_6c.commanded_value)
}

// optional double output_value = 3;
inline bool Brake_rpt_6c::has_output_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Brake_rpt_6c::set_has_output_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Brake_rpt_6c::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Brake_rpt_6c::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline double Brake_rpt_6c::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_rpt_6c.output_value)
  return output_value_;
}
inline void Brake_rpt_6c::set_output_value(double value) {
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_rpt_6c.output_value)
}

// optional .jmc_auto.canbus.Brake_rpt_6c.Brake_on_offType brake_on_off = 4;
inline bool Brake_rpt_6c::has_brake_on_off() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Brake_rpt_6c::set_has_brake_on_off() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Brake_rpt_6c::clear_has_brake_on_off() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Brake_rpt_6c::clear_brake_on_off() {
  brake_on_off_ = 0;
  clear_has_brake_on_off();
}
inline ::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType Brake_rpt_6c::brake_on_off() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_rpt_6c.brake_on_off)
  return static_cast< ::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType >(brake_on_off_);
}
inline void Brake_rpt_6c::set_brake_on_off(::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType value) {
  assert(::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType_IsValid(value));
  set_has_brake_on_off();
  brake_on_off_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_rpt_6c.brake_on_off)
}

// -------------------------------------------------------------------

// Steering_cmd_6d

// optional double position_value = 1;
inline bool Steering_cmd_6d::has_position_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Steering_cmd_6d::set_has_position_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Steering_cmd_6d::clear_has_position_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Steering_cmd_6d::clear_position_value() {
  position_value_ = 0;
  clear_has_position_value();
}
inline double Steering_cmd_6d::position_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_cmd_6d.position_value)
  return position_value_;
}
inline void Steering_cmd_6d::set_position_value(double value) {
  set_has_position_value();
  position_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_cmd_6d.position_value)
}

// optional double speed_limit = 2;
inline bool Steering_cmd_6d::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Steering_cmd_6d::set_has_speed_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Steering_cmd_6d::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Steering_cmd_6d::clear_speed_limit() {
  speed_limit_ = 0;
  clear_has_speed_limit();
}
inline double Steering_cmd_6d::speed_limit() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_cmd_6d.speed_limit)
  return speed_limit_;
}
inline void Steering_cmd_6d::set_speed_limit(double value) {
  set_has_speed_limit();
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_cmd_6d.speed_limit)
}

// -------------------------------------------------------------------

// Steering_rpt_1_6e

// optional double manual_input = 1;
inline bool Steering_rpt_1_6e::has_manual_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Steering_rpt_1_6e::set_has_manual_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Steering_rpt_1_6e::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Steering_rpt_1_6e::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline double Steering_rpt_1_6e::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_rpt_1_6e.manual_input)
  return manual_input_;
}
inline void Steering_rpt_1_6e::set_manual_input(double value) {
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_rpt_1_6e.manual_input)
}

// optional double commanded_value = 2;
inline bool Steering_rpt_1_6e::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Steering_rpt_1_6e::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Steering_rpt_1_6e::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Steering_rpt_1_6e::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline double Steering_rpt_1_6e::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_rpt_1_6e.commanded_value)
  return commanded_value_;
}
inline void Steering_rpt_1_6e::set_commanded_value(double value) {
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_rpt_1_6e.commanded_value)
}

// optional double output_value = 3;
inline bool Steering_rpt_1_6e::has_output_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Steering_rpt_1_6e::set_has_output_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Steering_rpt_1_6e::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Steering_rpt_1_6e::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline double Steering_rpt_1_6e::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_rpt_1_6e.output_value)
  return output_value_;
}
inline void Steering_rpt_1_6e::set_output_value(double value) {
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_rpt_1_6e.output_value)
}

// -------------------------------------------------------------------

// Wheel_speed_rpt_7a

// optional int32 wheel_spd_rear_right = 1;
inline bool Wheel_speed_rpt_7a::has_wheel_spd_rear_right() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wheel_speed_rpt_7a::set_has_wheel_spd_rear_right() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wheel_speed_rpt_7a::clear_has_wheel_spd_rear_right() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_rear_right() {
  wheel_spd_rear_right_ = 0;
  clear_has_wheel_spd_rear_right();
}
inline ::google::protobuf::int32 Wheel_speed_rpt_7a::wheel_spd_rear_right() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_right)
  return wheel_spd_rear_right_;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_rear_right(::google::protobuf::int32 value) {
  set_has_wheel_spd_rear_right();
  wheel_spd_rear_right_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_right)
}

// optional int32 wheel_spd_rear_left = 2;
inline bool Wheel_speed_rpt_7a::has_wheel_spd_rear_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wheel_speed_rpt_7a::set_has_wheel_spd_rear_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wheel_speed_rpt_7a::clear_has_wheel_spd_rear_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_rear_left() {
  wheel_spd_rear_left_ = 0;
  clear_has_wheel_spd_rear_left();
}
inline ::google::protobuf::int32 Wheel_speed_rpt_7a::wheel_spd_rear_left() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_left)
  return wheel_spd_rear_left_;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_rear_left(::google::protobuf::int32 value) {
  set_has_wheel_spd_rear_left();
  wheel_spd_rear_left_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_rear_left)
}

// optional int32 wheel_spd_front_right = 3;
inline bool Wheel_speed_rpt_7a::has_wheel_spd_front_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Wheel_speed_rpt_7a::set_has_wheel_spd_front_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Wheel_speed_rpt_7a::clear_has_wheel_spd_front_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_front_right() {
  wheel_spd_front_right_ = 0;
  clear_has_wheel_spd_front_right();
}
inline ::google::protobuf::int32 Wheel_speed_rpt_7a::wheel_spd_front_right() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_front_right)
  return wheel_spd_front_right_;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_front_right(::google::protobuf::int32 value) {
  set_has_wheel_spd_front_right();
  wheel_spd_front_right_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_front_right)
}

// optional int32 wheel_spd_front_left = 4;
inline bool Wheel_speed_rpt_7a::has_wheel_spd_front_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Wheel_speed_rpt_7a::set_has_wheel_spd_front_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Wheel_speed_rpt_7a::clear_has_wheel_spd_front_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Wheel_speed_rpt_7a::clear_wheel_spd_front_left() {
  wheel_spd_front_left_ = 0;
  clear_has_wheel_spd_front_left();
}
inline ::google::protobuf::int32 Wheel_speed_rpt_7a::wheel_spd_front_left() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_front_left)
  return wheel_spd_front_left_;
}
inline void Wheel_speed_rpt_7a::set_wheel_spd_front_left(::google::protobuf::int32 value) {
  set_has_wheel_spd_front_left();
  wheel_spd_front_left_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wheel_speed_rpt_7a.wheel_spd_front_left)
}

// -------------------------------------------------------------------

// Date_time_rpt_83

// optional int32 time_second = 1;
inline bool Date_time_rpt_83::has_time_second() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Date_time_rpt_83::set_has_time_second() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Date_time_rpt_83::clear_has_time_second() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Date_time_rpt_83::clear_time_second() {
  time_second_ = 0;
  clear_has_time_second();
}
inline ::google::protobuf::int32 Date_time_rpt_83::time_second() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Date_time_rpt_83.time_second)
  return time_second_;
}
inline void Date_time_rpt_83::set_time_second(::google::protobuf::int32 value) {
  set_has_time_second();
  time_second_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Date_time_rpt_83.time_second)
}

// optional int32 time_minute = 2;
inline bool Date_time_rpt_83::has_time_minute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Date_time_rpt_83::set_has_time_minute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Date_time_rpt_83::clear_has_time_minute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Date_time_rpt_83::clear_time_minute() {
  time_minute_ = 0;
  clear_has_time_minute();
}
inline ::google::protobuf::int32 Date_time_rpt_83::time_minute() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Date_time_rpt_83.time_minute)
  return time_minute_;
}
inline void Date_time_rpt_83::set_time_minute(::google::protobuf::int32 value) {
  set_has_time_minute();
  time_minute_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Date_time_rpt_83.time_minute)
}

// optional int32 time_hour = 3;
inline bool Date_time_rpt_83::has_time_hour() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Date_time_rpt_83::set_has_time_hour() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Date_time_rpt_83::clear_has_time_hour() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Date_time_rpt_83::clear_time_hour() {
  time_hour_ = 0;
  clear_has_time_hour();
}
inline ::google::protobuf::int32 Date_time_rpt_83::time_hour() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Date_time_rpt_83.time_hour)
  return time_hour_;
}
inline void Date_time_rpt_83::set_time_hour(::google::protobuf::int32 value) {
  set_has_time_hour();
  time_hour_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Date_time_rpt_83.time_hour)
}

// optional int32 date_day = 4;
inline bool Date_time_rpt_83::has_date_day() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Date_time_rpt_83::set_has_date_day() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Date_time_rpt_83::clear_has_date_day() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Date_time_rpt_83::clear_date_day() {
  date_day_ = 0;
  clear_has_date_day();
}
inline ::google::protobuf::int32 Date_time_rpt_83::date_day() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Date_time_rpt_83.date_day)
  return date_day_;
}
inline void Date_time_rpt_83::set_date_day(::google::protobuf::int32 value) {
  set_has_date_day();
  date_day_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Date_time_rpt_83.date_day)
}

// optional int32 date_month = 5;
inline bool Date_time_rpt_83::has_date_month() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Date_time_rpt_83::set_has_date_month() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Date_time_rpt_83::clear_has_date_month() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Date_time_rpt_83::clear_date_month() {
  date_month_ = 0;
  clear_has_date_month();
}
inline ::google::protobuf::int32 Date_time_rpt_83::date_month() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Date_time_rpt_83.date_month)
  return date_month_;
}
inline void Date_time_rpt_83::set_date_month(::google::protobuf::int32 value) {
  set_has_date_month();
  date_month_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Date_time_rpt_83.date_month)
}

// optional int32 date_year = 6;
inline bool Date_time_rpt_83::has_date_year() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Date_time_rpt_83::set_has_date_year() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Date_time_rpt_83::clear_has_date_year() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Date_time_rpt_83::clear_date_year() {
  date_year_ = 0;
  clear_has_date_year();
}
inline ::google::protobuf::int32 Date_time_rpt_83::date_year() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Date_time_rpt_83.date_year)
  return date_year_;
}
inline void Date_time_rpt_83::set_date_year(::google::protobuf::int32 value) {
  set_has_date_year();
  date_year_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Date_time_rpt_83.date_year)
}

// -------------------------------------------------------------------

// Brake_motor_rpt_1_70

// optional double motor_current = 1;
inline bool Brake_motor_rpt_1_70::has_motor_current() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake_motor_rpt_1_70::set_has_motor_current() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake_motor_rpt_1_70::clear_has_motor_current() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake_motor_rpt_1_70::clear_motor_current() {
  motor_current_ = 0;
  clear_has_motor_current();
}
inline double Brake_motor_rpt_1_70::motor_current() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_1_70.motor_current)
  return motor_current_;
}
inline void Brake_motor_rpt_1_70::set_motor_current(double value) {
  set_has_motor_current();
  motor_current_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_1_70.motor_current)
}

// optional double shaft_position = 2;
inline bool Brake_motor_rpt_1_70::has_shaft_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake_motor_rpt_1_70::set_has_shaft_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake_motor_rpt_1_70::clear_has_shaft_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake_motor_rpt_1_70::clear_shaft_position() {
  shaft_position_ = 0;
  clear_has_shaft_position();
}
inline double Brake_motor_rpt_1_70::shaft_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_1_70.shaft_position)
  return shaft_position_;
}
inline void Brake_motor_rpt_1_70::set_shaft_position(double value) {
  set_has_shaft_position();
  shaft_position_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_1_70.shaft_position)
}

// -------------------------------------------------------------------

// Headlight_rpt_77

// optional .jmc_auto.canbus.Headlight_rpt_77.Output_valueType output_value = 1;
inline bool Headlight_rpt_77::has_output_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Headlight_rpt_77::set_has_output_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Headlight_rpt_77::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Headlight_rpt_77::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline ::jmc_auto::canbus::Headlight_rpt_77_Output_valueType Headlight_rpt_77::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Headlight_rpt_77.output_value)
  return static_cast< ::jmc_auto::canbus::Headlight_rpt_77_Output_valueType >(output_value_);
}
inline void Headlight_rpt_77::set_output_value(::jmc_auto::canbus::Headlight_rpt_77_Output_valueType value) {
  assert(::jmc_auto::canbus::Headlight_rpt_77_Output_valueType_IsValid(value));
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Headlight_rpt_77.output_value)
}

// optional .jmc_auto.canbus.Headlight_rpt_77.Manual_inputType manual_input = 2;
inline bool Headlight_rpt_77::has_manual_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Headlight_rpt_77::set_has_manual_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Headlight_rpt_77::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Headlight_rpt_77::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline ::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType Headlight_rpt_77::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Headlight_rpt_77.manual_input)
  return static_cast< ::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType >(manual_input_);
}
inline void Headlight_rpt_77::set_manual_input(::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType value) {
  assert(::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType_IsValid(value));
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Headlight_rpt_77.manual_input)
}

// optional .jmc_auto.canbus.Headlight_rpt_77.Commanded_valueType commanded_value = 3;
inline bool Headlight_rpt_77::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Headlight_rpt_77::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Headlight_rpt_77::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Headlight_rpt_77::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline ::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType Headlight_rpt_77::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Headlight_rpt_77.commanded_value)
  return static_cast< ::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType >(commanded_value_);
}
inline void Headlight_rpt_77::set_commanded_value(::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType value) {
  assert(::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType_IsValid(value));
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Headlight_rpt_77.commanded_value)
}

// -------------------------------------------------------------------

// Accel_rpt_68

// optional double manual_input = 1;
inline bool Accel_rpt_68::has_manual_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Accel_rpt_68::set_has_manual_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Accel_rpt_68::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Accel_rpt_68::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline double Accel_rpt_68::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Accel_rpt_68.manual_input)
  return manual_input_;
}
inline void Accel_rpt_68::set_manual_input(double value) {
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Accel_rpt_68.manual_input)
}

// optional double commanded_value = 2;
inline bool Accel_rpt_68::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Accel_rpt_68::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Accel_rpt_68::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Accel_rpt_68::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline double Accel_rpt_68::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Accel_rpt_68.commanded_value)
  return commanded_value_;
}
inline void Accel_rpt_68::set_commanded_value(double value) {
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Accel_rpt_68.commanded_value)
}

// optional double output_value = 3;
inline bool Accel_rpt_68::has_output_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Accel_rpt_68::set_has_output_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Accel_rpt_68::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Accel_rpt_68::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline double Accel_rpt_68::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Accel_rpt_68.output_value)
  return output_value_;
}
inline void Accel_rpt_68::set_output_value(double value) {
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Accel_rpt_68.output_value)
}

// -------------------------------------------------------------------

// Steering_motor_rpt_3_75

// optional double torque_output = 1;
inline bool Steering_motor_rpt_3_75::has_torque_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Steering_motor_rpt_3_75::set_has_torque_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Steering_motor_rpt_3_75::clear_has_torque_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Steering_motor_rpt_3_75::clear_torque_output() {
  torque_output_ = 0;
  clear_has_torque_output();
}
inline double Steering_motor_rpt_3_75::torque_output() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_3_75.torque_output)
  return torque_output_;
}
inline void Steering_motor_rpt_3_75::set_torque_output(double value) {
  set_has_torque_output();
  torque_output_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_3_75.torque_output)
}

// optional double torque_input = 2;
inline bool Steering_motor_rpt_3_75::has_torque_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Steering_motor_rpt_3_75::set_has_torque_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Steering_motor_rpt_3_75::clear_has_torque_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Steering_motor_rpt_3_75::clear_torque_input() {
  torque_input_ = 0;
  clear_has_torque_input();
}
inline double Steering_motor_rpt_3_75::torque_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_3_75.torque_input)
  return torque_input_;
}
inline void Steering_motor_rpt_3_75::set_torque_input(double value) {
  set_has_torque_input();
  torque_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_3_75.torque_input)
}

// -------------------------------------------------------------------

// Turn_cmd_63

// optional .jmc_auto.canbus.Turn_cmd_63.Turn_signal_cmdType turn_signal_cmd = 1;
inline bool Turn_cmd_63::has_turn_signal_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Turn_cmd_63::set_has_turn_signal_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Turn_cmd_63::clear_has_turn_signal_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Turn_cmd_63::clear_turn_signal_cmd() {
  turn_signal_cmd_ = 0;
  clear_has_turn_signal_cmd();
}
inline ::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType Turn_cmd_63::turn_signal_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Turn_cmd_63.turn_signal_cmd)
  return static_cast< ::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType >(turn_signal_cmd_);
}
inline void Turn_cmd_63::set_turn_signal_cmd(::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType value) {
  assert(::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType_IsValid(value));
  set_has_turn_signal_cmd();
  turn_signal_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Turn_cmd_63.turn_signal_cmd)
}

// -------------------------------------------------------------------

// Turn_rpt_64

// optional .jmc_auto.canbus.Turn_rpt_64.Manual_inputType manual_input = 1;
inline bool Turn_rpt_64::has_manual_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Turn_rpt_64::set_has_manual_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Turn_rpt_64::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Turn_rpt_64::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline ::jmc_auto::canbus::Turn_rpt_64_Manual_inputType Turn_rpt_64::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Turn_rpt_64.manual_input)
  return static_cast< ::jmc_auto::canbus::Turn_rpt_64_Manual_inputType >(manual_input_);
}
inline void Turn_rpt_64::set_manual_input(::jmc_auto::canbus::Turn_rpt_64_Manual_inputType value) {
  assert(::jmc_auto::canbus::Turn_rpt_64_Manual_inputType_IsValid(value));
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Turn_rpt_64.manual_input)
}

// optional .jmc_auto.canbus.Turn_rpt_64.Commanded_valueType commanded_value = 2;
inline bool Turn_rpt_64::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Turn_rpt_64::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Turn_rpt_64::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Turn_rpt_64::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline ::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType Turn_rpt_64::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Turn_rpt_64.commanded_value)
  return static_cast< ::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType >(commanded_value_);
}
inline void Turn_rpt_64::set_commanded_value(::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType value) {
  assert(::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType_IsValid(value));
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Turn_rpt_64.commanded_value)
}

// optional .jmc_auto.canbus.Turn_rpt_64.Output_valueType output_value = 3;
inline bool Turn_rpt_64::has_output_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Turn_rpt_64::set_has_output_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Turn_rpt_64::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Turn_rpt_64::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline ::jmc_auto::canbus::Turn_rpt_64_Output_valueType Turn_rpt_64::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Turn_rpt_64.output_value)
  return static_cast< ::jmc_auto::canbus::Turn_rpt_64_Output_valueType >(output_value_);
}
inline void Turn_rpt_64::set_output_value(::jmc_auto::canbus::Turn_rpt_64_Output_valueType value) {
  assert(::jmc_auto::canbus::Turn_rpt_64_Output_valueType_IsValid(value));
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Turn_rpt_64.output_value)
}

// -------------------------------------------------------------------

// Shift_cmd_65

// optional .jmc_auto.canbus.Shift_cmd_65.Shift_cmdType shift_cmd = 1;
inline bool Shift_cmd_65::has_shift_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Shift_cmd_65::set_has_shift_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Shift_cmd_65::clear_has_shift_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Shift_cmd_65::clear_shift_cmd() {
  shift_cmd_ = 0;
  clear_has_shift_cmd();
}
inline ::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType Shift_cmd_65::shift_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Shift_cmd_65.shift_cmd)
  return static_cast< ::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType >(shift_cmd_);
}
inline void Shift_cmd_65::set_shift_cmd(::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType value) {
  assert(::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType_IsValid(value));
  set_has_shift_cmd();
  shift_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Shift_cmd_65.shift_cmd)
}

// -------------------------------------------------------------------

// Shift_rpt_66

// optional .jmc_auto.canbus.Shift_rpt_66.Manual_inputType manual_input = 1;
inline bool Shift_rpt_66::has_manual_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Shift_rpt_66::set_has_manual_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Shift_rpt_66::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Shift_rpt_66::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline ::jmc_auto::canbus::Shift_rpt_66_Manual_inputType Shift_rpt_66::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Shift_rpt_66.manual_input)
  return static_cast< ::jmc_auto::canbus::Shift_rpt_66_Manual_inputType >(manual_input_);
}
inline void Shift_rpt_66::set_manual_input(::jmc_auto::canbus::Shift_rpt_66_Manual_inputType value) {
  assert(::jmc_auto::canbus::Shift_rpt_66_Manual_inputType_IsValid(value));
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Shift_rpt_66.manual_input)
}

// optional .jmc_auto.canbus.Shift_rpt_66.Commanded_valueType commanded_value = 2;
inline bool Shift_rpt_66::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Shift_rpt_66::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Shift_rpt_66::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Shift_rpt_66::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline ::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType Shift_rpt_66::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Shift_rpt_66.commanded_value)
  return static_cast< ::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType >(commanded_value_);
}
inline void Shift_rpt_66::set_commanded_value(::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType value) {
  assert(::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType_IsValid(value));
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Shift_rpt_66.commanded_value)
}

// optional .jmc_auto.canbus.Shift_rpt_66.Output_valueType output_value = 3;
inline bool Shift_rpt_66::has_output_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Shift_rpt_66::set_has_output_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Shift_rpt_66::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Shift_rpt_66::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline ::jmc_auto::canbus::Shift_rpt_66_Output_valueType Shift_rpt_66::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Shift_rpt_66.output_value)
  return static_cast< ::jmc_auto::canbus::Shift_rpt_66_Output_valueType >(output_value_);
}
inline void Shift_rpt_66::set_output_value(::jmc_auto::canbus::Shift_rpt_66_Output_valueType value) {
  assert(::jmc_auto::canbus::Shift_rpt_66_Output_valueType_IsValid(value));
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Shift_rpt_66.output_value)
}

// -------------------------------------------------------------------

// Accel_cmd_67

// optional double accel_cmd = 1;
inline bool Accel_cmd_67::has_accel_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Accel_cmd_67::set_has_accel_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Accel_cmd_67::clear_has_accel_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Accel_cmd_67::clear_accel_cmd() {
  accel_cmd_ = 0;
  clear_has_accel_cmd();
}
inline double Accel_cmd_67::accel_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Accel_cmd_67.accel_cmd)
  return accel_cmd_;
}
inline void Accel_cmd_67::set_accel_cmd(double value) {
  set_has_accel_cmd();
  accel_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Accel_cmd_67.accel_cmd)
}

// -------------------------------------------------------------------

// Lat_lon_heading_rpt_82

// optional double heading = 1;
inline bool Lat_lon_heading_rpt_82::has_heading() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_heading() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lat_lon_heading_rpt_82::clear_has_heading() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lat_lon_heading_rpt_82::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double Lat_lon_heading_rpt_82::heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.heading)
  return heading_;
}
inline void Lat_lon_heading_rpt_82::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.heading)
}

// optional int32 longitude_seconds = 2;
inline bool Lat_lon_heading_rpt_82::has_longitude_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_longitude_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lat_lon_heading_rpt_82::clear_has_longitude_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lat_lon_heading_rpt_82::clear_longitude_seconds() {
  longitude_seconds_ = 0;
  clear_has_longitude_seconds();
}
inline ::google::protobuf::int32 Lat_lon_heading_rpt_82::longitude_seconds() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.longitude_seconds)
  return longitude_seconds_;
}
inline void Lat_lon_heading_rpt_82::set_longitude_seconds(::google::protobuf::int32 value) {
  set_has_longitude_seconds();
  longitude_seconds_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.longitude_seconds)
}

// optional int32 longitude_minutes = 3;
inline bool Lat_lon_heading_rpt_82::has_longitude_minutes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_longitude_minutes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lat_lon_heading_rpt_82::clear_has_longitude_minutes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lat_lon_heading_rpt_82::clear_longitude_minutes() {
  longitude_minutes_ = 0;
  clear_has_longitude_minutes();
}
inline ::google::protobuf::int32 Lat_lon_heading_rpt_82::longitude_minutes() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.longitude_minutes)
  return longitude_minutes_;
}
inline void Lat_lon_heading_rpt_82::set_longitude_minutes(::google::protobuf::int32 value) {
  set_has_longitude_minutes();
  longitude_minutes_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.longitude_minutes)
}

// optional int32 longitude_degrees = 4;
inline bool Lat_lon_heading_rpt_82::has_longitude_degrees() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_longitude_degrees() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Lat_lon_heading_rpt_82::clear_has_longitude_degrees() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Lat_lon_heading_rpt_82::clear_longitude_degrees() {
  longitude_degrees_ = 0;
  clear_has_longitude_degrees();
}
inline ::google::protobuf::int32 Lat_lon_heading_rpt_82::longitude_degrees() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.longitude_degrees)
  return longitude_degrees_;
}
inline void Lat_lon_heading_rpt_82::set_longitude_degrees(::google::protobuf::int32 value) {
  set_has_longitude_degrees();
  longitude_degrees_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.longitude_degrees)
}

// optional int32 latitude_seconds = 5;
inline bool Lat_lon_heading_rpt_82::has_latitude_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_latitude_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lat_lon_heading_rpt_82::clear_has_latitude_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lat_lon_heading_rpt_82::clear_latitude_seconds() {
  latitude_seconds_ = 0;
  clear_has_latitude_seconds();
}
inline ::google::protobuf::int32 Lat_lon_heading_rpt_82::latitude_seconds() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.latitude_seconds)
  return latitude_seconds_;
}
inline void Lat_lon_heading_rpt_82::set_latitude_seconds(::google::protobuf::int32 value) {
  set_has_latitude_seconds();
  latitude_seconds_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.latitude_seconds)
}

// optional int32 latitude_minutes = 6;
inline bool Lat_lon_heading_rpt_82::has_latitude_minutes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_latitude_minutes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Lat_lon_heading_rpt_82::clear_has_latitude_minutes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Lat_lon_heading_rpt_82::clear_latitude_minutes() {
  latitude_minutes_ = 0;
  clear_has_latitude_minutes();
}
inline ::google::protobuf::int32 Lat_lon_heading_rpt_82::latitude_minutes() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.latitude_minutes)
  return latitude_minutes_;
}
inline void Lat_lon_heading_rpt_82::set_latitude_minutes(::google::protobuf::int32 value) {
  set_has_latitude_minutes();
  latitude_minutes_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.latitude_minutes)
}

// optional int32 latitude_degrees = 7;
inline bool Lat_lon_heading_rpt_82::has_latitude_degrees() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Lat_lon_heading_rpt_82::set_has_latitude_degrees() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Lat_lon_heading_rpt_82::clear_has_latitude_degrees() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Lat_lon_heading_rpt_82::clear_latitude_degrees() {
  latitude_degrees_ = 0;
  clear_has_latitude_degrees();
}
inline ::google::protobuf::int32 Lat_lon_heading_rpt_82::latitude_degrees() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Lat_lon_heading_rpt_82.latitude_degrees)
  return latitude_degrees_;
}
inline void Lat_lon_heading_rpt_82::set_latitude_degrees(::google::protobuf::int32 value) {
  set_has_latitude_degrees();
  latitude_degrees_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Lat_lon_heading_rpt_82.latitude_degrees)
}

// -------------------------------------------------------------------

// Global_cmd_69

// optional .jmc_auto.canbus.Global_cmd_69.Pacmod_enableType pacmod_enable = 1;
inline bool Global_cmd_69::has_pacmod_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Global_cmd_69::set_has_pacmod_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Global_cmd_69::clear_has_pacmod_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Global_cmd_69::clear_pacmod_enable() {
  pacmod_enable_ = 0;
  clear_has_pacmod_enable();
}
inline ::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType Global_cmd_69::pacmod_enable() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_cmd_69.pacmod_enable)
  return static_cast< ::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType >(pacmod_enable_);
}
inline void Global_cmd_69::set_pacmod_enable(::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType value) {
  assert(::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType_IsValid(value));
  set_has_pacmod_enable();
  pacmod_enable_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_cmd_69.pacmod_enable)
}

// optional .jmc_auto.canbus.Global_cmd_69.Clear_overrideType clear_override = 2;
inline bool Global_cmd_69::has_clear_override() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Global_cmd_69::set_has_clear_override() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Global_cmd_69::clear_has_clear_override() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Global_cmd_69::clear_clear_override() {
  clear_override_ = 0;
  clear_has_clear_override();
}
inline ::jmc_auto::canbus::Global_cmd_69_Clear_overrideType Global_cmd_69::clear_override() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_cmd_69.clear_override)
  return static_cast< ::jmc_auto::canbus::Global_cmd_69_Clear_overrideType >(clear_override_);
}
inline void Global_cmd_69::set_clear_override(::jmc_auto::canbus::Global_cmd_69_Clear_overrideType value) {
  assert(::jmc_auto::canbus::Global_cmd_69_Clear_overrideType_IsValid(value));
  set_has_clear_override();
  clear_override_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_cmd_69.clear_override)
}

// optional .jmc_auto.canbus.Global_cmd_69.Ignore_overrideType ignore_override = 3;
inline bool Global_cmd_69::has_ignore_override() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Global_cmd_69::set_has_ignore_override() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Global_cmd_69::clear_has_ignore_override() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Global_cmd_69::clear_ignore_override() {
  ignore_override_ = 0;
  clear_has_ignore_override();
}
inline ::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType Global_cmd_69::ignore_override() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Global_cmd_69.ignore_override)
  return static_cast< ::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType >(ignore_override_);
}
inline void Global_cmd_69::set_ignore_override(::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType value) {
  assert(::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType_IsValid(value));
  set_has_ignore_override();
  ignore_override_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Global_cmd_69.ignore_override)
}

// -------------------------------------------------------------------

// Parking_brake_status_rpt_80

// optional .jmc_auto.canbus.Parking_brake_status_rpt_80.Parking_brake_enabledType parking_brake_enabled = 1;
inline bool Parking_brake_status_rpt_80::has_parking_brake_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parking_brake_status_rpt_80::set_has_parking_brake_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parking_brake_status_rpt_80::clear_has_parking_brake_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parking_brake_status_rpt_80::clear_parking_brake_enabled() {
  parking_brake_enabled_ = 0;
  clear_has_parking_brake_enabled();
}
inline ::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType Parking_brake_status_rpt_80::parking_brake_enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Parking_brake_status_rpt_80.parking_brake_enabled)
  return static_cast< ::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType >(parking_brake_enabled_);
}
inline void Parking_brake_status_rpt_80::set_parking_brake_enabled(::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType value) {
  assert(::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType_IsValid(value));
  set_has_parking_brake_enabled();
  parking_brake_enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Parking_brake_status_rpt_80.parking_brake_enabled)
}

// -------------------------------------------------------------------

// Yaw_rate_rpt_81

// optional double yaw_rate = 1;
inline bool Yaw_rate_rpt_81::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Yaw_rate_rpt_81::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Yaw_rate_rpt_81::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Yaw_rate_rpt_81::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline double Yaw_rate_rpt_81::yaw_rate() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Yaw_rate_rpt_81.yaw_rate)
  return yaw_rate_;
}
inline void Yaw_rate_rpt_81::set_yaw_rate(double value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Yaw_rate_rpt_81.yaw_rate)
}

// -------------------------------------------------------------------

// Horn_rpt_79

// optional .jmc_auto.canbus.Horn_rpt_79.Output_valueType output_value = 1;
inline bool Horn_rpt_79::has_output_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Horn_rpt_79::set_has_output_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Horn_rpt_79::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Horn_rpt_79::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline ::jmc_auto::canbus::Horn_rpt_79_Output_valueType Horn_rpt_79::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Horn_rpt_79.output_value)
  return static_cast< ::jmc_auto::canbus::Horn_rpt_79_Output_valueType >(output_value_);
}
inline void Horn_rpt_79::set_output_value(::jmc_auto::canbus::Horn_rpt_79_Output_valueType value) {
  assert(::jmc_auto::canbus::Horn_rpt_79_Output_valueType_IsValid(value));
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Horn_rpt_79.output_value)
}

// optional .jmc_auto.canbus.Horn_rpt_79.Commanded_valueType commanded_value = 2;
inline bool Horn_rpt_79::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Horn_rpt_79::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Horn_rpt_79::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Horn_rpt_79::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline ::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType Horn_rpt_79::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Horn_rpt_79.commanded_value)
  return static_cast< ::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType >(commanded_value_);
}
inline void Horn_rpt_79::set_commanded_value(::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType value) {
  assert(::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType_IsValid(value));
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Horn_rpt_79.commanded_value)
}

// optional .jmc_auto.canbus.Horn_rpt_79.Manual_inputType manual_input = 3;
inline bool Horn_rpt_79::has_manual_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Horn_rpt_79::set_has_manual_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Horn_rpt_79::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Horn_rpt_79::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline ::jmc_auto::canbus::Horn_rpt_79_Manual_inputType Horn_rpt_79::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Horn_rpt_79.manual_input)
  return static_cast< ::jmc_auto::canbus::Horn_rpt_79_Manual_inputType >(manual_input_);
}
inline void Horn_rpt_79::set_manual_input(::jmc_auto::canbus::Horn_rpt_79_Manual_inputType value) {
  assert(::jmc_auto::canbus::Horn_rpt_79_Manual_inputType_IsValid(value));
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Horn_rpt_79.manual_input)
}

// -------------------------------------------------------------------

// Horn_cmd_78

// optional .jmc_auto.canbus.Horn_cmd_78.Horn_cmdType horn_cmd = 1;
inline bool Horn_cmd_78::has_horn_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Horn_cmd_78::set_has_horn_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Horn_cmd_78::clear_has_horn_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Horn_cmd_78::clear_horn_cmd() {
  horn_cmd_ = 0;
  clear_has_horn_cmd();
}
inline ::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType Horn_cmd_78::horn_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Horn_cmd_78.horn_cmd)
  return static_cast< ::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType >(horn_cmd_);
}
inline void Horn_cmd_78::set_horn_cmd(::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType value) {
  assert(::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType_IsValid(value));
  set_has_horn_cmd();
  horn_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Horn_cmd_78.horn_cmd)
}

// -------------------------------------------------------------------

// Wiper_rpt_91

// optional .jmc_auto.canbus.Wiper_rpt_91.Output_valueType output_value = 1;
inline bool Wiper_rpt_91::has_output_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wiper_rpt_91::set_has_output_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wiper_rpt_91::clear_has_output_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wiper_rpt_91::clear_output_value() {
  output_value_ = 0;
  clear_has_output_value();
}
inline ::jmc_auto::canbus::Wiper_rpt_91_Output_valueType Wiper_rpt_91::output_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wiper_rpt_91.output_value)
  return static_cast< ::jmc_auto::canbus::Wiper_rpt_91_Output_valueType >(output_value_);
}
inline void Wiper_rpt_91::set_output_value(::jmc_auto::canbus::Wiper_rpt_91_Output_valueType value) {
  assert(::jmc_auto::canbus::Wiper_rpt_91_Output_valueType_IsValid(value));
  set_has_output_value();
  output_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wiper_rpt_91.output_value)
}

// optional .jmc_auto.canbus.Wiper_rpt_91.Commanded_valueType commanded_value = 2;
inline bool Wiper_rpt_91::has_commanded_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wiper_rpt_91::set_has_commanded_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wiper_rpt_91::clear_has_commanded_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wiper_rpt_91::clear_commanded_value() {
  commanded_value_ = 0;
  clear_has_commanded_value();
}
inline ::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType Wiper_rpt_91::commanded_value() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wiper_rpt_91.commanded_value)
  return static_cast< ::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType >(commanded_value_);
}
inline void Wiper_rpt_91::set_commanded_value(::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType value) {
  assert(::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType_IsValid(value));
  set_has_commanded_value();
  commanded_value_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wiper_rpt_91.commanded_value)
}

// optional .jmc_auto.canbus.Wiper_rpt_91.Manual_inputType manual_input = 3;
inline bool Wiper_rpt_91::has_manual_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Wiper_rpt_91::set_has_manual_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Wiper_rpt_91::clear_has_manual_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Wiper_rpt_91::clear_manual_input() {
  manual_input_ = 0;
  clear_has_manual_input();
}
inline ::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType Wiper_rpt_91::manual_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wiper_rpt_91.manual_input)
  return static_cast< ::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType >(manual_input_);
}
inline void Wiper_rpt_91::set_manual_input(::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType value) {
  assert(::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType_IsValid(value));
  set_has_manual_input();
  manual_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wiper_rpt_91.manual_input)
}

// -------------------------------------------------------------------

// Vehicle_speed_rpt_6f

// optional double vehicle_speed = 1;
inline bool Vehicle_speed_rpt_6f::has_vehicle_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_speed_rpt_6f::set_has_vehicle_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_speed_rpt_6f::clear_has_vehicle_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_speed_rpt_6f::clear_vehicle_speed() {
  vehicle_speed_ = 0;
  clear_has_vehicle_speed();
}
inline double Vehicle_speed_rpt_6f::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Vehicle_speed_rpt_6f.vehicle_speed)
  return vehicle_speed_;
}
inline void Vehicle_speed_rpt_6f::set_vehicle_speed(double value) {
  set_has_vehicle_speed();
  vehicle_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Vehicle_speed_rpt_6f.vehicle_speed)
}

// optional .jmc_auto.canbus.Vehicle_speed_rpt_6f.Vehicle_speed_validType vehicle_speed_valid = 2;
inline bool Vehicle_speed_rpt_6f::has_vehicle_speed_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_speed_rpt_6f::set_has_vehicle_speed_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_speed_rpt_6f::clear_has_vehicle_speed_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_speed_rpt_6f::clear_vehicle_speed_valid() {
  vehicle_speed_valid_ = 0;
  clear_has_vehicle_speed_valid();
}
inline ::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType Vehicle_speed_rpt_6f::vehicle_speed_valid() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Vehicle_speed_rpt_6f.vehicle_speed_valid)
  return static_cast< ::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType >(vehicle_speed_valid_);
}
inline void Vehicle_speed_rpt_6f::set_vehicle_speed_valid(::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType value) {
  assert(::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType_IsValid(value));
  set_has_vehicle_speed_valid();
  vehicle_speed_valid_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Vehicle_speed_rpt_6f.vehicle_speed_valid)
}

// -------------------------------------------------------------------

// Headlight_cmd_76

// optional .jmc_auto.canbus.Headlight_cmd_76.Headlight_cmdType headlight_cmd = 1;
inline bool Headlight_cmd_76::has_headlight_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Headlight_cmd_76::set_has_headlight_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Headlight_cmd_76::clear_has_headlight_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Headlight_cmd_76::clear_headlight_cmd() {
  headlight_cmd_ = 0;
  clear_has_headlight_cmd();
}
inline ::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType Headlight_cmd_76::headlight_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Headlight_cmd_76.headlight_cmd)
  return static_cast< ::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType >(headlight_cmd_);
}
inline void Headlight_cmd_76::set_headlight_cmd(::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType value) {
  assert(::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType_IsValid(value));
  set_has_headlight_cmd();
  headlight_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Headlight_cmd_76.headlight_cmd)
}

// -------------------------------------------------------------------

// Steering_motor_rpt_2_74

// optional int32 encoder_temperature = 1;
inline bool Steering_motor_rpt_2_74::has_encoder_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Steering_motor_rpt_2_74::set_has_encoder_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Steering_motor_rpt_2_74::clear_has_encoder_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Steering_motor_rpt_2_74::clear_encoder_temperature() {
  encoder_temperature_ = 0;
  clear_has_encoder_temperature();
}
inline ::google::protobuf::int32 Steering_motor_rpt_2_74::encoder_temperature() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_2_74.encoder_temperature)
  return encoder_temperature_;
}
inline void Steering_motor_rpt_2_74::set_encoder_temperature(::google::protobuf::int32 value) {
  set_has_encoder_temperature();
  encoder_temperature_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_2_74.encoder_temperature)
}

// optional int32 motor_temperature = 2;
inline bool Steering_motor_rpt_2_74::has_motor_temperature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Steering_motor_rpt_2_74::set_has_motor_temperature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Steering_motor_rpt_2_74::clear_has_motor_temperature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Steering_motor_rpt_2_74::clear_motor_temperature() {
  motor_temperature_ = 0;
  clear_has_motor_temperature();
}
inline ::google::protobuf::int32 Steering_motor_rpt_2_74::motor_temperature() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_2_74.motor_temperature)
  return motor_temperature_;
}
inline void Steering_motor_rpt_2_74::set_motor_temperature(::google::protobuf::int32 value) {
  set_has_motor_temperature();
  motor_temperature_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_2_74.motor_temperature)
}

// optional double angular_speed = 3;
inline bool Steering_motor_rpt_2_74::has_angular_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Steering_motor_rpt_2_74::set_has_angular_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Steering_motor_rpt_2_74::clear_has_angular_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Steering_motor_rpt_2_74::clear_angular_speed() {
  angular_speed_ = 0;
  clear_has_angular_speed();
}
inline double Steering_motor_rpt_2_74::angular_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_2_74.angular_speed)
  return angular_speed_;
}
inline void Steering_motor_rpt_2_74::set_angular_speed(double value) {
  set_has_angular_speed();
  angular_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_2_74.angular_speed)
}

// -------------------------------------------------------------------

// Brake_motor_rpt_2_71

// optional int32 encoder_temperature = 1;
inline bool Brake_motor_rpt_2_71::has_encoder_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake_motor_rpt_2_71::set_has_encoder_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake_motor_rpt_2_71::clear_has_encoder_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake_motor_rpt_2_71::clear_encoder_temperature() {
  encoder_temperature_ = 0;
  clear_has_encoder_temperature();
}
inline ::google::protobuf::int32 Brake_motor_rpt_2_71::encoder_temperature() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_2_71.encoder_temperature)
  return encoder_temperature_;
}
inline void Brake_motor_rpt_2_71::set_encoder_temperature(::google::protobuf::int32 value) {
  set_has_encoder_temperature();
  encoder_temperature_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_2_71.encoder_temperature)
}

// optional int32 motor_temperature = 2;
inline bool Brake_motor_rpt_2_71::has_motor_temperature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake_motor_rpt_2_71::set_has_motor_temperature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake_motor_rpt_2_71::clear_has_motor_temperature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake_motor_rpt_2_71::clear_motor_temperature() {
  motor_temperature_ = 0;
  clear_has_motor_temperature();
}
inline ::google::protobuf::int32 Brake_motor_rpt_2_71::motor_temperature() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_2_71.motor_temperature)
  return motor_temperature_;
}
inline void Brake_motor_rpt_2_71::set_motor_temperature(::google::protobuf::int32 value) {
  set_has_motor_temperature();
  motor_temperature_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_2_71.motor_temperature)
}

// optional double angular_speed = 3;
inline bool Brake_motor_rpt_2_71::has_angular_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Brake_motor_rpt_2_71::set_has_angular_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Brake_motor_rpt_2_71::clear_has_angular_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Brake_motor_rpt_2_71::clear_angular_speed() {
  angular_speed_ = 0;
  clear_has_angular_speed();
}
inline double Brake_motor_rpt_2_71::angular_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_2_71.angular_speed)
  return angular_speed_;
}
inline void Brake_motor_rpt_2_71::set_angular_speed(double value) {
  set_has_angular_speed();
  angular_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_2_71.angular_speed)
}

// -------------------------------------------------------------------

// Steering_motor_rpt_1_73

// optional double motor_current = 1;
inline bool Steering_motor_rpt_1_73::has_motor_current() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Steering_motor_rpt_1_73::set_has_motor_current() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Steering_motor_rpt_1_73::clear_has_motor_current() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Steering_motor_rpt_1_73::clear_motor_current() {
  motor_current_ = 0;
  clear_has_motor_current();
}
inline double Steering_motor_rpt_1_73::motor_current() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_1_73.motor_current)
  return motor_current_;
}
inline void Steering_motor_rpt_1_73::set_motor_current(double value) {
  set_has_motor_current();
  motor_current_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_1_73.motor_current)
}

// optional double shaft_position = 2;
inline bool Steering_motor_rpt_1_73::has_shaft_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Steering_motor_rpt_1_73::set_has_shaft_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Steering_motor_rpt_1_73::clear_has_shaft_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Steering_motor_rpt_1_73::clear_shaft_position() {
  shaft_position_ = 0;
  clear_has_shaft_position();
}
inline double Steering_motor_rpt_1_73::shaft_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Steering_motor_rpt_1_73.shaft_position)
  return shaft_position_;
}
inline void Steering_motor_rpt_1_73::set_shaft_position(double value) {
  set_has_shaft_position();
  shaft_position_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Steering_motor_rpt_1_73.shaft_position)
}

// -------------------------------------------------------------------

// Wiper_cmd_90

// optional .jmc_auto.canbus.Wiper_cmd_90.Wiper_cmdType wiper_cmd = 1;
inline bool Wiper_cmd_90::has_wiper_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wiper_cmd_90::set_has_wiper_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wiper_cmd_90::clear_has_wiper_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wiper_cmd_90::clear_wiper_cmd() {
  wiper_cmd_ = 0;
  clear_has_wiper_cmd();
}
inline ::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType Wiper_cmd_90::wiper_cmd() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Wiper_cmd_90.wiper_cmd)
  return static_cast< ::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType >(wiper_cmd_);
}
inline void Wiper_cmd_90::set_wiper_cmd(::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType value) {
  assert(::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType_IsValid(value));
  set_has_wiper_cmd();
  wiper_cmd_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Wiper_cmd_90.wiper_cmd)
}

// -------------------------------------------------------------------

// Brake_motor_rpt_3_72

// optional double torque_output = 1;
inline bool Brake_motor_rpt_3_72::has_torque_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake_motor_rpt_3_72::set_has_torque_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake_motor_rpt_3_72::clear_has_torque_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake_motor_rpt_3_72::clear_torque_output() {
  torque_output_ = 0;
  clear_has_torque_output();
}
inline double Brake_motor_rpt_3_72::torque_output() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_3_72.torque_output)
  return torque_output_;
}
inline void Brake_motor_rpt_3_72::set_torque_output(double value) {
  set_has_torque_output();
  torque_output_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_3_72.torque_output)
}

// optional double torque_input = 2;
inline bool Brake_motor_rpt_3_72::has_torque_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake_motor_rpt_3_72::set_has_torque_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake_motor_rpt_3_72::clear_has_torque_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake_motor_rpt_3_72::clear_torque_input() {
  torque_input_ = 0;
  clear_has_torque_input();
}
inline double Brake_motor_rpt_3_72::torque_input() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Brake_motor_rpt_3_72.torque_input)
  return torque_input_;
}
inline void Brake_motor_rpt_3_72::set_torque_input(double value) {
  set_has_torque_input();
  torque_input_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.canbus.Brake_motor_rpt_3_72.torque_input)
}

// -------------------------------------------------------------------

// Gem

// optional .jmc_auto.canbus.Global_rpt_6a global_rpt_6a = 1;
inline bool Gem::has_global_rpt_6a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gem::set_has_global_rpt_6a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gem::clear_has_global_rpt_6a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gem::clear_global_rpt_6a() {
  if (global_rpt_6a_ != NULL) global_rpt_6a_->::jmc_auto::canbus::Global_rpt_6a::Clear();
  clear_has_global_rpt_6a();
}
inline const ::jmc_auto::canbus::Global_rpt_6a& Gem::global_rpt_6a() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.global_rpt_6a)
  return global_rpt_6a_ != NULL ? *global_rpt_6a_
                         : *::jmc_auto::canbus::Global_rpt_6a::internal_default_instance();
}
inline ::jmc_auto::canbus::Global_rpt_6a* Gem::mutable_global_rpt_6a() {
  set_has_global_rpt_6a();
  if (global_rpt_6a_ == NULL) {
    global_rpt_6a_ = new ::jmc_auto::canbus::Global_rpt_6a;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.global_rpt_6a)
  return global_rpt_6a_;
}
inline ::jmc_auto::canbus::Global_rpt_6a* Gem::release_global_rpt_6a() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.global_rpt_6a)
  clear_has_global_rpt_6a();
  ::jmc_auto::canbus::Global_rpt_6a* temp = global_rpt_6a_;
  global_rpt_6a_ = NULL;
  return temp;
}
inline void Gem::set_allocated_global_rpt_6a(::jmc_auto::canbus::Global_rpt_6a* global_rpt_6a) {
  delete global_rpt_6a_;
  global_rpt_6a_ = global_rpt_6a;
  if (global_rpt_6a) {
    set_has_global_rpt_6a();
  } else {
    clear_has_global_rpt_6a();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.global_rpt_6a)
}

// optional .jmc_auto.canbus.Brake_cmd_6b brake_cmd_6b = 2;
inline bool Gem::has_brake_cmd_6b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gem::set_has_brake_cmd_6b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gem::clear_has_brake_cmd_6b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gem::clear_brake_cmd_6b() {
  if (brake_cmd_6b_ != NULL) brake_cmd_6b_->::jmc_auto::canbus::Brake_cmd_6b::Clear();
  clear_has_brake_cmd_6b();
}
inline const ::jmc_auto::canbus::Brake_cmd_6b& Gem::brake_cmd_6b() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.brake_cmd_6b)
  return brake_cmd_6b_ != NULL ? *brake_cmd_6b_
                         : *::jmc_auto::canbus::Brake_cmd_6b::internal_default_instance();
}
inline ::jmc_auto::canbus::Brake_cmd_6b* Gem::mutable_brake_cmd_6b() {
  set_has_brake_cmd_6b();
  if (brake_cmd_6b_ == NULL) {
    brake_cmd_6b_ = new ::jmc_auto::canbus::Brake_cmd_6b;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.brake_cmd_6b)
  return brake_cmd_6b_;
}
inline ::jmc_auto::canbus::Brake_cmd_6b* Gem::release_brake_cmd_6b() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.brake_cmd_6b)
  clear_has_brake_cmd_6b();
  ::jmc_auto::canbus::Brake_cmd_6b* temp = brake_cmd_6b_;
  brake_cmd_6b_ = NULL;
  return temp;
}
inline void Gem::set_allocated_brake_cmd_6b(::jmc_auto::canbus::Brake_cmd_6b* brake_cmd_6b) {
  delete brake_cmd_6b_;
  brake_cmd_6b_ = brake_cmd_6b;
  if (brake_cmd_6b) {
    set_has_brake_cmd_6b();
  } else {
    clear_has_brake_cmd_6b();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.brake_cmd_6b)
}

// optional .jmc_auto.canbus.Brake_rpt_6c brake_rpt_6c = 3;
inline bool Gem::has_brake_rpt_6c() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gem::set_has_brake_rpt_6c() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gem::clear_has_brake_rpt_6c() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gem::clear_brake_rpt_6c() {
  if (brake_rpt_6c_ != NULL) brake_rpt_6c_->::jmc_auto::canbus::Brake_rpt_6c::Clear();
  clear_has_brake_rpt_6c();
}
inline const ::jmc_auto::canbus::Brake_rpt_6c& Gem::brake_rpt_6c() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.brake_rpt_6c)
  return brake_rpt_6c_ != NULL ? *brake_rpt_6c_
                         : *::jmc_auto::canbus::Brake_rpt_6c::internal_default_instance();
}
inline ::jmc_auto::canbus::Brake_rpt_6c* Gem::mutable_brake_rpt_6c() {
  set_has_brake_rpt_6c();
  if (brake_rpt_6c_ == NULL) {
    brake_rpt_6c_ = new ::jmc_auto::canbus::Brake_rpt_6c;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.brake_rpt_6c)
  return brake_rpt_6c_;
}
inline ::jmc_auto::canbus::Brake_rpt_6c* Gem::release_brake_rpt_6c() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.brake_rpt_6c)
  clear_has_brake_rpt_6c();
  ::jmc_auto::canbus::Brake_rpt_6c* temp = brake_rpt_6c_;
  brake_rpt_6c_ = NULL;
  return temp;
}
inline void Gem::set_allocated_brake_rpt_6c(::jmc_auto::canbus::Brake_rpt_6c* brake_rpt_6c) {
  delete brake_rpt_6c_;
  brake_rpt_6c_ = brake_rpt_6c;
  if (brake_rpt_6c) {
    set_has_brake_rpt_6c();
  } else {
    clear_has_brake_rpt_6c();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.brake_rpt_6c)
}

// optional .jmc_auto.canbus.Steering_cmd_6d steering_cmd_6d = 4;
inline bool Gem::has_steering_cmd_6d() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gem::set_has_steering_cmd_6d() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gem::clear_has_steering_cmd_6d() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gem::clear_steering_cmd_6d() {
  if (steering_cmd_6d_ != NULL) steering_cmd_6d_->::jmc_auto::canbus::Steering_cmd_6d::Clear();
  clear_has_steering_cmd_6d();
}
inline const ::jmc_auto::canbus::Steering_cmd_6d& Gem::steering_cmd_6d() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.steering_cmd_6d)
  return steering_cmd_6d_ != NULL ? *steering_cmd_6d_
                         : *::jmc_auto::canbus::Steering_cmd_6d::internal_default_instance();
}
inline ::jmc_auto::canbus::Steering_cmd_6d* Gem::mutable_steering_cmd_6d() {
  set_has_steering_cmd_6d();
  if (steering_cmd_6d_ == NULL) {
    steering_cmd_6d_ = new ::jmc_auto::canbus::Steering_cmd_6d;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.steering_cmd_6d)
  return steering_cmd_6d_;
}
inline ::jmc_auto::canbus::Steering_cmd_6d* Gem::release_steering_cmd_6d() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.steering_cmd_6d)
  clear_has_steering_cmd_6d();
  ::jmc_auto::canbus::Steering_cmd_6d* temp = steering_cmd_6d_;
  steering_cmd_6d_ = NULL;
  return temp;
}
inline void Gem::set_allocated_steering_cmd_6d(::jmc_auto::canbus::Steering_cmd_6d* steering_cmd_6d) {
  delete steering_cmd_6d_;
  steering_cmd_6d_ = steering_cmd_6d;
  if (steering_cmd_6d) {
    set_has_steering_cmd_6d();
  } else {
    clear_has_steering_cmd_6d();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.steering_cmd_6d)
}

// optional .jmc_auto.canbus.Steering_rpt_1_6e steering_rpt_1_6e = 5;
inline bool Gem::has_steering_rpt_1_6e() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gem::set_has_steering_rpt_1_6e() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gem::clear_has_steering_rpt_1_6e() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gem::clear_steering_rpt_1_6e() {
  if (steering_rpt_1_6e_ != NULL) steering_rpt_1_6e_->::jmc_auto::canbus::Steering_rpt_1_6e::Clear();
  clear_has_steering_rpt_1_6e();
}
inline const ::jmc_auto::canbus::Steering_rpt_1_6e& Gem::steering_rpt_1_6e() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.steering_rpt_1_6e)
  return steering_rpt_1_6e_ != NULL ? *steering_rpt_1_6e_
                         : *::jmc_auto::canbus::Steering_rpt_1_6e::internal_default_instance();
}
inline ::jmc_auto::canbus::Steering_rpt_1_6e* Gem::mutable_steering_rpt_1_6e() {
  set_has_steering_rpt_1_6e();
  if (steering_rpt_1_6e_ == NULL) {
    steering_rpt_1_6e_ = new ::jmc_auto::canbus::Steering_rpt_1_6e;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.steering_rpt_1_6e)
  return steering_rpt_1_6e_;
}
inline ::jmc_auto::canbus::Steering_rpt_1_6e* Gem::release_steering_rpt_1_6e() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.steering_rpt_1_6e)
  clear_has_steering_rpt_1_6e();
  ::jmc_auto::canbus::Steering_rpt_1_6e* temp = steering_rpt_1_6e_;
  steering_rpt_1_6e_ = NULL;
  return temp;
}
inline void Gem::set_allocated_steering_rpt_1_6e(::jmc_auto::canbus::Steering_rpt_1_6e* steering_rpt_1_6e) {
  delete steering_rpt_1_6e_;
  steering_rpt_1_6e_ = steering_rpt_1_6e;
  if (steering_rpt_1_6e) {
    set_has_steering_rpt_1_6e();
  } else {
    clear_has_steering_rpt_1_6e();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.steering_rpt_1_6e)
}

// optional .jmc_auto.canbus.Wheel_speed_rpt_7a wheel_speed_rpt_7a = 6;
inline bool Gem::has_wheel_speed_rpt_7a() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Gem::set_has_wheel_speed_rpt_7a() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Gem::clear_has_wheel_speed_rpt_7a() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Gem::clear_wheel_speed_rpt_7a() {
  if (wheel_speed_rpt_7a_ != NULL) wheel_speed_rpt_7a_->::jmc_auto::canbus::Wheel_speed_rpt_7a::Clear();
  clear_has_wheel_speed_rpt_7a();
}
inline const ::jmc_auto::canbus::Wheel_speed_rpt_7a& Gem::wheel_speed_rpt_7a() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.wheel_speed_rpt_7a)
  return wheel_speed_rpt_7a_ != NULL ? *wheel_speed_rpt_7a_
                         : *::jmc_auto::canbus::Wheel_speed_rpt_7a::internal_default_instance();
}
inline ::jmc_auto::canbus::Wheel_speed_rpt_7a* Gem::mutable_wheel_speed_rpt_7a() {
  set_has_wheel_speed_rpt_7a();
  if (wheel_speed_rpt_7a_ == NULL) {
    wheel_speed_rpt_7a_ = new ::jmc_auto::canbus::Wheel_speed_rpt_7a;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.wheel_speed_rpt_7a)
  return wheel_speed_rpt_7a_;
}
inline ::jmc_auto::canbus::Wheel_speed_rpt_7a* Gem::release_wheel_speed_rpt_7a() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.wheel_speed_rpt_7a)
  clear_has_wheel_speed_rpt_7a();
  ::jmc_auto::canbus::Wheel_speed_rpt_7a* temp = wheel_speed_rpt_7a_;
  wheel_speed_rpt_7a_ = NULL;
  return temp;
}
inline void Gem::set_allocated_wheel_speed_rpt_7a(::jmc_auto::canbus::Wheel_speed_rpt_7a* wheel_speed_rpt_7a) {
  delete wheel_speed_rpt_7a_;
  wheel_speed_rpt_7a_ = wheel_speed_rpt_7a;
  if (wheel_speed_rpt_7a) {
    set_has_wheel_speed_rpt_7a();
  } else {
    clear_has_wheel_speed_rpt_7a();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.wheel_speed_rpt_7a)
}

// optional .jmc_auto.canbus.Date_time_rpt_83 date_time_rpt_83 = 7;
inline bool Gem::has_date_time_rpt_83() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gem::set_has_date_time_rpt_83() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gem::clear_has_date_time_rpt_83() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gem::clear_date_time_rpt_83() {
  if (date_time_rpt_83_ != NULL) date_time_rpt_83_->::jmc_auto::canbus::Date_time_rpt_83::Clear();
  clear_has_date_time_rpt_83();
}
inline const ::jmc_auto::canbus::Date_time_rpt_83& Gem::date_time_rpt_83() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.date_time_rpt_83)
  return date_time_rpt_83_ != NULL ? *date_time_rpt_83_
                         : *::jmc_auto::canbus::Date_time_rpt_83::internal_default_instance();
}
inline ::jmc_auto::canbus::Date_time_rpt_83* Gem::mutable_date_time_rpt_83() {
  set_has_date_time_rpt_83();
  if (date_time_rpt_83_ == NULL) {
    date_time_rpt_83_ = new ::jmc_auto::canbus::Date_time_rpt_83;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.date_time_rpt_83)
  return date_time_rpt_83_;
}
inline ::jmc_auto::canbus::Date_time_rpt_83* Gem::release_date_time_rpt_83() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.date_time_rpt_83)
  clear_has_date_time_rpt_83();
  ::jmc_auto::canbus::Date_time_rpt_83* temp = date_time_rpt_83_;
  date_time_rpt_83_ = NULL;
  return temp;
}
inline void Gem::set_allocated_date_time_rpt_83(::jmc_auto::canbus::Date_time_rpt_83* date_time_rpt_83) {
  delete date_time_rpt_83_;
  date_time_rpt_83_ = date_time_rpt_83;
  if (date_time_rpt_83) {
    set_has_date_time_rpt_83();
  } else {
    clear_has_date_time_rpt_83();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.date_time_rpt_83)
}

// optional .jmc_auto.canbus.Brake_motor_rpt_1_70 brake_motor_rpt_1_70 = 8;
inline bool Gem::has_brake_motor_rpt_1_70() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Gem::set_has_brake_motor_rpt_1_70() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Gem::clear_has_brake_motor_rpt_1_70() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Gem::clear_brake_motor_rpt_1_70() {
  if (brake_motor_rpt_1_70_ != NULL) brake_motor_rpt_1_70_->::jmc_auto::canbus::Brake_motor_rpt_1_70::Clear();
  clear_has_brake_motor_rpt_1_70();
}
inline const ::jmc_auto::canbus::Brake_motor_rpt_1_70& Gem::brake_motor_rpt_1_70() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.brake_motor_rpt_1_70)
  return brake_motor_rpt_1_70_ != NULL ? *brake_motor_rpt_1_70_
                         : *::jmc_auto::canbus::Brake_motor_rpt_1_70::internal_default_instance();
}
inline ::jmc_auto::canbus::Brake_motor_rpt_1_70* Gem::mutable_brake_motor_rpt_1_70() {
  set_has_brake_motor_rpt_1_70();
  if (brake_motor_rpt_1_70_ == NULL) {
    brake_motor_rpt_1_70_ = new ::jmc_auto::canbus::Brake_motor_rpt_1_70;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.brake_motor_rpt_1_70)
  return brake_motor_rpt_1_70_;
}
inline ::jmc_auto::canbus::Brake_motor_rpt_1_70* Gem::release_brake_motor_rpt_1_70() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.brake_motor_rpt_1_70)
  clear_has_brake_motor_rpt_1_70();
  ::jmc_auto::canbus::Brake_motor_rpt_1_70* temp = brake_motor_rpt_1_70_;
  brake_motor_rpt_1_70_ = NULL;
  return temp;
}
inline void Gem::set_allocated_brake_motor_rpt_1_70(::jmc_auto::canbus::Brake_motor_rpt_1_70* brake_motor_rpt_1_70) {
  delete brake_motor_rpt_1_70_;
  brake_motor_rpt_1_70_ = brake_motor_rpt_1_70;
  if (brake_motor_rpt_1_70) {
    set_has_brake_motor_rpt_1_70();
  } else {
    clear_has_brake_motor_rpt_1_70();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.brake_motor_rpt_1_70)
}

// optional .jmc_auto.canbus.Headlight_rpt_77 headlight_rpt_77 = 9;
inline bool Gem::has_headlight_rpt_77() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Gem::set_has_headlight_rpt_77() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Gem::clear_has_headlight_rpt_77() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Gem::clear_headlight_rpt_77() {
  if (headlight_rpt_77_ != NULL) headlight_rpt_77_->::jmc_auto::canbus::Headlight_rpt_77::Clear();
  clear_has_headlight_rpt_77();
}
inline const ::jmc_auto::canbus::Headlight_rpt_77& Gem::headlight_rpt_77() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.headlight_rpt_77)
  return headlight_rpt_77_ != NULL ? *headlight_rpt_77_
                         : *::jmc_auto::canbus::Headlight_rpt_77::internal_default_instance();
}
inline ::jmc_auto::canbus::Headlight_rpt_77* Gem::mutable_headlight_rpt_77() {
  set_has_headlight_rpt_77();
  if (headlight_rpt_77_ == NULL) {
    headlight_rpt_77_ = new ::jmc_auto::canbus::Headlight_rpt_77;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.headlight_rpt_77)
  return headlight_rpt_77_;
}
inline ::jmc_auto::canbus::Headlight_rpt_77* Gem::release_headlight_rpt_77() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.headlight_rpt_77)
  clear_has_headlight_rpt_77();
  ::jmc_auto::canbus::Headlight_rpt_77* temp = headlight_rpt_77_;
  headlight_rpt_77_ = NULL;
  return temp;
}
inline void Gem::set_allocated_headlight_rpt_77(::jmc_auto::canbus::Headlight_rpt_77* headlight_rpt_77) {
  delete headlight_rpt_77_;
  headlight_rpt_77_ = headlight_rpt_77;
  if (headlight_rpt_77) {
    set_has_headlight_rpt_77();
  } else {
    clear_has_headlight_rpt_77();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.headlight_rpt_77)
}

// optional .jmc_auto.canbus.Accel_rpt_68 accel_rpt_68 = 10;
inline bool Gem::has_accel_rpt_68() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Gem::set_has_accel_rpt_68() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Gem::clear_has_accel_rpt_68() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Gem::clear_accel_rpt_68() {
  if (accel_rpt_68_ != NULL) accel_rpt_68_->::jmc_auto::canbus::Accel_rpt_68::Clear();
  clear_has_accel_rpt_68();
}
inline const ::jmc_auto::canbus::Accel_rpt_68& Gem::accel_rpt_68() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.accel_rpt_68)
  return accel_rpt_68_ != NULL ? *accel_rpt_68_
                         : *::jmc_auto::canbus::Accel_rpt_68::internal_default_instance();
}
inline ::jmc_auto::canbus::Accel_rpt_68* Gem::mutable_accel_rpt_68() {
  set_has_accel_rpt_68();
  if (accel_rpt_68_ == NULL) {
    accel_rpt_68_ = new ::jmc_auto::canbus::Accel_rpt_68;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.accel_rpt_68)
  return accel_rpt_68_;
}
inline ::jmc_auto::canbus::Accel_rpt_68* Gem::release_accel_rpt_68() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.accel_rpt_68)
  clear_has_accel_rpt_68();
  ::jmc_auto::canbus::Accel_rpt_68* temp = accel_rpt_68_;
  accel_rpt_68_ = NULL;
  return temp;
}
inline void Gem::set_allocated_accel_rpt_68(::jmc_auto::canbus::Accel_rpt_68* accel_rpt_68) {
  delete accel_rpt_68_;
  accel_rpt_68_ = accel_rpt_68;
  if (accel_rpt_68) {
    set_has_accel_rpt_68();
  } else {
    clear_has_accel_rpt_68();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.accel_rpt_68)
}

// optional .jmc_auto.canbus.Steering_motor_rpt_3_75 steering_motor_rpt_3_75 = 11;
inline bool Gem::has_steering_motor_rpt_3_75() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Gem::set_has_steering_motor_rpt_3_75() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Gem::clear_has_steering_motor_rpt_3_75() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Gem::clear_steering_motor_rpt_3_75() {
  if (steering_motor_rpt_3_75_ != NULL) steering_motor_rpt_3_75_->::jmc_auto::canbus::Steering_motor_rpt_3_75::Clear();
  clear_has_steering_motor_rpt_3_75();
}
inline const ::jmc_auto::canbus::Steering_motor_rpt_3_75& Gem::steering_motor_rpt_3_75() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.steering_motor_rpt_3_75)
  return steering_motor_rpt_3_75_ != NULL ? *steering_motor_rpt_3_75_
                         : *::jmc_auto::canbus::Steering_motor_rpt_3_75::internal_default_instance();
}
inline ::jmc_auto::canbus::Steering_motor_rpt_3_75* Gem::mutable_steering_motor_rpt_3_75() {
  set_has_steering_motor_rpt_3_75();
  if (steering_motor_rpt_3_75_ == NULL) {
    steering_motor_rpt_3_75_ = new ::jmc_auto::canbus::Steering_motor_rpt_3_75;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.steering_motor_rpt_3_75)
  return steering_motor_rpt_3_75_;
}
inline ::jmc_auto::canbus::Steering_motor_rpt_3_75* Gem::release_steering_motor_rpt_3_75() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.steering_motor_rpt_3_75)
  clear_has_steering_motor_rpt_3_75();
  ::jmc_auto::canbus::Steering_motor_rpt_3_75* temp = steering_motor_rpt_3_75_;
  steering_motor_rpt_3_75_ = NULL;
  return temp;
}
inline void Gem::set_allocated_steering_motor_rpt_3_75(::jmc_auto::canbus::Steering_motor_rpt_3_75* steering_motor_rpt_3_75) {
  delete steering_motor_rpt_3_75_;
  steering_motor_rpt_3_75_ = steering_motor_rpt_3_75;
  if (steering_motor_rpt_3_75) {
    set_has_steering_motor_rpt_3_75();
  } else {
    clear_has_steering_motor_rpt_3_75();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.steering_motor_rpt_3_75)
}

// optional .jmc_auto.canbus.Turn_cmd_63 turn_cmd_63 = 12;
inline bool Gem::has_turn_cmd_63() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Gem::set_has_turn_cmd_63() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Gem::clear_has_turn_cmd_63() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Gem::clear_turn_cmd_63() {
  if (turn_cmd_63_ != NULL) turn_cmd_63_->::jmc_auto::canbus::Turn_cmd_63::Clear();
  clear_has_turn_cmd_63();
}
inline const ::jmc_auto::canbus::Turn_cmd_63& Gem::turn_cmd_63() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.turn_cmd_63)
  return turn_cmd_63_ != NULL ? *turn_cmd_63_
                         : *::jmc_auto::canbus::Turn_cmd_63::internal_default_instance();
}
inline ::jmc_auto::canbus::Turn_cmd_63* Gem::mutable_turn_cmd_63() {
  set_has_turn_cmd_63();
  if (turn_cmd_63_ == NULL) {
    turn_cmd_63_ = new ::jmc_auto::canbus::Turn_cmd_63;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.turn_cmd_63)
  return turn_cmd_63_;
}
inline ::jmc_auto::canbus::Turn_cmd_63* Gem::release_turn_cmd_63() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.turn_cmd_63)
  clear_has_turn_cmd_63();
  ::jmc_auto::canbus::Turn_cmd_63* temp = turn_cmd_63_;
  turn_cmd_63_ = NULL;
  return temp;
}
inline void Gem::set_allocated_turn_cmd_63(::jmc_auto::canbus::Turn_cmd_63* turn_cmd_63) {
  delete turn_cmd_63_;
  turn_cmd_63_ = turn_cmd_63;
  if (turn_cmd_63) {
    set_has_turn_cmd_63();
  } else {
    clear_has_turn_cmd_63();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.turn_cmd_63)
}

// optional .jmc_auto.canbus.Turn_rpt_64 turn_rpt_64 = 13;
inline bool Gem::has_turn_rpt_64() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Gem::set_has_turn_rpt_64() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Gem::clear_has_turn_rpt_64() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Gem::clear_turn_rpt_64() {
  if (turn_rpt_64_ != NULL) turn_rpt_64_->::jmc_auto::canbus::Turn_rpt_64::Clear();
  clear_has_turn_rpt_64();
}
inline const ::jmc_auto::canbus::Turn_rpt_64& Gem::turn_rpt_64() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.turn_rpt_64)
  return turn_rpt_64_ != NULL ? *turn_rpt_64_
                         : *::jmc_auto::canbus::Turn_rpt_64::internal_default_instance();
}
inline ::jmc_auto::canbus::Turn_rpt_64* Gem::mutable_turn_rpt_64() {
  set_has_turn_rpt_64();
  if (turn_rpt_64_ == NULL) {
    turn_rpt_64_ = new ::jmc_auto::canbus::Turn_rpt_64;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.turn_rpt_64)
  return turn_rpt_64_;
}
inline ::jmc_auto::canbus::Turn_rpt_64* Gem::release_turn_rpt_64() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.turn_rpt_64)
  clear_has_turn_rpt_64();
  ::jmc_auto::canbus::Turn_rpt_64* temp = turn_rpt_64_;
  turn_rpt_64_ = NULL;
  return temp;
}
inline void Gem::set_allocated_turn_rpt_64(::jmc_auto::canbus::Turn_rpt_64* turn_rpt_64) {
  delete turn_rpt_64_;
  turn_rpt_64_ = turn_rpt_64;
  if (turn_rpt_64) {
    set_has_turn_rpt_64();
  } else {
    clear_has_turn_rpt_64();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.turn_rpt_64)
}

// optional .jmc_auto.canbus.Shift_cmd_65 shift_cmd_65 = 14;
inline bool Gem::has_shift_cmd_65() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Gem::set_has_shift_cmd_65() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Gem::clear_has_shift_cmd_65() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Gem::clear_shift_cmd_65() {
  if (shift_cmd_65_ != NULL) shift_cmd_65_->::jmc_auto::canbus::Shift_cmd_65::Clear();
  clear_has_shift_cmd_65();
}
inline const ::jmc_auto::canbus::Shift_cmd_65& Gem::shift_cmd_65() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.shift_cmd_65)
  return shift_cmd_65_ != NULL ? *shift_cmd_65_
                         : *::jmc_auto::canbus::Shift_cmd_65::internal_default_instance();
}
inline ::jmc_auto::canbus::Shift_cmd_65* Gem::mutable_shift_cmd_65() {
  set_has_shift_cmd_65();
  if (shift_cmd_65_ == NULL) {
    shift_cmd_65_ = new ::jmc_auto::canbus::Shift_cmd_65;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.shift_cmd_65)
  return shift_cmd_65_;
}
inline ::jmc_auto::canbus::Shift_cmd_65* Gem::release_shift_cmd_65() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.shift_cmd_65)
  clear_has_shift_cmd_65();
  ::jmc_auto::canbus::Shift_cmd_65* temp = shift_cmd_65_;
  shift_cmd_65_ = NULL;
  return temp;
}
inline void Gem::set_allocated_shift_cmd_65(::jmc_auto::canbus::Shift_cmd_65* shift_cmd_65) {
  delete shift_cmd_65_;
  shift_cmd_65_ = shift_cmd_65;
  if (shift_cmd_65) {
    set_has_shift_cmd_65();
  } else {
    clear_has_shift_cmd_65();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.shift_cmd_65)
}

// optional .jmc_auto.canbus.Shift_rpt_66 shift_rpt_66 = 15;
inline bool Gem::has_shift_rpt_66() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Gem::set_has_shift_rpt_66() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Gem::clear_has_shift_rpt_66() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Gem::clear_shift_rpt_66() {
  if (shift_rpt_66_ != NULL) shift_rpt_66_->::jmc_auto::canbus::Shift_rpt_66::Clear();
  clear_has_shift_rpt_66();
}
inline const ::jmc_auto::canbus::Shift_rpt_66& Gem::shift_rpt_66() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.shift_rpt_66)
  return shift_rpt_66_ != NULL ? *shift_rpt_66_
                         : *::jmc_auto::canbus::Shift_rpt_66::internal_default_instance();
}
inline ::jmc_auto::canbus::Shift_rpt_66* Gem::mutable_shift_rpt_66() {
  set_has_shift_rpt_66();
  if (shift_rpt_66_ == NULL) {
    shift_rpt_66_ = new ::jmc_auto::canbus::Shift_rpt_66;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.shift_rpt_66)
  return shift_rpt_66_;
}
inline ::jmc_auto::canbus::Shift_rpt_66* Gem::release_shift_rpt_66() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.shift_rpt_66)
  clear_has_shift_rpt_66();
  ::jmc_auto::canbus::Shift_rpt_66* temp = shift_rpt_66_;
  shift_rpt_66_ = NULL;
  return temp;
}
inline void Gem::set_allocated_shift_rpt_66(::jmc_auto::canbus::Shift_rpt_66* shift_rpt_66) {
  delete shift_rpt_66_;
  shift_rpt_66_ = shift_rpt_66;
  if (shift_rpt_66) {
    set_has_shift_rpt_66();
  } else {
    clear_has_shift_rpt_66();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.shift_rpt_66)
}

// optional .jmc_auto.canbus.Accel_cmd_67 accel_cmd_67 = 16;
inline bool Gem::has_accel_cmd_67() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Gem::set_has_accel_cmd_67() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Gem::clear_has_accel_cmd_67() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Gem::clear_accel_cmd_67() {
  if (accel_cmd_67_ != NULL) accel_cmd_67_->::jmc_auto::canbus::Accel_cmd_67::Clear();
  clear_has_accel_cmd_67();
}
inline const ::jmc_auto::canbus::Accel_cmd_67& Gem::accel_cmd_67() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.accel_cmd_67)
  return accel_cmd_67_ != NULL ? *accel_cmd_67_
                         : *::jmc_auto::canbus::Accel_cmd_67::internal_default_instance();
}
inline ::jmc_auto::canbus::Accel_cmd_67* Gem::mutable_accel_cmd_67() {
  set_has_accel_cmd_67();
  if (accel_cmd_67_ == NULL) {
    accel_cmd_67_ = new ::jmc_auto::canbus::Accel_cmd_67;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.accel_cmd_67)
  return accel_cmd_67_;
}
inline ::jmc_auto::canbus::Accel_cmd_67* Gem::release_accel_cmd_67() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.accel_cmd_67)
  clear_has_accel_cmd_67();
  ::jmc_auto::canbus::Accel_cmd_67* temp = accel_cmd_67_;
  accel_cmd_67_ = NULL;
  return temp;
}
inline void Gem::set_allocated_accel_cmd_67(::jmc_auto::canbus::Accel_cmd_67* accel_cmd_67) {
  delete accel_cmd_67_;
  accel_cmd_67_ = accel_cmd_67;
  if (accel_cmd_67) {
    set_has_accel_cmd_67();
  } else {
    clear_has_accel_cmd_67();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.accel_cmd_67)
}

// optional .jmc_auto.canbus.Lat_lon_heading_rpt_82 lat_lon_heading_rpt_82 = 17;
inline bool Gem::has_lat_lon_heading_rpt_82() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Gem::set_has_lat_lon_heading_rpt_82() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Gem::clear_has_lat_lon_heading_rpt_82() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Gem::clear_lat_lon_heading_rpt_82() {
  if (lat_lon_heading_rpt_82_ != NULL) lat_lon_heading_rpt_82_->::jmc_auto::canbus::Lat_lon_heading_rpt_82::Clear();
  clear_has_lat_lon_heading_rpt_82();
}
inline const ::jmc_auto::canbus::Lat_lon_heading_rpt_82& Gem::lat_lon_heading_rpt_82() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.lat_lon_heading_rpt_82)
  return lat_lon_heading_rpt_82_ != NULL ? *lat_lon_heading_rpt_82_
                         : *::jmc_auto::canbus::Lat_lon_heading_rpt_82::internal_default_instance();
}
inline ::jmc_auto::canbus::Lat_lon_heading_rpt_82* Gem::mutable_lat_lon_heading_rpt_82() {
  set_has_lat_lon_heading_rpt_82();
  if (lat_lon_heading_rpt_82_ == NULL) {
    lat_lon_heading_rpt_82_ = new ::jmc_auto::canbus::Lat_lon_heading_rpt_82;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.lat_lon_heading_rpt_82)
  return lat_lon_heading_rpt_82_;
}
inline ::jmc_auto::canbus::Lat_lon_heading_rpt_82* Gem::release_lat_lon_heading_rpt_82() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.lat_lon_heading_rpt_82)
  clear_has_lat_lon_heading_rpt_82();
  ::jmc_auto::canbus::Lat_lon_heading_rpt_82* temp = lat_lon_heading_rpt_82_;
  lat_lon_heading_rpt_82_ = NULL;
  return temp;
}
inline void Gem::set_allocated_lat_lon_heading_rpt_82(::jmc_auto::canbus::Lat_lon_heading_rpt_82* lat_lon_heading_rpt_82) {
  delete lat_lon_heading_rpt_82_;
  lat_lon_heading_rpt_82_ = lat_lon_heading_rpt_82;
  if (lat_lon_heading_rpt_82) {
    set_has_lat_lon_heading_rpt_82();
  } else {
    clear_has_lat_lon_heading_rpt_82();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.lat_lon_heading_rpt_82)
}

// optional .jmc_auto.canbus.Global_cmd_69 global_cmd_69 = 18;
inline bool Gem::has_global_cmd_69() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Gem::set_has_global_cmd_69() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Gem::clear_has_global_cmd_69() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Gem::clear_global_cmd_69() {
  if (global_cmd_69_ != NULL) global_cmd_69_->::jmc_auto::canbus::Global_cmd_69::Clear();
  clear_has_global_cmd_69();
}
inline const ::jmc_auto::canbus::Global_cmd_69& Gem::global_cmd_69() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.global_cmd_69)
  return global_cmd_69_ != NULL ? *global_cmd_69_
                         : *::jmc_auto::canbus::Global_cmd_69::internal_default_instance();
}
inline ::jmc_auto::canbus::Global_cmd_69* Gem::mutable_global_cmd_69() {
  set_has_global_cmd_69();
  if (global_cmd_69_ == NULL) {
    global_cmd_69_ = new ::jmc_auto::canbus::Global_cmd_69;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.global_cmd_69)
  return global_cmd_69_;
}
inline ::jmc_auto::canbus::Global_cmd_69* Gem::release_global_cmd_69() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.global_cmd_69)
  clear_has_global_cmd_69();
  ::jmc_auto::canbus::Global_cmd_69* temp = global_cmd_69_;
  global_cmd_69_ = NULL;
  return temp;
}
inline void Gem::set_allocated_global_cmd_69(::jmc_auto::canbus::Global_cmd_69* global_cmd_69) {
  delete global_cmd_69_;
  global_cmd_69_ = global_cmd_69;
  if (global_cmd_69) {
    set_has_global_cmd_69();
  } else {
    clear_has_global_cmd_69();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.global_cmd_69)
}

// optional .jmc_auto.canbus.Parking_brake_status_rpt_80 parking_brake_status_rpt_80 = 19;
inline bool Gem::has_parking_brake_status_rpt_80() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Gem::set_has_parking_brake_status_rpt_80() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Gem::clear_has_parking_brake_status_rpt_80() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Gem::clear_parking_brake_status_rpt_80() {
  if (parking_brake_status_rpt_80_ != NULL) parking_brake_status_rpt_80_->::jmc_auto::canbus::Parking_brake_status_rpt_80::Clear();
  clear_has_parking_brake_status_rpt_80();
}
inline const ::jmc_auto::canbus::Parking_brake_status_rpt_80& Gem::parking_brake_status_rpt_80() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.parking_brake_status_rpt_80)
  return parking_brake_status_rpt_80_ != NULL ? *parking_brake_status_rpt_80_
                         : *::jmc_auto::canbus::Parking_brake_status_rpt_80::internal_default_instance();
}
inline ::jmc_auto::canbus::Parking_brake_status_rpt_80* Gem::mutable_parking_brake_status_rpt_80() {
  set_has_parking_brake_status_rpt_80();
  if (parking_brake_status_rpt_80_ == NULL) {
    parking_brake_status_rpt_80_ = new ::jmc_auto::canbus::Parking_brake_status_rpt_80;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.parking_brake_status_rpt_80)
  return parking_brake_status_rpt_80_;
}
inline ::jmc_auto::canbus::Parking_brake_status_rpt_80* Gem::release_parking_brake_status_rpt_80() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.parking_brake_status_rpt_80)
  clear_has_parking_brake_status_rpt_80();
  ::jmc_auto::canbus::Parking_brake_status_rpt_80* temp = parking_brake_status_rpt_80_;
  parking_brake_status_rpt_80_ = NULL;
  return temp;
}
inline void Gem::set_allocated_parking_brake_status_rpt_80(::jmc_auto::canbus::Parking_brake_status_rpt_80* parking_brake_status_rpt_80) {
  delete parking_brake_status_rpt_80_;
  parking_brake_status_rpt_80_ = parking_brake_status_rpt_80;
  if (parking_brake_status_rpt_80) {
    set_has_parking_brake_status_rpt_80();
  } else {
    clear_has_parking_brake_status_rpt_80();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.parking_brake_status_rpt_80)
}

// optional .jmc_auto.canbus.Yaw_rate_rpt_81 yaw_rate_rpt_81 = 20;
inline bool Gem::has_yaw_rate_rpt_81() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Gem::set_has_yaw_rate_rpt_81() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Gem::clear_has_yaw_rate_rpt_81() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Gem::clear_yaw_rate_rpt_81() {
  if (yaw_rate_rpt_81_ != NULL) yaw_rate_rpt_81_->::jmc_auto::canbus::Yaw_rate_rpt_81::Clear();
  clear_has_yaw_rate_rpt_81();
}
inline const ::jmc_auto::canbus::Yaw_rate_rpt_81& Gem::yaw_rate_rpt_81() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.yaw_rate_rpt_81)
  return yaw_rate_rpt_81_ != NULL ? *yaw_rate_rpt_81_
                         : *::jmc_auto::canbus::Yaw_rate_rpt_81::internal_default_instance();
}
inline ::jmc_auto::canbus::Yaw_rate_rpt_81* Gem::mutable_yaw_rate_rpt_81() {
  set_has_yaw_rate_rpt_81();
  if (yaw_rate_rpt_81_ == NULL) {
    yaw_rate_rpt_81_ = new ::jmc_auto::canbus::Yaw_rate_rpt_81;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.yaw_rate_rpt_81)
  return yaw_rate_rpt_81_;
}
inline ::jmc_auto::canbus::Yaw_rate_rpt_81* Gem::release_yaw_rate_rpt_81() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.yaw_rate_rpt_81)
  clear_has_yaw_rate_rpt_81();
  ::jmc_auto::canbus::Yaw_rate_rpt_81* temp = yaw_rate_rpt_81_;
  yaw_rate_rpt_81_ = NULL;
  return temp;
}
inline void Gem::set_allocated_yaw_rate_rpt_81(::jmc_auto::canbus::Yaw_rate_rpt_81* yaw_rate_rpt_81) {
  delete yaw_rate_rpt_81_;
  yaw_rate_rpt_81_ = yaw_rate_rpt_81;
  if (yaw_rate_rpt_81) {
    set_has_yaw_rate_rpt_81();
  } else {
    clear_has_yaw_rate_rpt_81();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.yaw_rate_rpt_81)
}

// optional .jmc_auto.canbus.Horn_rpt_79 horn_rpt_79 = 21;
inline bool Gem::has_horn_rpt_79() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Gem::set_has_horn_rpt_79() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Gem::clear_has_horn_rpt_79() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Gem::clear_horn_rpt_79() {
  if (horn_rpt_79_ != NULL) horn_rpt_79_->::jmc_auto::canbus::Horn_rpt_79::Clear();
  clear_has_horn_rpt_79();
}
inline const ::jmc_auto::canbus::Horn_rpt_79& Gem::horn_rpt_79() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.horn_rpt_79)
  return horn_rpt_79_ != NULL ? *horn_rpt_79_
                         : *::jmc_auto::canbus::Horn_rpt_79::internal_default_instance();
}
inline ::jmc_auto::canbus::Horn_rpt_79* Gem::mutable_horn_rpt_79() {
  set_has_horn_rpt_79();
  if (horn_rpt_79_ == NULL) {
    horn_rpt_79_ = new ::jmc_auto::canbus::Horn_rpt_79;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.horn_rpt_79)
  return horn_rpt_79_;
}
inline ::jmc_auto::canbus::Horn_rpt_79* Gem::release_horn_rpt_79() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.horn_rpt_79)
  clear_has_horn_rpt_79();
  ::jmc_auto::canbus::Horn_rpt_79* temp = horn_rpt_79_;
  horn_rpt_79_ = NULL;
  return temp;
}
inline void Gem::set_allocated_horn_rpt_79(::jmc_auto::canbus::Horn_rpt_79* horn_rpt_79) {
  delete horn_rpt_79_;
  horn_rpt_79_ = horn_rpt_79;
  if (horn_rpt_79) {
    set_has_horn_rpt_79();
  } else {
    clear_has_horn_rpt_79();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.horn_rpt_79)
}

// optional .jmc_auto.canbus.Horn_cmd_78 horn_cmd_78 = 22;
inline bool Gem::has_horn_cmd_78() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Gem::set_has_horn_cmd_78() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Gem::clear_has_horn_cmd_78() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Gem::clear_horn_cmd_78() {
  if (horn_cmd_78_ != NULL) horn_cmd_78_->::jmc_auto::canbus::Horn_cmd_78::Clear();
  clear_has_horn_cmd_78();
}
inline const ::jmc_auto::canbus::Horn_cmd_78& Gem::horn_cmd_78() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.horn_cmd_78)
  return horn_cmd_78_ != NULL ? *horn_cmd_78_
                         : *::jmc_auto::canbus::Horn_cmd_78::internal_default_instance();
}
inline ::jmc_auto::canbus::Horn_cmd_78* Gem::mutable_horn_cmd_78() {
  set_has_horn_cmd_78();
  if (horn_cmd_78_ == NULL) {
    horn_cmd_78_ = new ::jmc_auto::canbus::Horn_cmd_78;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.horn_cmd_78)
  return horn_cmd_78_;
}
inline ::jmc_auto::canbus::Horn_cmd_78* Gem::release_horn_cmd_78() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.horn_cmd_78)
  clear_has_horn_cmd_78();
  ::jmc_auto::canbus::Horn_cmd_78* temp = horn_cmd_78_;
  horn_cmd_78_ = NULL;
  return temp;
}
inline void Gem::set_allocated_horn_cmd_78(::jmc_auto::canbus::Horn_cmd_78* horn_cmd_78) {
  delete horn_cmd_78_;
  horn_cmd_78_ = horn_cmd_78;
  if (horn_cmd_78) {
    set_has_horn_cmd_78();
  } else {
    clear_has_horn_cmd_78();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.horn_cmd_78)
}

// optional .jmc_auto.canbus.Wiper_rpt_91 wiper_rpt_91 = 23;
inline bool Gem::has_wiper_rpt_91() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Gem::set_has_wiper_rpt_91() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Gem::clear_has_wiper_rpt_91() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Gem::clear_wiper_rpt_91() {
  if (wiper_rpt_91_ != NULL) wiper_rpt_91_->::jmc_auto::canbus::Wiper_rpt_91::Clear();
  clear_has_wiper_rpt_91();
}
inline const ::jmc_auto::canbus::Wiper_rpt_91& Gem::wiper_rpt_91() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.wiper_rpt_91)
  return wiper_rpt_91_ != NULL ? *wiper_rpt_91_
                         : *::jmc_auto::canbus::Wiper_rpt_91::internal_default_instance();
}
inline ::jmc_auto::canbus::Wiper_rpt_91* Gem::mutable_wiper_rpt_91() {
  set_has_wiper_rpt_91();
  if (wiper_rpt_91_ == NULL) {
    wiper_rpt_91_ = new ::jmc_auto::canbus::Wiper_rpt_91;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.wiper_rpt_91)
  return wiper_rpt_91_;
}
inline ::jmc_auto::canbus::Wiper_rpt_91* Gem::release_wiper_rpt_91() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.wiper_rpt_91)
  clear_has_wiper_rpt_91();
  ::jmc_auto::canbus::Wiper_rpt_91* temp = wiper_rpt_91_;
  wiper_rpt_91_ = NULL;
  return temp;
}
inline void Gem::set_allocated_wiper_rpt_91(::jmc_auto::canbus::Wiper_rpt_91* wiper_rpt_91) {
  delete wiper_rpt_91_;
  wiper_rpt_91_ = wiper_rpt_91;
  if (wiper_rpt_91) {
    set_has_wiper_rpt_91();
  } else {
    clear_has_wiper_rpt_91();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.wiper_rpt_91)
}

// optional .jmc_auto.canbus.Vehicle_speed_rpt_6f vehicle_speed_rpt_6f = 24;
inline bool Gem::has_vehicle_speed_rpt_6f() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Gem::set_has_vehicle_speed_rpt_6f() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Gem::clear_has_vehicle_speed_rpt_6f() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Gem::clear_vehicle_speed_rpt_6f() {
  if (vehicle_speed_rpt_6f_ != NULL) vehicle_speed_rpt_6f_->::jmc_auto::canbus::Vehicle_speed_rpt_6f::Clear();
  clear_has_vehicle_speed_rpt_6f();
}
inline const ::jmc_auto::canbus::Vehicle_speed_rpt_6f& Gem::vehicle_speed_rpt_6f() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.vehicle_speed_rpt_6f)
  return vehicle_speed_rpt_6f_ != NULL ? *vehicle_speed_rpt_6f_
                         : *::jmc_auto::canbus::Vehicle_speed_rpt_6f::internal_default_instance();
}
inline ::jmc_auto::canbus::Vehicle_speed_rpt_6f* Gem::mutable_vehicle_speed_rpt_6f() {
  set_has_vehicle_speed_rpt_6f();
  if (vehicle_speed_rpt_6f_ == NULL) {
    vehicle_speed_rpt_6f_ = new ::jmc_auto::canbus::Vehicle_speed_rpt_6f;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.vehicle_speed_rpt_6f)
  return vehicle_speed_rpt_6f_;
}
inline ::jmc_auto::canbus::Vehicle_speed_rpt_6f* Gem::release_vehicle_speed_rpt_6f() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.vehicle_speed_rpt_6f)
  clear_has_vehicle_speed_rpt_6f();
  ::jmc_auto::canbus::Vehicle_speed_rpt_6f* temp = vehicle_speed_rpt_6f_;
  vehicle_speed_rpt_6f_ = NULL;
  return temp;
}
inline void Gem::set_allocated_vehicle_speed_rpt_6f(::jmc_auto::canbus::Vehicle_speed_rpt_6f* vehicle_speed_rpt_6f) {
  delete vehicle_speed_rpt_6f_;
  vehicle_speed_rpt_6f_ = vehicle_speed_rpt_6f;
  if (vehicle_speed_rpt_6f) {
    set_has_vehicle_speed_rpt_6f();
  } else {
    clear_has_vehicle_speed_rpt_6f();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.vehicle_speed_rpt_6f)
}

// optional .jmc_auto.canbus.Headlight_cmd_76 headlight_cmd_76 = 25;
inline bool Gem::has_headlight_cmd_76() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Gem::set_has_headlight_cmd_76() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Gem::clear_has_headlight_cmd_76() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Gem::clear_headlight_cmd_76() {
  if (headlight_cmd_76_ != NULL) headlight_cmd_76_->::jmc_auto::canbus::Headlight_cmd_76::Clear();
  clear_has_headlight_cmd_76();
}
inline const ::jmc_auto::canbus::Headlight_cmd_76& Gem::headlight_cmd_76() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.headlight_cmd_76)
  return headlight_cmd_76_ != NULL ? *headlight_cmd_76_
                         : *::jmc_auto::canbus::Headlight_cmd_76::internal_default_instance();
}
inline ::jmc_auto::canbus::Headlight_cmd_76* Gem::mutable_headlight_cmd_76() {
  set_has_headlight_cmd_76();
  if (headlight_cmd_76_ == NULL) {
    headlight_cmd_76_ = new ::jmc_auto::canbus::Headlight_cmd_76;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.headlight_cmd_76)
  return headlight_cmd_76_;
}
inline ::jmc_auto::canbus::Headlight_cmd_76* Gem::release_headlight_cmd_76() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.headlight_cmd_76)
  clear_has_headlight_cmd_76();
  ::jmc_auto::canbus::Headlight_cmd_76* temp = headlight_cmd_76_;
  headlight_cmd_76_ = NULL;
  return temp;
}
inline void Gem::set_allocated_headlight_cmd_76(::jmc_auto::canbus::Headlight_cmd_76* headlight_cmd_76) {
  delete headlight_cmd_76_;
  headlight_cmd_76_ = headlight_cmd_76;
  if (headlight_cmd_76) {
    set_has_headlight_cmd_76();
  } else {
    clear_has_headlight_cmd_76();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.headlight_cmd_76)
}

// optional .jmc_auto.canbus.Steering_motor_rpt_2_74 steering_motor_rpt_2_74 = 26;
inline bool Gem::has_steering_motor_rpt_2_74() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Gem::set_has_steering_motor_rpt_2_74() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Gem::clear_has_steering_motor_rpt_2_74() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Gem::clear_steering_motor_rpt_2_74() {
  if (steering_motor_rpt_2_74_ != NULL) steering_motor_rpt_2_74_->::jmc_auto::canbus::Steering_motor_rpt_2_74::Clear();
  clear_has_steering_motor_rpt_2_74();
}
inline const ::jmc_auto::canbus::Steering_motor_rpt_2_74& Gem::steering_motor_rpt_2_74() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.steering_motor_rpt_2_74)
  return steering_motor_rpt_2_74_ != NULL ? *steering_motor_rpt_2_74_
                         : *::jmc_auto::canbus::Steering_motor_rpt_2_74::internal_default_instance();
}
inline ::jmc_auto::canbus::Steering_motor_rpt_2_74* Gem::mutable_steering_motor_rpt_2_74() {
  set_has_steering_motor_rpt_2_74();
  if (steering_motor_rpt_2_74_ == NULL) {
    steering_motor_rpt_2_74_ = new ::jmc_auto::canbus::Steering_motor_rpt_2_74;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.steering_motor_rpt_2_74)
  return steering_motor_rpt_2_74_;
}
inline ::jmc_auto::canbus::Steering_motor_rpt_2_74* Gem::release_steering_motor_rpt_2_74() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.steering_motor_rpt_2_74)
  clear_has_steering_motor_rpt_2_74();
  ::jmc_auto::canbus::Steering_motor_rpt_2_74* temp = steering_motor_rpt_2_74_;
  steering_motor_rpt_2_74_ = NULL;
  return temp;
}
inline void Gem::set_allocated_steering_motor_rpt_2_74(::jmc_auto::canbus::Steering_motor_rpt_2_74* steering_motor_rpt_2_74) {
  delete steering_motor_rpt_2_74_;
  steering_motor_rpt_2_74_ = steering_motor_rpt_2_74;
  if (steering_motor_rpt_2_74) {
    set_has_steering_motor_rpt_2_74();
  } else {
    clear_has_steering_motor_rpt_2_74();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.steering_motor_rpt_2_74)
}

// optional .jmc_auto.canbus.Brake_motor_rpt_2_71 brake_motor_rpt_2_71 = 27;
inline bool Gem::has_brake_motor_rpt_2_71() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Gem::set_has_brake_motor_rpt_2_71() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Gem::clear_has_brake_motor_rpt_2_71() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Gem::clear_brake_motor_rpt_2_71() {
  if (brake_motor_rpt_2_71_ != NULL) brake_motor_rpt_2_71_->::jmc_auto::canbus::Brake_motor_rpt_2_71::Clear();
  clear_has_brake_motor_rpt_2_71();
}
inline const ::jmc_auto::canbus::Brake_motor_rpt_2_71& Gem::brake_motor_rpt_2_71() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.brake_motor_rpt_2_71)
  return brake_motor_rpt_2_71_ != NULL ? *brake_motor_rpt_2_71_
                         : *::jmc_auto::canbus::Brake_motor_rpt_2_71::internal_default_instance();
}
inline ::jmc_auto::canbus::Brake_motor_rpt_2_71* Gem::mutable_brake_motor_rpt_2_71() {
  set_has_brake_motor_rpt_2_71();
  if (brake_motor_rpt_2_71_ == NULL) {
    brake_motor_rpt_2_71_ = new ::jmc_auto::canbus::Brake_motor_rpt_2_71;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.brake_motor_rpt_2_71)
  return brake_motor_rpt_2_71_;
}
inline ::jmc_auto::canbus::Brake_motor_rpt_2_71* Gem::release_brake_motor_rpt_2_71() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.brake_motor_rpt_2_71)
  clear_has_brake_motor_rpt_2_71();
  ::jmc_auto::canbus::Brake_motor_rpt_2_71* temp = brake_motor_rpt_2_71_;
  brake_motor_rpt_2_71_ = NULL;
  return temp;
}
inline void Gem::set_allocated_brake_motor_rpt_2_71(::jmc_auto::canbus::Brake_motor_rpt_2_71* brake_motor_rpt_2_71) {
  delete brake_motor_rpt_2_71_;
  brake_motor_rpt_2_71_ = brake_motor_rpt_2_71;
  if (brake_motor_rpt_2_71) {
    set_has_brake_motor_rpt_2_71();
  } else {
    clear_has_brake_motor_rpt_2_71();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.brake_motor_rpt_2_71)
}

// optional .jmc_auto.canbus.Steering_motor_rpt_1_73 steering_motor_rpt_1_73 = 28;
inline bool Gem::has_steering_motor_rpt_1_73() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Gem::set_has_steering_motor_rpt_1_73() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Gem::clear_has_steering_motor_rpt_1_73() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Gem::clear_steering_motor_rpt_1_73() {
  if (steering_motor_rpt_1_73_ != NULL) steering_motor_rpt_1_73_->::jmc_auto::canbus::Steering_motor_rpt_1_73::Clear();
  clear_has_steering_motor_rpt_1_73();
}
inline const ::jmc_auto::canbus::Steering_motor_rpt_1_73& Gem::steering_motor_rpt_1_73() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.steering_motor_rpt_1_73)
  return steering_motor_rpt_1_73_ != NULL ? *steering_motor_rpt_1_73_
                         : *::jmc_auto::canbus::Steering_motor_rpt_1_73::internal_default_instance();
}
inline ::jmc_auto::canbus::Steering_motor_rpt_1_73* Gem::mutable_steering_motor_rpt_1_73() {
  set_has_steering_motor_rpt_1_73();
  if (steering_motor_rpt_1_73_ == NULL) {
    steering_motor_rpt_1_73_ = new ::jmc_auto::canbus::Steering_motor_rpt_1_73;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.steering_motor_rpt_1_73)
  return steering_motor_rpt_1_73_;
}
inline ::jmc_auto::canbus::Steering_motor_rpt_1_73* Gem::release_steering_motor_rpt_1_73() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.steering_motor_rpt_1_73)
  clear_has_steering_motor_rpt_1_73();
  ::jmc_auto::canbus::Steering_motor_rpt_1_73* temp = steering_motor_rpt_1_73_;
  steering_motor_rpt_1_73_ = NULL;
  return temp;
}
inline void Gem::set_allocated_steering_motor_rpt_1_73(::jmc_auto::canbus::Steering_motor_rpt_1_73* steering_motor_rpt_1_73) {
  delete steering_motor_rpt_1_73_;
  steering_motor_rpt_1_73_ = steering_motor_rpt_1_73;
  if (steering_motor_rpt_1_73) {
    set_has_steering_motor_rpt_1_73();
  } else {
    clear_has_steering_motor_rpt_1_73();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.steering_motor_rpt_1_73)
}

// optional .jmc_auto.canbus.Wiper_cmd_90 wiper_cmd_90 = 29;
inline bool Gem::has_wiper_cmd_90() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Gem::set_has_wiper_cmd_90() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Gem::clear_has_wiper_cmd_90() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Gem::clear_wiper_cmd_90() {
  if (wiper_cmd_90_ != NULL) wiper_cmd_90_->::jmc_auto::canbus::Wiper_cmd_90::Clear();
  clear_has_wiper_cmd_90();
}
inline const ::jmc_auto::canbus::Wiper_cmd_90& Gem::wiper_cmd_90() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.wiper_cmd_90)
  return wiper_cmd_90_ != NULL ? *wiper_cmd_90_
                         : *::jmc_auto::canbus::Wiper_cmd_90::internal_default_instance();
}
inline ::jmc_auto::canbus::Wiper_cmd_90* Gem::mutable_wiper_cmd_90() {
  set_has_wiper_cmd_90();
  if (wiper_cmd_90_ == NULL) {
    wiper_cmd_90_ = new ::jmc_auto::canbus::Wiper_cmd_90;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.wiper_cmd_90)
  return wiper_cmd_90_;
}
inline ::jmc_auto::canbus::Wiper_cmd_90* Gem::release_wiper_cmd_90() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.wiper_cmd_90)
  clear_has_wiper_cmd_90();
  ::jmc_auto::canbus::Wiper_cmd_90* temp = wiper_cmd_90_;
  wiper_cmd_90_ = NULL;
  return temp;
}
inline void Gem::set_allocated_wiper_cmd_90(::jmc_auto::canbus::Wiper_cmd_90* wiper_cmd_90) {
  delete wiper_cmd_90_;
  wiper_cmd_90_ = wiper_cmd_90;
  if (wiper_cmd_90) {
    set_has_wiper_cmd_90();
  } else {
    clear_has_wiper_cmd_90();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.wiper_cmd_90)
}

// optional .jmc_auto.canbus.Brake_motor_rpt_3_72 brake_motor_rpt_3_72 = 30;
inline bool Gem::has_brake_motor_rpt_3_72() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Gem::set_has_brake_motor_rpt_3_72() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Gem::clear_has_brake_motor_rpt_3_72() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Gem::clear_brake_motor_rpt_3_72() {
  if (brake_motor_rpt_3_72_ != NULL) brake_motor_rpt_3_72_->::jmc_auto::canbus::Brake_motor_rpt_3_72::Clear();
  clear_has_brake_motor_rpt_3_72();
}
inline const ::jmc_auto::canbus::Brake_motor_rpt_3_72& Gem::brake_motor_rpt_3_72() const {
  // @@protoc_insertion_point(field_get:jmc_auto.canbus.Gem.brake_motor_rpt_3_72)
  return brake_motor_rpt_3_72_ != NULL ? *brake_motor_rpt_3_72_
                         : *::jmc_auto::canbus::Brake_motor_rpt_3_72::internal_default_instance();
}
inline ::jmc_auto::canbus::Brake_motor_rpt_3_72* Gem::mutable_brake_motor_rpt_3_72() {
  set_has_brake_motor_rpt_3_72();
  if (brake_motor_rpt_3_72_ == NULL) {
    brake_motor_rpt_3_72_ = new ::jmc_auto::canbus::Brake_motor_rpt_3_72;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.canbus.Gem.brake_motor_rpt_3_72)
  return brake_motor_rpt_3_72_;
}
inline ::jmc_auto::canbus::Brake_motor_rpt_3_72* Gem::release_brake_motor_rpt_3_72() {
  // @@protoc_insertion_point(field_release:jmc_auto.canbus.Gem.brake_motor_rpt_3_72)
  clear_has_brake_motor_rpt_3_72();
  ::jmc_auto::canbus::Brake_motor_rpt_3_72* temp = brake_motor_rpt_3_72_;
  brake_motor_rpt_3_72_ = NULL;
  return temp;
}
inline void Gem::set_allocated_brake_motor_rpt_3_72(::jmc_auto::canbus::Brake_motor_rpt_3_72* brake_motor_rpt_3_72) {
  delete brake_motor_rpt_3_72_;
  brake_motor_rpt_3_72_ = brake_motor_rpt_3_72;
  if (brake_motor_rpt_3_72) {
    set_has_brake_motor_rpt_3_72();
  } else {
    clear_has_brake_motor_rpt_3_72();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.canbus.Gem.brake_motor_rpt_3_72)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace canbus
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::canbus::ChassisDetail_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::ChassisDetail_Type>() {
  return ::jmc_auto::canbus::ChassisDetail_Type_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Light_TurnLightType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Light_TurnLightType>() {
  return ::jmc_auto::canbus::Light_TurnLightType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Light_BeamLampType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Light_BeamLampType>() {
  return ::jmc_auto::canbus::Light_BeamLampType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Light_LincolnLampType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Light_LincolnLampType>() {
  return ::jmc_auto::canbus::Light_LincolnLampType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Light_LincolnWiperType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Light_LincolnWiperType>() {
  return ::jmc_auto::canbus::Light_LincolnWiperType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Light_LincolnAmbientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Light_LincolnAmbientType>() {
  return ::jmc_auto::canbus::Light_LincolnAmbientType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Eps_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Eps_Type>() {
  return ::jmc_auto::canbus::Eps_Type_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Brake_HSAStatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Brake_HSAStatusType>() {
  return ::jmc_auto::canbus::Brake_HSAStatusType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Brake_HSAModeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Brake_HSAModeType>() {
  return ::jmc_auto::canbus::Brake_HSAModeType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Epb_PBrakeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Epb_PBrakeType>() {
  return ::jmc_auto::canbus::Epb_PBrakeType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Ems_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Ems_Type>() {
  return ::jmc_auto::canbus::Ems_Type_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::BasicInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::BasicInfo_Type>() {
  return ::jmc_auto::canbus::BasicInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType>() {
  return ::jmc_auto::canbus::Global_rpt_6a_Pacmod_statusType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Global_rpt_6a_Override_statusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Global_rpt_6a_Override_statusType>() {
  return ::jmc_auto::canbus::Global_rpt_6a_Override_statusType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType>() {
  return ::jmc_auto::canbus::Global_rpt_6a_Brk_can_timeoutType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType>() {
  return ::jmc_auto::canbus::Brake_rpt_6c_Brake_on_offType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Headlight_rpt_77_Output_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Headlight_rpt_77_Output_valueType>() {
  return ::jmc_auto::canbus::Headlight_rpt_77_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType>() {
  return ::jmc_auto::canbus::Headlight_rpt_77_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType>() {
  return ::jmc_auto::canbus::Headlight_rpt_77_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType>() {
  return ::jmc_auto::canbus::Turn_cmd_63_Turn_signal_cmdType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Turn_rpt_64_Manual_inputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Turn_rpt_64_Manual_inputType>() {
  return ::jmc_auto::canbus::Turn_rpt_64_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType>() {
  return ::jmc_auto::canbus::Turn_rpt_64_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Turn_rpt_64_Output_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Turn_rpt_64_Output_valueType>() {
  return ::jmc_auto::canbus::Turn_rpt_64_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType>() {
  return ::jmc_auto::canbus::Shift_cmd_65_Shift_cmdType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Shift_rpt_66_Manual_inputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Shift_rpt_66_Manual_inputType>() {
  return ::jmc_auto::canbus::Shift_rpt_66_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType>() {
  return ::jmc_auto::canbus::Shift_rpt_66_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Shift_rpt_66_Output_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Shift_rpt_66_Output_valueType>() {
  return ::jmc_auto::canbus::Shift_rpt_66_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType>() {
  return ::jmc_auto::canbus::Global_cmd_69_Pacmod_enableType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Global_cmd_69_Clear_overrideType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Global_cmd_69_Clear_overrideType>() {
  return ::jmc_auto::canbus::Global_cmd_69_Clear_overrideType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType>() {
  return ::jmc_auto::canbus::Global_cmd_69_Ignore_overrideType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType>() {
  return ::jmc_auto::canbus::Parking_brake_status_rpt_80_Parking_brake_enabledType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Horn_rpt_79_Output_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Horn_rpt_79_Output_valueType>() {
  return ::jmc_auto::canbus::Horn_rpt_79_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType>() {
  return ::jmc_auto::canbus::Horn_rpt_79_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Horn_rpt_79_Manual_inputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Horn_rpt_79_Manual_inputType>() {
  return ::jmc_auto::canbus::Horn_rpt_79_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType>() {
  return ::jmc_auto::canbus::Horn_cmd_78_Horn_cmdType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Wiper_rpt_91_Output_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Wiper_rpt_91_Output_valueType>() {
  return ::jmc_auto::canbus::Wiper_rpt_91_Output_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType>() {
  return ::jmc_auto::canbus::Wiper_rpt_91_Commanded_valueType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType>() {
  return ::jmc_auto::canbus::Wiper_rpt_91_Manual_inputType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType>() {
  return ::jmc_auto::canbus::Vehicle_speed_rpt_6f_Vehicle_speed_validType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType>() {
  return ::jmc_auto::canbus::Headlight_cmd_76_Headlight_cmdType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType>() {
  return ::jmc_auto::canbus::Wiper_cmd_90_Wiper_cmdType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fcanbus_2fproto_2fchassis_5fdetail_2eproto__INCLUDED
