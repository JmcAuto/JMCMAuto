// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/map/proto/map_overlap.proto

#ifndef PROTOBUF_modules_2fmap_2fproto_2fmap_5foverlap_2eproto__INCLUDED
#define PROTOBUF_modules_2fmap_2fproto_2fmap_5foverlap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "modules/map/proto/map_id.pb.h"
#include "modules/map/proto/map_geometry.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace hdmap {
class ClearAreaOverlapInfo;
class ClearAreaOverlapInfoDefaultTypeInternal;
extern ClearAreaOverlapInfoDefaultTypeInternal _ClearAreaOverlapInfo_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class Curve;
class CurveDefaultTypeInternal;
extern CurveDefaultTypeInternal _Curve_default_instance_;
class CurveSegment;
class CurveSegmentDefaultTypeInternal;
extern CurveSegmentDefaultTypeInternal _CurveSegment_default_instance_;
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class JunctionOverlapInfo;
class JunctionOverlapInfoDefaultTypeInternal;
extern JunctionOverlapInfoDefaultTypeInternal _JunctionOverlapInfo_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class LineSegment;
class LineSegmentDefaultTypeInternal;
extern LineSegmentDefaultTypeInternal _LineSegment_default_instance_;
class ObjectOverlapInfo;
class ObjectOverlapInfoDefaultTypeInternal;
extern ObjectOverlapInfoDefaultTypeInternal _ObjectOverlapInfo_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class ParkingSpaceOverlapInfo;
class ParkingSpaceOverlapInfoDefaultTypeInternal;
extern ParkingSpaceOverlapInfoDefaultTypeInternal _ParkingSpaceOverlapInfo_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class RegionOverlapInfo;
class RegionOverlapInfoDefaultTypeInternal;
extern RegionOverlapInfoDefaultTypeInternal _RegionOverlapInfo_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
class SpeedBumpOverlapInfo;
class SpeedBumpOverlapInfoDefaultTypeInternal;
extern SpeedBumpOverlapInfoDefaultTypeInternal _SpeedBumpOverlapInfo_default_instance_;
class StopSignOverlapInfo;
class StopSignOverlapInfoDefaultTypeInternal;
extern StopSignOverlapInfoDefaultTypeInternal _StopSignOverlapInfo_default_instance_;
class YieldOverlapInfo;
class YieldOverlapInfoDefaultTypeInternal;
extern YieldOverlapInfoDefaultTypeInternal _YieldOverlapInfo_default_instance_;
}  // namespace hdmap
}  // namespace jmc_auto

namespace jmc_auto {
namespace hdmap {

namespace protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto

// ===================================================================

class LaneOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.LaneOverlapInfo) */ {
 public:
  LaneOverlapInfo();
  virtual ~LaneOverlapInfo();

  LaneOverlapInfo(const LaneOverlapInfo& from);

  inline LaneOverlapInfo& operator=(const LaneOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneOverlapInfo& default_instance();

  static inline const LaneOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const LaneOverlapInfo*>(
               &_LaneOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LaneOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline LaneOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneOverlapInfo& from);
  void MergeFrom(const LaneOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.hdmap.Id region_overlap_id = 5;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 5;
  const ::jmc_auto::hdmap::Id& region_overlap_id() const;
  ::jmc_auto::hdmap::Id* mutable_region_overlap_id();
  ::jmc_auto::hdmap::Id* release_region_overlap_id();
  void set_allocated_region_overlap_id(::jmc_auto::hdmap::Id* region_overlap_id);

  // optional double start_s = 1;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 1;
  double start_s() const;
  void set_start_s(double value);

  // optional double end_s = 2;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 2;
  double end_s() const;
  void set_end_s(double value);

  // optional bool is_merge = 3;
  bool has_is_merge() const;
  void clear_is_merge();
  static const int kIsMergeFieldNumber = 3;
  bool is_merge() const;
  void set_is_merge(bool value);

  // optional bool has_precedence = 4;
  bool has_has_precedence() const;
  void clear_has_precedence();
  static const int kHasPrecedenceFieldNumber = 4;
  bool has_precedence() const;
  void set_has_precedence(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.LaneOverlapInfo)
 private:
  void set_has_start_s();
  void clear_has_start_s();
  void set_has_end_s();
  void clear_has_end_s();
  void set_has_is_merge();
  void clear_has_is_merge();
  void set_has_has_precedence();
  void clear_has_has_precedence();
  void set_has_region_overlap_id();
  void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::hdmap::Id* region_overlap_id_;
  double start_s_;
  double end_s_;
  bool is_merge_;
  bool has_precedence_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignalOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.SignalOverlapInfo) */ {
 public:
  SignalOverlapInfo();
  virtual ~SignalOverlapInfo();

  SignalOverlapInfo(const SignalOverlapInfo& from);

  inline SignalOverlapInfo& operator=(const SignalOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalOverlapInfo& default_instance();

  static inline const SignalOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SignalOverlapInfo*>(
               &_SignalOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SignalOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline SignalOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SignalOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignalOverlapInfo& from);
  void MergeFrom(const SignalOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignalOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.SignalOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopSignOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.StopSignOverlapInfo) */ {
 public:
  StopSignOverlapInfo();
  virtual ~StopSignOverlapInfo();

  StopSignOverlapInfo(const StopSignOverlapInfo& from);

  inline StopSignOverlapInfo& operator=(const StopSignOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignOverlapInfo& default_instance();

  static inline const StopSignOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const StopSignOverlapInfo*>(
               &_StopSignOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(StopSignOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline StopSignOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  StopSignOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopSignOverlapInfo& from);
  void MergeFrom(const StopSignOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopSignOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.StopSignOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.CrosswalkOverlapInfo) */ {
 public:
  CrosswalkOverlapInfo();
  virtual ~CrosswalkOverlapInfo();

  CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from);

  inline CrosswalkOverlapInfo& operator=(const CrosswalkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkOverlapInfo& default_instance();

  static inline const CrosswalkOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const CrosswalkOverlapInfo*>(
               &_CrosswalkOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CrosswalkOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline CrosswalkOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CrosswalkOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrosswalkOverlapInfo& from);
  void MergeFrom(const CrosswalkOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrosswalkOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.hdmap.Id region_overlap_id = 1;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 1;
  const ::jmc_auto::hdmap::Id& region_overlap_id() const;
  ::jmc_auto::hdmap::Id* mutable_region_overlap_id();
  ::jmc_auto::hdmap::Id* release_region_overlap_id();
  void set_allocated_region_overlap_id(::jmc_auto::hdmap::Id* region_overlap_id);

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.CrosswalkOverlapInfo)
 private:
  void set_has_region_overlap_id();
  void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::hdmap::Id* region_overlap_id_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JunctionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.JunctionOverlapInfo) */ {
 public:
  JunctionOverlapInfo();
  virtual ~JunctionOverlapInfo();

  JunctionOverlapInfo(const JunctionOverlapInfo& from);

  inline JunctionOverlapInfo& operator=(const JunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JunctionOverlapInfo& default_instance();

  static inline const JunctionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const JunctionOverlapInfo*>(
               &_JunctionOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(JunctionOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline JunctionOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  JunctionOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JunctionOverlapInfo& from);
  void MergeFrom(const JunctionOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JunctionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.JunctionOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YieldOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.YieldOverlapInfo) */ {
 public:
  YieldOverlapInfo();
  virtual ~YieldOverlapInfo();

  YieldOverlapInfo(const YieldOverlapInfo& from);

  inline YieldOverlapInfo& operator=(const YieldOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldOverlapInfo& default_instance();

  static inline const YieldOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const YieldOverlapInfo*>(
               &_YieldOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(YieldOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline YieldOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  YieldOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YieldOverlapInfo& from);
  void MergeFrom(const YieldOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YieldOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.YieldOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearAreaOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.ClearAreaOverlapInfo) */ {
 public:
  ClearAreaOverlapInfo();
  virtual ~ClearAreaOverlapInfo();

  ClearAreaOverlapInfo(const ClearAreaOverlapInfo& from);

  inline ClearAreaOverlapInfo& operator=(const ClearAreaOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearAreaOverlapInfo& default_instance();

  static inline const ClearAreaOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ClearAreaOverlapInfo*>(
               &_ClearAreaOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ClearAreaOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline ClearAreaOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ClearAreaOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClearAreaOverlapInfo& from);
  void MergeFrom(const ClearAreaOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClearAreaOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.ClearAreaOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedBumpOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.SpeedBumpOverlapInfo) */ {
 public:
  SpeedBumpOverlapInfo();
  virtual ~SpeedBumpOverlapInfo();

  SpeedBumpOverlapInfo(const SpeedBumpOverlapInfo& from);

  inline SpeedBumpOverlapInfo& operator=(const SpeedBumpOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedBumpOverlapInfo& default_instance();

  static inline const SpeedBumpOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SpeedBumpOverlapInfo*>(
               &_SpeedBumpOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SpeedBumpOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline SpeedBumpOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SpeedBumpOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpeedBumpOverlapInfo& from);
  void MergeFrom(const SpeedBumpOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpeedBumpOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.SpeedBumpOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParkingSpaceOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.ParkingSpaceOverlapInfo) */ {
 public:
  ParkingSpaceOverlapInfo();
  virtual ~ParkingSpaceOverlapInfo();

  ParkingSpaceOverlapInfo(const ParkingSpaceOverlapInfo& from);

  inline ParkingSpaceOverlapInfo& operator=(const ParkingSpaceOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpaceOverlapInfo& default_instance();

  static inline const ParkingSpaceOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceOverlapInfo*>(
               &_ParkingSpaceOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ParkingSpaceOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline ParkingSpaceOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSpaceOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSpaceOverlapInfo& from);
  void MergeFrom(const ParkingSpaceOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSpaceOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.ParkingSpaceOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.ObjectOverlapInfo) */ {
 public:
  ObjectOverlapInfo();
  virtual ~ObjectOverlapInfo();

  ObjectOverlapInfo(const ObjectOverlapInfo& from);

  inline ObjectOverlapInfo& operator=(const ObjectOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectOverlapInfo& default_instance();

  enum OverlapInfoCase {
    kLaneOverlapInfo = 3,
    kSignalOverlapInfo = 4,
    kStopSignOverlapInfo = 5,
    kCrosswalkOverlapInfo = 6,
    kJunctionOverlapInfo = 7,
    kYieldSignOverlapInfo = 8,
    kClearAreaOverlapInfo = 9,
    kSpeedBumpOverlapInfo = 10,
    kParkingSpaceOverlapInfo = 11,
    OVERLAP_INFO_NOT_SET = 0,
  };

  static inline const ObjectOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectOverlapInfo*>(
               &_ObjectOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ObjectOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline ObjectOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ObjectOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObjectOverlapInfo& from);
  void MergeFrom(const ObjectOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObjectOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::jmc_auto::hdmap::Id& id() const;
  ::jmc_auto::hdmap::Id* mutable_id();
  ::jmc_auto::hdmap::Id* release_id();
  void set_allocated_id(::jmc_auto::hdmap::Id* id);

  // optional .jmc_auto.hdmap.LaneOverlapInfo lane_overlap_info = 3;
  bool has_lane_overlap_info() const;
  void clear_lane_overlap_info();
  static const int kLaneOverlapInfoFieldNumber = 3;
  const ::jmc_auto::hdmap::LaneOverlapInfo& lane_overlap_info() const;
  ::jmc_auto::hdmap::LaneOverlapInfo* mutable_lane_overlap_info();
  ::jmc_auto::hdmap::LaneOverlapInfo* release_lane_overlap_info();
  void set_allocated_lane_overlap_info(::jmc_auto::hdmap::LaneOverlapInfo* lane_overlap_info);

  // optional .jmc_auto.hdmap.SignalOverlapInfo signal_overlap_info = 4;
  bool has_signal_overlap_info() const;
  void clear_signal_overlap_info();
  static const int kSignalOverlapInfoFieldNumber = 4;
  const ::jmc_auto::hdmap::SignalOverlapInfo& signal_overlap_info() const;
  ::jmc_auto::hdmap::SignalOverlapInfo* mutable_signal_overlap_info();
  ::jmc_auto::hdmap::SignalOverlapInfo* release_signal_overlap_info();
  void set_allocated_signal_overlap_info(::jmc_auto::hdmap::SignalOverlapInfo* signal_overlap_info);

  // optional .jmc_auto.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
  bool has_stop_sign_overlap_info() const;
  void clear_stop_sign_overlap_info();
  static const int kStopSignOverlapInfoFieldNumber = 5;
  const ::jmc_auto::hdmap::StopSignOverlapInfo& stop_sign_overlap_info() const;
  ::jmc_auto::hdmap::StopSignOverlapInfo* mutable_stop_sign_overlap_info();
  ::jmc_auto::hdmap::StopSignOverlapInfo* release_stop_sign_overlap_info();
  void set_allocated_stop_sign_overlap_info(::jmc_auto::hdmap::StopSignOverlapInfo* stop_sign_overlap_info);

  // optional .jmc_auto.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
  bool has_crosswalk_overlap_info() const;
  void clear_crosswalk_overlap_info();
  static const int kCrosswalkOverlapInfoFieldNumber = 6;
  const ::jmc_auto::hdmap::CrosswalkOverlapInfo& crosswalk_overlap_info() const;
  ::jmc_auto::hdmap::CrosswalkOverlapInfo* mutable_crosswalk_overlap_info();
  ::jmc_auto::hdmap::CrosswalkOverlapInfo* release_crosswalk_overlap_info();
  void set_allocated_crosswalk_overlap_info(::jmc_auto::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info);

  // optional .jmc_auto.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
  bool has_junction_overlap_info() const;
  void clear_junction_overlap_info();
  static const int kJunctionOverlapInfoFieldNumber = 7;
  const ::jmc_auto::hdmap::JunctionOverlapInfo& junction_overlap_info() const;
  ::jmc_auto::hdmap::JunctionOverlapInfo* mutable_junction_overlap_info();
  ::jmc_auto::hdmap::JunctionOverlapInfo* release_junction_overlap_info();
  void set_allocated_junction_overlap_info(::jmc_auto::hdmap::JunctionOverlapInfo* junction_overlap_info);

  // optional .jmc_auto.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
  bool has_yield_sign_overlap_info() const;
  void clear_yield_sign_overlap_info();
  static const int kYieldSignOverlapInfoFieldNumber = 8;
  const ::jmc_auto::hdmap::YieldOverlapInfo& yield_sign_overlap_info() const;
  ::jmc_auto::hdmap::YieldOverlapInfo* mutable_yield_sign_overlap_info();
  ::jmc_auto::hdmap::YieldOverlapInfo* release_yield_sign_overlap_info();
  void set_allocated_yield_sign_overlap_info(::jmc_auto::hdmap::YieldOverlapInfo* yield_sign_overlap_info);

  // optional .jmc_auto.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
  bool has_clear_area_overlap_info() const;
  void clear_clear_area_overlap_info();
  static const int kClearAreaOverlapInfoFieldNumber = 9;
  const ::jmc_auto::hdmap::ClearAreaOverlapInfo& clear_area_overlap_info() const;
  ::jmc_auto::hdmap::ClearAreaOverlapInfo* mutable_clear_area_overlap_info();
  ::jmc_auto::hdmap::ClearAreaOverlapInfo* release_clear_area_overlap_info();
  void set_allocated_clear_area_overlap_info(::jmc_auto::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info);

  // optional .jmc_auto.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
  bool has_speed_bump_overlap_info() const;
  void clear_speed_bump_overlap_info();
  static const int kSpeedBumpOverlapInfoFieldNumber = 10;
  const ::jmc_auto::hdmap::SpeedBumpOverlapInfo& speed_bump_overlap_info() const;
  ::jmc_auto::hdmap::SpeedBumpOverlapInfo* mutable_speed_bump_overlap_info();
  ::jmc_auto::hdmap::SpeedBumpOverlapInfo* release_speed_bump_overlap_info();
  void set_allocated_speed_bump_overlap_info(::jmc_auto::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info);

  // optional .jmc_auto.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
  bool has_parking_space_overlap_info() const;
  void clear_parking_space_overlap_info();
  static const int kParkingSpaceOverlapInfoFieldNumber = 11;
  const ::jmc_auto::hdmap::ParkingSpaceOverlapInfo& parking_space_overlap_info() const;
  ::jmc_auto::hdmap::ParkingSpaceOverlapInfo* mutable_parking_space_overlap_info();
  ::jmc_auto::hdmap::ParkingSpaceOverlapInfo* release_parking_space_overlap_info();
  void set_allocated_parking_space_overlap_info(::jmc_auto::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info);

  OverlapInfoCase overlap_info_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.ObjectOverlapInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_lane_overlap_info();
  void set_has_signal_overlap_info();
  void set_has_stop_sign_overlap_info();
  void set_has_crosswalk_overlap_info();
  void set_has_junction_overlap_info();
  void set_has_yield_sign_overlap_info();
  void set_has_clear_area_overlap_info();
  void set_has_speed_bump_overlap_info();
  void set_has_parking_space_overlap_info();

  inline bool has_overlap_info() const;
  void clear_overlap_info();
  inline void clear_has_overlap_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::hdmap::Id* id_;
  union OverlapInfoUnion {
    OverlapInfoUnion() {}
    ::jmc_auto::hdmap::LaneOverlapInfo* lane_overlap_info_;
    ::jmc_auto::hdmap::SignalOverlapInfo* signal_overlap_info_;
    ::jmc_auto::hdmap::StopSignOverlapInfo* stop_sign_overlap_info_;
    ::jmc_auto::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info_;
    ::jmc_auto::hdmap::JunctionOverlapInfo* junction_overlap_info_;
    ::jmc_auto::hdmap::YieldOverlapInfo* yield_sign_overlap_info_;
    ::jmc_auto::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info_;
    ::jmc_auto::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info_;
    ::jmc_auto::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info_;
  } overlap_info_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.RegionOverlapInfo) */ {
 public:
  RegionOverlapInfo();
  virtual ~RegionOverlapInfo();

  RegionOverlapInfo(const RegionOverlapInfo& from);

  inline RegionOverlapInfo& operator=(const RegionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionOverlapInfo& default_instance();

  static inline const RegionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapInfo*>(
               &_RegionOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RegionOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline RegionOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionOverlapInfo& from);
  void MergeFrom(const RegionOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.hdmap.Polygon polygon = 2;
  int polygon_size() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  const ::jmc_auto::hdmap::Polygon& polygon(int index) const;
  ::jmc_auto::hdmap::Polygon* mutable_polygon(int index);
  ::jmc_auto::hdmap::Polygon* add_polygon();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::Polygon >*
      mutable_polygon();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::Polygon >&
      polygon() const;

  // optional .jmc_auto.hdmap.Id region_overlap_id = 1;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 1;
  const ::jmc_auto::hdmap::Id& region_overlap_id() const;
  ::jmc_auto::hdmap::Id* mutable_region_overlap_id();
  ::jmc_auto::hdmap::Id* release_region_overlap_id();
  void set_allocated_region_overlap_id(::jmc_auto::hdmap::Id* region_overlap_id);

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.RegionOverlapInfo)
 private:
  void set_has_region_overlap_id();
  void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::Polygon > polygon_;
  ::jmc_auto::hdmap::Id* region_overlap_id_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Overlap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.hdmap.Overlap) */ {
 public:
  Overlap();
  virtual ~Overlap();

  Overlap(const Overlap& from);

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap& default_instance();

  static inline const Overlap* internal_default_instance() {
    return reinterpret_cast<const Overlap*>(
               &_Overlap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Overlap* other);

  // implements Message ----------------------------------------------

  inline Overlap* New() const PROTOBUF_FINAL { return New(NULL); }

  Overlap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Overlap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.hdmap.ObjectOverlapInfo object = 2;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  const ::jmc_auto::hdmap::ObjectOverlapInfo& object(int index) const;
  ::jmc_auto::hdmap::ObjectOverlapInfo* mutable_object(int index);
  ::jmc_auto::hdmap::ObjectOverlapInfo* add_object();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::ObjectOverlapInfo >*
      mutable_object();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::ObjectOverlapInfo >&
      object() const;

  // repeated .jmc_auto.hdmap.RegionOverlapInfo region_overlap_info = 3;
  int region_overlap_info_size() const;
  void clear_region_overlap_info();
  static const int kRegionOverlapInfoFieldNumber = 3;
  const ::jmc_auto::hdmap::RegionOverlapInfo& region_overlap_info(int index) const;
  ::jmc_auto::hdmap::RegionOverlapInfo* mutable_region_overlap_info(int index);
  ::jmc_auto::hdmap::RegionOverlapInfo* add_region_overlap_info();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::RegionOverlapInfo >*
      mutable_region_overlap_info();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::RegionOverlapInfo >&
      region_overlap_info() const;

  // optional .jmc_auto.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::jmc_auto::hdmap::Id& id() const;
  ::jmc_auto::hdmap::Id* mutable_id();
  ::jmc_auto::hdmap::Id* release_id();
  void set_allocated_id(::jmc_auto::hdmap::Id* id);

  // @@protoc_insertion_point(class_scope:jmc_auto.hdmap.Overlap)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::ObjectOverlapInfo > object_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::RegionOverlapInfo > region_overlap_info_;
  ::jmc_auto::hdmap::Id* id_;
  friend struct protobuf_modules_2fmap_2fproto_2fmap_5foverlap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LaneOverlapInfo

// optional double start_s = 1;
inline bool LaneOverlapInfo::has_start_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneOverlapInfo::set_has_start_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneOverlapInfo::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
inline double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.LaneOverlapInfo.start_s)
  return start_s_;
}
inline void LaneOverlapInfo::set_start_s(double value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.hdmap.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
inline bool LaneOverlapInfo::has_end_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneOverlapInfo::set_has_end_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneOverlapInfo::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
inline double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.LaneOverlapInfo.end_s)
  return end_s_;
}
inline void LaneOverlapInfo::set_end_s(double value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.hdmap.LaneOverlapInfo.end_s)
}

// optional bool is_merge = 3;
inline bool LaneOverlapInfo::has_is_merge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneOverlapInfo::set_has_is_merge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneOverlapInfo::clear_has_is_merge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneOverlapInfo::clear_is_merge() {
  is_merge_ = false;
  clear_has_is_merge();
}
inline bool LaneOverlapInfo::is_merge() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.LaneOverlapInfo.is_merge)
  return is_merge_;
}
inline void LaneOverlapInfo::set_is_merge(bool value) {
  set_has_is_merge();
  is_merge_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.hdmap.LaneOverlapInfo.is_merge)
}

// optional bool has_precedence = 4;
inline bool LaneOverlapInfo::has_has_precedence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneOverlapInfo::set_has_has_precedence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneOverlapInfo::clear_has_has_precedence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneOverlapInfo::clear_has_precedence() {
  has_precedence_ = false;
  clear_has_has_precedence();
}
inline bool LaneOverlapInfo::has_precedence() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.LaneOverlapInfo.has_precedence)
  return has_precedence_;
}
inline void LaneOverlapInfo::set_has_precedence(bool value) {
  set_has_has_precedence();
  has_precedence_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.hdmap.LaneOverlapInfo.has_precedence)
}

// optional .jmc_auto.hdmap.Id region_overlap_id = 5;
inline bool LaneOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneOverlapInfo::clear_region_overlap_id() {
  if (region_overlap_id_ != NULL) region_overlap_id_->::jmc_auto::hdmap::Id::Clear();
  clear_has_region_overlap_id();
}
inline const ::jmc_auto::hdmap::Id& LaneOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.LaneOverlapInfo.region_overlap_id)
  return region_overlap_id_ != NULL ? *region_overlap_id_
                         : *::jmc_auto::hdmap::Id::internal_default_instance();
}
inline ::jmc_auto::hdmap::Id* LaneOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    region_overlap_id_ = new ::jmc_auto::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.LaneOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline ::jmc_auto::hdmap::Id* LaneOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.LaneOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::jmc_auto::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline void LaneOverlapInfo::set_allocated_region_overlap_id(::jmc_auto::hdmap::Id* region_overlap_id) {
  delete region_overlap_id_;
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.LaneOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// SignalOverlapInfo

// -------------------------------------------------------------------

// StopSignOverlapInfo

// -------------------------------------------------------------------

// CrosswalkOverlapInfo

// optional .jmc_auto.hdmap.Id region_overlap_id = 1;
inline bool CrosswalkOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_region_overlap_id() {
  if (region_overlap_id_ != NULL) region_overlap_id_->::jmc_auto::hdmap::Id::Clear();
  clear_has_region_overlap_id();
}
inline const ::jmc_auto::hdmap::Id& CrosswalkOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return region_overlap_id_ != NULL ? *region_overlap_id_
                         : *::jmc_auto::hdmap::Id::internal_default_instance();
}
inline ::jmc_auto::hdmap::Id* CrosswalkOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    region_overlap_id_ = new ::jmc_auto::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline ::jmc_auto::hdmap::Id* CrosswalkOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::jmc_auto::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline void CrosswalkOverlapInfo::set_allocated_region_overlap_id(::jmc_auto::hdmap::Id* region_overlap_id) {
  delete region_overlap_id_;
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.CrosswalkOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// JunctionOverlapInfo

// -------------------------------------------------------------------

// YieldOverlapInfo

// -------------------------------------------------------------------

// ClearAreaOverlapInfo

// -------------------------------------------------------------------

// SpeedBumpOverlapInfo

// -------------------------------------------------------------------

// ParkingSpaceOverlapInfo

// -------------------------------------------------------------------

// ObjectOverlapInfo

// optional .jmc_auto.hdmap.Id id = 1;
inline bool ObjectOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectOverlapInfo::clear_id() {
  if (id_ != NULL) id_->::jmc_auto::hdmap::Id::Clear();
  clear_has_id();
}
inline const ::jmc_auto::hdmap::Id& ObjectOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.id)
  return id_ != NULL ? *id_
                         : *::jmc_auto::hdmap::Id::internal_default_instance();
}
inline ::jmc_auto::hdmap::Id* ObjectOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::jmc_auto::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.id)
  return id_;
}
inline ::jmc_auto::hdmap::Id* ObjectOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.id)
  clear_has_id();
  ::jmc_auto::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ObjectOverlapInfo::set_allocated_id(::jmc_auto::hdmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.id)
}

// optional .jmc_auto.hdmap.LaneOverlapInfo lane_overlap_info = 3;
inline bool ObjectOverlapInfo::has_lane_overlap_info() const {
  return overlap_info_case() == kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_lane_overlap_info() {
  _oneof_case_[0] = kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::clear_lane_overlap_info() {
  if (has_lane_overlap_info()) {
    delete overlap_info_.lane_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::LaneOverlapInfo& ObjectOverlapInfo::lane_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return has_lane_overlap_info()
      ? *overlap_info_.lane_overlap_info_
      : ::jmc_auto::hdmap::LaneOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::LaneOverlapInfo* ObjectOverlapInfo::mutable_lane_overlap_info() {
  if (!has_lane_overlap_info()) {
    clear_overlap_info();
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = new ::jmc_auto::hdmap::LaneOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return overlap_info_.lane_overlap_info_;
}
inline ::jmc_auto::hdmap::LaneOverlapInfo* ObjectOverlapInfo::release_lane_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.lane_overlap_info)
  if (has_lane_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::LaneOverlapInfo* temp = overlap_info_.lane_overlap_info_;
    overlap_info_.lane_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_lane_overlap_info(::jmc_auto::hdmap::LaneOverlapInfo* lane_overlap_info) {
  clear_overlap_info();
  if (lane_overlap_info) {
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = lane_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.lane_overlap_info)
}

// optional .jmc_auto.hdmap.SignalOverlapInfo signal_overlap_info = 4;
inline bool ObjectOverlapInfo::has_signal_overlap_info() const {
  return overlap_info_case() == kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_signal_overlap_info() {
  _oneof_case_[0] = kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::clear_signal_overlap_info() {
  if (has_signal_overlap_info()) {
    delete overlap_info_.signal_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::SignalOverlapInfo& ObjectOverlapInfo::signal_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return has_signal_overlap_info()
      ? *overlap_info_.signal_overlap_info_
      : ::jmc_auto::hdmap::SignalOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::SignalOverlapInfo* ObjectOverlapInfo::mutable_signal_overlap_info() {
  if (!has_signal_overlap_info()) {
    clear_overlap_info();
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = new ::jmc_auto::hdmap::SignalOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return overlap_info_.signal_overlap_info_;
}
inline ::jmc_auto::hdmap::SignalOverlapInfo* ObjectOverlapInfo::release_signal_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.signal_overlap_info)
  if (has_signal_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::SignalOverlapInfo* temp = overlap_info_.signal_overlap_info_;
    overlap_info_.signal_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_signal_overlap_info(::jmc_auto::hdmap::SignalOverlapInfo* signal_overlap_info) {
  clear_overlap_info();
  if (signal_overlap_info) {
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = signal_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.signal_overlap_info)
}

// optional .jmc_auto.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
inline bool ObjectOverlapInfo::has_stop_sign_overlap_info() const {
  return overlap_info_case() == kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_stop_sign_overlap_info() {
  _oneof_case_[0] = kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_stop_sign_overlap_info() {
  if (has_stop_sign_overlap_info()) {
    delete overlap_info_.stop_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::stop_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return has_stop_sign_overlap_info()
      ? *overlap_info_.stop_sign_overlap_info_
      : ::jmc_auto::hdmap::StopSignOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::mutable_stop_sign_overlap_info() {
  if (!has_stop_sign_overlap_info()) {
    clear_overlap_info();
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = new ::jmc_auto::hdmap::StopSignOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return overlap_info_.stop_sign_overlap_info_;
}
inline ::jmc_auto::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::release_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  if (has_stop_sign_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::StopSignOverlapInfo* temp = overlap_info_.stop_sign_overlap_info_;
    overlap_info_.stop_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_stop_sign_overlap_info(::jmc_auto::hdmap::StopSignOverlapInfo* stop_sign_overlap_info) {
  clear_overlap_info();
  if (stop_sign_overlap_info) {
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = stop_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
}

// optional .jmc_auto.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
inline bool ObjectOverlapInfo::has_crosswalk_overlap_info() const {
  return overlap_info_case() == kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_crosswalk_overlap_info() {
  _oneof_case_[0] = kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::clear_crosswalk_overlap_info() {
  if (has_crosswalk_overlap_info()) {
    delete overlap_info_.crosswalk_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::crosswalk_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return has_crosswalk_overlap_info()
      ? *overlap_info_.crosswalk_overlap_info_
      : ::jmc_auto::hdmap::CrosswalkOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::mutable_crosswalk_overlap_info() {
  if (!has_crosswalk_overlap_info()) {
    clear_overlap_info();
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = new ::jmc_auto::hdmap::CrosswalkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return overlap_info_.crosswalk_overlap_info_;
}
inline ::jmc_auto::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::release_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  if (has_crosswalk_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_overlap_info_;
    overlap_info_.crosswalk_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_crosswalk_overlap_info(::jmc_auto::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info) {
  clear_overlap_info();
  if (crosswalk_overlap_info) {
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = crosswalk_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
}

// optional .jmc_auto.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
inline bool ObjectOverlapInfo::has_junction_overlap_info() const {
  return overlap_info_case() == kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_junction_overlap_info() {
  _oneof_case_[0] = kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_junction_overlap_info() {
  if (has_junction_overlap_info()) {
    delete overlap_info_.junction_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return has_junction_overlap_info()
      ? *overlap_info_.junction_overlap_info_
      : ::jmc_auto::hdmap::JunctionOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::mutable_junction_overlap_info() {
  if (!has_junction_overlap_info()) {
    clear_overlap_info();
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = new ::jmc_auto::hdmap::JunctionOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return overlap_info_.junction_overlap_info_;
}
inline ::jmc_auto::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::release_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.junction_overlap_info)
  if (has_junction_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::JunctionOverlapInfo* temp = overlap_info_.junction_overlap_info_;
    overlap_info_.junction_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_junction_overlap_info(::jmc_auto::hdmap::JunctionOverlapInfo* junction_overlap_info) {
  clear_overlap_info();
  if (junction_overlap_info) {
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = junction_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.junction_overlap_info)
}

// optional .jmc_auto.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
inline bool ObjectOverlapInfo::has_yield_sign_overlap_info() const {
  return overlap_info_case() == kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_yield_sign_overlap_info() {
  _oneof_case_[0] = kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_yield_sign_overlap_info() {
  if (has_yield_sign_overlap_info()) {
    delete overlap_info_.yield_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::YieldOverlapInfo& ObjectOverlapInfo::yield_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return has_yield_sign_overlap_info()
      ? *overlap_info_.yield_sign_overlap_info_
      : ::jmc_auto::hdmap::YieldOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::YieldOverlapInfo* ObjectOverlapInfo::mutable_yield_sign_overlap_info() {
  if (!has_yield_sign_overlap_info()) {
    clear_overlap_info();
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = new ::jmc_auto::hdmap::YieldOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return overlap_info_.yield_sign_overlap_info_;
}
inline ::jmc_auto::hdmap::YieldOverlapInfo* ObjectOverlapInfo::release_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  if (has_yield_sign_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::YieldOverlapInfo* temp = overlap_info_.yield_sign_overlap_info_;
    overlap_info_.yield_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_yield_sign_overlap_info(::jmc_auto::hdmap::YieldOverlapInfo* yield_sign_overlap_info) {
  clear_overlap_info();
  if (yield_sign_overlap_info) {
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = yield_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
}

// optional .jmc_auto.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
inline bool ObjectOverlapInfo::has_clear_area_overlap_info() const {
  return overlap_info_case() == kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_clear_area_overlap_info() {
  _oneof_case_[0] = kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::clear_clear_area_overlap_info() {
  if (has_clear_area_overlap_info()) {
    delete overlap_info_.clear_area_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::clear_area_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return has_clear_area_overlap_info()
      ? *overlap_info_.clear_area_overlap_info_
      : ::jmc_auto::hdmap::ClearAreaOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::mutable_clear_area_overlap_info() {
  if (!has_clear_area_overlap_info()) {
    clear_overlap_info();
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = new ::jmc_auto::hdmap::ClearAreaOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return overlap_info_.clear_area_overlap_info_;
}
inline ::jmc_auto::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::release_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  if (has_clear_area_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::ClearAreaOverlapInfo* temp = overlap_info_.clear_area_overlap_info_;
    overlap_info_.clear_area_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_clear_area_overlap_info(::jmc_auto::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info) {
  clear_overlap_info();
  if (clear_area_overlap_info) {
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = clear_area_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
}

// optional .jmc_auto.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
inline bool ObjectOverlapInfo::has_speed_bump_overlap_info() const {
  return overlap_info_case() == kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_speed_bump_overlap_info() {
  _oneof_case_[0] = kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::clear_speed_bump_overlap_info() {
  if (has_speed_bump_overlap_info()) {
    delete overlap_info_.speed_bump_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::speed_bump_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return has_speed_bump_overlap_info()
      ? *overlap_info_.speed_bump_overlap_info_
      : ::jmc_auto::hdmap::SpeedBumpOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::mutable_speed_bump_overlap_info() {
  if (!has_speed_bump_overlap_info()) {
    clear_overlap_info();
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = new ::jmc_auto::hdmap::SpeedBumpOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return overlap_info_.speed_bump_overlap_info_;
}
inline ::jmc_auto::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::release_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  if (has_speed_bump_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::SpeedBumpOverlapInfo* temp = overlap_info_.speed_bump_overlap_info_;
    overlap_info_.speed_bump_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_speed_bump_overlap_info(::jmc_auto::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info) {
  clear_overlap_info();
  if (speed_bump_overlap_info) {
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = speed_bump_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
}

// optional .jmc_auto.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
inline bool ObjectOverlapInfo::has_parking_space_overlap_info() const {
  return overlap_info_case() == kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_parking_space_overlap_info() {
  _oneof_case_[0] = kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::clear_parking_space_overlap_info() {
  if (has_parking_space_overlap_info()) {
    delete overlap_info_.parking_space_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::jmc_auto::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::parking_space_overlap_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return has_parking_space_overlap_info()
      ? *overlap_info_.parking_space_overlap_info_
      : ::jmc_auto::hdmap::ParkingSpaceOverlapInfo::default_instance();
}
inline ::jmc_auto::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::mutable_parking_space_overlap_info() {
  if (!has_parking_space_overlap_info()) {
    clear_overlap_info();
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = new ::jmc_auto::hdmap::ParkingSpaceOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return overlap_info_.parking_space_overlap_info_;
}
inline ::jmc_auto::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::release_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  if (has_parking_space_overlap_info()) {
    clear_has_overlap_info();
    ::jmc_auto::hdmap::ParkingSpaceOverlapInfo* temp = overlap_info_.parking_space_overlap_info_;
    overlap_info_.parking_space_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_parking_space_overlap_info(::jmc_auto::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info) {
  clear_overlap_info();
  if (parking_space_overlap_info) {
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = parking_space_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
}

inline bool ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
inline void ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
inline ObjectOverlapInfo::OverlapInfoCase ObjectOverlapInfo::overlap_info_case() const {
  return ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegionOverlapInfo

// optional .jmc_auto.hdmap.Id region_overlap_id = 1;
inline bool RegionOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionOverlapInfo::clear_region_overlap_id() {
  if (region_overlap_id_ != NULL) region_overlap_id_->::jmc_auto::hdmap::Id::Clear();
  clear_has_region_overlap_id();
}
inline const ::jmc_auto::hdmap::Id& RegionOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.RegionOverlapInfo.region_overlap_id)
  return region_overlap_id_ != NULL ? *region_overlap_id_
                         : *::jmc_auto::hdmap::Id::internal_default_instance();
}
inline ::jmc_auto::hdmap::Id* RegionOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    region_overlap_id_ = new ::jmc_auto::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.RegionOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline ::jmc_auto::hdmap::Id* RegionOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.RegionOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::jmc_auto::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline void RegionOverlapInfo::set_allocated_region_overlap_id(::jmc_auto::hdmap::Id* region_overlap_id) {
  delete region_overlap_id_;
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.RegionOverlapInfo.region_overlap_id)
}

// repeated .jmc_auto.hdmap.Polygon polygon = 2;
inline int RegionOverlapInfo::polygon_size() const {
  return polygon_.size();
}
inline void RegionOverlapInfo::clear_polygon() {
  polygon_.Clear();
}
inline const ::jmc_auto::hdmap::Polygon& RegionOverlapInfo::polygon(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Get(index);
}
inline ::jmc_auto::hdmap::Polygon* RegionOverlapInfo::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Mutable(index);
}
inline ::jmc_auto::hdmap::Polygon* RegionOverlapInfo::add_polygon() {
  // @@protoc_insertion_point(field_add:jmc_auto.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::Polygon >*
RegionOverlapInfo::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.hdmap.RegionOverlapInfo.polygon)
  return &polygon_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::Polygon >&
RegionOverlapInfo::polygon() const {
  // @@protoc_insertion_point(field_list:jmc_auto.hdmap.RegionOverlapInfo.polygon)
  return polygon_;
}

// -------------------------------------------------------------------

// Overlap

// optional .jmc_auto.hdmap.Id id = 1;
inline bool Overlap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Overlap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Overlap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Overlap::clear_id() {
  if (id_ != NULL) id_->::jmc_auto::hdmap::Id::Clear();
  clear_has_id();
}
inline const ::jmc_auto::hdmap::Id& Overlap::id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.Overlap.id)
  return id_ != NULL ? *id_
                         : *::jmc_auto::hdmap::Id::internal_default_instance();
}
inline ::jmc_auto::hdmap::Id* Overlap::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::jmc_auto::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.Overlap.id)
  return id_;
}
inline ::jmc_auto::hdmap::Id* Overlap::release_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.hdmap.Overlap.id)
  clear_has_id();
  ::jmc_auto::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Overlap::set_allocated_id(::jmc_auto::hdmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.hdmap.Overlap.id)
}

// repeated .jmc_auto.hdmap.ObjectOverlapInfo object = 2;
inline int Overlap::object_size() const {
  return object_.size();
}
inline void Overlap::clear_object() {
  object_.Clear();
}
inline const ::jmc_auto::hdmap::ObjectOverlapInfo& Overlap::object(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.Overlap.object)
  return object_.Get(index);
}
inline ::jmc_auto::hdmap::ObjectOverlapInfo* Overlap::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.Overlap.object)
  return object_.Mutable(index);
}
inline ::jmc_auto::hdmap::ObjectOverlapInfo* Overlap::add_object() {
  // @@protoc_insertion_point(field_add:jmc_auto.hdmap.Overlap.object)
  return object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::ObjectOverlapInfo >*
Overlap::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.hdmap.Overlap.object)
  return &object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::ObjectOverlapInfo >&
Overlap::object() const {
  // @@protoc_insertion_point(field_list:jmc_auto.hdmap.Overlap.object)
  return object_;
}

// repeated .jmc_auto.hdmap.RegionOverlapInfo region_overlap_info = 3;
inline int Overlap::region_overlap_info_size() const {
  return region_overlap_info_.size();
}
inline void Overlap::clear_region_overlap_info() {
  region_overlap_info_.Clear();
}
inline const ::jmc_auto::hdmap::RegionOverlapInfo& Overlap::region_overlap_info(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.hdmap.Overlap.region_overlap_info)
  return region_overlap_info_.Get(index);
}
inline ::jmc_auto::hdmap::RegionOverlapInfo* Overlap::mutable_region_overlap_info(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.hdmap.Overlap.region_overlap_info)
  return region_overlap_info_.Mutable(index);
}
inline ::jmc_auto::hdmap::RegionOverlapInfo* Overlap::add_region_overlap_info() {
  // @@protoc_insertion_point(field_add:jmc_auto.hdmap.Overlap.region_overlap_info)
  return region_overlap_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::RegionOverlapInfo >*
Overlap::mutable_region_overlap_info() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.hdmap.Overlap.region_overlap_info)
  return &region_overlap_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::hdmap::RegionOverlapInfo >&
Overlap::region_overlap_info() const {
  // @@protoc_insertion_point(field_list:jmc_auto.hdmap.Overlap.region_overlap_info)
  return region_overlap_info_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace hdmap
}  // namespace jmc_auto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fmap_2fproto_2fmap_5foverlap_2eproto__INCLUDED
