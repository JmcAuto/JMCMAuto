// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/open_space_roi_decider_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "modules/planning/proto/open_space_roi_decider_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace jmc_auto {
namespace planning {
class OpenSpaceRoiDeciderConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<OpenSpaceRoiDeciderConfig> {
} _OpenSpaceRoiDeciderConfig_default_instance_;

namespace protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[1];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[1];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, roi_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, roi_longitudinal_range_start_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, roi_longitudinal_range_end_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, parking_start_range_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, parking_inwards_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, enable_perception_obstacles_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, parking_depth_buffer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, roi_line_segment_min_angle_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, roi_line_segment_length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, roi_line_segment_length_from_map_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, perception_obstacle_filtering_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, perception_obstacle_buffer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, curb_heading_tangent_change_upper_limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceRoiDeciderConfig, end_pose_s_distance_),
  0,
  4,
  5,
  6,
  1,
  2,
  7,
  8,
  9,
  10,
  11,
  3,
  12,
  13,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 19, sizeof(OpenSpaceRoiDeciderConfig)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_OpenSpaceRoiDeciderConfig_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "modules/planning/proto/open_space_roi_decider_config.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 1);
}

}  // namespace

void TableStruct::Shutdown() {
  _OpenSpaceRoiDeciderConfig_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _OpenSpaceRoiDeciderConfig_default_instance_.DefaultConstruct();
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n:modules/planning/proto/open_space_roi_"
      "decider_config.proto\022\021jmc_auto.planning\""
      "\312\005\n\031OpenSpaceRoiDeciderConfig\022F\n\010roi_typ"
      "e\030\001 \001(\01624.jmc_auto.planning.OpenSpaceRoi"
      "DeciderConfig.RoiType\022(\n\034roi_longitudina"
      "l_range_start\030\002 \001(\001:\00210\022&\n\032roi_longitudi"
      "nal_range_end\030\003 \001(\001:\00210\022\036\n\023parking_start"
      "_range\030\004 \001(\001:\0017\022\036\n\017parking_inwards\030\005 \001(\010"
      ":\005false\022#\n\033enable_perception_obstacles\030\006"
      " \001(\010\022!\n\024parking_depth_buffer\030\007 \001(\001:\0030.1\022"
      "\'\n\032roi_line_segment_min_angle\030\010 \001(\001:\0030.3"
      "\022\"\n\027roi_line_segment_length\030\t \001(\001:\0011\022,\n "
      "roi_line_segment_length_from_map\030\n \001(\001:\002"
      "10\0224\n&perception_obstacle_filtering_dist"
      "ance\030\013 \001(\001:\0041000\022\"\n\032perception_obstacle_"
      "buffer\030\014 \001(\001\0222\n\'curb_heading_tangent_cha"
      "nge_upper_limit\030\r \001(\001:\0011\022\037\n\023end_pose_s_d"
      "istance\030\016 \001(\001:\00210\"a\n\007RoiType\022\017\n\013NOT_DEFI"
      "NED\020\000\022\013\n\007PARKING\020\001\022\r\n\tPULL_OVER\020\002\022\017\n\013PAR"
      "K_AND_GO\020\003\022\030\n\024NARROW_STREET_U_TURN\020\004"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 796);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "modules/planning/proto/open_space_roi_decider_config.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto

const ::google::protobuf::EnumDescriptor* OpenSpaceRoiDeciderConfig_RoiType_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::file_level_enum_descriptors[0];
}
bool OpenSpaceRoiDeciderConfig_RoiType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::NOT_DEFINED;
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::PARKING;
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::PULL_OVER;
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::PARK_AND_GO;
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::NARROW_STREET_U_TURN;
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::RoiType_MIN;
const OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::RoiType_MAX;
const int OpenSpaceRoiDeciderConfig::RoiType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OpenSpaceRoiDeciderConfig::kRoiTypeFieldNumber;
const int OpenSpaceRoiDeciderConfig::kRoiLongitudinalRangeStartFieldNumber;
const int OpenSpaceRoiDeciderConfig::kRoiLongitudinalRangeEndFieldNumber;
const int OpenSpaceRoiDeciderConfig::kParkingStartRangeFieldNumber;
const int OpenSpaceRoiDeciderConfig::kParkingInwardsFieldNumber;
const int OpenSpaceRoiDeciderConfig::kEnablePerceptionObstaclesFieldNumber;
const int OpenSpaceRoiDeciderConfig::kParkingDepthBufferFieldNumber;
const int OpenSpaceRoiDeciderConfig::kRoiLineSegmentMinAngleFieldNumber;
const int OpenSpaceRoiDeciderConfig::kRoiLineSegmentLengthFieldNumber;
const int OpenSpaceRoiDeciderConfig::kRoiLineSegmentLengthFromMapFieldNumber;
const int OpenSpaceRoiDeciderConfig::kPerceptionObstacleFilteringDistanceFieldNumber;
const int OpenSpaceRoiDeciderConfig::kPerceptionObstacleBufferFieldNumber;
const int OpenSpaceRoiDeciderConfig::kCurbHeadingTangentChangeUpperLimitFieldNumber;
const int OpenSpaceRoiDeciderConfig::kEndPoseSDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OpenSpaceRoiDeciderConfig::OpenSpaceRoiDeciderConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
}
OpenSpaceRoiDeciderConfig::OpenSpaceRoiDeciderConfig(const OpenSpaceRoiDeciderConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&roi_type_, &from.roi_type_,
    reinterpret_cast<char*>(&end_pose_s_distance_) -
    reinterpret_cast<char*>(&roi_type_) + sizeof(end_pose_s_distance_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
}

void OpenSpaceRoiDeciderConfig::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&roi_type_, 0, reinterpret_cast<char*>(&perception_obstacle_buffer_) -
    reinterpret_cast<char*>(&roi_type_) + sizeof(perception_obstacle_buffer_));
  roi_longitudinal_range_start_ = 10;
  roi_longitudinal_range_end_ = 10;
  parking_start_range_ = 7;
  parking_depth_buffer_ = 0.1;
  roi_line_segment_min_angle_ = 0.3;
  roi_line_segment_length_ = 1;
  roi_line_segment_length_from_map_ = 10;
  perception_obstacle_filtering_distance_ = 1000;
  curb_heading_tangent_change_upper_limit_ = 1;
  end_pose_s_distance_ = 10;
}

OpenSpaceRoiDeciderConfig::~OpenSpaceRoiDeciderConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  SharedDtor();
}

void OpenSpaceRoiDeciderConfig::SharedDtor() {
}

void OpenSpaceRoiDeciderConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpenSpaceRoiDeciderConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const OpenSpaceRoiDeciderConfig& OpenSpaceRoiDeciderConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

OpenSpaceRoiDeciderConfig* OpenSpaceRoiDeciderConfig::New(::google::protobuf::Arena* arena) const {
  OpenSpaceRoiDeciderConfig* n = new OpenSpaceRoiDeciderConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpenSpaceRoiDeciderConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  if (_has_bits_[0 / 32] & 255u) {
    ::memset(&roi_type_, 0, reinterpret_cast<char*>(&perception_obstacle_buffer_) -
      reinterpret_cast<char*>(&roi_type_) + sizeof(perception_obstacle_buffer_));
    roi_longitudinal_range_start_ = 10;
    roi_longitudinal_range_end_ = 10;
    parking_start_range_ = 7;
    parking_depth_buffer_ = 0.1;
  }
  if (_has_bits_[8 / 32] & 16128u) {
    roi_line_segment_min_angle_ = 0.3;
    roi_line_segment_length_ = 1;
    roi_line_segment_length_from_map_ = 10;
    perception_obstacle_filtering_distance_ = 1000;
    curb_heading_tangent_change_upper_limit_ = 1;
    end_pose_s_distance_ = 10;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OpenSpaceRoiDeciderConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig.RoiType roi_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::OpenSpaceRoiDeciderConfig_RoiType_IsValid(value)) {
            set_roi_type(static_cast< ::jmc_auto::planning::OpenSpaceRoiDeciderConfig_RoiType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double roi_longitudinal_range_start = 2 [default = 10];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_roi_longitudinal_range_start();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roi_longitudinal_range_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double roi_longitudinal_range_end = 3 [default = 10];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_roi_longitudinal_range_end();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roi_longitudinal_range_end_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double parking_start_range = 4 [default = 7];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_parking_start_range();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &parking_start_range_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool parking_inwards = 5 [default = false];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_parking_inwards();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &parking_inwards_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_perception_obstacles = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_enable_perception_obstacles();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_perception_obstacles_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double parking_depth_buffer = 7 [default = 0.1];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(57u)) {
          set_has_parking_depth_buffer();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &parking_depth_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double roi_line_segment_min_angle = 8 [default = 0.3];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(65u)) {
          set_has_roi_line_segment_min_angle();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roi_line_segment_min_angle_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double roi_line_segment_length = 9 [default = 1];
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(73u)) {
          set_has_roi_line_segment_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roi_line_segment_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double roi_line_segment_length_from_map = 10 [default = 10];
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(81u)) {
          set_has_roi_line_segment_length_from_map();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &roi_line_segment_length_from_map_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double perception_obstacle_filtering_distance = 11 [default = 1000];
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(89u)) {
          set_has_perception_obstacle_filtering_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &perception_obstacle_filtering_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double perception_obstacle_buffer = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(97u)) {
          set_has_perception_obstacle_buffer();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &perception_obstacle_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double curb_heading_tangent_change_upper_limit = 13 [default = 1];
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(105u)) {
          set_has_curb_heading_tangent_change_upper_limit();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &curb_heading_tangent_change_upper_limit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double end_pose_s_distance = 14 [default = 10];
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(113u)) {
          set_has_end_pose_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &end_pose_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  return false;
#undef DO_
}

void OpenSpaceRoiDeciderConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig.RoiType roi_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->roi_type(), output);
  }

  // optional double roi_longitudinal_range_start = 2 [default = 10];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->roi_longitudinal_range_start(), output);
  }

  // optional double roi_longitudinal_range_end = 3 [default = 10];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->roi_longitudinal_range_end(), output);
  }

  // optional double parking_start_range = 4 [default = 7];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->parking_start_range(), output);
  }

  // optional bool parking_inwards = 5 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->parking_inwards(), output);
  }

  // optional bool enable_perception_obstacles = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->enable_perception_obstacles(), output);
  }

  // optional double parking_depth_buffer = 7 [default = 0.1];
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->parking_depth_buffer(), output);
  }

  // optional double roi_line_segment_min_angle = 8 [default = 0.3];
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->roi_line_segment_min_angle(), output);
  }

  // optional double roi_line_segment_length = 9 [default = 1];
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->roi_line_segment_length(), output);
  }

  // optional double roi_line_segment_length_from_map = 10 [default = 10];
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->roi_line_segment_length_from_map(), output);
  }

  // optional double perception_obstacle_filtering_distance = 11 [default = 1000];
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->perception_obstacle_filtering_distance(), output);
  }

  // optional double perception_obstacle_buffer = 12;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->perception_obstacle_buffer(), output);
  }

  // optional double curb_heading_tangent_change_upper_limit = 13 [default = 1];
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->curb_heading_tangent_change_upper_limit(), output);
  }

  // optional double end_pose_s_distance = 14 [default = 10];
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->end_pose_s_distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
}

::google::protobuf::uint8* OpenSpaceRoiDeciderConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig.RoiType roi_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->roi_type(), target);
  }

  // optional double roi_longitudinal_range_start = 2 [default = 10];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->roi_longitudinal_range_start(), target);
  }

  // optional double roi_longitudinal_range_end = 3 [default = 10];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->roi_longitudinal_range_end(), target);
  }

  // optional double parking_start_range = 4 [default = 7];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->parking_start_range(), target);
  }

  // optional bool parking_inwards = 5 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->parking_inwards(), target);
  }

  // optional bool enable_perception_obstacles = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->enable_perception_obstacles(), target);
  }

  // optional double parking_depth_buffer = 7 [default = 0.1];
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->parking_depth_buffer(), target);
  }

  // optional double roi_line_segment_min_angle = 8 [default = 0.3];
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->roi_line_segment_min_angle(), target);
  }

  // optional double roi_line_segment_length = 9 [default = 1];
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->roi_line_segment_length(), target);
  }

  // optional double roi_line_segment_length_from_map = 10 [default = 10];
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->roi_line_segment_length_from_map(), target);
  }

  // optional double perception_obstacle_filtering_distance = 11 [default = 1000];
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->perception_obstacle_filtering_distance(), target);
  }

  // optional double perception_obstacle_buffer = 12;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->perception_obstacle_buffer(), target);
  }

  // optional double curb_heading_tangent_change_upper_limit = 13 [default = 1];
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->curb_heading_tangent_change_upper_limit(), target);
  }

  // optional double end_pose_s_distance = 14 [default = 10];
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->end_pose_s_distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  return target;
}

size_t OpenSpaceRoiDeciderConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig.RoiType roi_type = 1;
    if (has_roi_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->roi_type());
    }

    // optional bool parking_inwards = 5 [default = false];
    if (has_parking_inwards()) {
      total_size += 1 + 1;
    }

    // optional bool enable_perception_obstacles = 6;
    if (has_enable_perception_obstacles()) {
      total_size += 1 + 1;
    }

    // optional double perception_obstacle_buffer = 12;
    if (has_perception_obstacle_buffer()) {
      total_size += 1 + 8;
    }

    // optional double roi_longitudinal_range_start = 2 [default = 10];
    if (has_roi_longitudinal_range_start()) {
      total_size += 1 + 8;
    }

    // optional double roi_longitudinal_range_end = 3 [default = 10];
    if (has_roi_longitudinal_range_end()) {
      total_size += 1 + 8;
    }

    // optional double parking_start_range = 4 [default = 7];
    if (has_parking_start_range()) {
      total_size += 1 + 8;
    }

    // optional double parking_depth_buffer = 7 [default = 0.1];
    if (has_parking_depth_buffer()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & 16128u) {
    // optional double roi_line_segment_min_angle = 8 [default = 0.3];
    if (has_roi_line_segment_min_angle()) {
      total_size += 1 + 8;
    }

    // optional double roi_line_segment_length = 9 [default = 1];
    if (has_roi_line_segment_length()) {
      total_size += 1 + 8;
    }

    // optional double roi_line_segment_length_from_map = 10 [default = 10];
    if (has_roi_line_segment_length_from_map()) {
      total_size += 1 + 8;
    }

    // optional double perception_obstacle_filtering_distance = 11 [default = 1000];
    if (has_perception_obstacle_filtering_distance()) {
      total_size += 1 + 8;
    }

    // optional double curb_heading_tangent_change_upper_limit = 13 [default = 1];
    if (has_curb_heading_tangent_change_upper_limit()) {
      total_size += 1 + 8;
    }

    // optional double end_pose_s_distance = 14 [default = 10];
    if (has_end_pose_s_distance()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenSpaceRoiDeciderConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const OpenSpaceRoiDeciderConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const OpenSpaceRoiDeciderConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
    MergeFrom(*source);
  }
}

void OpenSpaceRoiDeciderConfig::MergeFrom(const OpenSpaceRoiDeciderConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      roi_type_ = from.roi_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      parking_inwards_ = from.parking_inwards_;
    }
    if (cached_has_bits & 0x00000004u) {
      enable_perception_obstacles_ = from.enable_perception_obstacles_;
    }
    if (cached_has_bits & 0x00000008u) {
      perception_obstacle_buffer_ = from.perception_obstacle_buffer_;
    }
    if (cached_has_bits & 0x00000010u) {
      roi_longitudinal_range_start_ = from.roi_longitudinal_range_start_;
    }
    if (cached_has_bits & 0x00000020u) {
      roi_longitudinal_range_end_ = from.roi_longitudinal_range_end_;
    }
    if (cached_has_bits & 0x00000040u) {
      parking_start_range_ = from.parking_start_range_;
    }
    if (cached_has_bits & 0x00000080u) {
      parking_depth_buffer_ = from.parking_depth_buffer_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 16128u) {
    if (cached_has_bits & 0x00000100u) {
      roi_line_segment_min_angle_ = from.roi_line_segment_min_angle_;
    }
    if (cached_has_bits & 0x00000200u) {
      roi_line_segment_length_ = from.roi_line_segment_length_;
    }
    if (cached_has_bits & 0x00000400u) {
      roi_line_segment_length_from_map_ = from.roi_line_segment_length_from_map_;
    }
    if (cached_has_bits & 0x00000800u) {
      perception_obstacle_filtering_distance_ = from.perception_obstacle_filtering_distance_;
    }
    if (cached_has_bits & 0x00001000u) {
      curb_heading_tangent_change_upper_limit_ = from.curb_heading_tangent_change_upper_limit_;
    }
    if (cached_has_bits & 0x00002000u) {
      end_pose_s_distance_ = from.end_pose_s_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void OpenSpaceRoiDeciderConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpenSpaceRoiDeciderConfig::CopyFrom(const OpenSpaceRoiDeciderConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.OpenSpaceRoiDeciderConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenSpaceRoiDeciderConfig::IsInitialized() const {
  return true;
}

void OpenSpaceRoiDeciderConfig::Swap(OpenSpaceRoiDeciderConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpenSpaceRoiDeciderConfig::InternalSwap(OpenSpaceRoiDeciderConfig* other) {
  std::swap(roi_type_, other->roi_type_);
  std::swap(parking_inwards_, other->parking_inwards_);
  std::swap(enable_perception_obstacles_, other->enable_perception_obstacles_);
  std::swap(perception_obstacle_buffer_, other->perception_obstacle_buffer_);
  std::swap(roi_longitudinal_range_start_, other->roi_longitudinal_range_start_);
  std::swap(roi_longitudinal_range_end_, other->roi_longitudinal_range_end_);
  std::swap(parking_start_range_, other->parking_start_range_);
  std::swap(parking_depth_buffer_, other->parking_depth_buffer_);
  std::swap(roi_line_segment_min_angle_, other->roi_line_segment_min_angle_);
  std::swap(roi_line_segment_length_, other->roi_line_segment_length_);
  std::swap(roi_line_segment_length_from_map_, other->roi_line_segment_length_from_map_);
  std::swap(perception_obstacle_filtering_distance_, other->perception_obstacle_filtering_distance_);
  std::swap(curb_heading_tangent_change_upper_limit_, other->curb_heading_tangent_change_upper_limit_);
  std::swap(end_pose_s_distance_, other->end_pose_s_distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OpenSpaceRoiDeciderConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpenSpaceRoiDeciderConfig

// optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig.RoiType roi_type = 1;
bool OpenSpaceRoiDeciderConfig::has_roi_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_roi_type() {
  _has_bits_[0] |= 0x00000001u;
}
void OpenSpaceRoiDeciderConfig::clear_has_roi_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void OpenSpaceRoiDeciderConfig::clear_roi_type() {
  roi_type_ = 0;
  clear_has_roi_type();
}
::jmc_auto::planning::OpenSpaceRoiDeciderConfig_RoiType OpenSpaceRoiDeciderConfig::roi_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_type)
  return static_cast< ::jmc_auto::planning::OpenSpaceRoiDeciderConfig_RoiType >(roi_type_);
}
void OpenSpaceRoiDeciderConfig::set_roi_type(::jmc_auto::planning::OpenSpaceRoiDeciderConfig_RoiType value) {
  assert(::jmc_auto::planning::OpenSpaceRoiDeciderConfig_RoiType_IsValid(value));
  set_has_roi_type();
  roi_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_type)
}

// optional double roi_longitudinal_range_start = 2 [default = 10];
bool OpenSpaceRoiDeciderConfig::has_roi_longitudinal_range_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_roi_longitudinal_range_start() {
  _has_bits_[0] |= 0x00000010u;
}
void OpenSpaceRoiDeciderConfig::clear_has_roi_longitudinal_range_start() {
  _has_bits_[0] &= ~0x00000010u;
}
void OpenSpaceRoiDeciderConfig::clear_roi_longitudinal_range_start() {
  roi_longitudinal_range_start_ = 10;
  clear_has_roi_longitudinal_range_start();
}
double OpenSpaceRoiDeciderConfig::roi_longitudinal_range_start() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_longitudinal_range_start)
  return roi_longitudinal_range_start_;
}
void OpenSpaceRoiDeciderConfig::set_roi_longitudinal_range_start(double value) {
  set_has_roi_longitudinal_range_start();
  roi_longitudinal_range_start_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_longitudinal_range_start)
}

// optional double roi_longitudinal_range_end = 3 [default = 10];
bool OpenSpaceRoiDeciderConfig::has_roi_longitudinal_range_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_roi_longitudinal_range_end() {
  _has_bits_[0] |= 0x00000020u;
}
void OpenSpaceRoiDeciderConfig::clear_has_roi_longitudinal_range_end() {
  _has_bits_[0] &= ~0x00000020u;
}
void OpenSpaceRoiDeciderConfig::clear_roi_longitudinal_range_end() {
  roi_longitudinal_range_end_ = 10;
  clear_has_roi_longitudinal_range_end();
}
double OpenSpaceRoiDeciderConfig::roi_longitudinal_range_end() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_longitudinal_range_end)
  return roi_longitudinal_range_end_;
}
void OpenSpaceRoiDeciderConfig::set_roi_longitudinal_range_end(double value) {
  set_has_roi_longitudinal_range_end();
  roi_longitudinal_range_end_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_longitudinal_range_end)
}

// optional double parking_start_range = 4 [default = 7];
bool OpenSpaceRoiDeciderConfig::has_parking_start_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_parking_start_range() {
  _has_bits_[0] |= 0x00000040u;
}
void OpenSpaceRoiDeciderConfig::clear_has_parking_start_range() {
  _has_bits_[0] &= ~0x00000040u;
}
void OpenSpaceRoiDeciderConfig::clear_parking_start_range() {
  parking_start_range_ = 7;
  clear_has_parking_start_range();
}
double OpenSpaceRoiDeciderConfig::parking_start_range() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.parking_start_range)
  return parking_start_range_;
}
void OpenSpaceRoiDeciderConfig::set_parking_start_range(double value) {
  set_has_parking_start_range();
  parking_start_range_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.parking_start_range)
}

// optional bool parking_inwards = 5 [default = false];
bool OpenSpaceRoiDeciderConfig::has_parking_inwards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_parking_inwards() {
  _has_bits_[0] |= 0x00000002u;
}
void OpenSpaceRoiDeciderConfig::clear_has_parking_inwards() {
  _has_bits_[0] &= ~0x00000002u;
}
void OpenSpaceRoiDeciderConfig::clear_parking_inwards() {
  parking_inwards_ = false;
  clear_has_parking_inwards();
}
bool OpenSpaceRoiDeciderConfig::parking_inwards() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.parking_inwards)
  return parking_inwards_;
}
void OpenSpaceRoiDeciderConfig::set_parking_inwards(bool value) {
  set_has_parking_inwards();
  parking_inwards_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.parking_inwards)
}

// optional bool enable_perception_obstacles = 6;
bool OpenSpaceRoiDeciderConfig::has_enable_perception_obstacles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_enable_perception_obstacles() {
  _has_bits_[0] |= 0x00000004u;
}
void OpenSpaceRoiDeciderConfig::clear_has_enable_perception_obstacles() {
  _has_bits_[0] &= ~0x00000004u;
}
void OpenSpaceRoiDeciderConfig::clear_enable_perception_obstacles() {
  enable_perception_obstacles_ = false;
  clear_has_enable_perception_obstacles();
}
bool OpenSpaceRoiDeciderConfig::enable_perception_obstacles() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.enable_perception_obstacles)
  return enable_perception_obstacles_;
}
void OpenSpaceRoiDeciderConfig::set_enable_perception_obstacles(bool value) {
  set_has_enable_perception_obstacles();
  enable_perception_obstacles_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.enable_perception_obstacles)
}

// optional double parking_depth_buffer = 7 [default = 0.1];
bool OpenSpaceRoiDeciderConfig::has_parking_depth_buffer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_parking_depth_buffer() {
  _has_bits_[0] |= 0x00000080u;
}
void OpenSpaceRoiDeciderConfig::clear_has_parking_depth_buffer() {
  _has_bits_[0] &= ~0x00000080u;
}
void OpenSpaceRoiDeciderConfig::clear_parking_depth_buffer() {
  parking_depth_buffer_ = 0.1;
  clear_has_parking_depth_buffer();
}
double OpenSpaceRoiDeciderConfig::parking_depth_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.parking_depth_buffer)
  return parking_depth_buffer_;
}
void OpenSpaceRoiDeciderConfig::set_parking_depth_buffer(double value) {
  set_has_parking_depth_buffer();
  parking_depth_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.parking_depth_buffer)
}

// optional double roi_line_segment_min_angle = 8 [default = 0.3];
bool OpenSpaceRoiDeciderConfig::has_roi_line_segment_min_angle() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_roi_line_segment_min_angle() {
  _has_bits_[0] |= 0x00000100u;
}
void OpenSpaceRoiDeciderConfig::clear_has_roi_line_segment_min_angle() {
  _has_bits_[0] &= ~0x00000100u;
}
void OpenSpaceRoiDeciderConfig::clear_roi_line_segment_min_angle() {
  roi_line_segment_min_angle_ = 0.3;
  clear_has_roi_line_segment_min_angle();
}
double OpenSpaceRoiDeciderConfig::roi_line_segment_min_angle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_line_segment_min_angle)
  return roi_line_segment_min_angle_;
}
void OpenSpaceRoiDeciderConfig::set_roi_line_segment_min_angle(double value) {
  set_has_roi_line_segment_min_angle();
  roi_line_segment_min_angle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_line_segment_min_angle)
}

// optional double roi_line_segment_length = 9 [default = 1];
bool OpenSpaceRoiDeciderConfig::has_roi_line_segment_length() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_roi_line_segment_length() {
  _has_bits_[0] |= 0x00000200u;
}
void OpenSpaceRoiDeciderConfig::clear_has_roi_line_segment_length() {
  _has_bits_[0] &= ~0x00000200u;
}
void OpenSpaceRoiDeciderConfig::clear_roi_line_segment_length() {
  roi_line_segment_length_ = 1;
  clear_has_roi_line_segment_length();
}
double OpenSpaceRoiDeciderConfig::roi_line_segment_length() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_line_segment_length)
  return roi_line_segment_length_;
}
void OpenSpaceRoiDeciderConfig::set_roi_line_segment_length(double value) {
  set_has_roi_line_segment_length();
  roi_line_segment_length_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_line_segment_length)
}

// optional double roi_line_segment_length_from_map = 10 [default = 10];
bool OpenSpaceRoiDeciderConfig::has_roi_line_segment_length_from_map() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_roi_line_segment_length_from_map() {
  _has_bits_[0] |= 0x00000400u;
}
void OpenSpaceRoiDeciderConfig::clear_has_roi_line_segment_length_from_map() {
  _has_bits_[0] &= ~0x00000400u;
}
void OpenSpaceRoiDeciderConfig::clear_roi_line_segment_length_from_map() {
  roi_line_segment_length_from_map_ = 10;
  clear_has_roi_line_segment_length_from_map();
}
double OpenSpaceRoiDeciderConfig::roi_line_segment_length_from_map() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_line_segment_length_from_map)
  return roi_line_segment_length_from_map_;
}
void OpenSpaceRoiDeciderConfig::set_roi_line_segment_length_from_map(double value) {
  set_has_roi_line_segment_length_from_map();
  roi_line_segment_length_from_map_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.roi_line_segment_length_from_map)
}

// optional double perception_obstacle_filtering_distance = 11 [default = 1000];
bool OpenSpaceRoiDeciderConfig::has_perception_obstacle_filtering_distance() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_perception_obstacle_filtering_distance() {
  _has_bits_[0] |= 0x00000800u;
}
void OpenSpaceRoiDeciderConfig::clear_has_perception_obstacle_filtering_distance() {
  _has_bits_[0] &= ~0x00000800u;
}
void OpenSpaceRoiDeciderConfig::clear_perception_obstacle_filtering_distance() {
  perception_obstacle_filtering_distance_ = 1000;
  clear_has_perception_obstacle_filtering_distance();
}
double OpenSpaceRoiDeciderConfig::perception_obstacle_filtering_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.perception_obstacle_filtering_distance)
  return perception_obstacle_filtering_distance_;
}
void OpenSpaceRoiDeciderConfig::set_perception_obstacle_filtering_distance(double value) {
  set_has_perception_obstacle_filtering_distance();
  perception_obstacle_filtering_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.perception_obstacle_filtering_distance)
}

// optional double perception_obstacle_buffer = 12;
bool OpenSpaceRoiDeciderConfig::has_perception_obstacle_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_perception_obstacle_buffer() {
  _has_bits_[0] |= 0x00000008u;
}
void OpenSpaceRoiDeciderConfig::clear_has_perception_obstacle_buffer() {
  _has_bits_[0] &= ~0x00000008u;
}
void OpenSpaceRoiDeciderConfig::clear_perception_obstacle_buffer() {
  perception_obstacle_buffer_ = 0;
  clear_has_perception_obstacle_buffer();
}
double OpenSpaceRoiDeciderConfig::perception_obstacle_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.perception_obstacle_buffer)
  return perception_obstacle_buffer_;
}
void OpenSpaceRoiDeciderConfig::set_perception_obstacle_buffer(double value) {
  set_has_perception_obstacle_buffer();
  perception_obstacle_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.perception_obstacle_buffer)
}

// optional double curb_heading_tangent_change_upper_limit = 13 [default = 1];
bool OpenSpaceRoiDeciderConfig::has_curb_heading_tangent_change_upper_limit() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_curb_heading_tangent_change_upper_limit() {
  _has_bits_[0] |= 0x00001000u;
}
void OpenSpaceRoiDeciderConfig::clear_has_curb_heading_tangent_change_upper_limit() {
  _has_bits_[0] &= ~0x00001000u;
}
void OpenSpaceRoiDeciderConfig::clear_curb_heading_tangent_change_upper_limit() {
  curb_heading_tangent_change_upper_limit_ = 1;
  clear_has_curb_heading_tangent_change_upper_limit();
}
double OpenSpaceRoiDeciderConfig::curb_heading_tangent_change_upper_limit() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.curb_heading_tangent_change_upper_limit)
  return curb_heading_tangent_change_upper_limit_;
}
void OpenSpaceRoiDeciderConfig::set_curb_heading_tangent_change_upper_limit(double value) {
  set_has_curb_heading_tangent_change_upper_limit();
  curb_heading_tangent_change_upper_limit_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.curb_heading_tangent_change_upper_limit)
}

// optional double end_pose_s_distance = 14 [default = 10];
bool OpenSpaceRoiDeciderConfig::has_end_pose_s_distance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void OpenSpaceRoiDeciderConfig::set_has_end_pose_s_distance() {
  _has_bits_[0] |= 0x00002000u;
}
void OpenSpaceRoiDeciderConfig::clear_has_end_pose_s_distance() {
  _has_bits_[0] &= ~0x00002000u;
}
void OpenSpaceRoiDeciderConfig::clear_end_pose_s_distance() {
  end_pose_s_distance_ = 10;
  clear_has_end_pose_s_distance();
}
double OpenSpaceRoiDeciderConfig::end_pose_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceRoiDeciderConfig.end_pose_s_distance)
  return end_pose_s_distance_;
}
void OpenSpaceRoiDeciderConfig::set_end_pose_s_distance(double value) {
  set_has_end_pose_s_distance();
  end_pose_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceRoiDeciderConfig.end_pose_s_distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace jmc_auto

// @@protoc_insertion_point(global_scope)
