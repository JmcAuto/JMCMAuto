// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_status.proto

#ifndef PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto__INCLUDED
#define PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common/proto/geometry.pb.h"
#include "modules/planning/proto/planning_config.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace common {
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class PointLLH;
class PointLLHDefaultTypeInternal;
extern PointLLHDefaultTypeInternal _PointLLH_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
}  // namespace common
namespace planning {
class BareIntersectionStatus;
class BareIntersectionStatusDefaultTypeInternal;
extern BareIntersectionStatusDefaultTypeInternal _BareIntersectionStatus_default_instance_;
class ChangeLaneStatus;
class ChangeLaneStatusDefaultTypeInternal;
extern ChangeLaneStatusDefaultTypeInternal _ChangeLaneStatus_default_instance_;
class CrosswalkStatus;
class CrosswalkStatusDefaultTypeInternal;
extern CrosswalkStatusDefaultTypeInternal _CrosswalkStatus_default_instance_;
class DestinationStatus;
class DestinationStatusDefaultTypeInternal;
extern DestinationStatusDefaultTypeInternal _DestinationStatus_default_instance_;
class EmergencyStopStatus;
class EmergencyStopStatusDefaultTypeInternal;
extern EmergencyStopStatusDefaultTypeInternal _EmergencyStopStatus_default_instance_;
class NavigationPlanningConfig;
class NavigationPlanningConfigDefaultTypeInternal;
extern NavigationPlanningConfigDefaultTypeInternal _NavigationPlanningConfig_default_instance_;
class OpenSpaceStatus;
class OpenSpaceStatusDefaultTypeInternal;
extern OpenSpaceStatusDefaultTypeInternal _OpenSpaceStatus_default_instance_;
class ParkAndGoStatus;
class ParkAndGoStatusDefaultTypeInternal;
extern ParkAndGoStatusDefaultTypeInternal _ParkAndGoStatus_default_instance_;
class PathDeciderStatus;
class PathDeciderStatusDefaultTypeInternal;
extern PathDeciderStatusDefaultTypeInternal _PathDeciderStatus_default_instance_;
class PlannerNaviConfig;
class PlannerNaviConfigDefaultTypeInternal;
extern PlannerNaviConfigDefaultTypeInternal _PlannerNaviConfig_default_instance_;
class PlannerPublicRoadConfig;
class PlannerPublicRoadConfigDefaultTypeInternal;
extern PlannerPublicRoadConfigDefaultTypeInternal _PlannerPublicRoadConfig_default_instance_;
class PlanningConfig;
class PlanningConfigDefaultTypeInternal;
extern PlanningConfigDefaultTypeInternal _PlanningConfig_default_instance_;
class PlanningStatus;
class PlanningStatusDefaultTypeInternal;
extern PlanningStatusDefaultTypeInternal _PlanningStatus_default_instance_;
class PullOverStatus;
class PullOverStatusDefaultTypeInternal;
extern PullOverStatusDefaultTypeInternal _PullOverStatus_default_instance_;
class ReroutingStatus;
class ReroutingStatusDefaultTypeInternal;
extern ReroutingStatusDefaultTypeInternal _ReroutingStatus_default_instance_;
class RtkPlanningConfig;
class RtkPlanningConfigDefaultTypeInternal;
extern RtkPlanningConfigDefaultTypeInternal _RtkPlanningConfig_default_instance_;
class ScenarioBareIntersectionUnprotectedConfig;
class ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal;
extern ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal _ScenarioBareIntersectionUnprotectedConfig_default_instance_;
class ScenarioConfig;
class ScenarioConfigDefaultTypeInternal;
extern ScenarioConfigDefaultTypeInternal _ScenarioConfig_default_instance_;
class ScenarioConfig_StageConfig;
class ScenarioConfig_StageConfigDefaultTypeInternal;
extern ScenarioConfig_StageConfigDefaultTypeInternal _ScenarioConfig_StageConfig_default_instance_;
class ScenarioEmergencyPullOverConfig;
class ScenarioEmergencyPullOverConfigDefaultTypeInternal;
extern ScenarioEmergencyPullOverConfigDefaultTypeInternal _ScenarioEmergencyPullOverConfig_default_instance_;
class ScenarioEmergencyStopConfig;
class ScenarioEmergencyStopConfigDefaultTypeInternal;
extern ScenarioEmergencyStopConfigDefaultTypeInternal _ScenarioEmergencyStopConfig_default_instance_;
class ScenarioLaneFollowConfig;
class ScenarioLaneFollowConfigDefaultTypeInternal;
extern ScenarioLaneFollowConfigDefaultTypeInternal _ScenarioLaneFollowConfig_default_instance_;
class ScenarioNarrowStreetUTurnConfig;
class ScenarioNarrowStreetUTurnConfigDefaultTypeInternal;
extern ScenarioNarrowStreetUTurnConfigDefaultTypeInternal _ScenarioNarrowStreetUTurnConfig_default_instance_;
class ScenarioParkAndGoConfig;
class ScenarioParkAndGoConfigDefaultTypeInternal;
extern ScenarioParkAndGoConfigDefaultTypeInternal _ScenarioParkAndGoConfig_default_instance_;
class ScenarioPullOverConfig;
class ScenarioPullOverConfigDefaultTypeInternal;
extern ScenarioPullOverConfigDefaultTypeInternal _ScenarioPullOverConfig_default_instance_;
class ScenarioStatus;
class ScenarioStatusDefaultTypeInternal;
extern ScenarioStatusDefaultTypeInternal _ScenarioStatus_default_instance_;
class ScenarioStopSignUnprotectedConfig;
class ScenarioStopSignUnprotectedConfigDefaultTypeInternal;
extern ScenarioStopSignUnprotectedConfigDefaultTypeInternal _ScenarioStopSignUnprotectedConfig_default_instance_;
class ScenarioTestLearningModelConfig;
class ScenarioTestLearningModelConfigDefaultTypeInternal;
extern ScenarioTestLearningModelConfigDefaultTypeInternal _ScenarioTestLearningModelConfig_default_instance_;
class ScenarioTrafficLightProtectedConfig;
class ScenarioTrafficLightProtectedConfigDefaultTypeInternal;
extern ScenarioTrafficLightProtectedConfigDefaultTypeInternal _ScenarioTrafficLightProtectedConfig_default_instance_;
class ScenarioTrafficLightUnprotectedLeftTurnConfig;
class ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_;
class ScenarioTrafficLightUnprotectedRightTurnConfig;
class ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_;
class ScenarioValetParkingConfig;
class ScenarioValetParkingConfigDefaultTypeInternal;
extern ScenarioValetParkingConfigDefaultTypeInternal _ScenarioValetParkingConfig_default_instance_;
class ScenarioYieldSignConfig;
class ScenarioYieldSignConfigDefaultTypeInternal;
extern ScenarioYieldSignConfigDefaultTypeInternal _ScenarioYieldSignConfig_default_instance_;
class StandardPlanningConfig;
class StandardPlanningConfigDefaultTypeInternal;
extern StandardPlanningConfigDefaultTypeInternal _StandardPlanningConfig_default_instance_;
class StopSignStatus;
class StopSignStatusDefaultTypeInternal;
extern StopSignStatusDefaultTypeInternal _StopSignStatus_default_instance_;
class StopTime;
class StopTimeDefaultTypeInternal;
extern StopTimeDefaultTypeInternal _StopTime_default_instance_;
class TaskConfig;
class TaskConfigDefaultTypeInternal;
extern TaskConfigDefaultTypeInternal _TaskConfig_default_instance_;
class TrafficLightStatus;
class TrafficLightStatusDefaultTypeInternal;
extern TrafficLightStatusDefaultTypeInternal _TrafficLightStatus_default_instance_;
class YieldSignStatus;
class YieldSignStatusDefaultTypeInternal;
extern YieldSignStatusDefaultTypeInternal _YieldSignStatus_default_instance_;
}  // namespace planning
namespace routing {
class LaneSegment;
class LaneSegmentDefaultTypeInternal;
extern LaneSegmentDefaultTypeInternal _LaneSegment_default_instance_;
class LaneWaypoint;
class LaneWaypointDefaultTypeInternal;
extern LaneWaypointDefaultTypeInternal _LaneWaypoint_default_instance_;
class Measurement;
class MeasurementDefaultTypeInternal;
extern MeasurementDefaultTypeInternal _Measurement_default_instance_;
class ParkingInfo;
class ParkingInfoDefaultTypeInternal;
extern ParkingInfoDefaultTypeInternal _ParkingInfo_default_instance_;
class Passage;
class PassageDefaultTypeInternal;
extern PassageDefaultTypeInternal _Passage_default_instance_;
class RoadSegment;
class RoadSegmentDefaultTypeInternal;
extern RoadSegmentDefaultTypeInternal _RoadSegment_default_instance_;
class RoutingRequest;
class RoutingRequestDefaultTypeInternal;
extern RoutingRequestDefaultTypeInternal _RoutingRequest_default_instance_;
class RoutingResponse;
class RoutingResponseDefaultTypeInternal;
extern RoutingResponseDefaultTypeInternal _RoutingResponse_default_instance_;
}  // namespace routing
}  // namespace jmc_auto

namespace jmc_auto {
namespace planning {

namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto

enum ChangeLaneStatus_Status {
  ChangeLaneStatus_Status_IN_CHANGE_LANE = 1,
  ChangeLaneStatus_Status_CHANGE_LANE_FAILED = 2,
  ChangeLaneStatus_Status_CHANGE_LANE_FINISHED = 3
};
bool ChangeLaneStatus_Status_IsValid(int value);
const ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MIN = ChangeLaneStatus_Status_IN_CHANGE_LANE;
const ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MAX = ChangeLaneStatus_Status_CHANGE_LANE_FINISHED;
const int ChangeLaneStatus_Status_Status_ARRAYSIZE = ChangeLaneStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeLaneStatus_Status_descriptor();
inline const ::std::string& ChangeLaneStatus_Status_Name(ChangeLaneStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeLaneStatus_Status_descriptor(), value);
}
inline bool ChangeLaneStatus_Status_Parse(
    const ::std::string& name, ChangeLaneStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeLaneStatus_Status>(
    ChangeLaneStatus_Status_descriptor(), name, value);
}
enum PathDeciderStatus_LaneBorrowDirection {
  PathDeciderStatus_LaneBorrowDirection_LEFT_BORROW = 1,
  PathDeciderStatus_LaneBorrowDirection_RIGHT_BORROW = 2
};
bool PathDeciderStatus_LaneBorrowDirection_IsValid(int value);
const PathDeciderStatus_LaneBorrowDirection PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MIN = PathDeciderStatus_LaneBorrowDirection_LEFT_BORROW;
const PathDeciderStatus_LaneBorrowDirection PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MAX = PathDeciderStatus_LaneBorrowDirection_RIGHT_BORROW;
const int PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_ARRAYSIZE = PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathDeciderStatus_LaneBorrowDirection_descriptor();
inline const ::std::string& PathDeciderStatus_LaneBorrowDirection_Name(PathDeciderStatus_LaneBorrowDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathDeciderStatus_LaneBorrowDirection_descriptor(), value);
}
inline bool PathDeciderStatus_LaneBorrowDirection_Parse(
    const ::std::string& name, PathDeciderStatus_LaneBorrowDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathDeciderStatus_LaneBorrowDirection>(
    PathDeciderStatus_LaneBorrowDirection_descriptor(), name, value);
}
enum PullOverStatus_PullOverType {
  PullOverStatus_PullOverType_PULL_OVER = 1,
  PullOverStatus_PullOverType_EMERGENCY_PULL_OVER = 2
};
bool PullOverStatus_PullOverType_IsValid(int value);
const PullOverStatus_PullOverType PullOverStatus_PullOverType_PullOverType_MIN = PullOverStatus_PullOverType_PULL_OVER;
const PullOverStatus_PullOverType PullOverStatus_PullOverType_PullOverType_MAX = PullOverStatus_PullOverType_EMERGENCY_PULL_OVER;
const int PullOverStatus_PullOverType_PullOverType_ARRAYSIZE = PullOverStatus_PullOverType_PullOverType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PullOverStatus_PullOverType_descriptor();
inline const ::std::string& PullOverStatus_PullOverType_Name(PullOverStatus_PullOverType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PullOverStatus_PullOverType_descriptor(), value);
}
inline bool PullOverStatus_PullOverType_Parse(
    const ::std::string& name, PullOverStatus_PullOverType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PullOverStatus_PullOverType>(
    PullOverStatus_PullOverType_descriptor(), name, value);
}
// ===================================================================

class BareIntersectionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.BareIntersectionStatus) */ {
 public:
  BareIntersectionStatus();
  virtual ~BareIntersectionStatus();

  BareIntersectionStatus(const BareIntersectionStatus& from);

  inline BareIntersectionStatus& operator=(const BareIntersectionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BareIntersectionStatus& default_instance();

  static inline const BareIntersectionStatus* internal_default_instance() {
    return reinterpret_cast<const BareIntersectionStatus*>(
               &_BareIntersectionStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(BareIntersectionStatus* other);

  // implements Message ----------------------------------------------

  inline BareIntersectionStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  BareIntersectionStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BareIntersectionStatus& from);
  void MergeFrom(const BareIntersectionStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BareIntersectionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string current_pnc_junction_overlap_id = 1;
  bool has_current_pnc_junction_overlap_id() const;
  void clear_current_pnc_junction_overlap_id();
  static const int kCurrentPncJunctionOverlapIdFieldNumber = 1;
  const ::std::string& current_pnc_junction_overlap_id() const;
  void set_current_pnc_junction_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void set_current_pnc_junction_overlap_id(::std::string&& value);
  #endif
  void set_current_pnc_junction_overlap_id(const char* value);
  void set_current_pnc_junction_overlap_id(const char* value, size_t size);
  ::std::string* mutable_current_pnc_junction_overlap_id();
  ::std::string* release_current_pnc_junction_overlap_id();
  void set_allocated_current_pnc_junction_overlap_id(::std::string* current_pnc_junction_overlap_id);

  // optional string done_pnc_junction_overlap_id = 2;
  bool has_done_pnc_junction_overlap_id() const;
  void clear_done_pnc_junction_overlap_id();
  static const int kDonePncJunctionOverlapIdFieldNumber = 2;
  const ::std::string& done_pnc_junction_overlap_id() const;
  void set_done_pnc_junction_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void set_done_pnc_junction_overlap_id(::std::string&& value);
  #endif
  void set_done_pnc_junction_overlap_id(const char* value);
  void set_done_pnc_junction_overlap_id(const char* value, size_t size);
  ::std::string* mutable_done_pnc_junction_overlap_id();
  ::std::string* release_done_pnc_junction_overlap_id();
  void set_allocated_done_pnc_junction_overlap_id(::std::string* done_pnc_junction_overlap_id);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.BareIntersectionStatus)
 private:
  void set_has_current_pnc_junction_overlap_id();
  void clear_has_current_pnc_junction_overlap_id();
  void set_has_done_pnc_junction_overlap_id();
  void clear_has_done_pnc_junction_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr current_pnc_junction_overlap_id_;
  ::google::protobuf::internal::ArenaStringPtr done_pnc_junction_overlap_id_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangeLaneStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ChangeLaneStatus) */ {
 public:
  ChangeLaneStatus();
  virtual ~ChangeLaneStatus();

  ChangeLaneStatus(const ChangeLaneStatus& from);

  inline ChangeLaneStatus& operator=(const ChangeLaneStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeLaneStatus& default_instance();

  static inline const ChangeLaneStatus* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneStatus*>(
               &_ChangeLaneStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ChangeLaneStatus* other);

  // implements Message ----------------------------------------------

  inline ChangeLaneStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangeLaneStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangeLaneStatus& from);
  void MergeFrom(const ChangeLaneStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangeLaneStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChangeLaneStatus_Status Status;
  static const Status IN_CHANGE_LANE =
    ChangeLaneStatus_Status_IN_CHANGE_LANE;
  static const Status CHANGE_LANE_FAILED =
    ChangeLaneStatus_Status_CHANGE_LANE_FAILED;
  static const Status CHANGE_LANE_FINISHED =
    ChangeLaneStatus_Status_CHANGE_LANE_FINISHED;
  static inline bool Status_IsValid(int value) {
    return ChangeLaneStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ChangeLaneStatus_Status_Status_MIN;
  static const Status Status_MAX =
    ChangeLaneStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ChangeLaneStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ChangeLaneStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ChangeLaneStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ChangeLaneStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string path_id = 2;
  bool has_path_id() const;
  void clear_path_id();
  static const int kPathIdFieldNumber = 2;
  const ::std::string& path_id() const;
  void set_path_id(const ::std::string& value);
  #if LANG_CXX11
  void set_path_id(::std::string&& value);
  #endif
  void set_path_id(const char* value);
  void set_path_id(const char* value, size_t size);
  ::std::string* mutable_path_id();
  ::std::string* release_path_id();
  void set_allocated_path_id(::std::string* path_id);

  // optional .jmc_auto.common.Point3D lane_change_start_position = 5;
  bool has_lane_change_start_position() const;
  void clear_lane_change_start_position();
  static const int kLaneChangeStartPositionFieldNumber = 5;
  const ::jmc_auto::common::Point3D& lane_change_start_position() const;
  ::jmc_auto::common::Point3D* mutable_lane_change_start_position();
  ::jmc_auto::common::Point3D* release_lane_change_start_position();
  void set_allocated_lane_change_start_position(::jmc_auto::common::Point3D* lane_change_start_position);

  // optional double timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  double timestamp() const;
  void set_timestamp(double value);

  // optional double last_succeed_timestamp = 6;
  bool has_last_succeed_timestamp() const;
  void clear_last_succeed_timestamp();
  static const int kLastSucceedTimestampFieldNumber = 6;
  double last_succeed_timestamp() const;
  void set_last_succeed_timestamp(double value);

  // optional bool exist_lane_change_start_position = 4 [default = false];
  bool has_exist_lane_change_start_position() const;
  void clear_exist_lane_change_start_position();
  static const int kExistLaneChangeStartPositionFieldNumber = 4;
  bool exist_lane_change_start_position() const;
  void set_exist_lane_change_start_position(bool value);

  // optional bool is_current_opt_succeed = 7 [default = false];
  bool has_is_current_opt_succeed() const;
  void clear_is_current_opt_succeed();
  static const int kIsCurrentOptSucceedFieldNumber = 7;
  bool is_current_opt_succeed() const;
  void set_is_current_opt_succeed(bool value);

  // optional bool is_clear_to_change_lane = 8 [default = false];
  bool has_is_clear_to_change_lane() const;
  void clear_is_clear_to_change_lane();
  static const int kIsClearToChangeLaneFieldNumber = 8;
  bool is_clear_to_change_lane() const;
  void set_is_clear_to_change_lane(bool value);

  // optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::jmc_auto::planning::ChangeLaneStatus_Status status() const;
  void set_status(::jmc_auto::planning::ChangeLaneStatus_Status value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ChangeLaneStatus)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_path_id();
  void clear_has_path_id();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_exist_lane_change_start_position();
  void clear_has_exist_lane_change_start_position();
  void set_has_lane_change_start_position();
  void clear_has_lane_change_start_position();
  void set_has_last_succeed_timestamp();
  void clear_has_last_succeed_timestamp();
  void set_has_is_current_opt_succeed();
  void clear_has_is_current_opt_succeed();
  void set_has_is_clear_to_change_lane();
  void clear_has_is_clear_to_change_lane();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_id_;
  ::jmc_auto::common::Point3D* lane_change_start_position_;
  double timestamp_;
  double last_succeed_timestamp_;
  bool exist_lane_change_start_position_;
  bool is_current_opt_succeed_;
  bool is_clear_to_change_lane_;
  int status_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.StopTime) */ {
 public:
  StopTime();
  virtual ~StopTime();

  StopTime(const StopTime& from);

  inline StopTime& operator=(const StopTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopTime& default_instance();

  static inline const StopTime* internal_default_instance() {
    return reinterpret_cast<const StopTime*>(
               &_StopTime_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(StopTime* other);

  // implements Message ----------------------------------------------

  inline StopTime* New() const PROTOBUF_FINAL { return New(NULL); }

  StopTime* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopTime& from);
  void MergeFrom(const StopTime& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string obstacle_id = 1;
  bool has_obstacle_id() const;
  void clear_obstacle_id();
  static const int kObstacleIdFieldNumber = 1;
  const ::std::string& obstacle_id() const;
  void set_obstacle_id(const ::std::string& value);
  #if LANG_CXX11
  void set_obstacle_id(::std::string&& value);
  #endif
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  ::std::string* mutable_obstacle_id();
  ::std::string* release_obstacle_id();
  void set_allocated_obstacle_id(::std::string* obstacle_id);

  // optional double obstacle_stop_timestamp = 2;
  bool has_obstacle_stop_timestamp() const;
  void clear_obstacle_stop_timestamp();
  static const int kObstacleStopTimestampFieldNumber = 2;
  double obstacle_stop_timestamp() const;
  void set_obstacle_stop_timestamp(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.StopTime)
 private:
  void set_has_obstacle_id();
  void clear_has_obstacle_id();
  void set_has_obstacle_stop_timestamp();
  void clear_has_obstacle_stop_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr obstacle_id_;
  double obstacle_stop_timestamp_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.CrosswalkStatus) */ {
 public:
  CrosswalkStatus();
  virtual ~CrosswalkStatus();

  CrosswalkStatus(const CrosswalkStatus& from);

  inline CrosswalkStatus& operator=(const CrosswalkStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkStatus& default_instance();

  static inline const CrosswalkStatus* internal_default_instance() {
    return reinterpret_cast<const CrosswalkStatus*>(
               &_CrosswalkStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CrosswalkStatus* other);

  // implements Message ----------------------------------------------

  inline CrosswalkStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  CrosswalkStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrosswalkStatus& from);
  void MergeFrom(const CrosswalkStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrosswalkStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.StopTime stop_time = 2;
  int stop_time_size() const;
  void clear_stop_time();
  static const int kStopTimeFieldNumber = 2;
  const ::jmc_auto::planning::StopTime& stop_time(int index) const;
  ::jmc_auto::planning::StopTime* mutable_stop_time(int index);
  ::jmc_auto::planning::StopTime* add_stop_time();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime >*
      mutable_stop_time();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime >&
      stop_time() const;

  // repeated string finished_crosswalk = 3;
  int finished_crosswalk_size() const;
  void clear_finished_crosswalk();
  static const int kFinishedCrosswalkFieldNumber = 3;
  const ::std::string& finished_crosswalk(int index) const;
  ::std::string* mutable_finished_crosswalk(int index);
  void set_finished_crosswalk(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_finished_crosswalk(int index, ::std::string&& value);
  #endif
  void set_finished_crosswalk(int index, const char* value);
  void set_finished_crosswalk(int index, const char* value, size_t size);
  ::std::string* add_finished_crosswalk();
  void add_finished_crosswalk(const ::std::string& value);
  #if LANG_CXX11
  void add_finished_crosswalk(::std::string&& value);
  #endif
  void add_finished_crosswalk(const char* value);
  void add_finished_crosswalk(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& finished_crosswalk() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_finished_crosswalk();

  // optional string crosswalk_id = 1;
  bool has_crosswalk_id() const;
  void clear_crosswalk_id();
  static const int kCrosswalkIdFieldNumber = 1;
  const ::std::string& crosswalk_id() const;
  void set_crosswalk_id(const ::std::string& value);
  #if LANG_CXX11
  void set_crosswalk_id(::std::string&& value);
  #endif
  void set_crosswalk_id(const char* value);
  void set_crosswalk_id(const char* value, size_t size);
  ::std::string* mutable_crosswalk_id();
  ::std::string* release_crosswalk_id();
  void set_allocated_crosswalk_id(::std::string* crosswalk_id);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.CrosswalkStatus)
 private:
  void set_has_crosswalk_id();
  void clear_has_crosswalk_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime > stop_time_;
  ::google::protobuf::RepeatedPtrField< ::std::string> finished_crosswalk_;
  ::google::protobuf::internal::ArenaStringPtr crosswalk_id_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DestinationStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.DestinationStatus) */ {
 public:
  DestinationStatus();
  virtual ~DestinationStatus();

  DestinationStatus(const DestinationStatus& from);

  inline DestinationStatus& operator=(const DestinationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationStatus& default_instance();

  static inline const DestinationStatus* internal_default_instance() {
    return reinterpret_cast<const DestinationStatus*>(
               &_DestinationStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DestinationStatus* other);

  // implements Message ----------------------------------------------

  inline DestinationStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  DestinationStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DestinationStatus& from);
  void MergeFrom(const DestinationStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestinationStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool has_passed_destination = 1 [default = false];
  bool has_has_passed_destination() const;
  void clear_has_passed_destination();
  static const int kHasPassedDestinationFieldNumber = 1;
  bool has_passed_destination() const;
  void set_has_passed_destination(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.DestinationStatus)
 private:
  void set_has_has_passed_destination();
  void clear_has_has_passed_destination();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool has_passed_destination_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmergencyStopStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.EmergencyStopStatus) */ {
 public:
  EmergencyStopStatus();
  virtual ~EmergencyStopStatus();

  EmergencyStopStatus(const EmergencyStopStatus& from);

  inline EmergencyStopStatus& operator=(const EmergencyStopStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmergencyStopStatus& default_instance();

  static inline const EmergencyStopStatus* internal_default_instance() {
    return reinterpret_cast<const EmergencyStopStatus*>(
               &_EmergencyStopStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(EmergencyStopStatus* other);

  // implements Message ----------------------------------------------

  inline EmergencyStopStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  EmergencyStopStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmergencyStopStatus& from);
  void MergeFrom(const EmergencyStopStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmergencyStopStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.common.PointENU stop_fence_point = 1;
  bool has_stop_fence_point() const;
  void clear_stop_fence_point();
  static const int kStopFencePointFieldNumber = 1;
  const ::jmc_auto::common::PointENU& stop_fence_point() const;
  ::jmc_auto::common::PointENU* mutable_stop_fence_point();
  ::jmc_auto::common::PointENU* release_stop_fence_point();
  void set_allocated_stop_fence_point(::jmc_auto::common::PointENU* stop_fence_point);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.EmergencyStopStatus)
 private:
  void set_has_stop_fence_point();
  void clear_has_stop_fence_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::common::PointENU* stop_fence_point_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenSpaceStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.OpenSpaceStatus) */ {
 public:
  OpenSpaceStatus();
  virtual ~OpenSpaceStatus();

  OpenSpaceStatus(const OpenSpaceStatus& from);

  inline OpenSpaceStatus& operator=(const OpenSpaceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenSpaceStatus& default_instance();

  static inline const OpenSpaceStatus* internal_default_instance() {
    return reinterpret_cast<const OpenSpaceStatus*>(
               &_OpenSpaceStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(OpenSpaceStatus* other);

  // implements Message ----------------------------------------------

  inline OpenSpaceStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenSpaceStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OpenSpaceStatus& from);
  void MergeFrom(const OpenSpaceStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OpenSpaceStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string partitioned_trajectories_index_history = 1;
  int partitioned_trajectories_index_history_size() const;
  void clear_partitioned_trajectories_index_history();
  static const int kPartitionedTrajectoriesIndexHistoryFieldNumber = 1;
  const ::std::string& partitioned_trajectories_index_history(int index) const;
  ::std::string* mutable_partitioned_trajectories_index_history(int index);
  void set_partitioned_trajectories_index_history(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_partitioned_trajectories_index_history(int index, ::std::string&& value);
  #endif
  void set_partitioned_trajectories_index_history(int index, const char* value);
  void set_partitioned_trajectories_index_history(int index, const char* value, size_t size);
  ::std::string* add_partitioned_trajectories_index_history();
  void add_partitioned_trajectories_index_history(const ::std::string& value);
  #if LANG_CXX11
  void add_partitioned_trajectories_index_history(::std::string&& value);
  #endif
  void add_partitioned_trajectories_index_history(const char* value);
  void add_partitioned_trajectories_index_history(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& partitioned_trajectories_index_history() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_partitioned_trajectories_index_history();

  // optional bool position_init = 2 [default = false];
  bool has_position_init() const;
  void clear_position_init();
  static const int kPositionInitFieldNumber = 2;
  bool position_init() const;
  void set_position_init(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.OpenSpaceStatus)
 private:
  void set_has_position_init();
  void clear_has_position_init();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> partitioned_trajectories_index_history_;
  bool position_init_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParkAndGoStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ParkAndGoStatus) */ {
 public:
  ParkAndGoStatus();
  virtual ~ParkAndGoStatus();

  ParkAndGoStatus(const ParkAndGoStatus& from);

  inline ParkAndGoStatus& operator=(const ParkAndGoStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkAndGoStatus& default_instance();

  static inline const ParkAndGoStatus* internal_default_instance() {
    return reinterpret_cast<const ParkAndGoStatus*>(
               &_ParkAndGoStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ParkAndGoStatus* other);

  // implements Message ----------------------------------------------

  inline ParkAndGoStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkAndGoStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkAndGoStatus& from);
  void MergeFrom(const ParkAndGoStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkAndGoStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.common.PointENU adc_init_position = 1;
  bool has_adc_init_position() const;
  void clear_adc_init_position();
  static const int kAdcInitPositionFieldNumber = 1;
  const ::jmc_auto::common::PointENU& adc_init_position() const;
  ::jmc_auto::common::PointENU* mutable_adc_init_position();
  ::jmc_auto::common::PointENU* release_adc_init_position();
  void set_allocated_adc_init_position(::jmc_auto::common::PointENU* adc_init_position);

  // optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
  bool has_adc_adjust_end_pose() const;
  void clear_adc_adjust_end_pose();
  static const int kAdcAdjustEndPoseFieldNumber = 4;
  const ::jmc_auto::common::PointENU& adc_adjust_end_pose() const;
  ::jmc_auto::common::PointENU* mutable_adc_adjust_end_pose();
  ::jmc_auto::common::PointENU* release_adc_adjust_end_pose();
  void set_allocated_adc_adjust_end_pose(::jmc_auto::common::PointENU* adc_adjust_end_pose);

  // optional double adc_init_heading = 2;
  bool has_adc_init_heading() const;
  void clear_adc_init_heading();
  static const int kAdcInitHeadingFieldNumber = 2;
  double adc_init_heading() const;
  void set_adc_init_heading(double value);

  // optional bool in_check_stage = 3;
  bool has_in_check_stage() const;
  void clear_in_check_stage();
  static const int kInCheckStageFieldNumber = 3;
  bool in_check_stage() const;
  void set_in_check_stage(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ParkAndGoStatus)
 private:
  void set_has_adc_init_position();
  void clear_has_adc_init_position();
  void set_has_adc_init_heading();
  void clear_has_adc_init_heading();
  void set_has_in_check_stage();
  void clear_has_in_check_stage();
  void set_has_adc_adjust_end_pose();
  void clear_has_adc_adjust_end_pose();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::common::PointENU* adc_init_position_;
  ::jmc_auto::common::PointENU* adc_adjust_end_pose_;
  double adc_init_heading_;
  bool in_check_stage_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathDeciderStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PathDeciderStatus) */ {
 public:
  PathDeciderStatus();
  virtual ~PathDeciderStatus();

  PathDeciderStatus(const PathDeciderStatus& from);

  inline PathDeciderStatus& operator=(const PathDeciderStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathDeciderStatus& default_instance();

  static inline const PathDeciderStatus* internal_default_instance() {
    return reinterpret_cast<const PathDeciderStatus*>(
               &_PathDeciderStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PathDeciderStatus* other);

  // implements Message ----------------------------------------------

  inline PathDeciderStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PathDeciderStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PathDeciderStatus& from);
  void MergeFrom(const PathDeciderStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PathDeciderStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PathDeciderStatus_LaneBorrowDirection LaneBorrowDirection;
  static const LaneBorrowDirection LEFT_BORROW =
    PathDeciderStatus_LaneBorrowDirection_LEFT_BORROW;
  static const LaneBorrowDirection RIGHT_BORROW =
    PathDeciderStatus_LaneBorrowDirection_RIGHT_BORROW;
  static inline bool LaneBorrowDirection_IsValid(int value) {
    return PathDeciderStatus_LaneBorrowDirection_IsValid(value);
  }
  static const LaneBorrowDirection LaneBorrowDirection_MIN =
    PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MIN;
  static const LaneBorrowDirection LaneBorrowDirection_MAX =
    PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_MAX;
  static const int LaneBorrowDirection_ARRAYSIZE =
    PathDeciderStatus_LaneBorrowDirection_LaneBorrowDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneBorrowDirection_descriptor() {
    return PathDeciderStatus_LaneBorrowDirection_descriptor();
  }
  static inline const ::std::string& LaneBorrowDirection_Name(LaneBorrowDirection value) {
    return PathDeciderStatus_LaneBorrowDirection_Name(value);
  }
  static inline bool LaneBorrowDirection_Parse(const ::std::string& name,
      LaneBorrowDirection* value) {
    return PathDeciderStatus_LaneBorrowDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  int decided_side_pass_direction_size() const;
  void clear_decided_side_pass_direction();
  static const int kDecidedSidePassDirectionFieldNumber = 5;
  ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection decided_side_pass_direction(int index) const;
  void set_decided_side_pass_direction(int index, ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection value);
  void add_decided_side_pass_direction(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection value);
  const ::google::protobuf::RepeatedField<int>& decided_side_pass_direction() const;
  ::google::protobuf::RepeatedField<int>* mutable_decided_side_pass_direction();

  // optional string front_static_obstacle_id = 4 [default = ""];
  bool has_front_static_obstacle_id() const;
  void clear_front_static_obstacle_id();
  static const int kFrontStaticObstacleIdFieldNumber = 4;
  const ::std::string& front_static_obstacle_id() const;
  void set_front_static_obstacle_id(const ::std::string& value);
  #if LANG_CXX11
  void set_front_static_obstacle_id(::std::string&& value);
  #endif
  void set_front_static_obstacle_id(const char* value);
  void set_front_static_obstacle_id(const char* value, size_t size);
  ::std::string* mutable_front_static_obstacle_id();
  ::std::string* release_front_static_obstacle_id();
  void set_allocated_front_static_obstacle_id(::std::string* front_static_obstacle_id);

  // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
  bool has_front_static_obstacle_cycle_counter() const;
  void clear_front_static_obstacle_cycle_counter();
  static const int kFrontStaticObstacleCycleCounterFieldNumber = 1;
  ::google::protobuf::int32 front_static_obstacle_cycle_counter() const;
  void set_front_static_obstacle_cycle_counter(::google::protobuf::int32 value);

  // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
  bool has_able_to_use_self_lane_counter() const;
  void clear_able_to_use_self_lane_counter();
  static const int kAbleToUseSelfLaneCounterFieldNumber = 2;
  ::google::protobuf::int32 able_to_use_self_lane_counter() const;
  void set_able_to_use_self_lane_counter(::google::protobuf::int32 value);

  // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
  bool has_is_in_path_lane_borrow_scenario() const;
  void clear_is_in_path_lane_borrow_scenario();
  static const int kIsInPathLaneBorrowScenarioFieldNumber = 3;
  bool is_in_path_lane_borrow_scenario() const;
  void set_is_in_path_lane_borrow_scenario(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PathDeciderStatus)
 private:
  void set_has_front_static_obstacle_cycle_counter();
  void clear_has_front_static_obstacle_cycle_counter();
  void set_has_able_to_use_self_lane_counter();
  void clear_has_able_to_use_self_lane_counter();
  void set_has_is_in_path_lane_borrow_scenario();
  void clear_has_is_in_path_lane_borrow_scenario();
  void set_has_front_static_obstacle_id();
  void clear_has_front_static_obstacle_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> decided_side_pass_direction_;
  ::google::protobuf::internal::ArenaStringPtr front_static_obstacle_id_;
  ::google::protobuf::int32 front_static_obstacle_cycle_counter_;
  ::google::protobuf::int32 able_to_use_self_lane_counter_;
  bool is_in_path_lane_borrow_scenario_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PullOverStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PullOverStatus) */ {
 public:
  PullOverStatus();
  virtual ~PullOverStatus();

  PullOverStatus(const PullOverStatus& from);

  inline PullOverStatus& operator=(const PullOverStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PullOverStatus& default_instance();

  static inline const PullOverStatus* internal_default_instance() {
    return reinterpret_cast<const PullOverStatus*>(
               &_PullOverStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PullOverStatus* other);

  // implements Message ----------------------------------------------

  inline PullOverStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PullOverStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PullOverStatus& from);
  void MergeFrom(const PullOverStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PullOverStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PullOverStatus_PullOverType PullOverType;
  static const PullOverType PULL_OVER =
    PullOverStatus_PullOverType_PULL_OVER;
  static const PullOverType EMERGENCY_PULL_OVER =
    PullOverStatus_PullOverType_EMERGENCY_PULL_OVER;
  static inline bool PullOverType_IsValid(int value) {
    return PullOverStatus_PullOverType_IsValid(value);
  }
  static const PullOverType PullOverType_MIN =
    PullOverStatus_PullOverType_PullOverType_MIN;
  static const PullOverType PullOverType_MAX =
    PullOverStatus_PullOverType_PullOverType_MAX;
  static const int PullOverType_ARRAYSIZE =
    PullOverStatus_PullOverType_PullOverType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PullOverType_descriptor() {
    return PullOverStatus_PullOverType_descriptor();
  }
  static inline const ::std::string& PullOverType_Name(PullOverType value) {
    return PullOverStatus_PullOverType_Name(value);
  }
  static inline bool PullOverType_Parse(const ::std::string& name,
      PullOverType* value) {
    return PullOverStatus_PullOverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.common.PointENU position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::jmc_auto::common::PointENU& position() const;
  ::jmc_auto::common::PointENU* mutable_position();
  ::jmc_auto::common::PointENU* release_position();
  void set_allocated_position(::jmc_auto::common::PointENU* position);

  // optional double theta = 4;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 4;
  double theta() const;
  void set_theta(double value);

  // optional double length_front = 5;
  bool has_length_front() const;
  void clear_length_front();
  static const int kLengthFrontFieldNumber = 5;
  double length_front() const;
  void set_length_front(double value);

  // optional double length_back = 6;
  bool has_length_back() const;
  void clear_length_back();
  static const int kLengthBackFieldNumber = 6;
  double length_back() const;
  void set_length_back(double value);

  // optional double width_left = 7;
  bool has_width_left() const;
  void clear_width_left();
  static const int kWidthLeftFieldNumber = 7;
  double width_left() const;
  void set_width_left(double value);

  // optional double width_right = 8;
  bool has_width_right() const;
  void clear_width_right();
  static const int kWidthRightFieldNumber = 8;
  double width_right() const;
  void set_width_right(double value);

  // optional bool plan_pull_over_path = 2 [default = false];
  bool has_plan_pull_over_path() const;
  void clear_plan_pull_over_path();
  static const int kPlanPullOverPathFieldNumber = 2;
  bool plan_pull_over_path() const;
  void set_plan_pull_over_path(bool value);

  // optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
  bool has_pull_over_type() const;
  void clear_pull_over_type();
  static const int kPullOverTypeFieldNumber = 1;
  ::jmc_auto::planning::PullOverStatus_PullOverType pull_over_type() const;
  void set_pull_over_type(::jmc_auto::planning::PullOverStatus_PullOverType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PullOverStatus)
 private:
  void set_has_pull_over_type();
  void clear_has_pull_over_type();
  void set_has_plan_pull_over_path();
  void clear_has_plan_pull_over_path();
  void set_has_position();
  void clear_has_position();
  void set_has_theta();
  void clear_has_theta();
  void set_has_length_front();
  void clear_has_length_front();
  void set_has_length_back();
  void clear_has_length_back();
  void set_has_width_left();
  void clear_has_width_left();
  void set_has_width_right();
  void clear_has_width_right();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::common::PointENU* position_;
  double theta_;
  double length_front_;
  double length_back_;
  double width_left_;
  double width_right_;
  bool plan_pull_over_path_;
  int pull_over_type_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReroutingStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ReroutingStatus) */ {
 public:
  ReroutingStatus();
  virtual ~ReroutingStatus();

  ReroutingStatus(const ReroutingStatus& from);

  inline ReroutingStatus& operator=(const ReroutingStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReroutingStatus& default_instance();

  static inline const ReroutingStatus* internal_default_instance() {
    return reinterpret_cast<const ReroutingStatus*>(
               &_ReroutingStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ReroutingStatus* other);

  // implements Message ----------------------------------------------

  inline ReroutingStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ReroutingStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReroutingStatus& from);
  void MergeFrom(const ReroutingStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReroutingStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.routing.RoutingRequest routing_request = 3;
  bool has_routing_request() const;
  void clear_routing_request();
  static const int kRoutingRequestFieldNumber = 3;
  const ::jmc_auto::routing::RoutingRequest& routing_request() const;
  ::jmc_auto::routing::RoutingRequest* mutable_routing_request();
  ::jmc_auto::routing::RoutingRequest* release_routing_request();
  void set_allocated_routing_request(::jmc_auto::routing::RoutingRequest* routing_request);

  // optional double last_rerouting_time = 1;
  bool has_last_rerouting_time() const;
  void clear_last_rerouting_time();
  static const int kLastReroutingTimeFieldNumber = 1;
  double last_rerouting_time() const;
  void set_last_rerouting_time(double value);

  // optional bool need_rerouting = 2 [default = false];
  bool has_need_rerouting() const;
  void clear_need_rerouting();
  static const int kNeedReroutingFieldNumber = 2;
  bool need_rerouting() const;
  void set_need_rerouting(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ReroutingStatus)
 private:
  void set_has_last_rerouting_time();
  void clear_has_last_rerouting_time();
  void set_has_need_rerouting();
  void clear_has_need_rerouting();
  void set_has_routing_request();
  void clear_has_routing_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::routing::RoutingRequest* routing_request_;
  double last_rerouting_time_;
  bool need_rerouting_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioStatus) */ {
 public:
  ScenarioStatus();
  virtual ~ScenarioStatus();

  ScenarioStatus(const ScenarioStatus& from);

  inline ScenarioStatus& operator=(const ScenarioStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioStatus& default_instance();

  static inline const ScenarioStatus* internal_default_instance() {
    return reinterpret_cast<const ScenarioStatus*>(
               &_ScenarioStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ScenarioStatus* other);

  // implements Message ----------------------------------------------

  inline ScenarioStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioStatus& from);
  void MergeFrom(const ScenarioStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  bool has_scenario_type() const;
  void clear_scenario_type();
  static const int kScenarioTypeFieldNumber = 1;
  ::jmc_auto::planning::ScenarioConfig_ScenarioType scenario_type() const;
  void set_scenario_type(::jmc_auto::planning::ScenarioConfig_ScenarioType value);

  // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
  bool has_stage_type() const;
  void clear_stage_type();
  static const int kStageTypeFieldNumber = 2;
  ::jmc_auto::planning::ScenarioConfig_StageType stage_type() const;
  void set_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioStatus)
 private:
  void set_has_scenario_type();
  void clear_has_scenario_type();
  void set_has_stage_type();
  void clear_has_stage_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int scenario_type_;
  int stage_type_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopSignStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.StopSignStatus) */ {
 public:
  StopSignStatus();
  virtual ~StopSignStatus();

  StopSignStatus(const StopSignStatus& from);

  inline StopSignStatus& operator=(const StopSignStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignStatus& default_instance();

  static inline const StopSignStatus* internal_default_instance() {
    return reinterpret_cast<const StopSignStatus*>(
               &_StopSignStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(StopSignStatus* other);

  // implements Message ----------------------------------------------

  inline StopSignStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  StopSignStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopSignStatus& from);
  void MergeFrom(const StopSignStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopSignStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string wait_for_obstacle_id = 3;
  int wait_for_obstacle_id_size() const;
  void clear_wait_for_obstacle_id();
  static const int kWaitForObstacleIdFieldNumber = 3;
  const ::std::string& wait_for_obstacle_id(int index) const;
  ::std::string* mutable_wait_for_obstacle_id(int index);
  void set_wait_for_obstacle_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_wait_for_obstacle_id(int index, ::std::string&& value);
  #endif
  void set_wait_for_obstacle_id(int index, const char* value);
  void set_wait_for_obstacle_id(int index, const char* value, size_t size);
  ::std::string* add_wait_for_obstacle_id();
  void add_wait_for_obstacle_id(const ::std::string& value);
  #if LANG_CXX11
  void add_wait_for_obstacle_id(::std::string&& value);
  #endif
  void add_wait_for_obstacle_id(const char* value);
  void add_wait_for_obstacle_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& wait_for_obstacle_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_wait_for_obstacle_id();

  // optional string current_stop_sign_overlap_id = 1;
  bool has_current_stop_sign_overlap_id() const;
  void clear_current_stop_sign_overlap_id();
  static const int kCurrentStopSignOverlapIdFieldNumber = 1;
  const ::std::string& current_stop_sign_overlap_id() const;
  void set_current_stop_sign_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void set_current_stop_sign_overlap_id(::std::string&& value);
  #endif
  void set_current_stop_sign_overlap_id(const char* value);
  void set_current_stop_sign_overlap_id(const char* value, size_t size);
  ::std::string* mutable_current_stop_sign_overlap_id();
  ::std::string* release_current_stop_sign_overlap_id();
  void set_allocated_current_stop_sign_overlap_id(::std::string* current_stop_sign_overlap_id);

  // optional string done_stop_sign_overlap_id = 2;
  bool has_done_stop_sign_overlap_id() const;
  void clear_done_stop_sign_overlap_id();
  static const int kDoneStopSignOverlapIdFieldNumber = 2;
  const ::std::string& done_stop_sign_overlap_id() const;
  void set_done_stop_sign_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void set_done_stop_sign_overlap_id(::std::string&& value);
  #endif
  void set_done_stop_sign_overlap_id(const char* value);
  void set_done_stop_sign_overlap_id(const char* value, size_t size);
  ::std::string* mutable_done_stop_sign_overlap_id();
  ::std::string* release_done_stop_sign_overlap_id();
  void set_allocated_done_stop_sign_overlap_id(::std::string* done_stop_sign_overlap_id);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.StopSignStatus)
 private:
  void set_has_current_stop_sign_overlap_id();
  void clear_has_current_stop_sign_overlap_id();
  void set_has_done_stop_sign_overlap_id();
  void clear_has_done_stop_sign_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> wait_for_obstacle_id_;
  ::google::protobuf::internal::ArenaStringPtr current_stop_sign_overlap_id_;
  ::google::protobuf::internal::ArenaStringPtr done_stop_sign_overlap_id_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrafficLightStatus) */ {
 public:
  TrafficLightStatus();
  virtual ~TrafficLightStatus();

  TrafficLightStatus(const TrafficLightStatus& from);

  inline TrafficLightStatus& operator=(const TrafficLightStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightStatus& default_instance();

  static inline const TrafficLightStatus* internal_default_instance() {
    return reinterpret_cast<const TrafficLightStatus*>(
               &_TrafficLightStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TrafficLightStatus* other);

  // implements Message ----------------------------------------------

  inline TrafficLightStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightStatus& from);
  void MergeFrom(const TrafficLightStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string current_traffic_light_overlap_id = 1;
  int current_traffic_light_overlap_id_size() const;
  void clear_current_traffic_light_overlap_id();
  static const int kCurrentTrafficLightOverlapIdFieldNumber = 1;
  const ::std::string& current_traffic_light_overlap_id(int index) const;
  ::std::string* mutable_current_traffic_light_overlap_id(int index);
  void set_current_traffic_light_overlap_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_current_traffic_light_overlap_id(int index, ::std::string&& value);
  #endif
  void set_current_traffic_light_overlap_id(int index, const char* value);
  void set_current_traffic_light_overlap_id(int index, const char* value, size_t size);
  ::std::string* add_current_traffic_light_overlap_id();
  void add_current_traffic_light_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void add_current_traffic_light_overlap_id(::std::string&& value);
  #endif
  void add_current_traffic_light_overlap_id(const char* value);
  void add_current_traffic_light_overlap_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& current_traffic_light_overlap_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_current_traffic_light_overlap_id();

  // repeated string done_traffic_light_overlap_id = 2;
  int done_traffic_light_overlap_id_size() const;
  void clear_done_traffic_light_overlap_id();
  static const int kDoneTrafficLightOverlapIdFieldNumber = 2;
  const ::std::string& done_traffic_light_overlap_id(int index) const;
  ::std::string* mutable_done_traffic_light_overlap_id(int index);
  void set_done_traffic_light_overlap_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_done_traffic_light_overlap_id(int index, ::std::string&& value);
  #endif
  void set_done_traffic_light_overlap_id(int index, const char* value);
  void set_done_traffic_light_overlap_id(int index, const char* value, size_t size);
  ::std::string* add_done_traffic_light_overlap_id();
  void add_done_traffic_light_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void add_done_traffic_light_overlap_id(::std::string&& value);
  #endif
  void add_done_traffic_light_overlap_id(const char* value);
  void add_done_traffic_light_overlap_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& done_traffic_light_overlap_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_done_traffic_light_overlap_id();

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrafficLightStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> current_traffic_light_overlap_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> done_traffic_light_overlap_id_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YieldSignStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.YieldSignStatus) */ {
 public:
  YieldSignStatus();
  virtual ~YieldSignStatus();

  YieldSignStatus(const YieldSignStatus& from);

  inline YieldSignStatus& operator=(const YieldSignStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldSignStatus& default_instance();

  static inline const YieldSignStatus* internal_default_instance() {
    return reinterpret_cast<const YieldSignStatus*>(
               &_YieldSignStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(YieldSignStatus* other);

  // implements Message ----------------------------------------------

  inline YieldSignStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  YieldSignStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YieldSignStatus& from);
  void MergeFrom(const YieldSignStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YieldSignStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string current_yield_sign_overlap_id = 1;
  int current_yield_sign_overlap_id_size() const;
  void clear_current_yield_sign_overlap_id();
  static const int kCurrentYieldSignOverlapIdFieldNumber = 1;
  const ::std::string& current_yield_sign_overlap_id(int index) const;
  ::std::string* mutable_current_yield_sign_overlap_id(int index);
  void set_current_yield_sign_overlap_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_current_yield_sign_overlap_id(int index, ::std::string&& value);
  #endif
  void set_current_yield_sign_overlap_id(int index, const char* value);
  void set_current_yield_sign_overlap_id(int index, const char* value, size_t size);
  ::std::string* add_current_yield_sign_overlap_id();
  void add_current_yield_sign_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void add_current_yield_sign_overlap_id(::std::string&& value);
  #endif
  void add_current_yield_sign_overlap_id(const char* value);
  void add_current_yield_sign_overlap_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& current_yield_sign_overlap_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_current_yield_sign_overlap_id();

  // repeated string done_yield_sign_overlap_id = 2;
  int done_yield_sign_overlap_id_size() const;
  void clear_done_yield_sign_overlap_id();
  static const int kDoneYieldSignOverlapIdFieldNumber = 2;
  const ::std::string& done_yield_sign_overlap_id(int index) const;
  ::std::string* mutable_done_yield_sign_overlap_id(int index);
  void set_done_yield_sign_overlap_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_done_yield_sign_overlap_id(int index, ::std::string&& value);
  #endif
  void set_done_yield_sign_overlap_id(int index, const char* value);
  void set_done_yield_sign_overlap_id(int index, const char* value, size_t size);
  ::std::string* add_done_yield_sign_overlap_id();
  void add_done_yield_sign_overlap_id(const ::std::string& value);
  #if LANG_CXX11
  void add_done_yield_sign_overlap_id(::std::string&& value);
  #endif
  void add_done_yield_sign_overlap_id(const char* value);
  void add_done_yield_sign_overlap_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& done_yield_sign_overlap_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_done_yield_sign_overlap_id();

  // repeated string wait_for_obstacle_id = 3;
  int wait_for_obstacle_id_size() const;
  void clear_wait_for_obstacle_id();
  static const int kWaitForObstacleIdFieldNumber = 3;
  const ::std::string& wait_for_obstacle_id(int index) const;
  ::std::string* mutable_wait_for_obstacle_id(int index);
  void set_wait_for_obstacle_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_wait_for_obstacle_id(int index, ::std::string&& value);
  #endif
  void set_wait_for_obstacle_id(int index, const char* value);
  void set_wait_for_obstacle_id(int index, const char* value, size_t size);
  ::std::string* add_wait_for_obstacle_id();
  void add_wait_for_obstacle_id(const ::std::string& value);
  #if LANG_CXX11
  void add_wait_for_obstacle_id(::std::string&& value);
  #endif
  void add_wait_for_obstacle_id(const char* value);
  void add_wait_for_obstacle_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& wait_for_obstacle_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_wait_for_obstacle_id();

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.YieldSignStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> current_yield_sign_overlap_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> done_yield_sign_overlap_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> wait_for_obstacle_id_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PlanningStatus) */ {
 public:
  PlanningStatus();
  virtual ~PlanningStatus();

  PlanningStatus(const PlanningStatus& from);

  inline PlanningStatus& operator=(const PlanningStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningStatus& default_instance();

  static inline const PlanningStatus* internal_default_instance() {
    return reinterpret_cast<const PlanningStatus*>(
               &_PlanningStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(PlanningStatus* other);

  // implements Message ----------------------------------------------

  inline PlanningStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningStatus& from);
  void MergeFrom(const PlanningStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
  bool has_bare_intersection() const;
  void clear_bare_intersection();
  static const int kBareIntersectionFieldNumber = 1;
  const ::jmc_auto::planning::BareIntersectionStatus& bare_intersection() const;
  ::jmc_auto::planning::BareIntersectionStatus* mutable_bare_intersection();
  ::jmc_auto::planning::BareIntersectionStatus* release_bare_intersection();
  void set_allocated_bare_intersection(::jmc_auto::planning::BareIntersectionStatus* bare_intersection);

  // optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
  bool has_change_lane() const;
  void clear_change_lane();
  static const int kChangeLaneFieldNumber = 2;
  const ::jmc_auto::planning::ChangeLaneStatus& change_lane() const;
  ::jmc_auto::planning::ChangeLaneStatus* mutable_change_lane();
  ::jmc_auto::planning::ChangeLaneStatus* release_change_lane();
  void set_allocated_change_lane(::jmc_auto::planning::ChangeLaneStatus* change_lane);

  // optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 3;
  const ::jmc_auto::planning::CrosswalkStatus& crosswalk() const;
  ::jmc_auto::planning::CrosswalkStatus* mutable_crosswalk();
  ::jmc_auto::planning::CrosswalkStatus* release_crosswalk();
  void set_allocated_crosswalk(::jmc_auto::planning::CrosswalkStatus* crosswalk);

  // optional .jmc_auto.planning.DestinationStatus destination = 4;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 4;
  const ::jmc_auto::planning::DestinationStatus& destination() const;
  ::jmc_auto::planning::DestinationStatus* mutable_destination();
  ::jmc_auto::planning::DestinationStatus* release_destination();
  void set_allocated_destination(::jmc_auto::planning::DestinationStatus* destination);

  // optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
  bool has_emergency_stop() const;
  void clear_emergency_stop();
  static const int kEmergencyStopFieldNumber = 5;
  const ::jmc_auto::planning::EmergencyStopStatus& emergency_stop() const;
  ::jmc_auto::planning::EmergencyStopStatus* mutable_emergency_stop();
  ::jmc_auto::planning::EmergencyStopStatus* release_emergency_stop();
  void set_allocated_emergency_stop(::jmc_auto::planning::EmergencyStopStatus* emergency_stop);

  // optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
  bool has_open_space() const;
  void clear_open_space();
  static const int kOpenSpaceFieldNumber = 6;
  const ::jmc_auto::planning::OpenSpaceStatus& open_space() const;
  ::jmc_auto::planning::OpenSpaceStatus* mutable_open_space();
  ::jmc_auto::planning::OpenSpaceStatus* release_open_space();
  void set_allocated_open_space(::jmc_auto::planning::OpenSpaceStatus* open_space);

  // optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
  bool has_park_and_go() const;
  void clear_park_and_go();
  static const int kParkAndGoFieldNumber = 7;
  const ::jmc_auto::planning::ParkAndGoStatus& park_and_go() const;
  ::jmc_auto::planning::ParkAndGoStatus* mutable_park_and_go();
  ::jmc_auto::planning::ParkAndGoStatus* release_park_and_go();
  void set_allocated_park_and_go(::jmc_auto::planning::ParkAndGoStatus* park_and_go);

  // optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
  bool has_path_decider() const;
  void clear_path_decider();
  static const int kPathDeciderFieldNumber = 8;
  const ::jmc_auto::planning::PathDeciderStatus& path_decider() const;
  ::jmc_auto::planning::PathDeciderStatus* mutable_path_decider();
  ::jmc_auto::planning::PathDeciderStatus* release_path_decider();
  void set_allocated_path_decider(::jmc_auto::planning::PathDeciderStatus* path_decider);

  // optional .jmc_auto.planning.PullOverStatus pull_over = 9;
  bool has_pull_over() const;
  void clear_pull_over();
  static const int kPullOverFieldNumber = 9;
  const ::jmc_auto::planning::PullOverStatus& pull_over() const;
  ::jmc_auto::planning::PullOverStatus* mutable_pull_over();
  ::jmc_auto::planning::PullOverStatus* release_pull_over();
  void set_allocated_pull_over(::jmc_auto::planning::PullOverStatus* pull_over);

  // optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
  bool has_rerouting() const;
  void clear_rerouting();
  static const int kReroutingFieldNumber = 10;
  const ::jmc_auto::planning::ReroutingStatus& rerouting() const;
  ::jmc_auto::planning::ReroutingStatus* mutable_rerouting();
  ::jmc_auto::planning::ReroutingStatus* release_rerouting();
  void set_allocated_rerouting(::jmc_auto::planning::ReroutingStatus* rerouting);

  // optional .jmc_auto.planning.ScenarioStatus scenario = 11;
  bool has_scenario() const;
  void clear_scenario();
  static const int kScenarioFieldNumber = 11;
  const ::jmc_auto::planning::ScenarioStatus& scenario() const;
  ::jmc_auto::planning::ScenarioStatus* mutable_scenario();
  ::jmc_auto::planning::ScenarioStatus* release_scenario();
  void set_allocated_scenario(::jmc_auto::planning::ScenarioStatus* scenario);

  // optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
  bool has_stop_sign() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 12;
  const ::jmc_auto::planning::StopSignStatus& stop_sign() const;
  ::jmc_auto::planning::StopSignStatus* mutable_stop_sign();
  ::jmc_auto::planning::StopSignStatus* release_stop_sign();
  void set_allocated_stop_sign(::jmc_auto::planning::StopSignStatus* stop_sign);

  // optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
  bool has_traffic_light() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 13;
  const ::jmc_auto::planning::TrafficLightStatus& traffic_light() const;
  ::jmc_auto::planning::TrafficLightStatus* mutable_traffic_light();
  ::jmc_auto::planning::TrafficLightStatus* release_traffic_light();
  void set_allocated_traffic_light(::jmc_auto::planning::TrafficLightStatus* traffic_light);

  // optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
  bool has_yield_sign() const;
  void clear_yield_sign();
  static const int kYieldSignFieldNumber = 14;
  const ::jmc_auto::planning::YieldSignStatus& yield_sign() const;
  ::jmc_auto::planning::YieldSignStatus* mutable_yield_sign();
  ::jmc_auto::planning::YieldSignStatus* release_yield_sign();
  void set_allocated_yield_sign(::jmc_auto::planning::YieldSignStatus* yield_sign);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PlanningStatus)
 private:
  void set_has_bare_intersection();
  void clear_has_bare_intersection();
  void set_has_change_lane();
  void clear_has_change_lane();
  void set_has_crosswalk();
  void clear_has_crosswalk();
  void set_has_destination();
  void clear_has_destination();
  void set_has_emergency_stop();
  void clear_has_emergency_stop();
  void set_has_open_space();
  void clear_has_open_space();
  void set_has_park_and_go();
  void clear_has_park_and_go();
  void set_has_path_decider();
  void clear_has_path_decider();
  void set_has_pull_over();
  void clear_has_pull_over();
  void set_has_rerouting();
  void clear_has_rerouting();
  void set_has_scenario();
  void clear_has_scenario();
  void set_has_stop_sign();
  void clear_has_stop_sign();
  void set_has_traffic_light();
  void clear_has_traffic_light();
  void set_has_yield_sign();
  void clear_has_yield_sign();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::BareIntersectionStatus* bare_intersection_;
  ::jmc_auto::planning::ChangeLaneStatus* change_lane_;
  ::jmc_auto::planning::CrosswalkStatus* crosswalk_;
  ::jmc_auto::planning::DestinationStatus* destination_;
  ::jmc_auto::planning::EmergencyStopStatus* emergency_stop_;
  ::jmc_auto::planning::OpenSpaceStatus* open_space_;
  ::jmc_auto::planning::ParkAndGoStatus* park_and_go_;
  ::jmc_auto::planning::PathDeciderStatus* path_decider_;
  ::jmc_auto::planning::PullOverStatus* pull_over_;
  ::jmc_auto::planning::ReroutingStatus* rerouting_;
  ::jmc_auto::planning::ScenarioStatus* scenario_;
  ::jmc_auto::planning::StopSignStatus* stop_sign_;
  ::jmc_auto::planning::TrafficLightStatus* traffic_light_;
  ::jmc_auto::planning::YieldSignStatus* yield_sign_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BareIntersectionStatus

// optional string current_pnc_junction_overlap_id = 1;
inline bool BareIntersectionStatus::has_current_pnc_junction_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BareIntersectionStatus::set_has_current_pnc_junction_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BareIntersectionStatus::clear_has_current_pnc_junction_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BareIntersectionStatus::clear_current_pnc_junction_overlap_id() {
  current_pnc_junction_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_pnc_junction_overlap_id();
}
inline const ::std::string& BareIntersectionStatus::current_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return current_pnc_junction_overlap_id_.GetNoArena();
}
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const ::std::string& value) {
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
#if LANG_CXX11
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(::std::string&& value) {
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
#endif
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const char* value, size_t size) {
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
inline ::std::string* BareIntersectionStatus::mutable_current_pnc_junction_overlap_id() {
  set_has_current_pnc_junction_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return current_pnc_junction_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BareIntersectionStatus::release_current_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  clear_has_current_pnc_junction_overlap_id();
  return current_pnc_junction_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BareIntersectionStatus::set_allocated_current_pnc_junction_overlap_id(::std::string* current_pnc_junction_overlap_id) {
  if (current_pnc_junction_overlap_id != NULL) {
    set_has_current_pnc_junction_overlap_id();
  } else {
    clear_has_current_pnc_junction_overlap_id();
  }
  current_pnc_junction_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_pnc_junction_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}

// optional string done_pnc_junction_overlap_id = 2;
inline bool BareIntersectionStatus::has_done_pnc_junction_overlap_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BareIntersectionStatus::set_has_done_pnc_junction_overlap_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BareIntersectionStatus::clear_has_done_pnc_junction_overlap_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BareIntersectionStatus::clear_done_pnc_junction_overlap_id() {
  done_pnc_junction_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_done_pnc_junction_overlap_id();
}
inline const ::std::string& BareIntersectionStatus::done_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return done_pnc_junction_overlap_id_.GetNoArena();
}
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const ::std::string& value) {
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
#if LANG_CXX11
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(::std::string&& value) {
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
#endif
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const char* value, size_t size) {
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
inline ::std::string* BareIntersectionStatus::mutable_done_pnc_junction_overlap_id() {
  set_has_done_pnc_junction_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return done_pnc_junction_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BareIntersectionStatus::release_done_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  clear_has_done_pnc_junction_overlap_id();
  return done_pnc_junction_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BareIntersectionStatus::set_allocated_done_pnc_junction_overlap_id(::std::string* done_pnc_junction_overlap_id) {
  if (done_pnc_junction_overlap_id != NULL) {
    set_has_done_pnc_junction_overlap_id();
  } else {
    clear_has_done_pnc_junction_overlap_id();
  }
  done_pnc_junction_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), done_pnc_junction_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}

// -------------------------------------------------------------------

// ChangeLaneStatus

// optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
inline bool ChangeLaneStatus::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChangeLaneStatus::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChangeLaneStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChangeLaneStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::jmc_auto::planning::ChangeLaneStatus_Status ChangeLaneStatus::status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.status)
  return static_cast< ::jmc_auto::planning::ChangeLaneStatus_Status >(status_);
}
inline void ChangeLaneStatus::set_status(::jmc_auto::planning::ChangeLaneStatus_Status value) {
  assert(::jmc_auto::planning::ChangeLaneStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.status)
}

// optional string path_id = 2;
inline bool ChangeLaneStatus::has_path_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeLaneStatus::set_has_path_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeLaneStatus::clear_has_path_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeLaneStatus::clear_path_id() {
  path_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path_id();
}
inline const ::std::string& ChangeLaneStatus::path_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.path_id)
  return path_id_.GetNoArena();
}
inline void ChangeLaneStatus::set_path_id(const ::std::string& value) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.path_id)
}
#if LANG_CXX11
inline void ChangeLaneStatus::set_path_id(::std::string&& value) {
  set_has_path_id();
  path_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.ChangeLaneStatus.path_id)
}
#endif
inline void ChangeLaneStatus::set_path_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.ChangeLaneStatus.path_id)
}
inline void ChangeLaneStatus::set_path_id(const char* value, size_t size) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.ChangeLaneStatus.path_id)
}
inline ::std::string* ChangeLaneStatus::mutable_path_id() {
  set_has_path_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ChangeLaneStatus.path_id)
  return path_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeLaneStatus::release_path_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ChangeLaneStatus.path_id)
  clear_has_path_id();
  return path_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeLaneStatus::set_allocated_path_id(::std::string* path_id) {
  if (path_id != NULL) {
    set_has_path_id();
  } else {
    clear_has_path_id();
  }
  path_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ChangeLaneStatus.path_id)
}

// optional double timestamp = 3;
inline bool ChangeLaneStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeLaneStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeLaneStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeLaneStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ChangeLaneStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.timestamp)
  return timestamp_;
}
inline void ChangeLaneStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.timestamp)
}

// optional bool exist_lane_change_start_position = 4 [default = false];
inline bool ChangeLaneStatus::has_exist_lane_change_start_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeLaneStatus::set_has_exist_lane_change_start_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeLaneStatus::clear_has_exist_lane_change_start_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeLaneStatus::clear_exist_lane_change_start_position() {
  exist_lane_change_start_position_ = false;
  clear_has_exist_lane_change_start_position();
}
inline bool ChangeLaneStatus::exist_lane_change_start_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.exist_lane_change_start_position)
  return exist_lane_change_start_position_;
}
inline void ChangeLaneStatus::set_exist_lane_change_start_position(bool value) {
  set_has_exist_lane_change_start_position();
  exist_lane_change_start_position_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.exist_lane_change_start_position)
}

// optional .jmc_auto.common.Point3D lane_change_start_position = 5;
inline bool ChangeLaneStatus::has_lane_change_start_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeLaneStatus::set_has_lane_change_start_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeLaneStatus::clear_has_lane_change_start_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeLaneStatus::clear_lane_change_start_position() {
  if (lane_change_start_position_ != NULL) lane_change_start_position_->::jmc_auto::common::Point3D::Clear();
  clear_has_lane_change_start_position();
}
inline const ::jmc_auto::common::Point3D& ChangeLaneStatus::lane_change_start_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
  return lane_change_start_position_ != NULL ? *lane_change_start_position_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* ChangeLaneStatus::mutable_lane_change_start_position() {
  set_has_lane_change_start_position();
  if (lane_change_start_position_ == NULL) {
    lane_change_start_position_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
  return lane_change_start_position_;
}
inline ::jmc_auto::common::Point3D* ChangeLaneStatus::release_lane_change_start_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
  clear_has_lane_change_start_position();
  ::jmc_auto::common::Point3D* temp = lane_change_start_position_;
  lane_change_start_position_ = NULL;
  return temp;
}
inline void ChangeLaneStatus::set_allocated_lane_change_start_position(::jmc_auto::common::Point3D* lane_change_start_position) {
  delete lane_change_start_position_;
  lane_change_start_position_ = lane_change_start_position;
  if (lane_change_start_position) {
    set_has_lane_change_start_position();
  } else {
    clear_has_lane_change_start_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
}

// optional double last_succeed_timestamp = 6;
inline bool ChangeLaneStatus::has_last_succeed_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeLaneStatus::set_has_last_succeed_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeLaneStatus::clear_has_last_succeed_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeLaneStatus::clear_last_succeed_timestamp() {
  last_succeed_timestamp_ = 0;
  clear_has_last_succeed_timestamp();
}
inline double ChangeLaneStatus::last_succeed_timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.last_succeed_timestamp)
  return last_succeed_timestamp_;
}
inline void ChangeLaneStatus::set_last_succeed_timestamp(double value) {
  set_has_last_succeed_timestamp();
  last_succeed_timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.last_succeed_timestamp)
}

// optional bool is_current_opt_succeed = 7 [default = false];
inline bool ChangeLaneStatus::has_is_current_opt_succeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChangeLaneStatus::set_has_is_current_opt_succeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChangeLaneStatus::clear_has_is_current_opt_succeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChangeLaneStatus::clear_is_current_opt_succeed() {
  is_current_opt_succeed_ = false;
  clear_has_is_current_opt_succeed();
}
inline bool ChangeLaneStatus::is_current_opt_succeed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.is_current_opt_succeed)
  return is_current_opt_succeed_;
}
inline void ChangeLaneStatus::set_is_current_opt_succeed(bool value) {
  set_has_is_current_opt_succeed();
  is_current_opt_succeed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.is_current_opt_succeed)
}

// optional bool is_clear_to_change_lane = 8 [default = false];
inline bool ChangeLaneStatus::has_is_clear_to_change_lane() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChangeLaneStatus::set_has_is_clear_to_change_lane() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChangeLaneStatus::clear_has_is_clear_to_change_lane() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChangeLaneStatus::clear_is_clear_to_change_lane() {
  is_clear_to_change_lane_ = false;
  clear_has_is_clear_to_change_lane();
}
inline bool ChangeLaneStatus::is_clear_to_change_lane() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.is_clear_to_change_lane)
  return is_clear_to_change_lane_;
}
inline void ChangeLaneStatus::set_is_clear_to_change_lane(bool value) {
  set_has_is_clear_to_change_lane();
  is_clear_to_change_lane_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.is_clear_to_change_lane)
}

// -------------------------------------------------------------------

// StopTime

// optional string obstacle_id = 1;
inline bool StopTime::has_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopTime::set_has_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopTime::clear_has_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopTime::clear_obstacle_id() {
  obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_obstacle_id();
}
inline const ::std::string& StopTime::obstacle_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopTime.obstacle_id)
  return obstacle_id_.GetNoArena();
}
inline void StopTime::set_obstacle_id(const ::std::string& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopTime.obstacle_id)
}
#if LANG_CXX11
inline void StopTime::set_obstacle_id(::std::string&& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.StopTime.obstacle_id)
}
#endif
inline void StopTime::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopTime.obstacle_id)
}
inline void StopTime::set_obstacle_id(const char* value, size_t size) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopTime.obstacle_id)
}
inline ::std::string* StopTime::mutable_obstacle_id() {
  set_has_obstacle_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopTime.obstacle_id)
  return obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopTime::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StopTime.obstacle_id)
  clear_has_obstacle_id();
  return obstacle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopTime::set_allocated_obstacle_id(::std::string* obstacle_id) {
  if (obstacle_id != NULL) {
    set_has_obstacle_id();
  } else {
    clear_has_obstacle_id();
  }
  obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StopTime.obstacle_id)
}

// optional double obstacle_stop_timestamp = 2;
inline bool StopTime::has_obstacle_stop_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopTime::set_has_obstacle_stop_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopTime::clear_has_obstacle_stop_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopTime::clear_obstacle_stop_timestamp() {
  obstacle_stop_timestamp_ = 0;
  clear_has_obstacle_stop_timestamp();
}
inline double StopTime::obstacle_stop_timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopTime.obstacle_stop_timestamp)
  return obstacle_stop_timestamp_;
}
inline void StopTime::set_obstacle_stop_timestamp(double value) {
  set_has_obstacle_stop_timestamp();
  obstacle_stop_timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopTime.obstacle_stop_timestamp)
}

// -------------------------------------------------------------------

// CrosswalkStatus

// optional string crosswalk_id = 1;
inline bool CrosswalkStatus::has_crosswalk_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkStatus::set_has_crosswalk_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkStatus::clear_has_crosswalk_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkStatus::clear_crosswalk_id() {
  crosswalk_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_crosswalk_id();
}
inline const ::std::string& CrosswalkStatus::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
  return crosswalk_id_.GetNoArena();
}
inline void CrosswalkStatus::set_crosswalk_id(const ::std::string& value) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
#if LANG_CXX11
inline void CrosswalkStatus::set_crosswalk_id(::std::string&& value) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
#endif
inline void CrosswalkStatus::set_crosswalk_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
inline void CrosswalkStatus::set_crosswalk_id(const char* value, size_t size) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
inline ::std::string* CrosswalkStatus::mutable_crosswalk_id() {
  set_has_crosswalk_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
  return crosswalk_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrosswalkStatus::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
  clear_has_crosswalk_id();
  return crosswalk_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrosswalkStatus::set_allocated_crosswalk_id(::std::string* crosswalk_id) {
  if (crosswalk_id != NULL) {
    set_has_crosswalk_id();
  } else {
    clear_has_crosswalk_id();
  }
  crosswalk_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crosswalk_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}

// repeated .jmc_auto.planning.StopTime stop_time = 2;
inline int CrosswalkStatus::stop_time_size() const {
  return stop_time_.size();
}
inline void CrosswalkStatus::clear_stop_time() {
  stop_time_.Clear();
}
inline const ::jmc_auto::planning::StopTime& CrosswalkStatus::stop_time(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_.Get(index);
}
inline ::jmc_auto::planning::StopTime* CrosswalkStatus::mutable_stop_time(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_.Mutable(index);
}
inline ::jmc_auto::planning::StopTime* CrosswalkStatus::add_stop_time() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime >*
CrosswalkStatus::mutable_stop_time() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.CrosswalkStatus.stop_time)
  return &stop_time_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime >&
CrosswalkStatus::stop_time() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_;
}

// repeated string finished_crosswalk = 3;
inline int CrosswalkStatus::finished_crosswalk_size() const {
  return finished_crosswalk_.size();
}
inline void CrosswalkStatus::clear_finished_crosswalk() {
  finished_crosswalk_.Clear();
}
inline const ::std::string& CrosswalkStatus::finished_crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Get(index);
}
inline ::std::string* CrosswalkStatus::mutable_finished_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Mutable(index);
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  finished_crosswalk_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CrosswalkStatus::set_finished_crosswalk(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  finished_crosswalk_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CrosswalkStatus::set_finished_crosswalk(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  finished_crosswalk_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::set_finished_crosswalk(int index, const char* value, size_t size) {
  finished_crosswalk_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
inline ::std::string* CrosswalkStatus::add_finished_crosswalk() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Add();
}
inline void CrosswalkStatus::add_finished_crosswalk(const ::std::string& value) {
  finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
#if LANG_CXX11
inline void CrosswalkStatus::add_finished_crosswalk(::std::string&& value) {
  finished_crosswalk_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
#endif
inline void CrosswalkStatus::add_finished_crosswalk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
inline void CrosswalkStatus::add_finished_crosswalk(const char* value, size_t size) {
  finished_crosswalk_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CrosswalkStatus::finished_crosswalk() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CrosswalkStatus::mutable_finished_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return &finished_crosswalk_;
}

// -------------------------------------------------------------------

// DestinationStatus

// optional bool has_passed_destination = 1 [default = false];
inline bool DestinationStatus::has_has_passed_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DestinationStatus::set_has_has_passed_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DestinationStatus::clear_has_has_passed_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DestinationStatus::clear_has_passed_destination() {
  has_passed_destination_ = false;
  clear_has_has_passed_destination();
}
inline bool DestinationStatus::has_passed_destination() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.DestinationStatus.has_passed_destination)
  return has_passed_destination_;
}
inline void DestinationStatus::set_has_passed_destination(bool value) {
  set_has_has_passed_destination();
  has_passed_destination_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.DestinationStatus.has_passed_destination)
}

// -------------------------------------------------------------------

// EmergencyStopStatus

// optional .jmc_auto.common.PointENU stop_fence_point = 1;
inline bool EmergencyStopStatus::has_stop_fence_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmergencyStopStatus::set_has_stop_fence_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmergencyStopStatus::clear_has_stop_fence_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmergencyStopStatus::clear_stop_fence_point() {
  if (stop_fence_point_ != NULL) stop_fence_point_->::jmc_auto::common::PointENU::Clear();
  clear_has_stop_fence_point();
}
inline const ::jmc_auto::common::PointENU& EmergencyStopStatus::stop_fence_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
  return stop_fence_point_ != NULL ? *stop_fence_point_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
inline ::jmc_auto::common::PointENU* EmergencyStopStatus::mutable_stop_fence_point() {
  set_has_stop_fence_point();
  if (stop_fence_point_ == NULL) {
    stop_fence_point_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
  return stop_fence_point_;
}
inline ::jmc_auto::common::PointENU* EmergencyStopStatus::release_stop_fence_point() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
  clear_has_stop_fence_point();
  ::jmc_auto::common::PointENU* temp = stop_fence_point_;
  stop_fence_point_ = NULL;
  return temp;
}
inline void EmergencyStopStatus::set_allocated_stop_fence_point(::jmc_auto::common::PointENU* stop_fence_point) {
  delete stop_fence_point_;
  stop_fence_point_ = stop_fence_point;
  if (stop_fence_point) {
    set_has_stop_fence_point();
  } else {
    clear_has_stop_fence_point();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
}

// -------------------------------------------------------------------

// OpenSpaceStatus

// repeated string partitioned_trajectories_index_history = 1;
inline int OpenSpaceStatus::partitioned_trajectories_index_history_size() const {
  return partitioned_trajectories_index_history_.size();
}
inline void OpenSpaceStatus::clear_partitioned_trajectories_index_history() {
  partitioned_trajectories_index_history_.Clear();
}
inline const ::std::string& OpenSpaceStatus::partitioned_trajectories_index_history(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_.Get(index);
}
inline ::std::string* OpenSpaceStatus::mutable_partitioned_trajectories_index_history(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_.Mutable(index);
}
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  partitioned_trajectories_index_history_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  partitioned_trajectories_index_history_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  partitioned_trajectories_index_history_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const char* value, size_t size) {
  partitioned_trajectories_index_history_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline ::std::string* OpenSpaceStatus::add_partitioned_trajectories_index_history() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_.Add();
}
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(const ::std::string& value) {
  partitioned_trajectories_index_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
#if LANG_CXX11
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(::std::string&& value) {
  partitioned_trajectories_index_history_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
#endif
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  partitioned_trajectories_index_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline void OpenSpaceStatus::add_partitioned_trajectories_index_history(const char* value, size_t size) {
  partitioned_trajectories_index_history_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpenSpaceStatus::partitioned_trajectories_index_history() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OpenSpaceStatus::mutable_partitioned_trajectories_index_history() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return &partitioned_trajectories_index_history_;
}

// optional bool position_init = 2 [default = false];
inline bool OpenSpaceStatus::has_position_init() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenSpaceStatus::set_has_position_init() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenSpaceStatus::clear_has_position_init() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenSpaceStatus::clear_position_init() {
  position_init_ = false;
  clear_has_position_init();
}
inline bool OpenSpaceStatus::position_init() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceStatus.position_init)
  return position_init_;
}
inline void OpenSpaceStatus::set_position_init(bool value) {
  set_has_position_init();
  position_init_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceStatus.position_init)
}

// -------------------------------------------------------------------

// ParkAndGoStatus

// optional .jmc_auto.common.PointENU adc_init_position = 1;
inline bool ParkAndGoStatus::has_adc_init_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkAndGoStatus::set_has_adc_init_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkAndGoStatus::clear_has_adc_init_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkAndGoStatus::clear_adc_init_position() {
  if (adc_init_position_ != NULL) adc_init_position_->::jmc_auto::common::PointENU::Clear();
  clear_has_adc_init_position();
}
inline const ::jmc_auto::common::PointENU& ParkAndGoStatus::adc_init_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
  return adc_init_position_ != NULL ? *adc_init_position_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
inline ::jmc_auto::common::PointENU* ParkAndGoStatus::mutable_adc_init_position() {
  set_has_adc_init_position();
  if (adc_init_position_ == NULL) {
    adc_init_position_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
  return adc_init_position_;
}
inline ::jmc_auto::common::PointENU* ParkAndGoStatus::release_adc_init_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
  clear_has_adc_init_position();
  ::jmc_auto::common::PointENU* temp = adc_init_position_;
  adc_init_position_ = NULL;
  return temp;
}
inline void ParkAndGoStatus::set_allocated_adc_init_position(::jmc_auto::common::PointENU* adc_init_position) {
  delete adc_init_position_;
  adc_init_position_ = adc_init_position;
  if (adc_init_position) {
    set_has_adc_init_position();
  } else {
    clear_has_adc_init_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
}

// optional double adc_init_heading = 2;
inline bool ParkAndGoStatus::has_adc_init_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParkAndGoStatus::set_has_adc_init_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParkAndGoStatus::clear_has_adc_init_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParkAndGoStatus::clear_adc_init_heading() {
  adc_init_heading_ = 0;
  clear_has_adc_init_heading();
}
inline double ParkAndGoStatus::adc_init_heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.adc_init_heading)
  return adc_init_heading_;
}
inline void ParkAndGoStatus::set_adc_init_heading(double value) {
  set_has_adc_init_heading();
  adc_init_heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ParkAndGoStatus.adc_init_heading)
}

// optional bool in_check_stage = 3;
inline bool ParkAndGoStatus::has_in_check_stage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParkAndGoStatus::set_has_in_check_stage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParkAndGoStatus::clear_has_in_check_stage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParkAndGoStatus::clear_in_check_stage() {
  in_check_stage_ = false;
  clear_has_in_check_stage();
}
inline bool ParkAndGoStatus::in_check_stage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.in_check_stage)
  return in_check_stage_;
}
inline void ParkAndGoStatus::set_in_check_stage(bool value) {
  set_has_in_check_stage();
  in_check_stage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ParkAndGoStatus.in_check_stage)
}

// optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
inline bool ParkAndGoStatus::has_adc_adjust_end_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkAndGoStatus::set_has_adc_adjust_end_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkAndGoStatus::clear_has_adc_adjust_end_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkAndGoStatus::clear_adc_adjust_end_pose() {
  if (adc_adjust_end_pose_ != NULL) adc_adjust_end_pose_->::jmc_auto::common::PointENU::Clear();
  clear_has_adc_adjust_end_pose();
}
inline const ::jmc_auto::common::PointENU& ParkAndGoStatus::adc_adjust_end_pose() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
  return adc_adjust_end_pose_ != NULL ? *adc_adjust_end_pose_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
inline ::jmc_auto::common::PointENU* ParkAndGoStatus::mutable_adc_adjust_end_pose() {
  set_has_adc_adjust_end_pose();
  if (adc_adjust_end_pose_ == NULL) {
    adc_adjust_end_pose_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
  return adc_adjust_end_pose_;
}
inline ::jmc_auto::common::PointENU* ParkAndGoStatus::release_adc_adjust_end_pose() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
  clear_has_adc_adjust_end_pose();
  ::jmc_auto::common::PointENU* temp = adc_adjust_end_pose_;
  adc_adjust_end_pose_ = NULL;
  return temp;
}
inline void ParkAndGoStatus::set_allocated_adc_adjust_end_pose(::jmc_auto::common::PointENU* adc_adjust_end_pose) {
  delete adc_adjust_end_pose_;
  adc_adjust_end_pose_ = adc_adjust_end_pose;
  if (adc_adjust_end_pose) {
    set_has_adc_adjust_end_pose();
  } else {
    clear_has_adc_adjust_end_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
}

// -------------------------------------------------------------------

// PathDeciderStatus

// optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
inline bool PathDeciderStatus::has_front_static_obstacle_cycle_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathDeciderStatus::set_has_front_static_obstacle_cycle_counter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathDeciderStatus::clear_has_front_static_obstacle_cycle_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathDeciderStatus::clear_front_static_obstacle_cycle_counter() {
  front_static_obstacle_cycle_counter_ = 0;
  clear_has_front_static_obstacle_cycle_counter();
}
inline ::google::protobuf::int32 PathDeciderStatus::front_static_obstacle_cycle_counter() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_cycle_counter)
  return front_static_obstacle_cycle_counter_;
}
inline void PathDeciderStatus::set_front_static_obstacle_cycle_counter(::google::protobuf::int32 value) {
  set_has_front_static_obstacle_cycle_counter();
  front_static_obstacle_cycle_counter_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_cycle_counter)
}

// optional int32 able_to_use_self_lane_counter = 2 [default = 0];
inline bool PathDeciderStatus::has_able_to_use_self_lane_counter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathDeciderStatus::set_has_able_to_use_self_lane_counter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathDeciderStatus::clear_has_able_to_use_self_lane_counter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathDeciderStatus::clear_able_to_use_self_lane_counter() {
  able_to_use_self_lane_counter_ = 0;
  clear_has_able_to_use_self_lane_counter();
}
inline ::google::protobuf::int32 PathDeciderStatus::able_to_use_self_lane_counter() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.able_to_use_self_lane_counter)
  return able_to_use_self_lane_counter_;
}
inline void PathDeciderStatus::set_able_to_use_self_lane_counter(::google::protobuf::int32 value) {
  set_has_able_to_use_self_lane_counter();
  able_to_use_self_lane_counter_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.able_to_use_self_lane_counter)
}

// optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
inline bool PathDeciderStatus::has_is_in_path_lane_borrow_scenario() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PathDeciderStatus::set_has_is_in_path_lane_borrow_scenario() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PathDeciderStatus::clear_has_is_in_path_lane_borrow_scenario() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PathDeciderStatus::clear_is_in_path_lane_borrow_scenario() {
  is_in_path_lane_borrow_scenario_ = false;
  clear_has_is_in_path_lane_borrow_scenario();
}
inline bool PathDeciderStatus::is_in_path_lane_borrow_scenario() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.is_in_path_lane_borrow_scenario)
  return is_in_path_lane_borrow_scenario_;
}
inline void PathDeciderStatus::set_is_in_path_lane_borrow_scenario(bool value) {
  set_has_is_in_path_lane_borrow_scenario();
  is_in_path_lane_borrow_scenario_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.is_in_path_lane_borrow_scenario)
}

// optional string front_static_obstacle_id = 4 [default = ""];
inline bool PathDeciderStatus::has_front_static_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathDeciderStatus::set_has_front_static_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathDeciderStatus::clear_has_front_static_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathDeciderStatus::clear_front_static_obstacle_id() {
  front_static_obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_front_static_obstacle_id();
}
inline const ::std::string& PathDeciderStatus::front_static_obstacle_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
  return front_static_obstacle_id_.GetNoArena();
}
inline void PathDeciderStatus::set_front_static_obstacle_id(const ::std::string& value) {
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
#if LANG_CXX11
inline void PathDeciderStatus::set_front_static_obstacle_id(::std::string&& value) {
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
#endif
inline void PathDeciderStatus::set_front_static_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
inline void PathDeciderStatus::set_front_static_obstacle_id(const char* value, size_t size) {
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
inline ::std::string* PathDeciderStatus::mutable_front_static_obstacle_id() {
  set_has_front_static_obstacle_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
  return front_static_obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PathDeciderStatus::release_front_static_obstacle_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
  clear_has_front_static_obstacle_id();
  return front_static_obstacle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PathDeciderStatus::set_allocated_front_static_obstacle_id(::std::string* front_static_obstacle_id) {
  if (front_static_obstacle_id != NULL) {
    set_has_front_static_obstacle_id();
  } else {
    clear_has_front_static_obstacle_id();
  }
  front_static_obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), front_static_obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}

// repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
inline int PathDeciderStatus::decided_side_pass_direction_size() const {
  return decided_side_pass_direction_.size();
}
inline void PathDeciderStatus::clear_decided_side_pass_direction() {
  decided_side_pass_direction_.Clear();
}
inline ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::decided_side_pass_direction(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
  return static_cast< ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection >(decided_side_pass_direction_.Get(index));
}
inline void PathDeciderStatus::set_decided_side_pass_direction(int index, ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection value) {
  assert(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value));
  decided_side_pass_direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
}
inline void PathDeciderStatus::add_decided_side_pass_direction(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection value) {
  assert(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value));
  decided_side_pass_direction_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
}
inline const ::google::protobuf::RepeatedField<int>&
PathDeciderStatus::decided_side_pass_direction() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
  return decided_side_pass_direction_;
}
inline ::google::protobuf::RepeatedField<int>*
PathDeciderStatus::mutable_decided_side_pass_direction() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
  return &decided_side_pass_direction_;
}

// -------------------------------------------------------------------

// PullOverStatus

// optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
inline bool PullOverStatus::has_pull_over_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PullOverStatus::set_has_pull_over_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PullOverStatus::clear_has_pull_over_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PullOverStatus::clear_pull_over_type() {
  pull_over_type_ = 1;
  clear_has_pull_over_type();
}
inline ::jmc_auto::planning::PullOverStatus_PullOverType PullOverStatus::pull_over_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.pull_over_type)
  return static_cast< ::jmc_auto::planning::PullOverStatus_PullOverType >(pull_over_type_);
}
inline void PullOverStatus::set_pull_over_type(::jmc_auto::planning::PullOverStatus_PullOverType value) {
  assert(::jmc_auto::planning::PullOverStatus_PullOverType_IsValid(value));
  set_has_pull_over_type();
  pull_over_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.pull_over_type)
}

// optional bool plan_pull_over_path = 2 [default = false];
inline bool PullOverStatus::has_plan_pull_over_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PullOverStatus::set_has_plan_pull_over_path() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PullOverStatus::clear_has_plan_pull_over_path() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PullOverStatus::clear_plan_pull_over_path() {
  plan_pull_over_path_ = false;
  clear_has_plan_pull_over_path();
}
inline bool PullOverStatus::plan_pull_over_path() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.plan_pull_over_path)
  return plan_pull_over_path_;
}
inline void PullOverStatus::set_plan_pull_over_path(bool value) {
  set_has_plan_pull_over_path();
  plan_pull_over_path_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.plan_pull_over_path)
}

// optional .jmc_auto.common.PointENU position = 3;
inline bool PullOverStatus::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PullOverStatus::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PullOverStatus::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PullOverStatus::clear_position() {
  if (position_ != NULL) position_->::jmc_auto::common::PointENU::Clear();
  clear_has_position();
}
inline const ::jmc_auto::common::PointENU& PullOverStatus::position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.position)
  return position_ != NULL ? *position_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
inline ::jmc_auto::common::PointENU* PullOverStatus::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PullOverStatus.position)
  return position_;
}
inline ::jmc_auto::common::PointENU* PullOverStatus::release_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PullOverStatus.position)
  clear_has_position();
  ::jmc_auto::common::PointENU* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PullOverStatus::set_allocated_position(::jmc_auto::common::PointENU* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PullOverStatus.position)
}

// optional double theta = 4;
inline bool PullOverStatus::has_theta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PullOverStatus::set_has_theta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PullOverStatus::clear_has_theta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PullOverStatus::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double PullOverStatus::theta() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.theta)
  return theta_;
}
inline void PullOverStatus::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.theta)
}

// optional double length_front = 5;
inline bool PullOverStatus::has_length_front() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PullOverStatus::set_has_length_front() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PullOverStatus::clear_has_length_front() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PullOverStatus::clear_length_front() {
  length_front_ = 0;
  clear_has_length_front();
}
inline double PullOverStatus::length_front() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.length_front)
  return length_front_;
}
inline void PullOverStatus::set_length_front(double value) {
  set_has_length_front();
  length_front_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.length_front)
}

// optional double length_back = 6;
inline bool PullOverStatus::has_length_back() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PullOverStatus::set_has_length_back() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PullOverStatus::clear_has_length_back() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PullOverStatus::clear_length_back() {
  length_back_ = 0;
  clear_has_length_back();
}
inline double PullOverStatus::length_back() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.length_back)
  return length_back_;
}
inline void PullOverStatus::set_length_back(double value) {
  set_has_length_back();
  length_back_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.length_back)
}

// optional double width_left = 7;
inline bool PullOverStatus::has_width_left() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PullOverStatus::set_has_width_left() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PullOverStatus::clear_has_width_left() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PullOverStatus::clear_width_left() {
  width_left_ = 0;
  clear_has_width_left();
}
inline double PullOverStatus::width_left() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.width_left)
  return width_left_;
}
inline void PullOverStatus::set_width_left(double value) {
  set_has_width_left();
  width_left_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.width_left)
}

// optional double width_right = 8;
inline bool PullOverStatus::has_width_right() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PullOverStatus::set_has_width_right() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PullOverStatus::clear_has_width_right() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PullOverStatus::clear_width_right() {
  width_right_ = 0;
  clear_has_width_right();
}
inline double PullOverStatus::width_right() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.width_right)
  return width_right_;
}
inline void PullOverStatus::set_width_right(double value) {
  set_has_width_right();
  width_right_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.width_right)
}

// -------------------------------------------------------------------

// ReroutingStatus

// optional double last_rerouting_time = 1;
inline bool ReroutingStatus::has_last_rerouting_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReroutingStatus::set_has_last_rerouting_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReroutingStatus::clear_has_last_rerouting_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReroutingStatus::clear_last_rerouting_time() {
  last_rerouting_time_ = 0;
  clear_has_last_rerouting_time();
}
inline double ReroutingStatus::last_rerouting_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingStatus.last_rerouting_time)
  return last_rerouting_time_;
}
inline void ReroutingStatus::set_last_rerouting_time(double value) {
  set_has_last_rerouting_time();
  last_rerouting_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReroutingStatus.last_rerouting_time)
}

// optional bool need_rerouting = 2 [default = false];
inline bool ReroutingStatus::has_need_rerouting() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReroutingStatus::set_has_need_rerouting() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReroutingStatus::clear_has_need_rerouting() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReroutingStatus::clear_need_rerouting() {
  need_rerouting_ = false;
  clear_has_need_rerouting();
}
inline bool ReroutingStatus::need_rerouting() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingStatus.need_rerouting)
  return need_rerouting_;
}
inline void ReroutingStatus::set_need_rerouting(bool value) {
  set_has_need_rerouting();
  need_rerouting_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReroutingStatus.need_rerouting)
}

// optional .jmc_auto.routing.RoutingRequest routing_request = 3;
inline bool ReroutingStatus::has_routing_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReroutingStatus::set_has_routing_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReroutingStatus::clear_has_routing_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReroutingStatus::clear_routing_request() {
  if (routing_request_ != NULL) routing_request_->::jmc_auto::routing::RoutingRequest::Clear();
  clear_has_routing_request();
}
inline const ::jmc_auto::routing::RoutingRequest& ReroutingStatus::routing_request() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingStatus.routing_request)
  return routing_request_ != NULL ? *routing_request_
                         : *::jmc_auto::routing::RoutingRequest::internal_default_instance();
}
inline ::jmc_auto::routing::RoutingRequest* ReroutingStatus::mutable_routing_request() {
  set_has_routing_request();
  if (routing_request_ == NULL) {
    routing_request_ = new ::jmc_auto::routing::RoutingRequest;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ReroutingStatus.routing_request)
  return routing_request_;
}
inline ::jmc_auto::routing::RoutingRequest* ReroutingStatus::release_routing_request() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ReroutingStatus.routing_request)
  clear_has_routing_request();
  ::jmc_auto::routing::RoutingRequest* temp = routing_request_;
  routing_request_ = NULL;
  return temp;
}
inline void ReroutingStatus::set_allocated_routing_request(::jmc_auto::routing::RoutingRequest* routing_request) {
  delete routing_request_;
  routing_request_ = routing_request;
  if (routing_request) {
    set_has_routing_request();
  } else {
    clear_has_routing_request();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ReroutingStatus.routing_request)
}

// -------------------------------------------------------------------

// ScenarioStatus

// optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline bool ScenarioStatus::has_scenario_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioStatus::set_has_scenario_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioStatus::clear_has_scenario_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioStatus::clear_scenario_type() {
  scenario_type_ = 0;
  clear_has_scenario_type();
}
inline ::jmc_auto::planning::ScenarioConfig_ScenarioType ScenarioStatus::scenario_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStatus.scenario_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
inline void ScenarioStatus::set_scenario_type(::jmc_auto::planning::ScenarioConfig_ScenarioType value) {
  assert(::jmc_auto::planning::ScenarioConfig_ScenarioType_IsValid(value));
  set_has_scenario_type();
  scenario_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStatus.scenario_type)
}

// optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
inline bool ScenarioStatus::has_stage_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioStatus::set_has_stage_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioStatus::clear_has_stage_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioStatus::clear_stage_type() {
  stage_type_ = 0;
  clear_has_stage_type();
}
inline ::jmc_auto::planning::ScenarioConfig_StageType ScenarioStatus::stage_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStatus.stage_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(stage_type_);
}
inline void ScenarioStatus::set_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  set_has_stage_type();
  stage_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStatus.stage_type)
}

// -------------------------------------------------------------------

// StopSignStatus

// optional string current_stop_sign_overlap_id = 1;
inline bool StopSignStatus::has_current_stop_sign_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSignStatus::set_has_current_stop_sign_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSignStatus::clear_has_current_stop_sign_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSignStatus::clear_current_stop_sign_overlap_id() {
  current_stop_sign_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_stop_sign_overlap_id();
}
inline const ::std::string& StopSignStatus::current_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
  return current_stop_sign_overlap_id_.GetNoArena();
}
inline void StopSignStatus::set_current_stop_sign_overlap_id(const ::std::string& value) {
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
#if LANG_CXX11
inline void StopSignStatus::set_current_stop_sign_overlap_id(::std::string&& value) {
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
#endif
inline void StopSignStatus::set_current_stop_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline void StopSignStatus::set_current_stop_sign_overlap_id(const char* value, size_t size) {
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
inline ::std::string* StopSignStatus::mutable_current_stop_sign_overlap_id() {
  set_has_current_stop_sign_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
  return current_stop_sign_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopSignStatus::release_current_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
  clear_has_current_stop_sign_overlap_id();
  return current_stop_sign_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus::set_allocated_current_stop_sign_overlap_id(::std::string* current_stop_sign_overlap_id) {
  if (current_stop_sign_overlap_id != NULL) {
    set_has_current_stop_sign_overlap_id();
  } else {
    clear_has_current_stop_sign_overlap_id();
  }
  current_stop_sign_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_stop_sign_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}

// optional string done_stop_sign_overlap_id = 2;
inline bool StopSignStatus::has_done_stop_sign_overlap_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopSignStatus::set_has_done_stop_sign_overlap_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopSignStatus::clear_has_done_stop_sign_overlap_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopSignStatus::clear_done_stop_sign_overlap_id() {
  done_stop_sign_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_done_stop_sign_overlap_id();
}
inline const ::std::string& StopSignStatus::done_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
  return done_stop_sign_overlap_id_.GetNoArena();
}
inline void StopSignStatus::set_done_stop_sign_overlap_id(const ::std::string& value) {
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
#if LANG_CXX11
inline void StopSignStatus::set_done_stop_sign_overlap_id(::std::string&& value) {
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
#endif
inline void StopSignStatus::set_done_stop_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline void StopSignStatus::set_done_stop_sign_overlap_id(const char* value, size_t size) {
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
inline ::std::string* StopSignStatus::mutable_done_stop_sign_overlap_id() {
  set_has_done_stop_sign_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
  return done_stop_sign_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopSignStatus::release_done_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
  clear_has_done_stop_sign_overlap_id();
  return done_stop_sign_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus::set_allocated_done_stop_sign_overlap_id(::std::string* done_stop_sign_overlap_id) {
  if (done_stop_sign_overlap_id != NULL) {
    set_has_done_stop_sign_overlap_id();
  } else {
    clear_has_done_stop_sign_overlap_id();
  }
  done_stop_sign_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), done_stop_sign_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}

// repeated string wait_for_obstacle_id = 3;
inline int StopSignStatus::wait_for_obstacle_id_size() const {
  return wait_for_obstacle_id_.size();
}
inline void StopSignStatus::clear_wait_for_obstacle_id() {
  wait_for_obstacle_id_.Clear();
}
inline const ::std::string& StopSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Get(index);
}
inline ::std::string* StopSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Mutable(index);
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StopSignStatus::set_wait_for_obstacle_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
inline ::std::string* StopSignStatus::add_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Add();
}
inline void StopSignStatus::add_wait_for_obstacle_id(const ::std::string& value) {
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
#if LANG_CXX11
inline void StopSignStatus::add_wait_for_obstacle_id(::std::string&& value) {
  wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
#endif
inline void StopSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
inline void StopSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StopSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StopSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return &wait_for_obstacle_id_;
}

// -------------------------------------------------------------------

// TrafficLightStatus

// repeated string current_traffic_light_overlap_id = 1;
inline int TrafficLightStatus::current_traffic_light_overlap_id_size() const {
  return current_traffic_light_overlap_id_.size();
}
inline void TrafficLightStatus::clear_current_traffic_light_overlap_id() {
  current_traffic_light_overlap_id_.Clear();
}
inline const ::std::string& TrafficLightStatus::current_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Get(index);
}
inline ::std::string* TrafficLightStatus::mutable_current_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Mutable(index);
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  current_traffic_light_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  current_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value, size_t size) {
  current_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline ::std::string* TrafficLightStatus::add_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Add();
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const ::std::string& value) {
  current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
#if LANG_CXX11
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(::std::string&& value) {
  current_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
#endif
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value, size_t size) {
  current_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficLightStatus::current_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficLightStatus::mutable_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return &current_traffic_light_overlap_id_;
}

// repeated string done_traffic_light_overlap_id = 2;
inline int TrafficLightStatus::done_traffic_light_overlap_id_size() const {
  return done_traffic_light_overlap_id_.size();
}
inline void TrafficLightStatus::clear_done_traffic_light_overlap_id() {
  done_traffic_light_overlap_id_.Clear();
}
inline const ::std::string& TrafficLightStatus::done_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Get(index);
}
inline ::std::string* TrafficLightStatus::mutable_done_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Mutable(index);
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  done_traffic_light_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  done_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value, size_t size) {
  done_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline ::std::string* TrafficLightStatus::add_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Add();
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const ::std::string& value) {
  done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
#if LANG_CXX11
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(::std::string&& value) {
  done_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
#endif
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value, size_t size) {
  done_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficLightStatus::done_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficLightStatus::mutable_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return &done_traffic_light_overlap_id_;
}

// -------------------------------------------------------------------

// YieldSignStatus

// repeated string current_yield_sign_overlap_id = 1;
inline int YieldSignStatus::current_yield_sign_overlap_id_size() const {
  return current_yield_sign_overlap_id_.size();
}
inline void YieldSignStatus::clear_current_yield_sign_overlap_id() {
  current_yield_sign_overlap_id_.Clear();
}
inline const ::std::string& YieldSignStatus::current_yield_sign_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_.Get(index);
}
inline ::std::string* YieldSignStatus::mutable_current_yield_sign_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_.Mutable(index);
}
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  current_yield_sign_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  current_yield_sign_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const char* value, size_t size) {
  current_yield_sign_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline ::std::string* YieldSignStatus::add_current_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_.Add();
}
inline void YieldSignStatus::add_current_yield_sign_overlap_id(const ::std::string& value) {
  current_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
#if LANG_CXX11
inline void YieldSignStatus::add_current_yield_sign_overlap_id(::std::string&& value) {
  current_yield_sign_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
#endif
inline void YieldSignStatus::add_current_yield_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_current_yield_sign_overlap_id(const char* value, size_t size) {
  current_yield_sign_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YieldSignStatus::current_yield_sign_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YieldSignStatus::mutable_current_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return &current_yield_sign_overlap_id_;
}

// repeated string done_yield_sign_overlap_id = 2;
inline int YieldSignStatus::done_yield_sign_overlap_id_size() const {
  return done_yield_sign_overlap_id_.size();
}
inline void YieldSignStatus::clear_done_yield_sign_overlap_id() {
  done_yield_sign_overlap_id_.Clear();
}
inline const ::std::string& YieldSignStatus::done_yield_sign_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_.Get(index);
}
inline ::std::string* YieldSignStatus::mutable_done_yield_sign_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_.Mutable(index);
}
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  done_yield_sign_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  done_yield_sign_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const char* value, size_t size) {
  done_yield_sign_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline ::std::string* YieldSignStatus::add_done_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_.Add();
}
inline void YieldSignStatus::add_done_yield_sign_overlap_id(const ::std::string& value) {
  done_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
#if LANG_CXX11
inline void YieldSignStatus::add_done_yield_sign_overlap_id(::std::string&& value) {
  done_yield_sign_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
#endif
inline void YieldSignStatus::add_done_yield_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline void YieldSignStatus::add_done_yield_sign_overlap_id(const char* value, size_t size) {
  done_yield_sign_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YieldSignStatus::done_yield_sign_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YieldSignStatus::mutable_done_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return &done_yield_sign_overlap_id_;
}

// repeated string wait_for_obstacle_id = 3;
inline int YieldSignStatus::wait_for_obstacle_id_size() const {
  return wait_for_obstacle_id_.size();
}
inline void YieldSignStatus::clear_wait_for_obstacle_id() {
  wait_for_obstacle_id_.Clear();
}
inline const ::std::string& YieldSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Get(index);
}
inline ::std::string* YieldSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Mutable(index);
}
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline ::std::string* YieldSignStatus::add_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Add();
}
inline void YieldSignStatus::add_wait_for_obstacle_id(const ::std::string& value) {
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
#if LANG_CXX11
inline void YieldSignStatus::add_wait_for_obstacle_id(::std::string&& value) {
  wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
#endif
inline void YieldSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline void YieldSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YieldSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YieldSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return &wait_for_obstacle_id_;
}

// -------------------------------------------------------------------

// PlanningStatus

// optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
inline bool PlanningStatus::has_bare_intersection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningStatus::set_has_bare_intersection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningStatus::clear_has_bare_intersection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningStatus::clear_bare_intersection() {
  if (bare_intersection_ != NULL) bare_intersection_->::jmc_auto::planning::BareIntersectionStatus::Clear();
  clear_has_bare_intersection();
}
inline const ::jmc_auto::planning::BareIntersectionStatus& PlanningStatus::bare_intersection() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.bare_intersection)
  return bare_intersection_ != NULL ? *bare_intersection_
                         : *::jmc_auto::planning::BareIntersectionStatus::internal_default_instance();
}
inline ::jmc_auto::planning::BareIntersectionStatus* PlanningStatus::mutable_bare_intersection() {
  set_has_bare_intersection();
  if (bare_intersection_ == NULL) {
    bare_intersection_ = new ::jmc_auto::planning::BareIntersectionStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.bare_intersection)
  return bare_intersection_;
}
inline ::jmc_auto::planning::BareIntersectionStatus* PlanningStatus::release_bare_intersection() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.bare_intersection)
  clear_has_bare_intersection();
  ::jmc_auto::planning::BareIntersectionStatus* temp = bare_intersection_;
  bare_intersection_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_bare_intersection(::jmc_auto::planning::BareIntersectionStatus* bare_intersection) {
  delete bare_intersection_;
  bare_intersection_ = bare_intersection;
  if (bare_intersection) {
    set_has_bare_intersection();
  } else {
    clear_has_bare_intersection();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.bare_intersection)
}

// optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
inline bool PlanningStatus::has_change_lane() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningStatus::set_has_change_lane() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningStatus::clear_has_change_lane() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningStatus::clear_change_lane() {
  if (change_lane_ != NULL) change_lane_->::jmc_auto::planning::ChangeLaneStatus::Clear();
  clear_has_change_lane();
}
inline const ::jmc_auto::planning::ChangeLaneStatus& PlanningStatus::change_lane() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.change_lane)
  return change_lane_ != NULL ? *change_lane_
                         : *::jmc_auto::planning::ChangeLaneStatus::internal_default_instance();
}
inline ::jmc_auto::planning::ChangeLaneStatus* PlanningStatus::mutable_change_lane() {
  set_has_change_lane();
  if (change_lane_ == NULL) {
    change_lane_ = new ::jmc_auto::planning::ChangeLaneStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.change_lane)
  return change_lane_;
}
inline ::jmc_auto::planning::ChangeLaneStatus* PlanningStatus::release_change_lane() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.change_lane)
  clear_has_change_lane();
  ::jmc_auto::planning::ChangeLaneStatus* temp = change_lane_;
  change_lane_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_change_lane(::jmc_auto::planning::ChangeLaneStatus* change_lane) {
  delete change_lane_;
  change_lane_ = change_lane;
  if (change_lane) {
    set_has_change_lane();
  } else {
    clear_has_change_lane();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.change_lane)
}

// optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
inline bool PlanningStatus::has_crosswalk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanningStatus::set_has_crosswalk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanningStatus::clear_has_crosswalk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanningStatus::clear_crosswalk() {
  if (crosswalk_ != NULL) crosswalk_->::jmc_auto::planning::CrosswalkStatus::Clear();
  clear_has_crosswalk();
}
inline const ::jmc_auto::planning::CrosswalkStatus& PlanningStatus::crosswalk() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.crosswalk)
  return crosswalk_ != NULL ? *crosswalk_
                         : *::jmc_auto::planning::CrosswalkStatus::internal_default_instance();
}
inline ::jmc_auto::planning::CrosswalkStatus* PlanningStatus::mutable_crosswalk() {
  set_has_crosswalk();
  if (crosswalk_ == NULL) {
    crosswalk_ = new ::jmc_auto::planning::CrosswalkStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.crosswalk)
  return crosswalk_;
}
inline ::jmc_auto::planning::CrosswalkStatus* PlanningStatus::release_crosswalk() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.crosswalk)
  clear_has_crosswalk();
  ::jmc_auto::planning::CrosswalkStatus* temp = crosswalk_;
  crosswalk_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_crosswalk(::jmc_auto::planning::CrosswalkStatus* crosswalk) {
  delete crosswalk_;
  crosswalk_ = crosswalk;
  if (crosswalk) {
    set_has_crosswalk();
  } else {
    clear_has_crosswalk();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.crosswalk)
}

// optional .jmc_auto.planning.DestinationStatus destination = 4;
inline bool PlanningStatus::has_destination() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanningStatus::set_has_destination() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanningStatus::clear_has_destination() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanningStatus::clear_destination() {
  if (destination_ != NULL) destination_->::jmc_auto::planning::DestinationStatus::Clear();
  clear_has_destination();
}
inline const ::jmc_auto::planning::DestinationStatus& PlanningStatus::destination() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.destination)
  return destination_ != NULL ? *destination_
                         : *::jmc_auto::planning::DestinationStatus::internal_default_instance();
}
inline ::jmc_auto::planning::DestinationStatus* PlanningStatus::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) {
    destination_ = new ::jmc_auto::planning::DestinationStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.destination)
  return destination_;
}
inline ::jmc_auto::planning::DestinationStatus* PlanningStatus::release_destination() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.destination)
  clear_has_destination();
  ::jmc_auto::planning::DestinationStatus* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_destination(::jmc_auto::planning::DestinationStatus* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.destination)
}

// optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
inline bool PlanningStatus::has_emergency_stop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlanningStatus::set_has_emergency_stop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlanningStatus::clear_has_emergency_stop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlanningStatus::clear_emergency_stop() {
  if (emergency_stop_ != NULL) emergency_stop_->::jmc_auto::planning::EmergencyStopStatus::Clear();
  clear_has_emergency_stop();
}
inline const ::jmc_auto::planning::EmergencyStopStatus& PlanningStatus::emergency_stop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.emergency_stop)
  return emergency_stop_ != NULL ? *emergency_stop_
                         : *::jmc_auto::planning::EmergencyStopStatus::internal_default_instance();
}
inline ::jmc_auto::planning::EmergencyStopStatus* PlanningStatus::mutable_emergency_stop() {
  set_has_emergency_stop();
  if (emergency_stop_ == NULL) {
    emergency_stop_ = new ::jmc_auto::planning::EmergencyStopStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.emergency_stop)
  return emergency_stop_;
}
inline ::jmc_auto::planning::EmergencyStopStatus* PlanningStatus::release_emergency_stop() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.emergency_stop)
  clear_has_emergency_stop();
  ::jmc_auto::planning::EmergencyStopStatus* temp = emergency_stop_;
  emergency_stop_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_emergency_stop(::jmc_auto::planning::EmergencyStopStatus* emergency_stop) {
  delete emergency_stop_;
  emergency_stop_ = emergency_stop;
  if (emergency_stop) {
    set_has_emergency_stop();
  } else {
    clear_has_emergency_stop();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.emergency_stop)
}

// optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
inline bool PlanningStatus::has_open_space() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlanningStatus::set_has_open_space() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlanningStatus::clear_has_open_space() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlanningStatus::clear_open_space() {
  if (open_space_ != NULL) open_space_->::jmc_auto::planning::OpenSpaceStatus::Clear();
  clear_has_open_space();
}
inline const ::jmc_auto::planning::OpenSpaceStatus& PlanningStatus::open_space() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.open_space)
  return open_space_ != NULL ? *open_space_
                         : *::jmc_auto::planning::OpenSpaceStatus::internal_default_instance();
}
inline ::jmc_auto::planning::OpenSpaceStatus* PlanningStatus::mutable_open_space() {
  set_has_open_space();
  if (open_space_ == NULL) {
    open_space_ = new ::jmc_auto::planning::OpenSpaceStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.open_space)
  return open_space_;
}
inline ::jmc_auto::planning::OpenSpaceStatus* PlanningStatus::release_open_space() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.open_space)
  clear_has_open_space();
  ::jmc_auto::planning::OpenSpaceStatus* temp = open_space_;
  open_space_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_open_space(::jmc_auto::planning::OpenSpaceStatus* open_space) {
  delete open_space_;
  open_space_ = open_space;
  if (open_space) {
    set_has_open_space();
  } else {
    clear_has_open_space();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.open_space)
}

// optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
inline bool PlanningStatus::has_park_and_go() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlanningStatus::set_has_park_and_go() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlanningStatus::clear_has_park_and_go() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlanningStatus::clear_park_and_go() {
  if (park_and_go_ != NULL) park_and_go_->::jmc_auto::planning::ParkAndGoStatus::Clear();
  clear_has_park_and_go();
}
inline const ::jmc_auto::planning::ParkAndGoStatus& PlanningStatus::park_and_go() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.park_and_go)
  return park_and_go_ != NULL ? *park_and_go_
                         : *::jmc_auto::planning::ParkAndGoStatus::internal_default_instance();
}
inline ::jmc_auto::planning::ParkAndGoStatus* PlanningStatus::mutable_park_and_go() {
  set_has_park_and_go();
  if (park_and_go_ == NULL) {
    park_and_go_ = new ::jmc_auto::planning::ParkAndGoStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.park_and_go)
  return park_and_go_;
}
inline ::jmc_auto::planning::ParkAndGoStatus* PlanningStatus::release_park_and_go() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.park_and_go)
  clear_has_park_and_go();
  ::jmc_auto::planning::ParkAndGoStatus* temp = park_and_go_;
  park_and_go_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_park_and_go(::jmc_auto::planning::ParkAndGoStatus* park_and_go) {
  delete park_and_go_;
  park_and_go_ = park_and_go;
  if (park_and_go) {
    set_has_park_and_go();
  } else {
    clear_has_park_and_go();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.park_and_go)
}

// optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
inline bool PlanningStatus::has_path_decider() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlanningStatus::set_has_path_decider() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlanningStatus::clear_has_path_decider() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlanningStatus::clear_path_decider() {
  if (path_decider_ != NULL) path_decider_->::jmc_auto::planning::PathDeciderStatus::Clear();
  clear_has_path_decider();
}
inline const ::jmc_auto::planning::PathDeciderStatus& PlanningStatus::path_decider() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.path_decider)
  return path_decider_ != NULL ? *path_decider_
                         : *::jmc_auto::planning::PathDeciderStatus::internal_default_instance();
}
inline ::jmc_auto::planning::PathDeciderStatus* PlanningStatus::mutable_path_decider() {
  set_has_path_decider();
  if (path_decider_ == NULL) {
    path_decider_ = new ::jmc_auto::planning::PathDeciderStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.path_decider)
  return path_decider_;
}
inline ::jmc_auto::planning::PathDeciderStatus* PlanningStatus::release_path_decider() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.path_decider)
  clear_has_path_decider();
  ::jmc_auto::planning::PathDeciderStatus* temp = path_decider_;
  path_decider_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_path_decider(::jmc_auto::planning::PathDeciderStatus* path_decider) {
  delete path_decider_;
  path_decider_ = path_decider;
  if (path_decider) {
    set_has_path_decider();
  } else {
    clear_has_path_decider();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.path_decider)
}

// optional .jmc_auto.planning.PullOverStatus pull_over = 9;
inline bool PlanningStatus::has_pull_over() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlanningStatus::set_has_pull_over() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlanningStatus::clear_has_pull_over() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlanningStatus::clear_pull_over() {
  if (pull_over_ != NULL) pull_over_->::jmc_auto::planning::PullOverStatus::Clear();
  clear_has_pull_over();
}
inline const ::jmc_auto::planning::PullOverStatus& PlanningStatus::pull_over() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.pull_over)
  return pull_over_ != NULL ? *pull_over_
                         : *::jmc_auto::planning::PullOverStatus::internal_default_instance();
}
inline ::jmc_auto::planning::PullOverStatus* PlanningStatus::mutable_pull_over() {
  set_has_pull_over();
  if (pull_over_ == NULL) {
    pull_over_ = new ::jmc_auto::planning::PullOverStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.pull_over)
  return pull_over_;
}
inline ::jmc_auto::planning::PullOverStatus* PlanningStatus::release_pull_over() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.pull_over)
  clear_has_pull_over();
  ::jmc_auto::planning::PullOverStatus* temp = pull_over_;
  pull_over_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_pull_over(::jmc_auto::planning::PullOverStatus* pull_over) {
  delete pull_over_;
  pull_over_ = pull_over;
  if (pull_over) {
    set_has_pull_over();
  } else {
    clear_has_pull_over();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.pull_over)
}

// optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
inline bool PlanningStatus::has_rerouting() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlanningStatus::set_has_rerouting() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlanningStatus::clear_has_rerouting() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlanningStatus::clear_rerouting() {
  if (rerouting_ != NULL) rerouting_->::jmc_auto::planning::ReroutingStatus::Clear();
  clear_has_rerouting();
}
inline const ::jmc_auto::planning::ReroutingStatus& PlanningStatus::rerouting() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.rerouting)
  return rerouting_ != NULL ? *rerouting_
                         : *::jmc_auto::planning::ReroutingStatus::internal_default_instance();
}
inline ::jmc_auto::planning::ReroutingStatus* PlanningStatus::mutable_rerouting() {
  set_has_rerouting();
  if (rerouting_ == NULL) {
    rerouting_ = new ::jmc_auto::planning::ReroutingStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.rerouting)
  return rerouting_;
}
inline ::jmc_auto::planning::ReroutingStatus* PlanningStatus::release_rerouting() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.rerouting)
  clear_has_rerouting();
  ::jmc_auto::planning::ReroutingStatus* temp = rerouting_;
  rerouting_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_rerouting(::jmc_auto::planning::ReroutingStatus* rerouting) {
  delete rerouting_;
  rerouting_ = rerouting;
  if (rerouting) {
    set_has_rerouting();
  } else {
    clear_has_rerouting();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.rerouting)
}

// optional .jmc_auto.planning.ScenarioStatus scenario = 11;
inline bool PlanningStatus::has_scenario() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlanningStatus::set_has_scenario() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlanningStatus::clear_has_scenario() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlanningStatus::clear_scenario() {
  if (scenario_ != NULL) scenario_->::jmc_auto::planning::ScenarioStatus::Clear();
  clear_has_scenario();
}
inline const ::jmc_auto::planning::ScenarioStatus& PlanningStatus::scenario() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.scenario)
  return scenario_ != NULL ? *scenario_
                         : *::jmc_auto::planning::ScenarioStatus::internal_default_instance();
}
inline ::jmc_auto::planning::ScenarioStatus* PlanningStatus::mutable_scenario() {
  set_has_scenario();
  if (scenario_ == NULL) {
    scenario_ = new ::jmc_auto::planning::ScenarioStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.scenario)
  return scenario_;
}
inline ::jmc_auto::planning::ScenarioStatus* PlanningStatus::release_scenario() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.scenario)
  clear_has_scenario();
  ::jmc_auto::planning::ScenarioStatus* temp = scenario_;
  scenario_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_scenario(::jmc_auto::planning::ScenarioStatus* scenario) {
  delete scenario_;
  scenario_ = scenario;
  if (scenario) {
    set_has_scenario();
  } else {
    clear_has_scenario();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.scenario)
}

// optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
inline bool PlanningStatus::has_stop_sign() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlanningStatus::set_has_stop_sign() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlanningStatus::clear_has_stop_sign() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlanningStatus::clear_stop_sign() {
  if (stop_sign_ != NULL) stop_sign_->::jmc_auto::planning::StopSignStatus::Clear();
  clear_has_stop_sign();
}
inline const ::jmc_auto::planning::StopSignStatus& PlanningStatus::stop_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.stop_sign)
  return stop_sign_ != NULL ? *stop_sign_
                         : *::jmc_auto::planning::StopSignStatus::internal_default_instance();
}
inline ::jmc_auto::planning::StopSignStatus* PlanningStatus::mutable_stop_sign() {
  set_has_stop_sign();
  if (stop_sign_ == NULL) {
    stop_sign_ = new ::jmc_auto::planning::StopSignStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.stop_sign)
  return stop_sign_;
}
inline ::jmc_auto::planning::StopSignStatus* PlanningStatus::release_stop_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.stop_sign)
  clear_has_stop_sign();
  ::jmc_auto::planning::StopSignStatus* temp = stop_sign_;
  stop_sign_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_stop_sign(::jmc_auto::planning::StopSignStatus* stop_sign) {
  delete stop_sign_;
  stop_sign_ = stop_sign;
  if (stop_sign) {
    set_has_stop_sign();
  } else {
    clear_has_stop_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.stop_sign)
}

// optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
inline bool PlanningStatus::has_traffic_light() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlanningStatus::set_has_traffic_light() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlanningStatus::clear_has_traffic_light() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlanningStatus::clear_traffic_light() {
  if (traffic_light_ != NULL) traffic_light_->::jmc_auto::planning::TrafficLightStatus::Clear();
  clear_has_traffic_light();
}
inline const ::jmc_auto::planning::TrafficLightStatus& PlanningStatus::traffic_light() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.traffic_light)
  return traffic_light_ != NULL ? *traffic_light_
                         : *::jmc_auto::planning::TrafficLightStatus::internal_default_instance();
}
inline ::jmc_auto::planning::TrafficLightStatus* PlanningStatus::mutable_traffic_light() {
  set_has_traffic_light();
  if (traffic_light_ == NULL) {
    traffic_light_ = new ::jmc_auto::planning::TrafficLightStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.traffic_light)
  return traffic_light_;
}
inline ::jmc_auto::planning::TrafficLightStatus* PlanningStatus::release_traffic_light() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.traffic_light)
  clear_has_traffic_light();
  ::jmc_auto::planning::TrafficLightStatus* temp = traffic_light_;
  traffic_light_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_traffic_light(::jmc_auto::planning::TrafficLightStatus* traffic_light) {
  delete traffic_light_;
  traffic_light_ = traffic_light;
  if (traffic_light) {
    set_has_traffic_light();
  } else {
    clear_has_traffic_light();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.traffic_light)
}

// optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
inline bool PlanningStatus::has_yield_sign() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlanningStatus::set_has_yield_sign() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlanningStatus::clear_has_yield_sign() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlanningStatus::clear_yield_sign() {
  if (yield_sign_ != NULL) yield_sign_->::jmc_auto::planning::YieldSignStatus::Clear();
  clear_has_yield_sign();
}
inline const ::jmc_auto::planning::YieldSignStatus& PlanningStatus::yield_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.yield_sign)
  return yield_sign_ != NULL ? *yield_sign_
                         : *::jmc_auto::planning::YieldSignStatus::internal_default_instance();
}
inline ::jmc_auto::planning::YieldSignStatus* PlanningStatus::mutable_yield_sign() {
  set_has_yield_sign();
  if (yield_sign_ == NULL) {
    yield_sign_ = new ::jmc_auto::planning::YieldSignStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.yield_sign)
  return yield_sign_;
}
inline ::jmc_auto::planning::YieldSignStatus* PlanningStatus::release_yield_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.yield_sign)
  clear_has_yield_sign();
  ::jmc_auto::planning::YieldSignStatus* temp = yield_sign_;
  yield_sign_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_yield_sign(::jmc_auto::planning::YieldSignStatus* yield_sign) {
  delete yield_sign_;
  yield_sign_ = yield_sign;
  if (yield_sign) {
    set_has_yield_sign();
  } else {
    clear_has_yield_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.yield_sign)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace planning
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::planning::ChangeLaneStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::ChangeLaneStatus_Status>() {
  return ::jmc_auto::planning::ChangeLaneStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection>() {
  return ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::planning::PullOverStatus_PullOverType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::PullOverStatus_PullOverType>() {
  return ::jmc_auto::planning::PullOverStatus_PullOverType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto__INCLUDED
