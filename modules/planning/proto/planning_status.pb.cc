// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_status.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "modules/planning/proto/planning_status.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace jmc_auto {
namespace planning {
class BareIntersectionStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BareIntersectionStatus> {
} _BareIntersectionStatus_default_instance_;
class ChangeLaneStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ChangeLaneStatus> {
} _ChangeLaneStatus_default_instance_;
class StopTimeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StopTime> {
} _StopTime_default_instance_;
class CrosswalkStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CrosswalkStatus> {
} _CrosswalkStatus_default_instance_;
class DestinationStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DestinationStatus> {
} _DestinationStatus_default_instance_;
class EmergencyStopStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EmergencyStopStatus> {
} _EmergencyStopStatus_default_instance_;
class OpenSpaceStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<OpenSpaceStatus> {
} _OpenSpaceStatus_default_instance_;
class ParkAndGoStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ParkAndGoStatus> {
} _ParkAndGoStatus_default_instance_;
class PathDeciderStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PathDeciderStatus> {
} _PathDeciderStatus_default_instance_;
class PullOverStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PullOverStatus> {
} _PullOverStatus_default_instance_;
class ReroutingStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ReroutingStatus> {
} _ReroutingStatus_default_instance_;
class ScenarioStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioStatus> {
} _ScenarioStatus_default_instance_;
class StopSignStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StopSignStatus> {
} _StopSignStatus_default_instance_;
class TrafficLightStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TrafficLightStatus> {
} _TrafficLightStatus_default_instance_;
class YieldSignStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<YieldSignStatus> {
} _YieldSignStatus_default_instance_;
class PlanningStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PlanningStatus> {
} _PlanningStatus_default_instance_;

namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[16];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BareIntersectionStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BareIntersectionStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BareIntersectionStatus, current_pnc_junction_overlap_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BareIntersectionStatus, done_pnc_junction_overlap_id_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, path_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, timestamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, exist_lane_change_start_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, lane_change_start_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, last_succeed_timestamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, is_current_opt_succeed_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangeLaneStatus, is_clear_to_change_lane_),
  7,
  0,
  2,
  4,
  1,
  3,
  5,
  6,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopTime, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopTime, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopTime, obstacle_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopTime, obstacle_stop_timestamp_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkStatus, crosswalk_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkStatus, stop_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrosswalkStatus, finished_crosswalk_),
  0,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DestinationStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DestinationStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DestinationStatus, has_passed_destination_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmergencyStopStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmergencyStopStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmergencyStopStatus, stop_fence_point_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceStatus, partitioned_trajectories_index_history_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenSpaceStatus, position_init_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParkAndGoStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParkAndGoStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParkAndGoStatus, adc_init_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParkAndGoStatus, adc_init_heading_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParkAndGoStatus, in_check_stage_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParkAndGoStatus, adc_adjust_end_pose_),
  0,
  2,
  3,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, front_static_obstacle_cycle_counter_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, able_to_use_self_lane_counter_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, is_in_path_lane_borrow_scenario_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, front_static_obstacle_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PathDeciderStatus, decided_side_pass_direction_),
  1,
  2,
  3,
  0,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, pull_over_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, plan_pull_over_path_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, theta_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, length_front_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, length_back_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, width_left_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PullOverStatus, width_right_),
  7,
  6,
  0,
  1,
  2,
  3,
  4,
  5,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReroutingStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReroutingStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReroutingStatus, last_rerouting_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReroutingStatus, need_rerouting_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReroutingStatus, routing_request_),
  1,
  2,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStatus, scenario_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStatus, stage_type_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSignStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSignStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSignStatus, current_stop_sign_overlap_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSignStatus, done_stop_sign_overlap_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSignStatus, wait_for_obstacle_id_),
  0,
  1,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficLightStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficLightStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficLightStatus, current_traffic_light_overlap_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficLightStatus, done_traffic_light_overlap_id_),
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(YieldSignStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(YieldSignStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(YieldSignStatus, current_yield_sign_overlap_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(YieldSignStatus, done_yield_sign_overlap_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(YieldSignStatus, wait_for_obstacle_id_),
  ~0u,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, bare_intersection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, change_lane_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, crosswalk_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, destination_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, emergency_stop_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, open_space_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, park_and_go_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, path_decider_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, pull_over_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, rerouting_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, scenario_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, stop_sign_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, traffic_light_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningStatus, yield_sign_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 7, sizeof(BareIntersectionStatus)},
  { 9, 22, sizeof(ChangeLaneStatus)},
  { 30, 37, sizeof(StopTime)},
  { 39, 47, sizeof(CrosswalkStatus)},
  { 50, 56, sizeof(DestinationStatus)},
  { 57, 63, sizeof(EmergencyStopStatus)},
  { 64, 71, sizeof(OpenSpaceStatus)},
  { 73, 82, sizeof(ParkAndGoStatus)},
  { 86, 96, sizeof(PathDeciderStatus)},
  { 101, 114, sizeof(PullOverStatus)},
  { 122, 130, sizeof(ReroutingStatus)},
  { 133, 140, sizeof(ScenarioStatus)},
  { 142, 150, sizeof(StopSignStatus)},
  { 153, 160, sizeof(TrafficLightStatus)},
  { 162, 170, sizeof(YieldSignStatus)},
  { 173, 192, sizeof(PlanningStatus)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_BareIntersectionStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ChangeLaneStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_StopTime_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CrosswalkStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DestinationStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EmergencyStopStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_OpenSpaceStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ParkAndGoStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PathDeciderStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PullOverStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ReroutingStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_StopSignStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_TrafficLightStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_YieldSignStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PlanningStatus_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "modules/planning/proto/planning_status.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 16);
}

}  // namespace

void TableStruct::Shutdown() {
  _BareIntersectionStatus_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _ChangeLaneStatus_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _StopTime_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _CrosswalkStatus_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _DestinationStatus_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _EmergencyStopStatus_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _OpenSpaceStatus_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _ParkAndGoStatus_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _PathDeciderStatus_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _PullOverStatus_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  _ReroutingStatus_default_instance_.Shutdown();
  delete file_level_metadata[10].reflection;
  _ScenarioStatus_default_instance_.Shutdown();
  delete file_level_metadata[11].reflection;
  _StopSignStatus_default_instance_.Shutdown();
  delete file_level_metadata[12].reflection;
  _TrafficLightStatus_default_instance_.Shutdown();
  delete file_level_metadata[13].reflection;
  _YieldSignStatus_default_instance_.Shutdown();
  delete file_level_metadata[14].reflection;
  _PlanningStatus_default_instance_.Shutdown();
  delete file_level_metadata[15].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::jmc_auto::common::protobuf_modules_2fcommon_2fproto_2fgeometry_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::routing::protobuf_modules_2frouting_2fproto_2frouting_2eproto::InitDefaults();
  _BareIntersectionStatus_default_instance_.DefaultConstruct();
  _ChangeLaneStatus_default_instance_.DefaultConstruct();
  _StopTime_default_instance_.DefaultConstruct();
  _CrosswalkStatus_default_instance_.DefaultConstruct();
  _DestinationStatus_default_instance_.DefaultConstruct();
  _EmergencyStopStatus_default_instance_.DefaultConstruct();
  _OpenSpaceStatus_default_instance_.DefaultConstruct();
  _ParkAndGoStatus_default_instance_.DefaultConstruct();
  _PathDeciderStatus_default_instance_.DefaultConstruct();
  _PullOverStatus_default_instance_.DefaultConstruct();
  _ReroutingStatus_default_instance_.DefaultConstruct();
  _ScenarioStatus_default_instance_.DefaultConstruct();
  _StopSignStatus_default_instance_.DefaultConstruct();
  _TrafficLightStatus_default_instance_.DefaultConstruct();
  _YieldSignStatus_default_instance_.DefaultConstruct();
  _PlanningStatus_default_instance_.DefaultConstruct();
  _ChangeLaneStatus_default_instance_.get_mutable()->lane_change_start_position_ = const_cast< ::jmc_auto::common::Point3D*>(
      ::jmc_auto::common::Point3D::internal_default_instance());
  _EmergencyStopStatus_default_instance_.get_mutable()->stop_fence_point_ = const_cast< ::jmc_auto::common::PointENU*>(
      ::jmc_auto::common::PointENU::internal_default_instance());
  _ParkAndGoStatus_default_instance_.get_mutable()->adc_init_position_ = const_cast< ::jmc_auto::common::PointENU*>(
      ::jmc_auto::common::PointENU::internal_default_instance());
  _ParkAndGoStatus_default_instance_.get_mutable()->adc_adjust_end_pose_ = const_cast< ::jmc_auto::common::PointENU*>(
      ::jmc_auto::common::PointENU::internal_default_instance());
  _PullOverStatus_default_instance_.get_mutable()->position_ = const_cast< ::jmc_auto::common::PointENU*>(
      ::jmc_auto::common::PointENU::internal_default_instance());
  _ReroutingStatus_default_instance_.get_mutable()->routing_request_ = const_cast< ::jmc_auto::routing::RoutingRequest*>(
      ::jmc_auto::routing::RoutingRequest::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->bare_intersection_ = const_cast< ::jmc_auto::planning::BareIntersectionStatus*>(
      ::jmc_auto::planning::BareIntersectionStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->change_lane_ = const_cast< ::jmc_auto::planning::ChangeLaneStatus*>(
      ::jmc_auto::planning::ChangeLaneStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->crosswalk_ = const_cast< ::jmc_auto::planning::CrosswalkStatus*>(
      ::jmc_auto::planning::CrosswalkStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->destination_ = const_cast< ::jmc_auto::planning::DestinationStatus*>(
      ::jmc_auto::planning::DestinationStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->emergency_stop_ = const_cast< ::jmc_auto::planning::EmergencyStopStatus*>(
      ::jmc_auto::planning::EmergencyStopStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->open_space_ = const_cast< ::jmc_auto::planning::OpenSpaceStatus*>(
      ::jmc_auto::planning::OpenSpaceStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->park_and_go_ = const_cast< ::jmc_auto::planning::ParkAndGoStatus*>(
      ::jmc_auto::planning::ParkAndGoStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->path_decider_ = const_cast< ::jmc_auto::planning::PathDeciderStatus*>(
      ::jmc_auto::planning::PathDeciderStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->pull_over_ = const_cast< ::jmc_auto::planning::PullOverStatus*>(
      ::jmc_auto::planning::PullOverStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->rerouting_ = const_cast< ::jmc_auto::planning::ReroutingStatus*>(
      ::jmc_auto::planning::ReroutingStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->scenario_ = const_cast< ::jmc_auto::planning::ScenarioStatus*>(
      ::jmc_auto::planning::ScenarioStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->stop_sign_ = const_cast< ::jmc_auto::planning::StopSignStatus*>(
      ::jmc_auto::planning::StopSignStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->traffic_light_ = const_cast< ::jmc_auto::planning::TrafficLightStatus*>(
      ::jmc_auto::planning::TrafficLightStatus::internal_default_instance());
  _PlanningStatus_default_instance_.get_mutable()->yield_sign_ = const_cast< ::jmc_auto::planning::YieldSignStatus*>(
      ::jmc_auto::planning::YieldSignStatus::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n,modules/planning/proto/planning_status"
      ".proto\022\021jmc_auto.planning\032#modules/commo"
      "n/proto/geometry.proto\032,modules/planning"
      "/proto/planning_config.proto\032#modules/ro"
      "uting/proto/routing.proto\"g\n\026BareInterse"
      "ctionStatus\022\'\n\037current_pnc_junction_over"
      "lap_id\030\001 \001(\t\022$\n\034done_pnc_junction_overla"
      "p_id\030\002 \001(\t\"\240\003\n\020ChangeLaneStatus\022:\n\006statu"
      "s\030\001 \001(\0162*.jmc_auto.planning.ChangeLaneSt"
      "atus.Status\022\017\n\007path_id\030\002 \001(\t\022\021\n\ttimestam"
      "p\030\003 \001(\001\022/\n exist_lane_change_start_posit"
      "ion\030\004 \001(\010:\005false\022<\n\032lane_change_start_po"
      "sition\030\005 \001(\0132\030.jmc_auto.common.Point3D\022\036"
      "\n\026last_succeed_timestamp\030\006 \001(\001\022%\n\026is_cur"
      "rent_opt_succeed\030\007 \001(\010:\005false\022&\n\027is_clea"
      "r_to_change_lane\030\010 \001(\010:\005false\"N\n\006Status\022"
      "\022\n\016IN_CHANGE_LANE\020\001\022\026\n\022CHANGE_LANE_FAILE"
      "D\020\002\022\030\n\024CHANGE_LANE_FINISHED\020\003\"@\n\010StopTim"
      "e\022\023\n\013obstacle_id\030\001 \001(\t\022\037\n\027obstacle_stop_"
      "timestamp\030\002 \001(\001\"s\n\017CrosswalkStatus\022\024\n\014cr"
      "osswalk_id\030\001 \001(\t\022.\n\tstop_time\030\002 \003(\0132\033.jm"
      "c_auto.planning.StopTime\022\032\n\022finished_cro"
      "sswalk\030\003 \003(\t\":\n\021DestinationStatus\022%\n\026has"
      "_passed_destination\030\001 \001(\010:\005false\"J\n\023Emer"
      "gencyStopStatus\0223\n\020stop_fence_point\030\001 \001("
      "\0132\031.jmc_auto.common.PointENU\"_\n\017OpenSpac"
      "eStatus\022.\n&partitioned_trajectories_inde"
      "x_history\030\001 \003(\t\022\034\n\rposition_init\030\002 \001(\010:\005"
      "false\"\261\001\n\017ParkAndGoStatus\0224\n\021adc_init_po"
      "sition\030\001 \001(\0132\031.jmc_auto.common.PointENU\022"
      "\030\n\020adc_init_heading\030\002 \001(\001\022\026\n\016in_check_st"
      "age\030\003 \001(\010\0226\n\023adc_adjust_end_pose\030\004 \001(\0132\031"
      ".jmc_auto.common.PointENU\"\332\002\n\021PathDecide"
      "rStatus\022.\n#front_static_obstacle_cycle_c"
      "ounter\030\001 \001(\005:\0010\022(\n\035able_to_use_self_lane"
      "_counter\030\002 \001(\005:\0010\022.\n\037is_in_path_lane_bor"
      "row_scenario\030\003 \001(\010:\005false\022\"\n\030front_stati"
      "c_obstacle_id\030\004 \001(\t:\000\022]\n\033decided_side_pa"
      "ss_direction\030\005 \003(\01628.jmc_auto.planning.P"
      "athDeciderStatus.LaneBorrowDirection\"8\n\023"
      "LaneBorrowDirection\022\017\n\013LEFT_BORROW\020\001\022\020\n\014"
      "RIGHT_BORROW\020\002\"\304\002\n\016PullOverStatus\022F\n\016pul"
      "l_over_type\030\001 \001(\0162..jmc_auto.planning.Pu"
      "llOverStatus.PullOverType\022\"\n\023plan_pull_o"
      "ver_path\030\002 \001(\010:\005false\022+\n\010position\030\003 \001(\0132"
      "\031.jmc_auto.common.PointENU\022\r\n\005theta\030\004 \001("
      "\001\022\024\n\014length_front\030\005 \001(\001\022\023\n\013length_back\030\006"
      " \001(\001\022\022\n\nwidth_left\030\007 \001(\001\022\023\n\013width_right\030"
      "\010 \001(\001\"6\n\014PullOverType\022\r\n\tPULL_OVER\020\001\022\027\n\023"
      "EMERGENCY_PULL_OVER\020\002\"\210\001\n\017ReroutingStatu"
      "s\022\033\n\023last_rerouting_time\030\001 \001(\001\022\035\n\016need_r"
      "erouting\030\002 \001(\010:\005false\0229\n\017routing_request"
      "\030\003 \001(\0132 .jmc_auto.routing.RoutingRequest"
      "\"\230\001\n\016ScenarioStatus\022E\n\rscenario_type\030\001 \001"
      "(\0162..jmc_auto.planning.ScenarioConfig.Sc"
      "enarioType\022\?\n\nstage_type\030\002 \001(\0162+.jmc_aut"
      "o.planning.ScenarioConfig.StageType\"w\n\016S"
      "topSignStatus\022$\n\034current_stop_sign_overl"
      "ap_id\030\001 \001(\t\022!\n\031done_stop_sign_overlap_id"
      "\030\002 \001(\t\022\034\n\024wait_for_obstacle_id\030\003 \003(\t\"e\n\022"
      "TrafficLightStatus\022(\n current_traffic_li"
      "ght_overlap_id\030\001 \003(\t\022%\n\035done_traffic_lig"
      "ht_overlap_id\030\002 \003(\t\"z\n\017YieldSignStatus\022%"
      "\n\035current_yield_sign_overlap_id\030\001 \003(\t\022\"\n"
      "\032done_yield_sign_overlap_id\030\002 \003(\t\022\034\n\024wai"
      "t_for_obstacle_id\030\003 \003(\t\"\275\006\n\016PlanningStat"
      "us\022D\n\021bare_intersection\030\001 \001(\0132).jmc_auto"
      ".planning.BareIntersectionStatus\0228\n\013chan"
      "ge_lane\030\002 \001(\0132#.jmc_auto.planning.Change"
      "LaneStatus\0225\n\tcrosswalk\030\003 \001(\0132\".jmc_auto"
      ".planning.CrosswalkStatus\0229\n\013destination"
      "\030\004 \001(\0132$.jmc_auto.planning.DestinationSt"
      "atus\022>\n\016emergency_stop\030\005 \001(\0132&.jmc_auto."
      "planning.EmergencyStopStatus\0226\n\nopen_spa"
      "ce\030\006 \001(\0132\".jmc_auto.planning.OpenSpaceSt"
      "atus\0227\n\013park_and_go\030\007 \001(\0132\".jmc_auto.pla"
      "nning.ParkAndGoStatus\022:\n\014path_decider\030\010 "
      "\001(\0132$.jmc_auto.planning.PathDeciderStatu"
      "s\0224\n\tpull_over\030\t \001(\0132!.jmc_auto.planning"
      ".PullOverStatus\0225\n\trerouting\030\n \001(\0132\".jmc"
      "_auto.planning.ReroutingStatus\0223\n\010scenar"
      "io\030\013 \001(\0132!.jmc_auto.planning.ScenarioSta"
      "tus\0224\n\tstop_sign\030\014 \001(\0132!.jmc_auto.planni"
      "ng.StopSignStatus\022<\n\rtraffic_light\030\r \001(\013"
      "2%.jmc_auto.planning.TrafficLightStatus\022"
      "6\n\nyield_sign\030\016 \001(\0132\".jmc_auto.planning."
      "YieldSignStatus"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 3455);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "modules/planning/proto/planning_status.proto", &protobuf_RegisterTypes);
  ::jmc_auto::common::protobuf_modules_2fcommon_2fproto_2fgeometry_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::routing::protobuf_modules_2frouting_2fproto_2frouting_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto

const ::google::protobuf::EnumDescriptor* ChangeLaneStatus_Status_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_enum_descriptors[0];
}
bool ChangeLaneStatus_Status_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ChangeLaneStatus_Status ChangeLaneStatus::IN_CHANGE_LANE;
const ChangeLaneStatus_Status ChangeLaneStatus::CHANGE_LANE_FAILED;
const ChangeLaneStatus_Status ChangeLaneStatus::CHANGE_LANE_FINISHED;
const ChangeLaneStatus_Status ChangeLaneStatus::Status_MIN;
const ChangeLaneStatus_Status ChangeLaneStatus::Status_MAX;
const int ChangeLaneStatus::Status_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* PathDeciderStatus_LaneBorrowDirection_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_enum_descriptors[1];
}
bool PathDeciderStatus_LaneBorrowDirection_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::LEFT_BORROW;
const PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::RIGHT_BORROW;
const PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::LaneBorrowDirection_MIN;
const PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::LaneBorrowDirection_MAX;
const int PathDeciderStatus::LaneBorrowDirection_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* PullOverStatus_PullOverType_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_enum_descriptors[2];
}
bool PullOverStatus_PullOverType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PullOverStatus_PullOverType PullOverStatus::PULL_OVER;
const PullOverStatus_PullOverType PullOverStatus::EMERGENCY_PULL_OVER;
const PullOverStatus_PullOverType PullOverStatus::PullOverType_MIN;
const PullOverStatus_PullOverType PullOverStatus::PullOverType_MAX;
const int PullOverStatus::PullOverType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BareIntersectionStatus::kCurrentPncJunctionOverlapIdFieldNumber;
const int BareIntersectionStatus::kDonePncJunctionOverlapIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BareIntersectionStatus::BareIntersectionStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.BareIntersectionStatus)
}
BareIntersectionStatus::BareIntersectionStatus(const BareIntersectionStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  current_pnc_junction_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_current_pnc_junction_overlap_id()) {
    current_pnc_junction_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.current_pnc_junction_overlap_id_);
  }
  done_pnc_junction_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_done_pnc_junction_overlap_id()) {
    done_pnc_junction_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.done_pnc_junction_overlap_id_);
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.BareIntersectionStatus)
}

void BareIntersectionStatus::SharedCtor() {
  _cached_size_ = 0;
  current_pnc_junction_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  done_pnc_junction_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

BareIntersectionStatus::~BareIntersectionStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.BareIntersectionStatus)
  SharedDtor();
}

void BareIntersectionStatus::SharedDtor() {
  current_pnc_junction_overlap_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  done_pnc_junction_overlap_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BareIntersectionStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BareIntersectionStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const BareIntersectionStatus& BareIntersectionStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

BareIntersectionStatus* BareIntersectionStatus::New(::google::protobuf::Arena* arena) const {
  BareIntersectionStatus* n = new BareIntersectionStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BareIntersectionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.BareIntersectionStatus)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_current_pnc_junction_overlap_id()) {
      GOOGLE_DCHECK(!current_pnc_junction_overlap_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*current_pnc_junction_overlap_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_done_pnc_junction_overlap_id()) {
      GOOGLE_DCHECK(!done_pnc_junction_overlap_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*done_pnc_junction_overlap_id_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool BareIntersectionStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.BareIntersectionStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string current_pnc_junction_overlap_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_current_pnc_junction_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->current_pnc_junction_overlap_id().data(), this->current_pnc_junction_overlap_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string done_pnc_junction_overlap_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_done_pnc_junction_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->done_pnc_junction_overlap_id().data(), this->done_pnc_junction_overlap_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.BareIntersectionStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.BareIntersectionStatus)
  return false;
#undef DO_
}

void BareIntersectionStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.BareIntersectionStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string current_pnc_junction_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_pnc_junction_overlap_id().data(), this->current_pnc_junction_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->current_pnc_junction_overlap_id(), output);
  }

  // optional string done_pnc_junction_overlap_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_pnc_junction_overlap_id().data(), this->done_pnc_junction_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->done_pnc_junction_overlap_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.BareIntersectionStatus)
}

::google::protobuf::uint8* BareIntersectionStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.BareIntersectionStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string current_pnc_junction_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_pnc_junction_overlap_id().data(), this->current_pnc_junction_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->current_pnc_junction_overlap_id(), target);
  }

  // optional string done_pnc_junction_overlap_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_pnc_junction_overlap_id().data(), this->done_pnc_junction_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->done_pnc_junction_overlap_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.BareIntersectionStatus)
  return target;
}

size_t BareIntersectionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.BareIntersectionStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string current_pnc_junction_overlap_id = 1;
    if (has_current_pnc_junction_overlap_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->current_pnc_junction_overlap_id());
    }

    // optional string done_pnc_junction_overlap_id = 2;
    if (has_done_pnc_junction_overlap_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->done_pnc_junction_overlap_id());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BareIntersectionStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.BareIntersectionStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const BareIntersectionStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const BareIntersectionStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.BareIntersectionStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.BareIntersectionStatus)
    MergeFrom(*source);
  }
}

void BareIntersectionStatus::MergeFrom(const BareIntersectionStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.BareIntersectionStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_current_pnc_junction_overlap_id();
      current_pnc_junction_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.current_pnc_junction_overlap_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_done_pnc_junction_overlap_id();
      done_pnc_junction_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.done_pnc_junction_overlap_id_);
    }
  }
}

void BareIntersectionStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.BareIntersectionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BareIntersectionStatus::CopyFrom(const BareIntersectionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.BareIntersectionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BareIntersectionStatus::IsInitialized() const {
  return true;
}

void BareIntersectionStatus::Swap(BareIntersectionStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BareIntersectionStatus::InternalSwap(BareIntersectionStatus* other) {
  current_pnc_junction_overlap_id_.Swap(&other->current_pnc_junction_overlap_id_);
  done_pnc_junction_overlap_id_.Swap(&other->done_pnc_junction_overlap_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BareIntersectionStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BareIntersectionStatus

// optional string current_pnc_junction_overlap_id = 1;
bool BareIntersectionStatus::has_current_pnc_junction_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BareIntersectionStatus::set_has_current_pnc_junction_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
void BareIntersectionStatus::clear_has_current_pnc_junction_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void BareIntersectionStatus::clear_current_pnc_junction_overlap_id() {
  current_pnc_junction_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_pnc_junction_overlap_id();
}
const ::std::string& BareIntersectionStatus::current_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return current_pnc_junction_overlap_id_.GetNoArena();
}
void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const ::std::string& value) {
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
#if LANG_CXX11
void BareIntersectionStatus::set_current_pnc_junction_overlap_id(::std::string&& value) {
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
#endif
void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
void BareIntersectionStatus::set_current_pnc_junction_overlap_id(const char* value, size_t size) {
  set_has_current_pnc_junction_overlap_id();
  current_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}
::std::string* BareIntersectionStatus::mutable_current_pnc_junction_overlap_id() {
  set_has_current_pnc_junction_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  return current_pnc_junction_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BareIntersectionStatus::release_current_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
  clear_has_current_pnc_junction_overlap_id();
  return current_pnc_junction_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BareIntersectionStatus::set_allocated_current_pnc_junction_overlap_id(::std::string* current_pnc_junction_overlap_id) {
  if (current_pnc_junction_overlap_id != NULL) {
    set_has_current_pnc_junction_overlap_id();
  } else {
    clear_has_current_pnc_junction_overlap_id();
  }
  current_pnc_junction_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_pnc_junction_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.BareIntersectionStatus.current_pnc_junction_overlap_id)
}

// optional string done_pnc_junction_overlap_id = 2;
bool BareIntersectionStatus::has_done_pnc_junction_overlap_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BareIntersectionStatus::set_has_done_pnc_junction_overlap_id() {
  _has_bits_[0] |= 0x00000002u;
}
void BareIntersectionStatus::clear_has_done_pnc_junction_overlap_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void BareIntersectionStatus::clear_done_pnc_junction_overlap_id() {
  done_pnc_junction_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_done_pnc_junction_overlap_id();
}
const ::std::string& BareIntersectionStatus::done_pnc_junction_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return done_pnc_junction_overlap_id_.GetNoArena();
}
void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const ::std::string& value) {
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
#if LANG_CXX11
void BareIntersectionStatus::set_done_pnc_junction_overlap_id(::std::string&& value) {
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
#endif
void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
void BareIntersectionStatus::set_done_pnc_junction_overlap_id(const char* value, size_t size) {
  set_has_done_pnc_junction_overlap_id();
  done_pnc_junction_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}
::std::string* BareIntersectionStatus::mutable_done_pnc_junction_overlap_id() {
  set_has_done_pnc_junction_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  return done_pnc_junction_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* BareIntersectionStatus::release_done_pnc_junction_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
  clear_has_done_pnc_junction_overlap_id();
  return done_pnc_junction_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void BareIntersectionStatus::set_allocated_done_pnc_junction_overlap_id(::std::string* done_pnc_junction_overlap_id) {
  if (done_pnc_junction_overlap_id != NULL) {
    set_has_done_pnc_junction_overlap_id();
  } else {
    clear_has_done_pnc_junction_overlap_id();
  }
  done_pnc_junction_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), done_pnc_junction_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.BareIntersectionStatus.done_pnc_junction_overlap_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChangeLaneStatus::kStatusFieldNumber;
const int ChangeLaneStatus::kPathIdFieldNumber;
const int ChangeLaneStatus::kTimestampFieldNumber;
const int ChangeLaneStatus::kExistLaneChangeStartPositionFieldNumber;
const int ChangeLaneStatus::kLaneChangeStartPositionFieldNumber;
const int ChangeLaneStatus::kLastSucceedTimestampFieldNumber;
const int ChangeLaneStatus::kIsCurrentOptSucceedFieldNumber;
const int ChangeLaneStatus::kIsClearToChangeLaneFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChangeLaneStatus::ChangeLaneStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ChangeLaneStatus)
}
ChangeLaneStatus::ChangeLaneStatus(const ChangeLaneStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  path_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_path_id()) {
    path_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_id_);
  }
  if (from.has_lane_change_start_position()) {
    lane_change_start_position_ = new ::jmc_auto::common::Point3D(*from.lane_change_start_position_);
  } else {
    lane_change_start_position_ = NULL;
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&timestamp_) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ChangeLaneStatus)
}

void ChangeLaneStatus::SharedCtor() {
  _cached_size_ = 0;
  path_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&lane_change_start_position_, 0, reinterpret_cast<char*>(&is_clear_to_change_lane_) -
    reinterpret_cast<char*>(&lane_change_start_position_) + sizeof(is_clear_to_change_lane_));
  status_ = 1;
}

ChangeLaneStatus::~ChangeLaneStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ChangeLaneStatus)
  SharedDtor();
}

void ChangeLaneStatus::SharedDtor() {
  path_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete lane_change_start_position_;
  }
}

void ChangeLaneStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChangeLaneStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ChangeLaneStatus& ChangeLaneStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

ChangeLaneStatus* ChangeLaneStatus::New(::google::protobuf::Arena* arena) const {
  ChangeLaneStatus* n = new ChangeLaneStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChangeLaneStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ChangeLaneStatus)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_path_id()) {
      GOOGLE_DCHECK(!path_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*path_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_lane_change_start_position()) {
      GOOGLE_DCHECK(lane_change_start_position_ != NULL);
      lane_change_start_position_->::jmc_auto::common::Point3D::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 252u) {
    ::memset(&timestamp_, 0, reinterpret_cast<char*>(&is_clear_to_change_lane_) -
      reinterpret_cast<char*>(&timestamp_) + sizeof(is_clear_to_change_lane_));
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ChangeLaneStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ChangeLaneStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::ChangeLaneStatus_Status_IsValid(value)) {
            set_status(static_cast< ::jmc_auto::planning::ChangeLaneStatus_Status >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string path_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path_id().data(), this->path_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.ChangeLaneStatus.path_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double timestamp = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_timestamp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool exist_lane_change_start_position = 4 [default = false];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_exist_lane_change_start_position();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &exist_lane_change_start_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.common.Point3D lane_change_start_position = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lane_change_start_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double last_succeed_timestamp = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(49u)) {
          set_has_last_succeed_timestamp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &last_succeed_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_current_opt_succeed = 7 [default = false];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u)) {
          set_has_is_current_opt_succeed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_current_opt_succeed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_clear_to_change_lane = 8 [default = false];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          set_has_is_clear_to_change_lane();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_clear_to_change_lane_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ChangeLaneStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ChangeLaneStatus)
  return false;
#undef DO_
}

void ChangeLaneStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ChangeLaneStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // optional string path_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path_id().data(), this->path_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.ChangeLaneStatus.path_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path_id(), output);
  }

  // optional double timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->timestamp(), output);
  }

  // optional bool exist_lane_change_start_position = 4 [default = false];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->exist_lane_change_start_position(), output);
  }

  // optional .jmc_auto.common.Point3D lane_change_start_position = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->lane_change_start_position_, output);
  }

  // optional double last_succeed_timestamp = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->last_succeed_timestamp(), output);
  }

  // optional bool is_current_opt_succeed = 7 [default = false];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_current_opt_succeed(), output);
  }

  // optional bool is_clear_to_change_lane = 8 [default = false];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_clear_to_change_lane(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ChangeLaneStatus)
}

::google::protobuf::uint8* ChangeLaneStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ChangeLaneStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->status(), target);
  }

  // optional string path_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path_id().data(), this->path_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.ChangeLaneStatus.path_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path_id(), target);
  }

  // optional double timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->timestamp(), target);
  }

  // optional bool exist_lane_change_start_position = 4 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->exist_lane_change_start_position(), target);
  }

  // optional .jmc_auto.common.Point3D lane_change_start_position = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->lane_change_start_position_, deterministic, target);
  }

  // optional double last_succeed_timestamp = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->last_succeed_timestamp(), target);
  }

  // optional bool is_current_opt_succeed = 7 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->is_current_opt_succeed(), target);
  }

  // optional bool is_clear_to_change_lane = 8 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->is_clear_to_change_lane(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ChangeLaneStatus)
  return target;
}

size_t ChangeLaneStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ChangeLaneStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional string path_id = 2;
    if (has_path_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path_id());
    }

    // optional .jmc_auto.common.Point3D lane_change_start_position = 5;
    if (has_lane_change_start_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lane_change_start_position_);
    }

    // optional double timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional double last_succeed_timestamp = 6;
    if (has_last_succeed_timestamp()) {
      total_size += 1 + 8;
    }

    // optional bool exist_lane_change_start_position = 4 [default = false];
    if (has_exist_lane_change_start_position()) {
      total_size += 1 + 1;
    }

    // optional bool is_current_opt_succeed = 7 [default = false];
    if (has_is_current_opt_succeed()) {
      total_size += 1 + 1;
    }

    // optional bool is_clear_to_change_lane = 8 [default = false];
    if (has_is_clear_to_change_lane()) {
      total_size += 1 + 1;
    }

    // optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeLaneStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ChangeLaneStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const ChangeLaneStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ChangeLaneStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ChangeLaneStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ChangeLaneStatus)
    MergeFrom(*source);
  }
}

void ChangeLaneStatus::MergeFrom(const ChangeLaneStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ChangeLaneStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_path_id();
      path_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_lane_change_start_position()->::jmc_auto::common::Point3D::MergeFrom(from.lane_change_start_position());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      last_succeed_timestamp_ = from.last_succeed_timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      exist_lane_change_start_position_ = from.exist_lane_change_start_position_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_current_opt_succeed_ = from.is_current_opt_succeed_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_clear_to_change_lane_ = from.is_clear_to_change_lane_;
    }
    if (cached_has_bits & 0x00000080u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ChangeLaneStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ChangeLaneStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChangeLaneStatus::CopyFrom(const ChangeLaneStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ChangeLaneStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeLaneStatus::IsInitialized() const {
  return true;
}

void ChangeLaneStatus::Swap(ChangeLaneStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChangeLaneStatus::InternalSwap(ChangeLaneStatus* other) {
  path_id_.Swap(&other->path_id_);
  std::swap(lane_change_start_position_, other->lane_change_start_position_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(last_succeed_timestamp_, other->last_succeed_timestamp_);
  std::swap(exist_lane_change_start_position_, other->exist_lane_change_start_position_);
  std::swap(is_current_opt_succeed_, other->is_current_opt_succeed_);
  std::swap(is_clear_to_change_lane_, other->is_clear_to_change_lane_);
  std::swap(status_, other->status_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ChangeLaneStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChangeLaneStatus

// optional .jmc_auto.planning.ChangeLaneStatus.Status status = 1;
bool ChangeLaneStatus::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ChangeLaneStatus::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
void ChangeLaneStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
void ChangeLaneStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
::jmc_auto::planning::ChangeLaneStatus_Status ChangeLaneStatus::status() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.status)
  return static_cast< ::jmc_auto::planning::ChangeLaneStatus_Status >(status_);
}
void ChangeLaneStatus::set_status(::jmc_auto::planning::ChangeLaneStatus_Status value) {
  assert(::jmc_auto::planning::ChangeLaneStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.status)
}

// optional string path_id = 2;
bool ChangeLaneStatus::has_path_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChangeLaneStatus::set_has_path_id() {
  _has_bits_[0] |= 0x00000001u;
}
void ChangeLaneStatus::clear_has_path_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void ChangeLaneStatus::clear_path_id() {
  path_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path_id();
}
const ::std::string& ChangeLaneStatus::path_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.path_id)
  return path_id_.GetNoArena();
}
void ChangeLaneStatus::set_path_id(const ::std::string& value) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.path_id)
}
#if LANG_CXX11
void ChangeLaneStatus::set_path_id(::std::string&& value) {
  set_has_path_id();
  path_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.ChangeLaneStatus.path_id)
}
#endif
void ChangeLaneStatus::set_path_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.ChangeLaneStatus.path_id)
}
void ChangeLaneStatus::set_path_id(const char* value, size_t size) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.ChangeLaneStatus.path_id)
}
::std::string* ChangeLaneStatus::mutable_path_id() {
  set_has_path_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ChangeLaneStatus.path_id)
  return path_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ChangeLaneStatus::release_path_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ChangeLaneStatus.path_id)
  clear_has_path_id();
  return path_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ChangeLaneStatus::set_allocated_path_id(::std::string* path_id) {
  if (path_id != NULL) {
    set_has_path_id();
  } else {
    clear_has_path_id();
  }
  path_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ChangeLaneStatus.path_id)
}

// optional double timestamp = 3;
bool ChangeLaneStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ChangeLaneStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
void ChangeLaneStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
void ChangeLaneStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
double ChangeLaneStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.timestamp)
  return timestamp_;
}
void ChangeLaneStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.timestamp)
}

// optional bool exist_lane_change_start_position = 4 [default = false];
bool ChangeLaneStatus::has_exist_lane_change_start_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ChangeLaneStatus::set_has_exist_lane_change_start_position() {
  _has_bits_[0] |= 0x00000010u;
}
void ChangeLaneStatus::clear_has_exist_lane_change_start_position() {
  _has_bits_[0] &= ~0x00000010u;
}
void ChangeLaneStatus::clear_exist_lane_change_start_position() {
  exist_lane_change_start_position_ = false;
  clear_has_exist_lane_change_start_position();
}
bool ChangeLaneStatus::exist_lane_change_start_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.exist_lane_change_start_position)
  return exist_lane_change_start_position_;
}
void ChangeLaneStatus::set_exist_lane_change_start_position(bool value) {
  set_has_exist_lane_change_start_position();
  exist_lane_change_start_position_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.exist_lane_change_start_position)
}

// optional .jmc_auto.common.Point3D lane_change_start_position = 5;
bool ChangeLaneStatus::has_lane_change_start_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ChangeLaneStatus::set_has_lane_change_start_position() {
  _has_bits_[0] |= 0x00000002u;
}
void ChangeLaneStatus::clear_has_lane_change_start_position() {
  _has_bits_[0] &= ~0x00000002u;
}
void ChangeLaneStatus::clear_lane_change_start_position() {
  if (lane_change_start_position_ != NULL) lane_change_start_position_->::jmc_auto::common::Point3D::Clear();
  clear_has_lane_change_start_position();
}
const ::jmc_auto::common::Point3D& ChangeLaneStatus::lane_change_start_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
  return lane_change_start_position_ != NULL ? *lane_change_start_position_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
::jmc_auto::common::Point3D* ChangeLaneStatus::mutable_lane_change_start_position() {
  set_has_lane_change_start_position();
  if (lane_change_start_position_ == NULL) {
    lane_change_start_position_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
  return lane_change_start_position_;
}
::jmc_auto::common::Point3D* ChangeLaneStatus::release_lane_change_start_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
  clear_has_lane_change_start_position();
  ::jmc_auto::common::Point3D* temp = lane_change_start_position_;
  lane_change_start_position_ = NULL;
  return temp;
}
void ChangeLaneStatus::set_allocated_lane_change_start_position(::jmc_auto::common::Point3D* lane_change_start_position) {
  delete lane_change_start_position_;
  lane_change_start_position_ = lane_change_start_position;
  if (lane_change_start_position) {
    set_has_lane_change_start_position();
  } else {
    clear_has_lane_change_start_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ChangeLaneStatus.lane_change_start_position)
}

// optional double last_succeed_timestamp = 6;
bool ChangeLaneStatus::has_last_succeed_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ChangeLaneStatus::set_has_last_succeed_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
void ChangeLaneStatus::clear_has_last_succeed_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
void ChangeLaneStatus::clear_last_succeed_timestamp() {
  last_succeed_timestamp_ = 0;
  clear_has_last_succeed_timestamp();
}
double ChangeLaneStatus::last_succeed_timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.last_succeed_timestamp)
  return last_succeed_timestamp_;
}
void ChangeLaneStatus::set_last_succeed_timestamp(double value) {
  set_has_last_succeed_timestamp();
  last_succeed_timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.last_succeed_timestamp)
}

// optional bool is_current_opt_succeed = 7 [default = false];
bool ChangeLaneStatus::has_is_current_opt_succeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ChangeLaneStatus::set_has_is_current_opt_succeed() {
  _has_bits_[0] |= 0x00000020u;
}
void ChangeLaneStatus::clear_has_is_current_opt_succeed() {
  _has_bits_[0] &= ~0x00000020u;
}
void ChangeLaneStatus::clear_is_current_opt_succeed() {
  is_current_opt_succeed_ = false;
  clear_has_is_current_opt_succeed();
}
bool ChangeLaneStatus::is_current_opt_succeed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.is_current_opt_succeed)
  return is_current_opt_succeed_;
}
void ChangeLaneStatus::set_is_current_opt_succeed(bool value) {
  set_has_is_current_opt_succeed();
  is_current_opt_succeed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.is_current_opt_succeed)
}

// optional bool is_clear_to_change_lane = 8 [default = false];
bool ChangeLaneStatus::has_is_clear_to_change_lane() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ChangeLaneStatus::set_has_is_clear_to_change_lane() {
  _has_bits_[0] |= 0x00000040u;
}
void ChangeLaneStatus::clear_has_is_clear_to_change_lane() {
  _has_bits_[0] &= ~0x00000040u;
}
void ChangeLaneStatus::clear_is_clear_to_change_lane() {
  is_clear_to_change_lane_ = false;
  clear_has_is_clear_to_change_lane();
}
bool ChangeLaneStatus::is_clear_to_change_lane() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChangeLaneStatus.is_clear_to_change_lane)
  return is_clear_to_change_lane_;
}
void ChangeLaneStatus::set_is_clear_to_change_lane(bool value) {
  set_has_is_clear_to_change_lane();
  is_clear_to_change_lane_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChangeLaneStatus.is_clear_to_change_lane)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopTime::kObstacleIdFieldNumber;
const int StopTime::kObstacleStopTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopTime::StopTime()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.StopTime)
}
StopTime::StopTime(const StopTime& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  obstacle_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_obstacle_id()) {
    obstacle_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.obstacle_id_);
  }
  obstacle_stop_timestamp_ = from.obstacle_stop_timestamp_;
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.StopTime)
}

void StopTime::SharedCtor() {
  _cached_size_ = 0;
  obstacle_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  obstacle_stop_timestamp_ = 0;
}

StopTime::~StopTime() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.StopTime)
  SharedDtor();
}

void StopTime::SharedDtor() {
  obstacle_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void StopTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopTime::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const StopTime& StopTime::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

StopTime* StopTime::New(::google::protobuf::Arena* arena) const {
  StopTime* n = new StopTime;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopTime::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.StopTime)
  if (has_obstacle_id()) {
    GOOGLE_DCHECK(!obstacle_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*obstacle_id_.UnsafeRawStringPointer())->clear();
  }
  obstacle_stop_timestamp_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StopTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.StopTime)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string obstacle_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_obstacle_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->obstacle_id().data(), this->obstacle_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.StopTime.obstacle_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double obstacle_stop_timestamp = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_obstacle_stop_timestamp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &obstacle_stop_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.StopTime)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.StopTime)
  return false;
#undef DO_
}

void StopTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.StopTime)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string obstacle_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->obstacle_id().data(), this->obstacle_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopTime.obstacle_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->obstacle_id(), output);
  }

  // optional double obstacle_stop_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->obstacle_stop_timestamp(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.StopTime)
}

::google::protobuf::uint8* StopTime::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.StopTime)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string obstacle_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->obstacle_id().data(), this->obstacle_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopTime.obstacle_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->obstacle_id(), target);
  }

  // optional double obstacle_stop_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->obstacle_stop_timestamp(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.StopTime)
  return target;
}

size_t StopTime::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.StopTime)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string obstacle_id = 1;
    if (has_obstacle_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->obstacle_id());
    }

    // optional double obstacle_stop_timestamp = 2;
    if (has_obstacle_stop_timestamp()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopTime::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.StopTime)
  GOOGLE_DCHECK_NE(&from, this);
  const StopTime* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const StopTime>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.StopTime)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.StopTime)
    MergeFrom(*source);
  }
}

void StopTime::MergeFrom(const StopTime& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.StopTime)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_obstacle_id();
      obstacle_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.obstacle_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      obstacle_stop_timestamp_ = from.obstacle_stop_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StopTime::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.StopTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopTime::CopyFrom(const StopTime& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.StopTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopTime::IsInitialized() const {
  return true;
}

void StopTime::Swap(StopTime* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopTime::InternalSwap(StopTime* other) {
  obstacle_id_.Swap(&other->obstacle_id_);
  std::swap(obstacle_stop_timestamp_, other->obstacle_stop_timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopTime::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StopTime

// optional string obstacle_id = 1;
bool StopTime::has_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StopTime::set_has_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
void StopTime::clear_has_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void StopTime::clear_obstacle_id() {
  obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_obstacle_id();
}
const ::std::string& StopTime::obstacle_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopTime.obstacle_id)
  return obstacle_id_.GetNoArena();
}
void StopTime::set_obstacle_id(const ::std::string& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopTime.obstacle_id)
}
#if LANG_CXX11
void StopTime::set_obstacle_id(::std::string&& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.StopTime.obstacle_id)
}
#endif
void StopTime::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopTime.obstacle_id)
}
void StopTime::set_obstacle_id(const char* value, size_t size) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopTime.obstacle_id)
}
::std::string* StopTime::mutable_obstacle_id() {
  set_has_obstacle_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopTime.obstacle_id)
  return obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* StopTime::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StopTime.obstacle_id)
  clear_has_obstacle_id();
  return obstacle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StopTime::set_allocated_obstacle_id(::std::string* obstacle_id) {
  if (obstacle_id != NULL) {
    set_has_obstacle_id();
  } else {
    clear_has_obstacle_id();
  }
  obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StopTime.obstacle_id)
}

// optional double obstacle_stop_timestamp = 2;
bool StopTime::has_obstacle_stop_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StopTime::set_has_obstacle_stop_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void StopTime::clear_has_obstacle_stop_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void StopTime::clear_obstacle_stop_timestamp() {
  obstacle_stop_timestamp_ = 0;
  clear_has_obstacle_stop_timestamp();
}
double StopTime::obstacle_stop_timestamp() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopTime.obstacle_stop_timestamp)
  return obstacle_stop_timestamp_;
}
void StopTime::set_obstacle_stop_timestamp(double value) {
  set_has_obstacle_stop_timestamp();
  obstacle_stop_timestamp_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopTime.obstacle_stop_timestamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CrosswalkStatus::kCrosswalkIdFieldNumber;
const int CrosswalkStatus::kStopTimeFieldNumber;
const int CrosswalkStatus::kFinishedCrosswalkFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CrosswalkStatus::CrosswalkStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.CrosswalkStatus)
}
CrosswalkStatus::CrosswalkStatus(const CrosswalkStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      stop_time_(from.stop_time_),
      finished_crosswalk_(from.finished_crosswalk_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  crosswalk_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_crosswalk_id()) {
    crosswalk_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.crosswalk_id_);
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.CrosswalkStatus)
}

void CrosswalkStatus::SharedCtor() {
  _cached_size_ = 0;
  crosswalk_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

CrosswalkStatus::~CrosswalkStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.CrosswalkStatus)
  SharedDtor();
}

void CrosswalkStatus::SharedDtor() {
  crosswalk_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CrosswalkStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CrosswalkStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CrosswalkStatus& CrosswalkStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

CrosswalkStatus* CrosswalkStatus::New(::google::protobuf::Arena* arena) const {
  CrosswalkStatus* n = new CrosswalkStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CrosswalkStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.CrosswalkStatus)
  stop_time_.Clear();
  finished_crosswalk_.Clear();
  if (has_crosswalk_id()) {
    GOOGLE_DCHECK(!crosswalk_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*crosswalk_id_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CrosswalkStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.CrosswalkStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string crosswalk_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_crosswalk_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->crosswalk_id().data(), this->crosswalk_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.CrosswalkStatus.crosswalk_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.StopTime stop_time = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stop_time()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string finished_crosswalk = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_finished_crosswalk()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->finished_crosswalk(this->finished_crosswalk_size() - 1).data(),
            this->finished_crosswalk(this->finished_crosswalk_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.CrosswalkStatus.finished_crosswalk");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.CrosswalkStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.CrosswalkStatus)
  return false;
#undef DO_
}

void CrosswalkStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.CrosswalkStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string crosswalk_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->crosswalk_id().data(), this->crosswalk_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.CrosswalkStatus.crosswalk_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->crosswalk_id(), output);
  }

  // repeated .jmc_auto.planning.StopTime stop_time = 2;
  for (unsigned int i = 0, n = this->stop_time_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->stop_time(i), output);
  }

  // repeated string finished_crosswalk = 3;
  for (int i = 0, n = this->finished_crosswalk_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->finished_crosswalk(i).data(), this->finished_crosswalk(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.CrosswalkStatus.finished_crosswalk");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->finished_crosswalk(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.CrosswalkStatus)
}

::google::protobuf::uint8* CrosswalkStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.CrosswalkStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string crosswalk_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->crosswalk_id().data(), this->crosswalk_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.CrosswalkStatus.crosswalk_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->crosswalk_id(), target);
  }

  // repeated .jmc_auto.planning.StopTime stop_time = 2;
  for (unsigned int i = 0, n = this->stop_time_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->stop_time(i), deterministic, target);
  }

  // repeated string finished_crosswalk = 3;
  for (int i = 0, n = this->finished_crosswalk_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->finished_crosswalk(i).data(), this->finished_crosswalk(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.CrosswalkStatus.finished_crosswalk");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->finished_crosswalk(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.CrosswalkStatus)
  return target;
}

size_t CrosswalkStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.CrosswalkStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.StopTime stop_time = 2;
  {
    unsigned int count = this->stop_time_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stop_time(i));
    }
  }

  // repeated string finished_crosswalk = 3;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->finished_crosswalk_size());
  for (int i = 0, n = this->finished_crosswalk_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->finished_crosswalk(i));
  }

  // optional string crosswalk_id = 1;
  if (has_crosswalk_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->crosswalk_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CrosswalkStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.CrosswalkStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const CrosswalkStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CrosswalkStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.CrosswalkStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.CrosswalkStatus)
    MergeFrom(*source);
  }
}

void CrosswalkStatus::MergeFrom(const CrosswalkStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.CrosswalkStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  stop_time_.MergeFrom(from.stop_time_);
  finished_crosswalk_.MergeFrom(from.finished_crosswalk_);
  if (from.has_crosswalk_id()) {
    set_has_crosswalk_id();
    crosswalk_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.crosswalk_id_);
  }
}

void CrosswalkStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.CrosswalkStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrosswalkStatus::CopyFrom(const CrosswalkStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.CrosswalkStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrosswalkStatus::IsInitialized() const {
  return true;
}

void CrosswalkStatus::Swap(CrosswalkStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CrosswalkStatus::InternalSwap(CrosswalkStatus* other) {
  stop_time_.InternalSwap(&other->stop_time_);
  finished_crosswalk_.InternalSwap(&other->finished_crosswalk_);
  crosswalk_id_.Swap(&other->crosswalk_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CrosswalkStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CrosswalkStatus

// optional string crosswalk_id = 1;
bool CrosswalkStatus::has_crosswalk_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CrosswalkStatus::set_has_crosswalk_id() {
  _has_bits_[0] |= 0x00000001u;
}
void CrosswalkStatus::clear_has_crosswalk_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void CrosswalkStatus::clear_crosswalk_id() {
  crosswalk_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_crosswalk_id();
}
const ::std::string& CrosswalkStatus::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
  return crosswalk_id_.GetNoArena();
}
void CrosswalkStatus::set_crosswalk_id(const ::std::string& value) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
#if LANG_CXX11
void CrosswalkStatus::set_crosswalk_id(::std::string&& value) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
#endif
void CrosswalkStatus::set_crosswalk_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
void CrosswalkStatus::set_crosswalk_id(const char* value, size_t size) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}
::std::string* CrosswalkStatus::mutable_crosswalk_id() {
  set_has_crosswalk_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
  return crosswalk_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CrosswalkStatus::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
  clear_has_crosswalk_id();
  return crosswalk_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CrosswalkStatus::set_allocated_crosswalk_id(::std::string* crosswalk_id) {
  if (crosswalk_id != NULL) {
    set_has_crosswalk_id();
  } else {
    clear_has_crosswalk_id();
  }
  crosswalk_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crosswalk_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.CrosswalkStatus.crosswalk_id)
}

// repeated .jmc_auto.planning.StopTime stop_time = 2;
int CrosswalkStatus::stop_time_size() const {
  return stop_time_.size();
}
void CrosswalkStatus::clear_stop_time() {
  stop_time_.Clear();
}
const ::jmc_auto::planning::StopTime& CrosswalkStatus::stop_time(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_.Get(index);
}
::jmc_auto::planning::StopTime* CrosswalkStatus::mutable_stop_time(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_.Mutable(index);
}
::jmc_auto::planning::StopTime* CrosswalkStatus::add_stop_time() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_.Add();
}
::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime >*
CrosswalkStatus::mutable_stop_time() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.CrosswalkStatus.stop_time)
  return &stop_time_;
}
const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::StopTime >&
CrosswalkStatus::stop_time() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.CrosswalkStatus.stop_time)
  return stop_time_;
}

// repeated string finished_crosswalk = 3;
int CrosswalkStatus::finished_crosswalk_size() const {
  return finished_crosswalk_.size();
}
void CrosswalkStatus::clear_finished_crosswalk() {
  finished_crosswalk_.Clear();
}
const ::std::string& CrosswalkStatus::finished_crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Get(index);
}
::std::string* CrosswalkStatus::mutable_finished_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Mutable(index);
}
void CrosswalkStatus::set_finished_crosswalk(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  finished_crosswalk_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void CrosswalkStatus::set_finished_crosswalk(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  finished_crosswalk_.Mutable(index)->assign(std::move(value));
}
#endif
void CrosswalkStatus::set_finished_crosswalk(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  finished_crosswalk_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
void CrosswalkStatus::set_finished_crosswalk(int index, const char* value, size_t size) {
  finished_crosswalk_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
::std::string* CrosswalkStatus::add_finished_crosswalk() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_.Add();
}
void CrosswalkStatus::add_finished_crosswalk(const ::std::string& value) {
  finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
#if LANG_CXX11
void CrosswalkStatus::add_finished_crosswalk(::std::string&& value) {
  finished_crosswalk_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
#endif
void CrosswalkStatus::add_finished_crosswalk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  finished_crosswalk_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
void CrosswalkStatus::add_finished_crosswalk(const char* value, size_t size) {
  finished_crosswalk_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
CrosswalkStatus::finished_crosswalk() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return finished_crosswalk_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
CrosswalkStatus::mutable_finished_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.CrosswalkStatus.finished_crosswalk)
  return &finished_crosswalk_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DestinationStatus::kHasPassedDestinationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DestinationStatus::DestinationStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.DestinationStatus)
}
DestinationStatus::DestinationStatus(const DestinationStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  has_passed_destination_ = from.has_passed_destination_;
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.DestinationStatus)
}

void DestinationStatus::SharedCtor() {
  _cached_size_ = 0;
  has_passed_destination_ = false;
}

DestinationStatus::~DestinationStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.DestinationStatus)
  SharedDtor();
}

void DestinationStatus::SharedDtor() {
}

void DestinationStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DestinationStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DestinationStatus& DestinationStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

DestinationStatus* DestinationStatus::New(::google::protobuf::Arena* arena) const {
  DestinationStatus* n = new DestinationStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DestinationStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.DestinationStatus)
  has_passed_destination_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DestinationStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.DestinationStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool has_passed_destination = 1 [default = false];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_has_passed_destination();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_passed_destination_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.DestinationStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.DestinationStatus)
  return false;
#undef DO_
}

void DestinationStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.DestinationStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool has_passed_destination = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->has_passed_destination(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.DestinationStatus)
}

::google::protobuf::uint8* DestinationStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.DestinationStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool has_passed_destination = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->has_passed_destination(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.DestinationStatus)
  return target;
}

size_t DestinationStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.DestinationStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bool has_passed_destination = 1 [default = false];
  if (has_has_passed_destination()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DestinationStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.DestinationStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const DestinationStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DestinationStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.DestinationStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.DestinationStatus)
    MergeFrom(*source);
  }
}

void DestinationStatus::MergeFrom(const DestinationStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.DestinationStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_has_passed_destination()) {
    set_has_passed_destination(from.has_passed_destination());
  }
}

void DestinationStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.DestinationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DestinationStatus::CopyFrom(const DestinationStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.DestinationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DestinationStatus::IsInitialized() const {
  return true;
}

void DestinationStatus::Swap(DestinationStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DestinationStatus::InternalSwap(DestinationStatus* other) {
  std::swap(has_passed_destination_, other->has_passed_destination_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DestinationStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DestinationStatus

// optional bool has_passed_destination = 1 [default = false];
bool DestinationStatus::has_has_passed_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DestinationStatus::set_has_has_passed_destination() {
  _has_bits_[0] |= 0x00000001u;
}
void DestinationStatus::clear_has_has_passed_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
void DestinationStatus::clear_has_passed_destination() {
  has_passed_destination_ = false;
  clear_has_has_passed_destination();
}
bool DestinationStatus::has_passed_destination() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.DestinationStatus.has_passed_destination)
  return has_passed_destination_;
}
void DestinationStatus::set_has_passed_destination(bool value) {
  set_has_has_passed_destination();
  has_passed_destination_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.DestinationStatus.has_passed_destination)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EmergencyStopStatus::kStopFencePointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EmergencyStopStatus::EmergencyStopStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.EmergencyStopStatus)
}
EmergencyStopStatus::EmergencyStopStatus(const EmergencyStopStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_stop_fence_point()) {
    stop_fence_point_ = new ::jmc_auto::common::PointENU(*from.stop_fence_point_);
  } else {
    stop_fence_point_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.EmergencyStopStatus)
}

void EmergencyStopStatus::SharedCtor() {
  _cached_size_ = 0;
  stop_fence_point_ = NULL;
}

EmergencyStopStatus::~EmergencyStopStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.EmergencyStopStatus)
  SharedDtor();
}

void EmergencyStopStatus::SharedDtor() {
  if (this != internal_default_instance()) {
    delete stop_fence_point_;
  }
}

void EmergencyStopStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmergencyStopStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EmergencyStopStatus& EmergencyStopStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

EmergencyStopStatus* EmergencyStopStatus::New(::google::protobuf::Arena* arena) const {
  EmergencyStopStatus* n = new EmergencyStopStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EmergencyStopStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.EmergencyStopStatus)
  if (has_stop_fence_point()) {
    GOOGLE_DCHECK(stop_fence_point_ != NULL);
    stop_fence_point_->::jmc_auto::common::PointENU::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EmergencyStopStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.EmergencyStopStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.common.PointENU stop_fence_point = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_fence_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.EmergencyStopStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.EmergencyStopStatus)
  return false;
#undef DO_
}

void EmergencyStopStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.EmergencyStopStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.common.PointENU stop_fence_point = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->stop_fence_point_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.EmergencyStopStatus)
}

::google::protobuf::uint8* EmergencyStopStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.EmergencyStopStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.common.PointENU stop_fence_point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->stop_fence_point_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.EmergencyStopStatus)
  return target;
}

size_t EmergencyStopStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.EmergencyStopStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .jmc_auto.common.PointENU stop_fence_point = 1;
  if (has_stop_fence_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->stop_fence_point_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmergencyStopStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.EmergencyStopStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const EmergencyStopStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EmergencyStopStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.EmergencyStopStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.EmergencyStopStatus)
    MergeFrom(*source);
  }
}

void EmergencyStopStatus::MergeFrom(const EmergencyStopStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.EmergencyStopStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_stop_fence_point()) {
    mutable_stop_fence_point()->::jmc_auto::common::PointENU::MergeFrom(from.stop_fence_point());
  }
}

void EmergencyStopStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.EmergencyStopStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmergencyStopStatus::CopyFrom(const EmergencyStopStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.EmergencyStopStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmergencyStopStatus::IsInitialized() const {
  return true;
}

void EmergencyStopStatus::Swap(EmergencyStopStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EmergencyStopStatus::InternalSwap(EmergencyStopStatus* other) {
  std::swap(stop_fence_point_, other->stop_fence_point_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EmergencyStopStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EmergencyStopStatus

// optional .jmc_auto.common.PointENU stop_fence_point = 1;
bool EmergencyStopStatus::has_stop_fence_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EmergencyStopStatus::set_has_stop_fence_point() {
  _has_bits_[0] |= 0x00000001u;
}
void EmergencyStopStatus::clear_has_stop_fence_point() {
  _has_bits_[0] &= ~0x00000001u;
}
void EmergencyStopStatus::clear_stop_fence_point() {
  if (stop_fence_point_ != NULL) stop_fence_point_->::jmc_auto::common::PointENU::Clear();
  clear_has_stop_fence_point();
}
const ::jmc_auto::common::PointENU& EmergencyStopStatus::stop_fence_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
  return stop_fence_point_ != NULL ? *stop_fence_point_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
::jmc_auto::common::PointENU* EmergencyStopStatus::mutable_stop_fence_point() {
  set_has_stop_fence_point();
  if (stop_fence_point_ == NULL) {
    stop_fence_point_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
  return stop_fence_point_;
}
::jmc_auto::common::PointENU* EmergencyStopStatus::release_stop_fence_point() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
  clear_has_stop_fence_point();
  ::jmc_auto::common::PointENU* temp = stop_fence_point_;
  stop_fence_point_ = NULL;
  return temp;
}
void EmergencyStopStatus::set_allocated_stop_fence_point(::jmc_auto::common::PointENU* stop_fence_point) {
  delete stop_fence_point_;
  stop_fence_point_ = stop_fence_point;
  if (stop_fence_point) {
    set_has_stop_fence_point();
  } else {
    clear_has_stop_fence_point();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.EmergencyStopStatus.stop_fence_point)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OpenSpaceStatus::kPartitionedTrajectoriesIndexHistoryFieldNumber;
const int OpenSpaceStatus::kPositionInitFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OpenSpaceStatus::OpenSpaceStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.OpenSpaceStatus)
}
OpenSpaceStatus::OpenSpaceStatus(const OpenSpaceStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      partitioned_trajectories_index_history_(from.partitioned_trajectories_index_history_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  position_init_ = from.position_init_;
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.OpenSpaceStatus)
}

void OpenSpaceStatus::SharedCtor() {
  _cached_size_ = 0;
  position_init_ = false;
}

OpenSpaceStatus::~OpenSpaceStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.OpenSpaceStatus)
  SharedDtor();
}

void OpenSpaceStatus::SharedDtor() {
}

void OpenSpaceStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpenSpaceStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const OpenSpaceStatus& OpenSpaceStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

OpenSpaceStatus* OpenSpaceStatus::New(::google::protobuf::Arena* arena) const {
  OpenSpaceStatus* n = new OpenSpaceStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpenSpaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.OpenSpaceStatus)
  partitioned_trajectories_index_history_.Clear();
  position_init_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OpenSpaceStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.OpenSpaceStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string partitioned_trajectories_index_history = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_partitioned_trajectories_index_history()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->partitioned_trajectories_index_history(this->partitioned_trajectories_index_history_size() - 1).data(),
            this->partitioned_trajectories_index_history(this->partitioned_trajectories_index_history_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool position_init = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_position_init();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &position_init_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.OpenSpaceStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.OpenSpaceStatus)
  return false;
#undef DO_
}

void OpenSpaceStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.OpenSpaceStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string partitioned_trajectories_index_history = 1;
  for (int i = 0, n = this->partitioned_trajectories_index_history_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->partitioned_trajectories_index_history(i).data(), this->partitioned_trajectories_index_history(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->partitioned_trajectories_index_history(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool position_init = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->position_init(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.OpenSpaceStatus)
}

::google::protobuf::uint8* OpenSpaceStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.OpenSpaceStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string partitioned_trajectories_index_history = 1;
  for (int i = 0, n = this->partitioned_trajectories_index_history_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->partitioned_trajectories_index_history(i).data(), this->partitioned_trajectories_index_history(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->partitioned_trajectories_index_history(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool position_init = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->position_init(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.OpenSpaceStatus)
  return target;
}

size_t OpenSpaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.OpenSpaceStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string partitioned_trajectories_index_history = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->partitioned_trajectories_index_history_size());
  for (int i = 0, n = this->partitioned_trajectories_index_history_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->partitioned_trajectories_index_history(i));
  }

  // optional bool position_init = 2 [default = false];
  if (has_position_init()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenSpaceStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.OpenSpaceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const OpenSpaceStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const OpenSpaceStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.OpenSpaceStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.OpenSpaceStatus)
    MergeFrom(*source);
  }
}

void OpenSpaceStatus::MergeFrom(const OpenSpaceStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.OpenSpaceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partitioned_trajectories_index_history_.MergeFrom(from.partitioned_trajectories_index_history_);
  if (from.has_position_init()) {
    set_position_init(from.position_init());
  }
}

void OpenSpaceStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.OpenSpaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpenSpaceStatus::CopyFrom(const OpenSpaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.OpenSpaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenSpaceStatus::IsInitialized() const {
  return true;
}

void OpenSpaceStatus::Swap(OpenSpaceStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpenSpaceStatus::InternalSwap(OpenSpaceStatus* other) {
  partitioned_trajectories_index_history_.InternalSwap(&other->partitioned_trajectories_index_history_);
  std::swap(position_init_, other->position_init_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OpenSpaceStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpenSpaceStatus

// repeated string partitioned_trajectories_index_history = 1;
int OpenSpaceStatus::partitioned_trajectories_index_history_size() const {
  return partitioned_trajectories_index_history_.size();
}
void OpenSpaceStatus::clear_partitioned_trajectories_index_history() {
  partitioned_trajectories_index_history_.Clear();
}
const ::std::string& OpenSpaceStatus::partitioned_trajectories_index_history(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_.Get(index);
}
::std::string* OpenSpaceStatus::mutable_partitioned_trajectories_index_history(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_.Mutable(index);
}
void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  partitioned_trajectories_index_history_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  partitioned_trajectories_index_history_.Mutable(index)->assign(std::move(value));
}
#endif
void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  partitioned_trajectories_index_history_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
void OpenSpaceStatus::set_partitioned_trajectories_index_history(int index, const char* value, size_t size) {
  partitioned_trajectories_index_history_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
::std::string* OpenSpaceStatus::add_partitioned_trajectories_index_history() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_.Add();
}
void OpenSpaceStatus::add_partitioned_trajectories_index_history(const ::std::string& value) {
  partitioned_trajectories_index_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
#if LANG_CXX11
void OpenSpaceStatus::add_partitioned_trajectories_index_history(::std::string&& value) {
  partitioned_trajectories_index_history_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
#endif
void OpenSpaceStatus::add_partitioned_trajectories_index_history(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  partitioned_trajectories_index_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
void OpenSpaceStatus::add_partitioned_trajectories_index_history(const char* value, size_t size) {
  partitioned_trajectories_index_history_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
OpenSpaceStatus::partitioned_trajectories_index_history() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return partitioned_trajectories_index_history_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
OpenSpaceStatus::mutable_partitioned_trajectories_index_history() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.OpenSpaceStatus.partitioned_trajectories_index_history)
  return &partitioned_trajectories_index_history_;
}

// optional bool position_init = 2 [default = false];
bool OpenSpaceStatus::has_position_init() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OpenSpaceStatus::set_has_position_init() {
  _has_bits_[0] |= 0x00000001u;
}
void OpenSpaceStatus::clear_has_position_init() {
  _has_bits_[0] &= ~0x00000001u;
}
void OpenSpaceStatus::clear_position_init() {
  position_init_ = false;
  clear_has_position_init();
}
bool OpenSpaceStatus::position_init() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OpenSpaceStatus.position_init)
  return position_init_;
}
void OpenSpaceStatus::set_position_init(bool value) {
  set_has_position_init();
  position_init_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OpenSpaceStatus.position_init)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ParkAndGoStatus::kAdcInitPositionFieldNumber;
const int ParkAndGoStatus::kAdcInitHeadingFieldNumber;
const int ParkAndGoStatus::kInCheckStageFieldNumber;
const int ParkAndGoStatus::kAdcAdjustEndPoseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ParkAndGoStatus::ParkAndGoStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ParkAndGoStatus)
}
ParkAndGoStatus::ParkAndGoStatus(const ParkAndGoStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_adc_init_position()) {
    adc_init_position_ = new ::jmc_auto::common::PointENU(*from.adc_init_position_);
  } else {
    adc_init_position_ = NULL;
  }
  if (from.has_adc_adjust_end_pose()) {
    adc_adjust_end_pose_ = new ::jmc_auto::common::PointENU(*from.adc_adjust_end_pose_);
  } else {
    adc_adjust_end_pose_ = NULL;
  }
  ::memcpy(&adc_init_heading_, &from.adc_init_heading_,
    reinterpret_cast<char*>(&in_check_stage_) -
    reinterpret_cast<char*>(&adc_init_heading_) + sizeof(in_check_stage_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ParkAndGoStatus)
}

void ParkAndGoStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&adc_init_position_, 0, reinterpret_cast<char*>(&in_check_stage_) -
    reinterpret_cast<char*>(&adc_init_position_) + sizeof(in_check_stage_));
}

ParkAndGoStatus::~ParkAndGoStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ParkAndGoStatus)
  SharedDtor();
}

void ParkAndGoStatus::SharedDtor() {
  if (this != internal_default_instance()) {
    delete adc_init_position_;
  }
  if (this != internal_default_instance()) {
    delete adc_adjust_end_pose_;
  }
}

void ParkAndGoStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParkAndGoStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ParkAndGoStatus& ParkAndGoStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

ParkAndGoStatus* ParkAndGoStatus::New(::google::protobuf::Arena* arena) const {
  ParkAndGoStatus* n = new ParkAndGoStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ParkAndGoStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ParkAndGoStatus)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_adc_init_position()) {
      GOOGLE_DCHECK(adc_init_position_ != NULL);
      adc_init_position_->::jmc_auto::common::PointENU::Clear();
    }
    if (has_adc_adjust_end_pose()) {
      GOOGLE_DCHECK(adc_adjust_end_pose_ != NULL);
      adc_adjust_end_pose_->::jmc_auto::common::PointENU::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 12u) {
    ::memset(&adc_init_heading_, 0, reinterpret_cast<char*>(&in_check_stage_) -
      reinterpret_cast<char*>(&adc_init_heading_) + sizeof(in_check_stage_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ParkAndGoStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ParkAndGoStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.common.PointENU adc_init_position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_adc_init_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double adc_init_heading = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_adc_init_heading();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &adc_init_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool in_check_stage = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_in_check_stage();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_check_stage_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_adc_adjust_end_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ParkAndGoStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ParkAndGoStatus)
  return false;
#undef DO_
}

void ParkAndGoStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ParkAndGoStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.common.PointENU adc_init_position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->adc_init_position_, output);
  }

  // optional double adc_init_heading = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->adc_init_heading(), output);
  }

  // optional bool in_check_stage = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->in_check_stage(), output);
  }

  // optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->adc_adjust_end_pose_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ParkAndGoStatus)
}

::google::protobuf::uint8* ParkAndGoStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ParkAndGoStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.common.PointENU adc_init_position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->adc_init_position_, deterministic, target);
  }

  // optional double adc_init_heading = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->adc_init_heading(), target);
  }

  // optional bool in_check_stage = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->in_check_stage(), target);
  }

  // optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->adc_adjust_end_pose_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ParkAndGoStatus)
  return target;
}

size_t ParkAndGoStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ParkAndGoStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional .jmc_auto.common.PointENU adc_init_position = 1;
    if (has_adc_init_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->adc_init_position_);
    }

    // optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
    if (has_adc_adjust_end_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->adc_adjust_end_pose_);
    }

    // optional double adc_init_heading = 2;
    if (has_adc_init_heading()) {
      total_size += 1 + 8;
    }

    // optional bool in_check_stage = 3;
    if (has_in_check_stage()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkAndGoStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ParkAndGoStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const ParkAndGoStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ParkAndGoStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ParkAndGoStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ParkAndGoStatus)
    MergeFrom(*source);
  }
}

void ParkAndGoStatus::MergeFrom(const ParkAndGoStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ParkAndGoStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_adc_init_position()->::jmc_auto::common::PointENU::MergeFrom(from.adc_init_position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_adc_adjust_end_pose()->::jmc_auto::common::PointENU::MergeFrom(from.adc_adjust_end_pose());
    }
    if (cached_has_bits & 0x00000004u) {
      adc_init_heading_ = from.adc_init_heading_;
    }
    if (cached_has_bits & 0x00000008u) {
      in_check_stage_ = from.in_check_stage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ParkAndGoStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ParkAndGoStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParkAndGoStatus::CopyFrom(const ParkAndGoStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ParkAndGoStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkAndGoStatus::IsInitialized() const {
  return true;
}

void ParkAndGoStatus::Swap(ParkAndGoStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ParkAndGoStatus::InternalSwap(ParkAndGoStatus* other) {
  std::swap(adc_init_position_, other->adc_init_position_);
  std::swap(adc_adjust_end_pose_, other->adc_adjust_end_pose_);
  std::swap(adc_init_heading_, other->adc_init_heading_);
  std::swap(in_check_stage_, other->in_check_stage_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ParkAndGoStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ParkAndGoStatus

// optional .jmc_auto.common.PointENU adc_init_position = 1;
bool ParkAndGoStatus::has_adc_init_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ParkAndGoStatus::set_has_adc_init_position() {
  _has_bits_[0] |= 0x00000001u;
}
void ParkAndGoStatus::clear_has_adc_init_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void ParkAndGoStatus::clear_adc_init_position() {
  if (adc_init_position_ != NULL) adc_init_position_->::jmc_auto::common::PointENU::Clear();
  clear_has_adc_init_position();
}
const ::jmc_auto::common::PointENU& ParkAndGoStatus::adc_init_position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
  return adc_init_position_ != NULL ? *adc_init_position_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
::jmc_auto::common::PointENU* ParkAndGoStatus::mutable_adc_init_position() {
  set_has_adc_init_position();
  if (adc_init_position_ == NULL) {
    adc_init_position_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
  return adc_init_position_;
}
::jmc_auto::common::PointENU* ParkAndGoStatus::release_adc_init_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
  clear_has_adc_init_position();
  ::jmc_auto::common::PointENU* temp = adc_init_position_;
  adc_init_position_ = NULL;
  return temp;
}
void ParkAndGoStatus::set_allocated_adc_init_position(::jmc_auto::common::PointENU* adc_init_position) {
  delete adc_init_position_;
  adc_init_position_ = adc_init_position;
  if (adc_init_position) {
    set_has_adc_init_position();
  } else {
    clear_has_adc_init_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ParkAndGoStatus.adc_init_position)
}

// optional double adc_init_heading = 2;
bool ParkAndGoStatus::has_adc_init_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ParkAndGoStatus::set_has_adc_init_heading() {
  _has_bits_[0] |= 0x00000004u;
}
void ParkAndGoStatus::clear_has_adc_init_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
void ParkAndGoStatus::clear_adc_init_heading() {
  adc_init_heading_ = 0;
  clear_has_adc_init_heading();
}
double ParkAndGoStatus::adc_init_heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.adc_init_heading)
  return adc_init_heading_;
}
void ParkAndGoStatus::set_adc_init_heading(double value) {
  set_has_adc_init_heading();
  adc_init_heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ParkAndGoStatus.adc_init_heading)
}

// optional bool in_check_stage = 3;
bool ParkAndGoStatus::has_in_check_stage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ParkAndGoStatus::set_has_in_check_stage() {
  _has_bits_[0] |= 0x00000008u;
}
void ParkAndGoStatus::clear_has_in_check_stage() {
  _has_bits_[0] &= ~0x00000008u;
}
void ParkAndGoStatus::clear_in_check_stage() {
  in_check_stage_ = false;
  clear_has_in_check_stage();
}
bool ParkAndGoStatus::in_check_stage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.in_check_stage)
  return in_check_stage_;
}
void ParkAndGoStatus::set_in_check_stage(bool value) {
  set_has_in_check_stage();
  in_check_stage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ParkAndGoStatus.in_check_stage)
}

// optional .jmc_auto.common.PointENU adc_adjust_end_pose = 4;
bool ParkAndGoStatus::has_adc_adjust_end_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ParkAndGoStatus::set_has_adc_adjust_end_pose() {
  _has_bits_[0] |= 0x00000002u;
}
void ParkAndGoStatus::clear_has_adc_adjust_end_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
void ParkAndGoStatus::clear_adc_adjust_end_pose() {
  if (adc_adjust_end_pose_ != NULL) adc_adjust_end_pose_->::jmc_auto::common::PointENU::Clear();
  clear_has_adc_adjust_end_pose();
}
const ::jmc_auto::common::PointENU& ParkAndGoStatus::adc_adjust_end_pose() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
  return adc_adjust_end_pose_ != NULL ? *adc_adjust_end_pose_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
::jmc_auto::common::PointENU* ParkAndGoStatus::mutable_adc_adjust_end_pose() {
  set_has_adc_adjust_end_pose();
  if (adc_adjust_end_pose_ == NULL) {
    adc_adjust_end_pose_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
  return adc_adjust_end_pose_;
}
::jmc_auto::common::PointENU* ParkAndGoStatus::release_adc_adjust_end_pose() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
  clear_has_adc_adjust_end_pose();
  ::jmc_auto::common::PointENU* temp = adc_adjust_end_pose_;
  adc_adjust_end_pose_ = NULL;
  return temp;
}
void ParkAndGoStatus::set_allocated_adc_adjust_end_pose(::jmc_auto::common::PointENU* adc_adjust_end_pose) {
  delete adc_adjust_end_pose_;
  adc_adjust_end_pose_ = adc_adjust_end_pose;
  if (adc_adjust_end_pose) {
    set_has_adc_adjust_end_pose();
  } else {
    clear_has_adc_adjust_end_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ParkAndGoStatus.adc_adjust_end_pose)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PathDeciderStatus::kFrontStaticObstacleCycleCounterFieldNumber;
const int PathDeciderStatus::kAbleToUseSelfLaneCounterFieldNumber;
const int PathDeciderStatus::kIsInPathLaneBorrowScenarioFieldNumber;
const int PathDeciderStatus::kFrontStaticObstacleIdFieldNumber;
const int PathDeciderStatus::kDecidedSidePassDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PathDeciderStatus::PathDeciderStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.PathDeciderStatus)
}
PathDeciderStatus::PathDeciderStatus(const PathDeciderStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      decided_side_pass_direction_(from.decided_side_pass_direction_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  front_static_obstacle_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_front_static_obstacle_id()) {
    front_static_obstacle_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.front_static_obstacle_id_);
  }
  ::memcpy(&front_static_obstacle_cycle_counter_, &from.front_static_obstacle_cycle_counter_,
    reinterpret_cast<char*>(&is_in_path_lane_borrow_scenario_) -
    reinterpret_cast<char*>(&front_static_obstacle_cycle_counter_) + sizeof(is_in_path_lane_borrow_scenario_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.PathDeciderStatus)
}

void PathDeciderStatus::SharedCtor() {
  _cached_size_ = 0;
  front_static_obstacle_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&front_static_obstacle_cycle_counter_, 0, reinterpret_cast<char*>(&is_in_path_lane_borrow_scenario_) -
    reinterpret_cast<char*>(&front_static_obstacle_cycle_counter_) + sizeof(is_in_path_lane_borrow_scenario_));
}

PathDeciderStatus::~PathDeciderStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.PathDeciderStatus)
  SharedDtor();
}

void PathDeciderStatus::SharedDtor() {
  front_static_obstacle_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PathDeciderStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PathDeciderStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PathDeciderStatus& PathDeciderStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

PathDeciderStatus* PathDeciderStatus::New(::google::protobuf::Arena* arena) const {
  PathDeciderStatus* n = new PathDeciderStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PathDeciderStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.PathDeciderStatus)
  decided_side_pass_direction_.Clear();
  if (has_front_static_obstacle_id()) {
    GOOGLE_DCHECK(!front_static_obstacle_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*front_static_obstacle_id_.UnsafeRawStringPointer())->clear();
  }
  if (_has_bits_[0 / 32] & 14u) {
    ::memset(&front_static_obstacle_cycle_counter_, 0, reinterpret_cast<char*>(&is_in_path_lane_borrow_scenario_) -
      reinterpret_cast<char*>(&front_static_obstacle_cycle_counter_) + sizeof(is_in_path_lane_borrow_scenario_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PathDeciderStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.PathDeciderStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_front_static_obstacle_cycle_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &front_static_obstacle_cycle_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_able_to_use_self_lane_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &able_to_use_self_lane_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_is_in_path_lane_borrow_scenario();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_in_path_lane_borrow_scenario_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string front_static_obstacle_id = 4 [default = ""];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_front_static_obstacle_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->front_static_obstacle_id().data(), this->front_static_obstacle_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value)) {
            add_decided_side_pass_direction(static_cast< ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(42u)) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 5,
                 ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_decided_side_pass_direction())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.PathDeciderStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.PathDeciderStatus)
  return false;
#undef DO_
}

void PathDeciderStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.PathDeciderStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->front_static_obstacle_cycle_counter(), output);
  }

  // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->able_to_use_self_lane_counter(), output);
  }

  // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_in_path_lane_borrow_scenario(), output);
  }

  // optional string front_static_obstacle_id = 4 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->front_static_obstacle_id().data(), this->front_static_obstacle_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->front_static_obstacle_id(), output);
  }

  // repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  for (int i = 0, n = this->decided_side_pass_direction_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->decided_side_pass_direction(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.PathDeciderStatus)
}

::google::protobuf::uint8* PathDeciderStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.PathDeciderStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->front_static_obstacle_cycle_counter(), target);
  }

  // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->able_to_use_self_lane_counter(), target);
  }

  // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->is_in_path_lane_borrow_scenario(), target);
  }

  // optional string front_static_obstacle_id = 4 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->front_static_obstacle_id().data(), this->front_static_obstacle_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->front_static_obstacle_id(), target);
  }

  // repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
    5, this->decided_side_pass_direction_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.PathDeciderStatus)
  return target;
}

size_t PathDeciderStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.PathDeciderStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
  {
    size_t data_size = 0;
    unsigned int count = this->decided_side_pass_direction_size();for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->decided_side_pass_direction(i));
    }
    total_size += (1UL * count) + data_size;
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional string front_static_obstacle_id = 4 [default = ""];
    if (has_front_static_obstacle_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->front_static_obstacle_id());
    }

    // optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
    if (has_front_static_obstacle_cycle_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->front_static_obstacle_cycle_counter());
    }

    // optional int32 able_to_use_self_lane_counter = 2 [default = 0];
    if (has_able_to_use_self_lane_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->able_to_use_self_lane_counter());
    }

    // optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
    if (has_is_in_path_lane_borrow_scenario()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PathDeciderStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.PathDeciderStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const PathDeciderStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PathDeciderStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.PathDeciderStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.PathDeciderStatus)
    MergeFrom(*source);
  }
}

void PathDeciderStatus::MergeFrom(const PathDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.PathDeciderStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  decided_side_pass_direction_.MergeFrom(from.decided_side_pass_direction_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_front_static_obstacle_id();
      front_static_obstacle_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.front_static_obstacle_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      front_static_obstacle_cycle_counter_ = from.front_static_obstacle_cycle_counter_;
    }
    if (cached_has_bits & 0x00000004u) {
      able_to_use_self_lane_counter_ = from.able_to_use_self_lane_counter_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_in_path_lane_borrow_scenario_ = from.is_in_path_lane_borrow_scenario_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PathDeciderStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.PathDeciderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PathDeciderStatus::CopyFrom(const PathDeciderStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.PathDeciderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathDeciderStatus::IsInitialized() const {
  return true;
}

void PathDeciderStatus::Swap(PathDeciderStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PathDeciderStatus::InternalSwap(PathDeciderStatus* other) {
  decided_side_pass_direction_.InternalSwap(&other->decided_side_pass_direction_);
  front_static_obstacle_id_.Swap(&other->front_static_obstacle_id_);
  std::swap(front_static_obstacle_cycle_counter_, other->front_static_obstacle_cycle_counter_);
  std::swap(able_to_use_self_lane_counter_, other->able_to_use_self_lane_counter_);
  std::swap(is_in_path_lane_borrow_scenario_, other->is_in_path_lane_borrow_scenario_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PathDeciderStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PathDeciderStatus

// optional int32 front_static_obstacle_cycle_counter = 1 [default = 0];
bool PathDeciderStatus::has_front_static_obstacle_cycle_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PathDeciderStatus::set_has_front_static_obstacle_cycle_counter() {
  _has_bits_[0] |= 0x00000002u;
}
void PathDeciderStatus::clear_has_front_static_obstacle_cycle_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
void PathDeciderStatus::clear_front_static_obstacle_cycle_counter() {
  front_static_obstacle_cycle_counter_ = 0;
  clear_has_front_static_obstacle_cycle_counter();
}
::google::protobuf::int32 PathDeciderStatus::front_static_obstacle_cycle_counter() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_cycle_counter)
  return front_static_obstacle_cycle_counter_;
}
void PathDeciderStatus::set_front_static_obstacle_cycle_counter(::google::protobuf::int32 value) {
  set_has_front_static_obstacle_cycle_counter();
  front_static_obstacle_cycle_counter_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_cycle_counter)
}

// optional int32 able_to_use_self_lane_counter = 2 [default = 0];
bool PathDeciderStatus::has_able_to_use_self_lane_counter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PathDeciderStatus::set_has_able_to_use_self_lane_counter() {
  _has_bits_[0] |= 0x00000004u;
}
void PathDeciderStatus::clear_has_able_to_use_self_lane_counter() {
  _has_bits_[0] &= ~0x00000004u;
}
void PathDeciderStatus::clear_able_to_use_self_lane_counter() {
  able_to_use_self_lane_counter_ = 0;
  clear_has_able_to_use_self_lane_counter();
}
::google::protobuf::int32 PathDeciderStatus::able_to_use_self_lane_counter() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.able_to_use_self_lane_counter)
  return able_to_use_self_lane_counter_;
}
void PathDeciderStatus::set_able_to_use_self_lane_counter(::google::protobuf::int32 value) {
  set_has_able_to_use_self_lane_counter();
  able_to_use_self_lane_counter_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.able_to_use_self_lane_counter)
}

// optional bool is_in_path_lane_borrow_scenario = 3 [default = false];
bool PathDeciderStatus::has_is_in_path_lane_borrow_scenario() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PathDeciderStatus::set_has_is_in_path_lane_borrow_scenario() {
  _has_bits_[0] |= 0x00000008u;
}
void PathDeciderStatus::clear_has_is_in_path_lane_borrow_scenario() {
  _has_bits_[0] &= ~0x00000008u;
}
void PathDeciderStatus::clear_is_in_path_lane_borrow_scenario() {
  is_in_path_lane_borrow_scenario_ = false;
  clear_has_is_in_path_lane_borrow_scenario();
}
bool PathDeciderStatus::is_in_path_lane_borrow_scenario() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.is_in_path_lane_borrow_scenario)
  return is_in_path_lane_borrow_scenario_;
}
void PathDeciderStatus::set_is_in_path_lane_borrow_scenario(bool value) {
  set_has_is_in_path_lane_borrow_scenario();
  is_in_path_lane_borrow_scenario_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.is_in_path_lane_borrow_scenario)
}

// optional string front_static_obstacle_id = 4 [default = ""];
bool PathDeciderStatus::has_front_static_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PathDeciderStatus::set_has_front_static_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
void PathDeciderStatus::clear_has_front_static_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void PathDeciderStatus::clear_front_static_obstacle_id() {
  front_static_obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_front_static_obstacle_id();
}
const ::std::string& PathDeciderStatus::front_static_obstacle_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
  return front_static_obstacle_id_.GetNoArena();
}
void PathDeciderStatus::set_front_static_obstacle_id(const ::std::string& value) {
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
#if LANG_CXX11
void PathDeciderStatus::set_front_static_obstacle_id(::std::string&& value) {
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
#endif
void PathDeciderStatus::set_front_static_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
void PathDeciderStatus::set_front_static_obstacle_id(const char* value, size_t size) {
  set_has_front_static_obstacle_id();
  front_static_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}
::std::string* PathDeciderStatus::mutable_front_static_obstacle_id() {
  set_has_front_static_obstacle_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
  return front_static_obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* PathDeciderStatus::release_front_static_obstacle_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
  clear_has_front_static_obstacle_id();
  return front_static_obstacle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void PathDeciderStatus::set_allocated_front_static_obstacle_id(::std::string* front_static_obstacle_id) {
  if (front_static_obstacle_id != NULL) {
    set_has_front_static_obstacle_id();
  } else {
    clear_has_front_static_obstacle_id();
  }
  front_static_obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), front_static_obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PathDeciderStatus.front_static_obstacle_id)
}

// repeated .jmc_auto.planning.PathDeciderStatus.LaneBorrowDirection decided_side_pass_direction = 5;
int PathDeciderStatus::decided_side_pass_direction_size() const {
  return decided_side_pass_direction_.size();
}
void PathDeciderStatus::clear_decided_side_pass_direction() {
  decided_side_pass_direction_.Clear();
}
::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection PathDeciderStatus::decided_side_pass_direction(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
  return static_cast< ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection >(decided_side_pass_direction_.Get(index));
}
void PathDeciderStatus::set_decided_side_pass_direction(int index, ::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection value) {
  assert(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value));
  decided_side_pass_direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
}
void PathDeciderStatus::add_decided_side_pass_direction(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection value) {
  assert(::jmc_auto::planning::PathDeciderStatus_LaneBorrowDirection_IsValid(value));
  decided_side_pass_direction_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
}
const ::google::protobuf::RepeatedField<int>&
PathDeciderStatus::decided_side_pass_direction() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
  return decided_side_pass_direction_;
}
::google::protobuf::RepeatedField<int>*
PathDeciderStatus::mutable_decided_side_pass_direction() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PathDeciderStatus.decided_side_pass_direction)
  return &decided_side_pass_direction_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PullOverStatus::kPullOverTypeFieldNumber;
const int PullOverStatus::kPlanPullOverPathFieldNumber;
const int PullOverStatus::kPositionFieldNumber;
const int PullOverStatus::kThetaFieldNumber;
const int PullOverStatus::kLengthFrontFieldNumber;
const int PullOverStatus::kLengthBackFieldNumber;
const int PullOverStatus::kWidthLeftFieldNumber;
const int PullOverStatus::kWidthRightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PullOverStatus::PullOverStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.PullOverStatus)
}
PullOverStatus::PullOverStatus(const PullOverStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::jmc_auto::common::PointENU(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&theta_, &from.theta_,
    reinterpret_cast<char*>(&pull_over_type_) -
    reinterpret_cast<char*>(&theta_) + sizeof(pull_over_type_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.PullOverStatus)
}

void PullOverStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&position_, 0, reinterpret_cast<char*>(&plan_pull_over_path_) -
    reinterpret_cast<char*>(&position_) + sizeof(plan_pull_over_path_));
  pull_over_type_ = 1;
}

PullOverStatus::~PullOverStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.PullOverStatus)
  SharedDtor();
}

void PullOverStatus::SharedDtor() {
  if (this != internal_default_instance()) {
    delete position_;
  }
}

void PullOverStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PullOverStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PullOverStatus& PullOverStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

PullOverStatus* PullOverStatus::New(::google::protobuf::Arena* arena) const {
  PullOverStatus* n = new PullOverStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PullOverStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.PullOverStatus)
  if (has_position()) {
    GOOGLE_DCHECK(position_ != NULL);
    position_->::jmc_auto::common::PointENU::Clear();
  }
  if (_has_bits_[0 / 32] & 254u) {
    ::memset(&theta_, 0, reinterpret_cast<char*>(&plan_pull_over_path_) -
      reinterpret_cast<char*>(&theta_) + sizeof(plan_pull_over_path_));
    pull_over_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PullOverStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.PullOverStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::PullOverStatus_PullOverType_IsValid(value)) {
            set_pull_over_type(static_cast< ::jmc_auto::planning::PullOverStatus_PullOverType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool plan_pull_over_path = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_plan_pull_over_path();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &plan_pull_over_path_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.common.PointENU position = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double theta = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_theta();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &theta_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double length_front = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(41u)) {
          set_has_length_front();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &length_front_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double length_back = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(49u)) {
          set_has_length_back();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &length_back_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double width_left = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(57u)) {
          set_has_width_left();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &width_left_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double width_right = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(65u)) {
          set_has_width_right();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &width_right_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.PullOverStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.PullOverStatus)
  return false;
#undef DO_
}

void PullOverStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.PullOverStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->pull_over_type(), output);
  }

  // optional bool plan_pull_over_path = 2 [default = false];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->plan_pull_over_path(), output);
  }

  // optional .jmc_auto.common.PointENU position = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->position_, output);
  }

  // optional double theta = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->theta(), output);
  }

  // optional double length_front = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->length_front(), output);
  }

  // optional double length_back = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->length_back(), output);
  }

  // optional double width_left = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->width_left(), output);
  }

  // optional double width_right = 8;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->width_right(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.PullOverStatus)
}

::google::protobuf::uint8* PullOverStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.PullOverStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->pull_over_type(), target);
  }

  // optional bool plan_pull_over_path = 2 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->plan_pull_over_path(), target);
  }

  // optional .jmc_auto.common.PointENU position = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->position_, deterministic, target);
  }

  // optional double theta = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->theta(), target);
  }

  // optional double length_front = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->length_front(), target);
  }

  // optional double length_back = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->length_back(), target);
  }

  // optional double width_left = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->width_left(), target);
  }

  // optional double width_right = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->width_right(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.PullOverStatus)
  return target;
}

size_t PullOverStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.PullOverStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional .jmc_auto.common.PointENU position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_);
    }

    // optional double theta = 4;
    if (has_theta()) {
      total_size += 1 + 8;
    }

    // optional double length_front = 5;
    if (has_length_front()) {
      total_size += 1 + 8;
    }

    // optional double length_back = 6;
    if (has_length_back()) {
      total_size += 1 + 8;
    }

    // optional double width_left = 7;
    if (has_width_left()) {
      total_size += 1 + 8;
    }

    // optional double width_right = 8;
    if (has_width_right()) {
      total_size += 1 + 8;
    }

    // optional bool plan_pull_over_path = 2 [default = false];
    if (has_plan_pull_over_path()) {
      total_size += 1 + 1;
    }

    // optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
    if (has_pull_over_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pull_over_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PullOverStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.PullOverStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const PullOverStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PullOverStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.PullOverStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.PullOverStatus)
    MergeFrom(*source);
  }
}

void PullOverStatus::MergeFrom(const PullOverStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.PullOverStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::jmc_auto::common::PointENU::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      theta_ = from.theta_;
    }
    if (cached_has_bits & 0x00000004u) {
      length_front_ = from.length_front_;
    }
    if (cached_has_bits & 0x00000008u) {
      length_back_ = from.length_back_;
    }
    if (cached_has_bits & 0x00000010u) {
      width_left_ = from.width_left_;
    }
    if (cached_has_bits & 0x00000020u) {
      width_right_ = from.width_right_;
    }
    if (cached_has_bits & 0x00000040u) {
      plan_pull_over_path_ = from.plan_pull_over_path_;
    }
    if (cached_has_bits & 0x00000080u) {
      pull_over_type_ = from.pull_over_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PullOverStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.PullOverStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PullOverStatus::CopyFrom(const PullOverStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.PullOverStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PullOverStatus::IsInitialized() const {
  return true;
}

void PullOverStatus::Swap(PullOverStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PullOverStatus::InternalSwap(PullOverStatus* other) {
  std::swap(position_, other->position_);
  std::swap(theta_, other->theta_);
  std::swap(length_front_, other->length_front_);
  std::swap(length_back_, other->length_back_);
  std::swap(width_left_, other->width_left_);
  std::swap(width_right_, other->width_right_);
  std::swap(plan_pull_over_path_, other->plan_pull_over_path_);
  std::swap(pull_over_type_, other->pull_over_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PullOverStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PullOverStatus

// optional .jmc_auto.planning.PullOverStatus.PullOverType pull_over_type = 1;
bool PullOverStatus::has_pull_over_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void PullOverStatus::set_has_pull_over_type() {
  _has_bits_[0] |= 0x00000080u;
}
void PullOverStatus::clear_has_pull_over_type() {
  _has_bits_[0] &= ~0x00000080u;
}
void PullOverStatus::clear_pull_over_type() {
  pull_over_type_ = 1;
  clear_has_pull_over_type();
}
::jmc_auto::planning::PullOverStatus_PullOverType PullOverStatus::pull_over_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.pull_over_type)
  return static_cast< ::jmc_auto::planning::PullOverStatus_PullOverType >(pull_over_type_);
}
void PullOverStatus::set_pull_over_type(::jmc_auto::planning::PullOverStatus_PullOverType value) {
  assert(::jmc_auto::planning::PullOverStatus_PullOverType_IsValid(value));
  set_has_pull_over_type();
  pull_over_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.pull_over_type)
}

// optional bool plan_pull_over_path = 2 [default = false];
bool PullOverStatus::has_plan_pull_over_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void PullOverStatus::set_has_plan_pull_over_path() {
  _has_bits_[0] |= 0x00000040u;
}
void PullOverStatus::clear_has_plan_pull_over_path() {
  _has_bits_[0] &= ~0x00000040u;
}
void PullOverStatus::clear_plan_pull_over_path() {
  plan_pull_over_path_ = false;
  clear_has_plan_pull_over_path();
}
bool PullOverStatus::plan_pull_over_path() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.plan_pull_over_path)
  return plan_pull_over_path_;
}
void PullOverStatus::set_plan_pull_over_path(bool value) {
  set_has_plan_pull_over_path();
  plan_pull_over_path_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.plan_pull_over_path)
}

// optional .jmc_auto.common.PointENU position = 3;
bool PullOverStatus::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PullOverStatus::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void PullOverStatus::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void PullOverStatus::clear_position() {
  if (position_ != NULL) position_->::jmc_auto::common::PointENU::Clear();
  clear_has_position();
}
const ::jmc_auto::common::PointENU& PullOverStatus::position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.position)
  return position_ != NULL ? *position_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
::jmc_auto::common::PointENU* PullOverStatus::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PullOverStatus.position)
  return position_;
}
::jmc_auto::common::PointENU* PullOverStatus::release_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PullOverStatus.position)
  clear_has_position();
  ::jmc_auto::common::PointENU* temp = position_;
  position_ = NULL;
  return temp;
}
void PullOverStatus::set_allocated_position(::jmc_auto::common::PointENU* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PullOverStatus.position)
}

// optional double theta = 4;
bool PullOverStatus::has_theta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PullOverStatus::set_has_theta() {
  _has_bits_[0] |= 0x00000002u;
}
void PullOverStatus::clear_has_theta() {
  _has_bits_[0] &= ~0x00000002u;
}
void PullOverStatus::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
double PullOverStatus::theta() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.theta)
  return theta_;
}
void PullOverStatus::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.theta)
}

// optional double length_front = 5;
bool PullOverStatus::has_length_front() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PullOverStatus::set_has_length_front() {
  _has_bits_[0] |= 0x00000004u;
}
void PullOverStatus::clear_has_length_front() {
  _has_bits_[0] &= ~0x00000004u;
}
void PullOverStatus::clear_length_front() {
  length_front_ = 0;
  clear_has_length_front();
}
double PullOverStatus::length_front() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.length_front)
  return length_front_;
}
void PullOverStatus::set_length_front(double value) {
  set_has_length_front();
  length_front_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.length_front)
}

// optional double length_back = 6;
bool PullOverStatus::has_length_back() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PullOverStatus::set_has_length_back() {
  _has_bits_[0] |= 0x00000008u;
}
void PullOverStatus::clear_has_length_back() {
  _has_bits_[0] &= ~0x00000008u;
}
void PullOverStatus::clear_length_back() {
  length_back_ = 0;
  clear_has_length_back();
}
double PullOverStatus::length_back() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.length_back)
  return length_back_;
}
void PullOverStatus::set_length_back(double value) {
  set_has_length_back();
  length_back_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.length_back)
}

// optional double width_left = 7;
bool PullOverStatus::has_width_left() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PullOverStatus::set_has_width_left() {
  _has_bits_[0] |= 0x00000010u;
}
void PullOverStatus::clear_has_width_left() {
  _has_bits_[0] &= ~0x00000010u;
}
void PullOverStatus::clear_width_left() {
  width_left_ = 0;
  clear_has_width_left();
}
double PullOverStatus::width_left() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.width_left)
  return width_left_;
}
void PullOverStatus::set_width_left(double value) {
  set_has_width_left();
  width_left_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.width_left)
}

// optional double width_right = 8;
bool PullOverStatus::has_width_right() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void PullOverStatus::set_has_width_right() {
  _has_bits_[0] |= 0x00000020u;
}
void PullOverStatus::clear_has_width_right() {
  _has_bits_[0] &= ~0x00000020u;
}
void PullOverStatus::clear_width_right() {
  width_right_ = 0;
  clear_has_width_right();
}
double PullOverStatus::width_right() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PullOverStatus.width_right)
  return width_right_;
}
void PullOverStatus::set_width_right(double value) {
  set_has_width_right();
  width_right_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PullOverStatus.width_right)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReroutingStatus::kLastReroutingTimeFieldNumber;
const int ReroutingStatus::kNeedReroutingFieldNumber;
const int ReroutingStatus::kRoutingRequestFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReroutingStatus::ReroutingStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ReroutingStatus)
}
ReroutingStatus::ReroutingStatus(const ReroutingStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_routing_request()) {
    routing_request_ = new ::jmc_auto::routing::RoutingRequest(*from.routing_request_);
  } else {
    routing_request_ = NULL;
  }
  ::memcpy(&last_rerouting_time_, &from.last_rerouting_time_,
    reinterpret_cast<char*>(&need_rerouting_) -
    reinterpret_cast<char*>(&last_rerouting_time_) + sizeof(need_rerouting_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ReroutingStatus)
}

void ReroutingStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&routing_request_, 0, reinterpret_cast<char*>(&need_rerouting_) -
    reinterpret_cast<char*>(&routing_request_) + sizeof(need_rerouting_));
}

ReroutingStatus::~ReroutingStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ReroutingStatus)
  SharedDtor();
}

void ReroutingStatus::SharedDtor() {
  if (this != internal_default_instance()) {
    delete routing_request_;
  }
}

void ReroutingStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReroutingStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ReroutingStatus& ReroutingStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

ReroutingStatus* ReroutingStatus::New(::google::protobuf::Arena* arena) const {
  ReroutingStatus* n = new ReroutingStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReroutingStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ReroutingStatus)
  if (has_routing_request()) {
    GOOGLE_DCHECK(routing_request_ != NULL);
    routing_request_->::jmc_auto::routing::RoutingRequest::Clear();
  }
  if (_has_bits_[0 / 32] & 6u) {
    ::memset(&last_rerouting_time_, 0, reinterpret_cast<char*>(&need_rerouting_) -
      reinterpret_cast<char*>(&last_rerouting_time_) + sizeof(need_rerouting_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ReroutingStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ReroutingStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double last_rerouting_time = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_last_rerouting_time();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &last_rerouting_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool need_rerouting = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_need_rerouting();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &need_rerouting_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.routing.RoutingRequest routing_request = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_routing_request()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ReroutingStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ReroutingStatus)
  return false;
#undef DO_
}

void ReroutingStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ReroutingStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double last_rerouting_time = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->last_rerouting_time(), output);
  }

  // optional bool need_rerouting = 2 [default = false];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->need_rerouting(), output);
  }

  // optional .jmc_auto.routing.RoutingRequest routing_request = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->routing_request_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ReroutingStatus)
}

::google::protobuf::uint8* ReroutingStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ReroutingStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double last_rerouting_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->last_rerouting_time(), target);
  }

  // optional bool need_rerouting = 2 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->need_rerouting(), target);
  }

  // optional .jmc_auto.routing.RoutingRequest routing_request = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->routing_request_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ReroutingStatus)
  return target;
}

size_t ReroutingStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ReroutingStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .jmc_auto.routing.RoutingRequest routing_request = 3;
    if (has_routing_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->routing_request_);
    }

    // optional double last_rerouting_time = 1;
    if (has_last_rerouting_time()) {
      total_size += 1 + 8;
    }

    // optional bool need_rerouting = 2 [default = false];
    if (has_need_rerouting()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReroutingStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ReroutingStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const ReroutingStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ReroutingStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ReroutingStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ReroutingStatus)
    MergeFrom(*source);
  }
}

void ReroutingStatus::MergeFrom(const ReroutingStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ReroutingStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_routing_request()->::jmc_auto::routing::RoutingRequest::MergeFrom(from.routing_request());
    }
    if (cached_has_bits & 0x00000002u) {
      last_rerouting_time_ = from.last_rerouting_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      need_rerouting_ = from.need_rerouting_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ReroutingStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ReroutingStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReroutingStatus::CopyFrom(const ReroutingStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ReroutingStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReroutingStatus::IsInitialized() const {
  return true;
}

void ReroutingStatus::Swap(ReroutingStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReroutingStatus::InternalSwap(ReroutingStatus* other) {
  std::swap(routing_request_, other->routing_request_);
  std::swap(last_rerouting_time_, other->last_rerouting_time_);
  std::swap(need_rerouting_, other->need_rerouting_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReroutingStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReroutingStatus

// optional double last_rerouting_time = 1;
bool ReroutingStatus::has_last_rerouting_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReroutingStatus::set_has_last_rerouting_time() {
  _has_bits_[0] |= 0x00000002u;
}
void ReroutingStatus::clear_has_last_rerouting_time() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReroutingStatus::clear_last_rerouting_time() {
  last_rerouting_time_ = 0;
  clear_has_last_rerouting_time();
}
double ReroutingStatus::last_rerouting_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingStatus.last_rerouting_time)
  return last_rerouting_time_;
}
void ReroutingStatus::set_last_rerouting_time(double value) {
  set_has_last_rerouting_time();
  last_rerouting_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReroutingStatus.last_rerouting_time)
}

// optional bool need_rerouting = 2 [default = false];
bool ReroutingStatus::has_need_rerouting() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ReroutingStatus::set_has_need_rerouting() {
  _has_bits_[0] |= 0x00000004u;
}
void ReroutingStatus::clear_has_need_rerouting() {
  _has_bits_[0] &= ~0x00000004u;
}
void ReroutingStatus::clear_need_rerouting() {
  need_rerouting_ = false;
  clear_has_need_rerouting();
}
bool ReroutingStatus::need_rerouting() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingStatus.need_rerouting)
  return need_rerouting_;
}
void ReroutingStatus::set_need_rerouting(bool value) {
  set_has_need_rerouting();
  need_rerouting_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReroutingStatus.need_rerouting)
}

// optional .jmc_auto.routing.RoutingRequest routing_request = 3;
bool ReroutingStatus::has_routing_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReroutingStatus::set_has_routing_request() {
  _has_bits_[0] |= 0x00000001u;
}
void ReroutingStatus::clear_has_routing_request() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReroutingStatus::clear_routing_request() {
  if (routing_request_ != NULL) routing_request_->::jmc_auto::routing::RoutingRequest::Clear();
  clear_has_routing_request();
}
const ::jmc_auto::routing::RoutingRequest& ReroutingStatus::routing_request() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingStatus.routing_request)
  return routing_request_ != NULL ? *routing_request_
                         : *::jmc_auto::routing::RoutingRequest::internal_default_instance();
}
::jmc_auto::routing::RoutingRequest* ReroutingStatus::mutable_routing_request() {
  set_has_routing_request();
  if (routing_request_ == NULL) {
    routing_request_ = new ::jmc_auto::routing::RoutingRequest;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ReroutingStatus.routing_request)
  return routing_request_;
}
::jmc_auto::routing::RoutingRequest* ReroutingStatus::release_routing_request() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ReroutingStatus.routing_request)
  clear_has_routing_request();
  ::jmc_auto::routing::RoutingRequest* temp = routing_request_;
  routing_request_ = NULL;
  return temp;
}
void ReroutingStatus::set_allocated_routing_request(::jmc_auto::routing::RoutingRequest* routing_request) {
  delete routing_request_;
  routing_request_ = routing_request;
  if (routing_request) {
    set_has_routing_request();
  } else {
    clear_has_routing_request();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ReroutingStatus.routing_request)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioStatus::kScenarioTypeFieldNumber;
const int ScenarioStatus::kStageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioStatus::ScenarioStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioStatus)
}
ScenarioStatus::ScenarioStatus(const ScenarioStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&scenario_type_, &from.scenario_type_,
    reinterpret_cast<char*>(&stage_type_) -
    reinterpret_cast<char*>(&scenario_type_) + sizeof(stage_type_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioStatus)
}

void ScenarioStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&scenario_type_, 0, reinterpret_cast<char*>(&stage_type_) -
    reinterpret_cast<char*>(&scenario_type_) + sizeof(stage_type_));
}

ScenarioStatus::~ScenarioStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioStatus)
  SharedDtor();
}

void ScenarioStatus::SharedDtor() {
}

void ScenarioStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioStatus& ScenarioStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioStatus* ScenarioStatus::New(::google::protobuf::Arena* arena) const {
  ScenarioStatus* n = new ScenarioStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioStatus)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&scenario_type_, 0, reinterpret_cast<char*>(&stage_type_) -
      reinterpret_cast<char*>(&scenario_type_) + sizeof(stage_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::ScenarioConfig_ScenarioType_IsValid(value)) {
            set_scenario_type(static_cast< ::jmc_auto::planning::ScenarioConfig_ScenarioType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value)) {
            set_stage_type(static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioStatus)
  return false;
#undef DO_
}

void ScenarioStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->scenario_type(), output);
  }

  // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->stage_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioStatus)
}

::google::protobuf::uint8* ScenarioStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->scenario_type(), target);
  }

  // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->stage_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioStatus)
  return target;
}

size_t ScenarioStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
    if (has_scenario_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->scenario_type());
    }

    // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
    if (has_stage_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->stage_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioStatus)
    MergeFrom(*source);
  }
}

void ScenarioStatus::MergeFrom(const ScenarioStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      scenario_type_ = from.scenario_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      stage_type_ = from.stage_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioStatus::CopyFrom(const ScenarioStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioStatus::IsInitialized() const {
  return true;
}

void ScenarioStatus::Swap(ScenarioStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioStatus::InternalSwap(ScenarioStatus* other) {
  std::swap(scenario_type_, other->scenario_type_);
  std::swap(stage_type_, other->stage_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioStatus

// optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
bool ScenarioStatus::has_scenario_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioStatus::set_has_scenario_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioStatus::clear_has_scenario_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioStatus::clear_scenario_type() {
  scenario_type_ = 0;
  clear_has_scenario_type();
}
::jmc_auto::planning::ScenarioConfig_ScenarioType ScenarioStatus::scenario_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStatus.scenario_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
void ScenarioStatus::set_scenario_type(::jmc_auto::planning::ScenarioConfig_ScenarioType value) {
  assert(::jmc_auto::planning::ScenarioConfig_ScenarioType_IsValid(value));
  set_has_scenario_type();
  scenario_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStatus.scenario_type)
}

// optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 2;
bool ScenarioStatus::has_stage_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioStatus::set_has_stage_type() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioStatus::clear_has_stage_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioStatus::clear_stage_type() {
  stage_type_ = 0;
  clear_has_stage_type();
}
::jmc_auto::planning::ScenarioConfig_StageType ScenarioStatus::stage_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStatus.stage_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(stage_type_);
}
void ScenarioStatus::set_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  set_has_stage_type();
  stage_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStatus.stage_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopSignStatus::kCurrentStopSignOverlapIdFieldNumber;
const int StopSignStatus::kDoneStopSignOverlapIdFieldNumber;
const int StopSignStatus::kWaitForObstacleIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopSignStatus::StopSignStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.StopSignStatus)
}
StopSignStatus::StopSignStatus(const StopSignStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      wait_for_obstacle_id_(from.wait_for_obstacle_id_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  current_stop_sign_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_current_stop_sign_overlap_id()) {
    current_stop_sign_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.current_stop_sign_overlap_id_);
  }
  done_stop_sign_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_done_stop_sign_overlap_id()) {
    done_stop_sign_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.done_stop_sign_overlap_id_);
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.StopSignStatus)
}

void StopSignStatus::SharedCtor() {
  _cached_size_ = 0;
  current_stop_sign_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  done_stop_sign_overlap_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

StopSignStatus::~StopSignStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.StopSignStatus)
  SharedDtor();
}

void StopSignStatus::SharedDtor() {
  current_stop_sign_overlap_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  done_stop_sign_overlap_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void StopSignStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopSignStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const StopSignStatus& StopSignStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

StopSignStatus* StopSignStatus::New(::google::protobuf::Arena* arena) const {
  StopSignStatus* n = new StopSignStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopSignStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.StopSignStatus)
  wait_for_obstacle_id_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_current_stop_sign_overlap_id()) {
      GOOGLE_DCHECK(!current_stop_sign_overlap_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*current_stop_sign_overlap_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_done_stop_sign_overlap_id()) {
      GOOGLE_DCHECK(!done_stop_sign_overlap_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*done_stop_sign_overlap_id_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StopSignStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.StopSignStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string current_stop_sign_overlap_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_current_stop_sign_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->current_stop_sign_overlap_id().data(), this->current_stop_sign_overlap_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string done_stop_sign_overlap_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_done_stop_sign_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->done_stop_sign_overlap_id().data(), this->done_stop_sign_overlap_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string wait_for_obstacle_id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_wait_for_obstacle_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->wait_for_obstacle_id(this->wait_for_obstacle_id_size() - 1).data(),
            this->wait_for_obstacle_id(this->wait_for_obstacle_id_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.StopSignStatus.wait_for_obstacle_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.StopSignStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.StopSignStatus)
  return false;
#undef DO_
}

void StopSignStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.StopSignStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string current_stop_sign_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_stop_sign_overlap_id().data(), this->current_stop_sign_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->current_stop_sign_overlap_id(), output);
  }

  // optional string done_stop_sign_overlap_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_stop_sign_overlap_id().data(), this->done_stop_sign_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->done_stop_sign_overlap_id(), output);
  }

  // repeated string wait_for_obstacle_id = 3;
  for (int i = 0, n = this->wait_for_obstacle_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wait_for_obstacle_id(i).data(), this->wait_for_obstacle_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopSignStatus.wait_for_obstacle_id");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->wait_for_obstacle_id(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.StopSignStatus)
}

::google::protobuf::uint8* StopSignStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.StopSignStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string current_stop_sign_overlap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_stop_sign_overlap_id().data(), this->current_stop_sign_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->current_stop_sign_overlap_id(), target);
  }

  // optional string done_stop_sign_overlap_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_stop_sign_overlap_id().data(), this->done_stop_sign_overlap_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->done_stop_sign_overlap_id(), target);
  }

  // repeated string wait_for_obstacle_id = 3;
  for (int i = 0, n = this->wait_for_obstacle_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wait_for_obstacle_id(i).data(), this->wait_for_obstacle_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.StopSignStatus.wait_for_obstacle_id");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->wait_for_obstacle_id(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.StopSignStatus)
  return target;
}

size_t StopSignStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.StopSignStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string wait_for_obstacle_id = 3;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->wait_for_obstacle_id_size());
  for (int i = 0, n = this->wait_for_obstacle_id_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->wait_for_obstacle_id(i));
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional string current_stop_sign_overlap_id = 1;
    if (has_current_stop_sign_overlap_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->current_stop_sign_overlap_id());
    }

    // optional string done_stop_sign_overlap_id = 2;
    if (has_done_stop_sign_overlap_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->done_stop_sign_overlap_id());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopSignStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.StopSignStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const StopSignStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const StopSignStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.StopSignStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.StopSignStatus)
    MergeFrom(*source);
  }
}

void StopSignStatus::MergeFrom(const StopSignStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.StopSignStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  wait_for_obstacle_id_.MergeFrom(from.wait_for_obstacle_id_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_current_stop_sign_overlap_id();
      current_stop_sign_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.current_stop_sign_overlap_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_done_stop_sign_overlap_id();
      done_stop_sign_overlap_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.done_stop_sign_overlap_id_);
    }
  }
}

void StopSignStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.StopSignStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopSignStatus::CopyFrom(const StopSignStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.StopSignStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSignStatus::IsInitialized() const {
  return true;
}

void StopSignStatus::Swap(StopSignStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopSignStatus::InternalSwap(StopSignStatus* other) {
  wait_for_obstacle_id_.InternalSwap(&other->wait_for_obstacle_id_);
  current_stop_sign_overlap_id_.Swap(&other->current_stop_sign_overlap_id_);
  done_stop_sign_overlap_id_.Swap(&other->done_stop_sign_overlap_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopSignStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StopSignStatus

// optional string current_stop_sign_overlap_id = 1;
bool StopSignStatus::has_current_stop_sign_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StopSignStatus::set_has_current_stop_sign_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
void StopSignStatus::clear_has_current_stop_sign_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void StopSignStatus::clear_current_stop_sign_overlap_id() {
  current_stop_sign_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_stop_sign_overlap_id();
}
const ::std::string& StopSignStatus::current_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
  return current_stop_sign_overlap_id_.GetNoArena();
}
void StopSignStatus::set_current_stop_sign_overlap_id(const ::std::string& value) {
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
#if LANG_CXX11
void StopSignStatus::set_current_stop_sign_overlap_id(::std::string&& value) {
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
#endif
void StopSignStatus::set_current_stop_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
void StopSignStatus::set_current_stop_sign_overlap_id(const char* value, size_t size) {
  set_has_current_stop_sign_overlap_id();
  current_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}
::std::string* StopSignStatus::mutable_current_stop_sign_overlap_id() {
  set_has_current_stop_sign_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
  return current_stop_sign_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* StopSignStatus::release_current_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
  clear_has_current_stop_sign_overlap_id();
  return current_stop_sign_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StopSignStatus::set_allocated_current_stop_sign_overlap_id(::std::string* current_stop_sign_overlap_id) {
  if (current_stop_sign_overlap_id != NULL) {
    set_has_current_stop_sign_overlap_id();
  } else {
    clear_has_current_stop_sign_overlap_id();
  }
  current_stop_sign_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_stop_sign_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StopSignStatus.current_stop_sign_overlap_id)
}

// optional string done_stop_sign_overlap_id = 2;
bool StopSignStatus::has_done_stop_sign_overlap_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StopSignStatus::set_has_done_stop_sign_overlap_id() {
  _has_bits_[0] |= 0x00000002u;
}
void StopSignStatus::clear_has_done_stop_sign_overlap_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void StopSignStatus::clear_done_stop_sign_overlap_id() {
  done_stop_sign_overlap_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_done_stop_sign_overlap_id();
}
const ::std::string& StopSignStatus::done_stop_sign_overlap_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
  return done_stop_sign_overlap_id_.GetNoArena();
}
void StopSignStatus::set_done_stop_sign_overlap_id(const ::std::string& value) {
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
#if LANG_CXX11
void StopSignStatus::set_done_stop_sign_overlap_id(::std::string&& value) {
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
#endif
void StopSignStatus::set_done_stop_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
void StopSignStatus::set_done_stop_sign_overlap_id(const char* value, size_t size) {
  set_has_done_stop_sign_overlap_id();
  done_stop_sign_overlap_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}
::std::string* StopSignStatus::mutable_done_stop_sign_overlap_id() {
  set_has_done_stop_sign_overlap_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
  return done_stop_sign_overlap_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* StopSignStatus::release_done_stop_sign_overlap_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
  clear_has_done_stop_sign_overlap_id();
  return done_stop_sign_overlap_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StopSignStatus::set_allocated_done_stop_sign_overlap_id(::std::string* done_stop_sign_overlap_id) {
  if (done_stop_sign_overlap_id != NULL) {
    set_has_done_stop_sign_overlap_id();
  } else {
    clear_has_done_stop_sign_overlap_id();
  }
  done_stop_sign_overlap_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), done_stop_sign_overlap_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StopSignStatus.done_stop_sign_overlap_id)
}

// repeated string wait_for_obstacle_id = 3;
int StopSignStatus::wait_for_obstacle_id_size() const {
  return wait_for_obstacle_id_.size();
}
void StopSignStatus::clear_wait_for_obstacle_id() {
  wait_for_obstacle_id_.Clear();
}
const ::std::string& StopSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Get(index);
}
::std::string* StopSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Mutable(index);
}
void StopSignStatus::set_wait_for_obstacle_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void StopSignStatus::set_wait_for_obstacle_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
}
#endif
void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
void StopSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
::std::string* StopSignStatus::add_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Add();
}
void StopSignStatus::add_wait_for_obstacle_id(const ::std::string& value) {
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
#if LANG_CXX11
void StopSignStatus::add_wait_for_obstacle_id(::std::string&& value) {
  wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
#endif
void StopSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
void StopSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
StopSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
StopSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.StopSignStatus.wait_for_obstacle_id)
  return &wait_for_obstacle_id_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficLightStatus::kCurrentTrafficLightOverlapIdFieldNumber;
const int TrafficLightStatus::kDoneTrafficLightOverlapIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficLightStatus::TrafficLightStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.TrafficLightStatus)
}
TrafficLightStatus::TrafficLightStatus(const TrafficLightStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      current_traffic_light_overlap_id_(from.current_traffic_light_overlap_id_),
      done_traffic_light_overlap_id_(from.done_traffic_light_overlap_id_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.TrafficLightStatus)
}

void TrafficLightStatus::SharedCtor() {
  _cached_size_ = 0;
}

TrafficLightStatus::~TrafficLightStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.TrafficLightStatus)
  SharedDtor();
}

void TrafficLightStatus::SharedDtor() {
}

void TrafficLightStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficLightStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficLightStatus& TrafficLightStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

TrafficLightStatus* TrafficLightStatus::New(::google::protobuf::Arena* arena) const {
  TrafficLightStatus* n = new TrafficLightStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficLightStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.TrafficLightStatus)
  current_traffic_light_overlap_id_.Clear();
  done_traffic_light_overlap_id_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TrafficLightStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.TrafficLightStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string current_traffic_light_overlap_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_current_traffic_light_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->current_traffic_light_overlap_id(this->current_traffic_light_overlap_id_size() - 1).data(),
            this->current_traffic_light_overlap_id(this->current_traffic_light_overlap_id_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string done_traffic_light_overlap_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_done_traffic_light_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->done_traffic_light_overlap_id(this->done_traffic_light_overlap_id_size() - 1).data(),
            this->done_traffic_light_overlap_id(this->done_traffic_light_overlap_id_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.TrafficLightStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.TrafficLightStatus)
  return false;
#undef DO_
}

void TrafficLightStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.TrafficLightStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string current_traffic_light_overlap_id = 1;
  for (int i = 0, n = this->current_traffic_light_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_traffic_light_overlap_id(i).data(), this->current_traffic_light_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->current_traffic_light_overlap_id(i), output);
  }

  // repeated string done_traffic_light_overlap_id = 2;
  for (int i = 0, n = this->done_traffic_light_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_traffic_light_overlap_id(i).data(), this->done_traffic_light_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->done_traffic_light_overlap_id(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.TrafficLightStatus)
}

::google::protobuf::uint8* TrafficLightStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.TrafficLightStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string current_traffic_light_overlap_id = 1;
  for (int i = 0, n = this->current_traffic_light_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_traffic_light_overlap_id(i).data(), this->current_traffic_light_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->current_traffic_light_overlap_id(i), target);
  }

  // repeated string done_traffic_light_overlap_id = 2;
  for (int i = 0, n = this->done_traffic_light_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_traffic_light_overlap_id(i).data(), this->done_traffic_light_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->done_traffic_light_overlap_id(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.TrafficLightStatus)
  return target;
}

size_t TrafficLightStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.TrafficLightStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string current_traffic_light_overlap_id = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->current_traffic_light_overlap_id_size());
  for (int i = 0, n = this->current_traffic_light_overlap_id_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->current_traffic_light_overlap_id(i));
  }

  // repeated string done_traffic_light_overlap_id = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->done_traffic_light_overlap_id_size());
  for (int i = 0, n = this->done_traffic_light_overlap_id_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->done_traffic_light_overlap_id(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficLightStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.TrafficLightStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficLightStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficLightStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.TrafficLightStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.TrafficLightStatus)
    MergeFrom(*source);
  }
}

void TrafficLightStatus::MergeFrom(const TrafficLightStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.TrafficLightStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  current_traffic_light_overlap_id_.MergeFrom(from.current_traffic_light_overlap_id_);
  done_traffic_light_overlap_id_.MergeFrom(from.done_traffic_light_overlap_id_);
}

void TrafficLightStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.TrafficLightStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficLightStatus::CopyFrom(const TrafficLightStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.TrafficLightStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficLightStatus::IsInitialized() const {
  return true;
}

void TrafficLightStatus::Swap(TrafficLightStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficLightStatus::InternalSwap(TrafficLightStatus* other) {
  current_traffic_light_overlap_id_.InternalSwap(&other->current_traffic_light_overlap_id_);
  done_traffic_light_overlap_id_.InternalSwap(&other->done_traffic_light_overlap_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficLightStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficLightStatus

// repeated string current_traffic_light_overlap_id = 1;
int TrafficLightStatus::current_traffic_light_overlap_id_size() const {
  return current_traffic_light_overlap_id_.size();
}
void TrafficLightStatus::clear_current_traffic_light_overlap_id() {
  current_traffic_light_overlap_id_.Clear();
}
const ::std::string& TrafficLightStatus::current_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Get(index);
}
::std::string* TrafficLightStatus::mutable_current_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Mutable(index);
}
void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  current_traffic_light_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  current_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
void TrafficLightStatus::set_current_traffic_light_overlap_id(int index, const char* value, size_t size) {
  current_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
::std::string* TrafficLightStatus::add_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_.Add();
}
void TrafficLightStatus::add_current_traffic_light_overlap_id(const ::std::string& value) {
  current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
#if LANG_CXX11
void TrafficLightStatus::add_current_traffic_light_overlap_id(::std::string&& value) {
  current_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
#endif
void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
void TrafficLightStatus::add_current_traffic_light_overlap_id(const char* value, size_t size) {
  current_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficLightStatus::current_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return current_traffic_light_overlap_id_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficLightStatus::mutable_current_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.TrafficLightStatus.current_traffic_light_overlap_id)
  return &current_traffic_light_overlap_id_;
}

// repeated string done_traffic_light_overlap_id = 2;
int TrafficLightStatus::done_traffic_light_overlap_id_size() const {
  return done_traffic_light_overlap_id_.size();
}
void TrafficLightStatus::clear_done_traffic_light_overlap_id() {
  done_traffic_light_overlap_id_.Clear();
}
const ::std::string& TrafficLightStatus::done_traffic_light_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Get(index);
}
::std::string* TrafficLightStatus::mutable_done_traffic_light_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Mutable(index);
}
void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  done_traffic_light_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  done_traffic_light_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_traffic_light_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
void TrafficLightStatus::set_done_traffic_light_overlap_id(int index, const char* value, size_t size) {
  done_traffic_light_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
::std::string* TrafficLightStatus::add_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_.Add();
}
void TrafficLightStatus::add_done_traffic_light_overlap_id(const ::std::string& value) {
  done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
#if LANG_CXX11
void TrafficLightStatus::add_done_traffic_light_overlap_id(::std::string&& value) {
  done_traffic_light_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
#endif
void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_traffic_light_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
void TrafficLightStatus::add_done_traffic_light_overlap_id(const char* value, size_t size) {
  done_traffic_light_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficLightStatus::done_traffic_light_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return done_traffic_light_overlap_id_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficLightStatus::mutable_done_traffic_light_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.TrafficLightStatus.done_traffic_light_overlap_id)
  return &done_traffic_light_overlap_id_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int YieldSignStatus::kCurrentYieldSignOverlapIdFieldNumber;
const int YieldSignStatus::kDoneYieldSignOverlapIdFieldNumber;
const int YieldSignStatus::kWaitForObstacleIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

YieldSignStatus::YieldSignStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.YieldSignStatus)
}
YieldSignStatus::YieldSignStatus(const YieldSignStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      current_yield_sign_overlap_id_(from.current_yield_sign_overlap_id_),
      done_yield_sign_overlap_id_(from.done_yield_sign_overlap_id_),
      wait_for_obstacle_id_(from.wait_for_obstacle_id_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.YieldSignStatus)
}

void YieldSignStatus::SharedCtor() {
  _cached_size_ = 0;
}

YieldSignStatus::~YieldSignStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.YieldSignStatus)
  SharedDtor();
}

void YieldSignStatus::SharedDtor() {
}

void YieldSignStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* YieldSignStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const YieldSignStatus& YieldSignStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

YieldSignStatus* YieldSignStatus::New(::google::protobuf::Arena* arena) const {
  YieldSignStatus* n = new YieldSignStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void YieldSignStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.YieldSignStatus)
  current_yield_sign_overlap_id_.Clear();
  done_yield_sign_overlap_id_.Clear();
  wait_for_obstacle_id_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool YieldSignStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.YieldSignStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string current_yield_sign_overlap_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_current_yield_sign_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->current_yield_sign_overlap_id(this->current_yield_sign_overlap_id_size() - 1).data(),
            this->current_yield_sign_overlap_id(this->current_yield_sign_overlap_id_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string done_yield_sign_overlap_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_done_yield_sign_overlap_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->done_yield_sign_overlap_id(this->done_yield_sign_overlap_id_size() - 1).data(),
            this->done_yield_sign_overlap_id(this->done_yield_sign_overlap_id_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string wait_for_obstacle_id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_wait_for_obstacle_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->wait_for_obstacle_id(this->wait_for_obstacle_id_size() - 1).data(),
            this->wait_for_obstacle_id(this->wait_for_obstacle_id_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.YieldSignStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.YieldSignStatus)
  return false;
#undef DO_
}

void YieldSignStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.YieldSignStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string current_yield_sign_overlap_id = 1;
  for (int i = 0, n = this->current_yield_sign_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_yield_sign_overlap_id(i).data(), this->current_yield_sign_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->current_yield_sign_overlap_id(i), output);
  }

  // repeated string done_yield_sign_overlap_id = 2;
  for (int i = 0, n = this->done_yield_sign_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_yield_sign_overlap_id(i).data(), this->done_yield_sign_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->done_yield_sign_overlap_id(i), output);
  }

  // repeated string wait_for_obstacle_id = 3;
  for (int i = 0, n = this->wait_for_obstacle_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wait_for_obstacle_id(i).data(), this->wait_for_obstacle_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->wait_for_obstacle_id(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.YieldSignStatus)
}

::google::protobuf::uint8* YieldSignStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.YieldSignStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string current_yield_sign_overlap_id = 1;
  for (int i = 0, n = this->current_yield_sign_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->current_yield_sign_overlap_id(i).data(), this->current_yield_sign_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->current_yield_sign_overlap_id(i), target);
  }

  // repeated string done_yield_sign_overlap_id = 2;
  for (int i = 0, n = this->done_yield_sign_overlap_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->done_yield_sign_overlap_id(i).data(), this->done_yield_sign_overlap_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->done_yield_sign_overlap_id(i), target);
  }

  // repeated string wait_for_obstacle_id = 3;
  for (int i = 0, n = this->wait_for_obstacle_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wait_for_obstacle_id(i).data(), this->wait_for_obstacle_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->wait_for_obstacle_id(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.YieldSignStatus)
  return target;
}

size_t YieldSignStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.YieldSignStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated string current_yield_sign_overlap_id = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->current_yield_sign_overlap_id_size());
  for (int i = 0, n = this->current_yield_sign_overlap_id_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->current_yield_sign_overlap_id(i));
  }

  // repeated string done_yield_sign_overlap_id = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->done_yield_sign_overlap_id_size());
  for (int i = 0, n = this->done_yield_sign_overlap_id_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->done_yield_sign_overlap_id(i));
  }

  // repeated string wait_for_obstacle_id = 3;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->wait_for_obstacle_id_size());
  for (int i = 0, n = this->wait_for_obstacle_id_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->wait_for_obstacle_id(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void YieldSignStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.YieldSignStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const YieldSignStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const YieldSignStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.YieldSignStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.YieldSignStatus)
    MergeFrom(*source);
  }
}

void YieldSignStatus::MergeFrom(const YieldSignStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.YieldSignStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  current_yield_sign_overlap_id_.MergeFrom(from.current_yield_sign_overlap_id_);
  done_yield_sign_overlap_id_.MergeFrom(from.done_yield_sign_overlap_id_);
  wait_for_obstacle_id_.MergeFrom(from.wait_for_obstacle_id_);
}

void YieldSignStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.YieldSignStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void YieldSignStatus::CopyFrom(const YieldSignStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.YieldSignStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool YieldSignStatus::IsInitialized() const {
  return true;
}

void YieldSignStatus::Swap(YieldSignStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void YieldSignStatus::InternalSwap(YieldSignStatus* other) {
  current_yield_sign_overlap_id_.InternalSwap(&other->current_yield_sign_overlap_id_);
  done_yield_sign_overlap_id_.InternalSwap(&other->done_yield_sign_overlap_id_);
  wait_for_obstacle_id_.InternalSwap(&other->wait_for_obstacle_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata YieldSignStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// YieldSignStatus

// repeated string current_yield_sign_overlap_id = 1;
int YieldSignStatus::current_yield_sign_overlap_id_size() const {
  return current_yield_sign_overlap_id_.size();
}
void YieldSignStatus::clear_current_yield_sign_overlap_id() {
  current_yield_sign_overlap_id_.Clear();
}
const ::std::string& YieldSignStatus::current_yield_sign_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_.Get(index);
}
::std::string* YieldSignStatus::mutable_current_yield_sign_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_.Mutable(index);
}
void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  current_yield_sign_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void YieldSignStatus::set_current_yield_sign_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  current_yield_sign_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
void YieldSignStatus::set_current_yield_sign_overlap_id(int index, const char* value, size_t size) {
  current_yield_sign_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
::std::string* YieldSignStatus::add_current_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_.Add();
}
void YieldSignStatus::add_current_yield_sign_overlap_id(const ::std::string& value) {
  current_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
#if LANG_CXX11
void YieldSignStatus::add_current_yield_sign_overlap_id(::std::string&& value) {
  current_yield_sign_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
#endif
void YieldSignStatus::add_current_yield_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  current_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
void YieldSignStatus::add_current_yield_sign_overlap_id(const char* value, size_t size) {
  current_yield_sign_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
YieldSignStatus::current_yield_sign_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return current_yield_sign_overlap_id_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
YieldSignStatus::mutable_current_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.YieldSignStatus.current_yield_sign_overlap_id)
  return &current_yield_sign_overlap_id_;
}

// repeated string done_yield_sign_overlap_id = 2;
int YieldSignStatus::done_yield_sign_overlap_id_size() const {
  return done_yield_sign_overlap_id_.size();
}
void YieldSignStatus::clear_done_yield_sign_overlap_id() {
  done_yield_sign_overlap_id_.Clear();
}
const ::std::string& YieldSignStatus::done_yield_sign_overlap_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_.Get(index);
}
::std::string* YieldSignStatus::mutable_done_yield_sign_overlap_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_.Mutable(index);
}
void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  done_yield_sign_overlap_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void YieldSignStatus::set_done_yield_sign_overlap_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  done_yield_sign_overlap_id_.Mutable(index)->assign(std::move(value));
}
#endif
void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_yield_sign_overlap_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
void YieldSignStatus::set_done_yield_sign_overlap_id(int index, const char* value, size_t size) {
  done_yield_sign_overlap_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
::std::string* YieldSignStatus::add_done_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_.Add();
}
void YieldSignStatus::add_done_yield_sign_overlap_id(const ::std::string& value) {
  done_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
#if LANG_CXX11
void YieldSignStatus::add_done_yield_sign_overlap_id(::std::string&& value) {
  done_yield_sign_overlap_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
#endif
void YieldSignStatus::add_done_yield_sign_overlap_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  done_yield_sign_overlap_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
void YieldSignStatus::add_done_yield_sign_overlap_id(const char* value, size_t size) {
  done_yield_sign_overlap_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
YieldSignStatus::done_yield_sign_overlap_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return done_yield_sign_overlap_id_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
YieldSignStatus::mutable_done_yield_sign_overlap_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.YieldSignStatus.done_yield_sign_overlap_id)
  return &done_yield_sign_overlap_id_;
}

// repeated string wait_for_obstacle_id = 3;
int YieldSignStatus::wait_for_obstacle_id_size() const {
  return wait_for_obstacle_id_.size();
}
void YieldSignStatus::clear_wait_for_obstacle_id() {
  wait_for_obstacle_id_.Clear();
}
const ::std::string& YieldSignStatus::wait_for_obstacle_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Get(index);
}
::std::string* YieldSignStatus::mutable_wait_for_obstacle_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Mutable(index);
}
void YieldSignStatus::set_wait_for_obstacle_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void YieldSignStatus::set_wait_for_obstacle_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  wait_for_obstacle_id_.Mutable(index)->assign(std::move(value));
}
#endif
void YieldSignStatus::set_wait_for_obstacle_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
void YieldSignStatus::set_wait_for_obstacle_id(int index, const char* value, size_t size) {
  wait_for_obstacle_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
::std::string* YieldSignStatus::add_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_.Add();
}
void YieldSignStatus::add_wait_for_obstacle_id(const ::std::string& value) {
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
#if LANG_CXX11
void YieldSignStatus::add_wait_for_obstacle_id(::std::string&& value) {
  wait_for_obstacle_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
#endif
void YieldSignStatus::add_wait_for_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wait_for_obstacle_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
void YieldSignStatus::add_wait_for_obstacle_id(const char* value, size_t size) {
  wait_for_obstacle_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
YieldSignStatus::wait_for_obstacle_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return wait_for_obstacle_id_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
YieldSignStatus::mutable_wait_for_obstacle_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.YieldSignStatus.wait_for_obstacle_id)
  return &wait_for_obstacle_id_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PlanningStatus::kBareIntersectionFieldNumber;
const int PlanningStatus::kChangeLaneFieldNumber;
const int PlanningStatus::kCrosswalkFieldNumber;
const int PlanningStatus::kDestinationFieldNumber;
const int PlanningStatus::kEmergencyStopFieldNumber;
const int PlanningStatus::kOpenSpaceFieldNumber;
const int PlanningStatus::kParkAndGoFieldNumber;
const int PlanningStatus::kPathDeciderFieldNumber;
const int PlanningStatus::kPullOverFieldNumber;
const int PlanningStatus::kReroutingFieldNumber;
const int PlanningStatus::kScenarioFieldNumber;
const int PlanningStatus::kStopSignFieldNumber;
const int PlanningStatus::kTrafficLightFieldNumber;
const int PlanningStatus::kYieldSignFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PlanningStatus::PlanningStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.PlanningStatus)
}
PlanningStatus::PlanningStatus(const PlanningStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_bare_intersection()) {
    bare_intersection_ = new ::jmc_auto::planning::BareIntersectionStatus(*from.bare_intersection_);
  } else {
    bare_intersection_ = NULL;
  }
  if (from.has_change_lane()) {
    change_lane_ = new ::jmc_auto::planning::ChangeLaneStatus(*from.change_lane_);
  } else {
    change_lane_ = NULL;
  }
  if (from.has_crosswalk()) {
    crosswalk_ = new ::jmc_auto::planning::CrosswalkStatus(*from.crosswalk_);
  } else {
    crosswalk_ = NULL;
  }
  if (from.has_destination()) {
    destination_ = new ::jmc_auto::planning::DestinationStatus(*from.destination_);
  } else {
    destination_ = NULL;
  }
  if (from.has_emergency_stop()) {
    emergency_stop_ = new ::jmc_auto::planning::EmergencyStopStatus(*from.emergency_stop_);
  } else {
    emergency_stop_ = NULL;
  }
  if (from.has_open_space()) {
    open_space_ = new ::jmc_auto::planning::OpenSpaceStatus(*from.open_space_);
  } else {
    open_space_ = NULL;
  }
  if (from.has_park_and_go()) {
    park_and_go_ = new ::jmc_auto::planning::ParkAndGoStatus(*from.park_and_go_);
  } else {
    park_and_go_ = NULL;
  }
  if (from.has_path_decider()) {
    path_decider_ = new ::jmc_auto::planning::PathDeciderStatus(*from.path_decider_);
  } else {
    path_decider_ = NULL;
  }
  if (from.has_pull_over()) {
    pull_over_ = new ::jmc_auto::planning::PullOverStatus(*from.pull_over_);
  } else {
    pull_over_ = NULL;
  }
  if (from.has_rerouting()) {
    rerouting_ = new ::jmc_auto::planning::ReroutingStatus(*from.rerouting_);
  } else {
    rerouting_ = NULL;
  }
  if (from.has_scenario()) {
    scenario_ = new ::jmc_auto::planning::ScenarioStatus(*from.scenario_);
  } else {
    scenario_ = NULL;
  }
  if (from.has_stop_sign()) {
    stop_sign_ = new ::jmc_auto::planning::StopSignStatus(*from.stop_sign_);
  } else {
    stop_sign_ = NULL;
  }
  if (from.has_traffic_light()) {
    traffic_light_ = new ::jmc_auto::planning::TrafficLightStatus(*from.traffic_light_);
  } else {
    traffic_light_ = NULL;
  }
  if (from.has_yield_sign()) {
    yield_sign_ = new ::jmc_auto::planning::YieldSignStatus(*from.yield_sign_);
  } else {
    yield_sign_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.PlanningStatus)
}

void PlanningStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&bare_intersection_, 0, reinterpret_cast<char*>(&yield_sign_) -
    reinterpret_cast<char*>(&bare_intersection_) + sizeof(yield_sign_));
}

PlanningStatus::~PlanningStatus() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.PlanningStatus)
  SharedDtor();
}

void PlanningStatus::SharedDtor() {
  if (this != internal_default_instance()) {
    delete bare_intersection_;
  }
  if (this != internal_default_instance()) {
    delete change_lane_;
  }
  if (this != internal_default_instance()) {
    delete crosswalk_;
  }
  if (this != internal_default_instance()) {
    delete destination_;
  }
  if (this != internal_default_instance()) {
    delete emergency_stop_;
  }
  if (this != internal_default_instance()) {
    delete open_space_;
  }
  if (this != internal_default_instance()) {
    delete park_and_go_;
  }
  if (this != internal_default_instance()) {
    delete path_decider_;
  }
  if (this != internal_default_instance()) {
    delete pull_over_;
  }
  if (this != internal_default_instance()) {
    delete rerouting_;
  }
  if (this != internal_default_instance()) {
    delete scenario_;
  }
  if (this != internal_default_instance()) {
    delete stop_sign_;
  }
  if (this != internal_default_instance()) {
    delete traffic_light_;
  }
  if (this != internal_default_instance()) {
    delete yield_sign_;
  }
}

void PlanningStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlanningStatus::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PlanningStatus& PlanningStatus::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::InitDefaults();
  return *internal_default_instance();
}

PlanningStatus* PlanningStatus::New(::google::protobuf::Arena* arena) const {
  PlanningStatus* n = new PlanningStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PlanningStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.PlanningStatus)
  if (_has_bits_[0 / 32] & 255u) {
    if (has_bare_intersection()) {
      GOOGLE_DCHECK(bare_intersection_ != NULL);
      bare_intersection_->::jmc_auto::planning::BareIntersectionStatus::Clear();
    }
    if (has_change_lane()) {
      GOOGLE_DCHECK(change_lane_ != NULL);
      change_lane_->::jmc_auto::planning::ChangeLaneStatus::Clear();
    }
    if (has_crosswalk()) {
      GOOGLE_DCHECK(crosswalk_ != NULL);
      crosswalk_->::jmc_auto::planning::CrosswalkStatus::Clear();
    }
    if (has_destination()) {
      GOOGLE_DCHECK(destination_ != NULL);
      destination_->::jmc_auto::planning::DestinationStatus::Clear();
    }
    if (has_emergency_stop()) {
      GOOGLE_DCHECK(emergency_stop_ != NULL);
      emergency_stop_->::jmc_auto::planning::EmergencyStopStatus::Clear();
    }
    if (has_open_space()) {
      GOOGLE_DCHECK(open_space_ != NULL);
      open_space_->::jmc_auto::planning::OpenSpaceStatus::Clear();
    }
    if (has_park_and_go()) {
      GOOGLE_DCHECK(park_and_go_ != NULL);
      park_and_go_->::jmc_auto::planning::ParkAndGoStatus::Clear();
    }
    if (has_path_decider()) {
      GOOGLE_DCHECK(path_decider_ != NULL);
      path_decider_->::jmc_auto::planning::PathDeciderStatus::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 16128u) {
    if (has_pull_over()) {
      GOOGLE_DCHECK(pull_over_ != NULL);
      pull_over_->::jmc_auto::planning::PullOverStatus::Clear();
    }
    if (has_rerouting()) {
      GOOGLE_DCHECK(rerouting_ != NULL);
      rerouting_->::jmc_auto::planning::ReroutingStatus::Clear();
    }
    if (has_scenario()) {
      GOOGLE_DCHECK(scenario_ != NULL);
      scenario_->::jmc_auto::planning::ScenarioStatus::Clear();
    }
    if (has_stop_sign()) {
      GOOGLE_DCHECK(stop_sign_ != NULL);
      stop_sign_->::jmc_auto::planning::StopSignStatus::Clear();
    }
    if (has_traffic_light()) {
      GOOGLE_DCHECK(traffic_light_ != NULL);
      traffic_light_->::jmc_auto::planning::TrafficLightStatus::Clear();
    }
    if (has_yield_sign()) {
      GOOGLE_DCHECK(yield_sign_ != NULL);
      yield_sign_->::jmc_auto::planning::YieldSignStatus::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PlanningStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.PlanningStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bare_intersection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_change_lane()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_crosswalk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.DestinationStatus destination = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_destination()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_emergency_stop()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_open_space()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_park_and_go()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path_decider()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PullOverStatus pull_over = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pull_over()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rerouting()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioStatus scenario = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scenario()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_sign()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traffic_light()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_yield_sign()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.PlanningStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.PlanningStatus)
  return false;
#undef DO_
}

void PlanningStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.PlanningStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->bare_intersection_, output);
  }

  // optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->change_lane_, output);
  }

  // optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->crosswalk_, output);
  }

  // optional .jmc_auto.planning.DestinationStatus destination = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->destination_, output);
  }

  // optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->emergency_stop_, output);
  }

  // optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->open_space_, output);
  }

  // optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->park_and_go_, output);
  }

  // optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->path_decider_, output);
  }

  // optional .jmc_auto.planning.PullOverStatus pull_over = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->pull_over_, output);
  }

  // optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->rerouting_, output);
  }

  // optional .jmc_auto.planning.ScenarioStatus scenario = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->scenario_, output);
  }

  // optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->stop_sign_, output);
  }

  // optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->traffic_light_, output);
  }

  // optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->yield_sign_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.PlanningStatus)
}

::google::protobuf::uint8* PlanningStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.PlanningStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->bare_intersection_, deterministic, target);
  }

  // optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->change_lane_, deterministic, target);
  }

  // optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->crosswalk_, deterministic, target);
  }

  // optional .jmc_auto.planning.DestinationStatus destination = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->destination_, deterministic, target);
  }

  // optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->emergency_stop_, deterministic, target);
  }

  // optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->open_space_, deterministic, target);
  }

  // optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->park_and_go_, deterministic, target);
  }

  // optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->path_decider_, deterministic, target);
  }

  // optional .jmc_auto.planning.PullOverStatus pull_over = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->pull_over_, deterministic, target);
  }

  // optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->rerouting_, deterministic, target);
  }

  // optional .jmc_auto.planning.ScenarioStatus scenario = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->scenario_, deterministic, target);
  }

  // optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *this->stop_sign_, deterministic, target);
  }

  // optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->traffic_light_, deterministic, target);
  }

  // optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, *this->yield_sign_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.PlanningStatus)
  return target;
}

size_t PlanningStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.PlanningStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
    if (has_bare_intersection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->bare_intersection_);
    }

    // optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
    if (has_change_lane()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->change_lane_);
    }

    // optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
    if (has_crosswalk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->crosswalk_);
    }

    // optional .jmc_auto.planning.DestinationStatus destination = 4;
    if (has_destination()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->destination_);
    }

    // optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
    if (has_emergency_stop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->emergency_stop_);
    }

    // optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
    if (has_open_space()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->open_space_);
    }

    // optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
    if (has_park_and_go()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->park_and_go_);
    }

    // optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
    if (has_path_decider()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->path_decider_);
    }

  }
  if (_has_bits_[8 / 32] & 16128u) {
    // optional .jmc_auto.planning.PullOverStatus pull_over = 9;
    if (has_pull_over()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pull_over_);
    }

    // optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
    if (has_rerouting()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->rerouting_);
    }

    // optional .jmc_auto.planning.ScenarioStatus scenario = 11;
    if (has_scenario()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scenario_);
    }

    // optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
    if (has_stop_sign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->stop_sign_);
    }

    // optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
    if (has_traffic_light()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->traffic_light_);
    }

    // optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
    if (has_yield_sign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->yield_sign_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlanningStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.PlanningStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const PlanningStatus* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PlanningStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.PlanningStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.PlanningStatus)
    MergeFrom(*source);
  }
}

void PlanningStatus::MergeFrom(const PlanningStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.PlanningStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_bare_intersection()->::jmc_auto::planning::BareIntersectionStatus::MergeFrom(from.bare_intersection());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_change_lane()->::jmc_auto::planning::ChangeLaneStatus::MergeFrom(from.change_lane());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_crosswalk()->::jmc_auto::planning::CrosswalkStatus::MergeFrom(from.crosswalk());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_destination()->::jmc_auto::planning::DestinationStatus::MergeFrom(from.destination());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_emergency_stop()->::jmc_auto::planning::EmergencyStopStatus::MergeFrom(from.emergency_stop());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_open_space()->::jmc_auto::planning::OpenSpaceStatus::MergeFrom(from.open_space());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_park_and_go()->::jmc_auto::planning::ParkAndGoStatus::MergeFrom(from.park_and_go());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_path_decider()->::jmc_auto::planning::PathDeciderStatus::MergeFrom(from.path_decider());
    }
  }
  if (cached_has_bits & 16128u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_pull_over()->::jmc_auto::planning::PullOverStatus::MergeFrom(from.pull_over());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_rerouting()->::jmc_auto::planning::ReroutingStatus::MergeFrom(from.rerouting());
    }
    if (cached_has_bits & 0x00000400u) {
      mutable_scenario()->::jmc_auto::planning::ScenarioStatus::MergeFrom(from.scenario());
    }
    if (cached_has_bits & 0x00000800u) {
      mutable_stop_sign()->::jmc_auto::planning::StopSignStatus::MergeFrom(from.stop_sign());
    }
    if (cached_has_bits & 0x00001000u) {
      mutable_traffic_light()->::jmc_auto::planning::TrafficLightStatus::MergeFrom(from.traffic_light());
    }
    if (cached_has_bits & 0x00002000u) {
      mutable_yield_sign()->::jmc_auto::planning::YieldSignStatus::MergeFrom(from.yield_sign());
    }
  }
}

void PlanningStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.PlanningStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlanningStatus::CopyFrom(const PlanningStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.PlanningStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanningStatus::IsInitialized() const {
  return true;
}

void PlanningStatus::Swap(PlanningStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PlanningStatus::InternalSwap(PlanningStatus* other) {
  std::swap(bare_intersection_, other->bare_intersection_);
  std::swap(change_lane_, other->change_lane_);
  std::swap(crosswalk_, other->crosswalk_);
  std::swap(destination_, other->destination_);
  std::swap(emergency_stop_, other->emergency_stop_);
  std::swap(open_space_, other->open_space_);
  std::swap(park_and_go_, other->park_and_go_);
  std::swap(path_decider_, other->path_decider_);
  std::swap(pull_over_, other->pull_over_);
  std::swap(rerouting_, other->rerouting_);
  std::swap(scenario_, other->scenario_);
  std::swap(stop_sign_, other->stop_sign_);
  std::swap(traffic_light_, other->traffic_light_);
  std::swap(yield_sign_, other->yield_sign_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PlanningStatus::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fstatus_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PlanningStatus

// optional .jmc_auto.planning.BareIntersectionStatus bare_intersection = 1;
bool PlanningStatus::has_bare_intersection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PlanningStatus::set_has_bare_intersection() {
  _has_bits_[0] |= 0x00000001u;
}
void PlanningStatus::clear_has_bare_intersection() {
  _has_bits_[0] &= ~0x00000001u;
}
void PlanningStatus::clear_bare_intersection() {
  if (bare_intersection_ != NULL) bare_intersection_->::jmc_auto::planning::BareIntersectionStatus::Clear();
  clear_has_bare_intersection();
}
const ::jmc_auto::planning::BareIntersectionStatus& PlanningStatus::bare_intersection() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.bare_intersection)
  return bare_intersection_ != NULL ? *bare_intersection_
                         : *::jmc_auto::planning::BareIntersectionStatus::internal_default_instance();
}
::jmc_auto::planning::BareIntersectionStatus* PlanningStatus::mutable_bare_intersection() {
  set_has_bare_intersection();
  if (bare_intersection_ == NULL) {
    bare_intersection_ = new ::jmc_auto::planning::BareIntersectionStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.bare_intersection)
  return bare_intersection_;
}
::jmc_auto::planning::BareIntersectionStatus* PlanningStatus::release_bare_intersection() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.bare_intersection)
  clear_has_bare_intersection();
  ::jmc_auto::planning::BareIntersectionStatus* temp = bare_intersection_;
  bare_intersection_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_bare_intersection(::jmc_auto::planning::BareIntersectionStatus* bare_intersection) {
  delete bare_intersection_;
  bare_intersection_ = bare_intersection;
  if (bare_intersection) {
    set_has_bare_intersection();
  } else {
    clear_has_bare_intersection();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.bare_intersection)
}

// optional .jmc_auto.planning.ChangeLaneStatus change_lane = 2;
bool PlanningStatus::has_change_lane() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PlanningStatus::set_has_change_lane() {
  _has_bits_[0] |= 0x00000002u;
}
void PlanningStatus::clear_has_change_lane() {
  _has_bits_[0] &= ~0x00000002u;
}
void PlanningStatus::clear_change_lane() {
  if (change_lane_ != NULL) change_lane_->::jmc_auto::planning::ChangeLaneStatus::Clear();
  clear_has_change_lane();
}
const ::jmc_auto::planning::ChangeLaneStatus& PlanningStatus::change_lane() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.change_lane)
  return change_lane_ != NULL ? *change_lane_
                         : *::jmc_auto::planning::ChangeLaneStatus::internal_default_instance();
}
::jmc_auto::planning::ChangeLaneStatus* PlanningStatus::mutable_change_lane() {
  set_has_change_lane();
  if (change_lane_ == NULL) {
    change_lane_ = new ::jmc_auto::planning::ChangeLaneStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.change_lane)
  return change_lane_;
}
::jmc_auto::planning::ChangeLaneStatus* PlanningStatus::release_change_lane() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.change_lane)
  clear_has_change_lane();
  ::jmc_auto::planning::ChangeLaneStatus* temp = change_lane_;
  change_lane_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_change_lane(::jmc_auto::planning::ChangeLaneStatus* change_lane) {
  delete change_lane_;
  change_lane_ = change_lane;
  if (change_lane) {
    set_has_change_lane();
  } else {
    clear_has_change_lane();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.change_lane)
}

// optional .jmc_auto.planning.CrosswalkStatus crosswalk = 3;
bool PlanningStatus::has_crosswalk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PlanningStatus::set_has_crosswalk() {
  _has_bits_[0] |= 0x00000004u;
}
void PlanningStatus::clear_has_crosswalk() {
  _has_bits_[0] &= ~0x00000004u;
}
void PlanningStatus::clear_crosswalk() {
  if (crosswalk_ != NULL) crosswalk_->::jmc_auto::planning::CrosswalkStatus::Clear();
  clear_has_crosswalk();
}
const ::jmc_auto::planning::CrosswalkStatus& PlanningStatus::crosswalk() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.crosswalk)
  return crosswalk_ != NULL ? *crosswalk_
                         : *::jmc_auto::planning::CrosswalkStatus::internal_default_instance();
}
::jmc_auto::planning::CrosswalkStatus* PlanningStatus::mutable_crosswalk() {
  set_has_crosswalk();
  if (crosswalk_ == NULL) {
    crosswalk_ = new ::jmc_auto::planning::CrosswalkStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.crosswalk)
  return crosswalk_;
}
::jmc_auto::planning::CrosswalkStatus* PlanningStatus::release_crosswalk() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.crosswalk)
  clear_has_crosswalk();
  ::jmc_auto::planning::CrosswalkStatus* temp = crosswalk_;
  crosswalk_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_crosswalk(::jmc_auto::planning::CrosswalkStatus* crosswalk) {
  delete crosswalk_;
  crosswalk_ = crosswalk;
  if (crosswalk) {
    set_has_crosswalk();
  } else {
    clear_has_crosswalk();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.crosswalk)
}

// optional .jmc_auto.planning.DestinationStatus destination = 4;
bool PlanningStatus::has_destination() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PlanningStatus::set_has_destination() {
  _has_bits_[0] |= 0x00000008u;
}
void PlanningStatus::clear_has_destination() {
  _has_bits_[0] &= ~0x00000008u;
}
void PlanningStatus::clear_destination() {
  if (destination_ != NULL) destination_->::jmc_auto::planning::DestinationStatus::Clear();
  clear_has_destination();
}
const ::jmc_auto::planning::DestinationStatus& PlanningStatus::destination() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.destination)
  return destination_ != NULL ? *destination_
                         : *::jmc_auto::planning::DestinationStatus::internal_default_instance();
}
::jmc_auto::planning::DestinationStatus* PlanningStatus::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) {
    destination_ = new ::jmc_auto::planning::DestinationStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.destination)
  return destination_;
}
::jmc_auto::planning::DestinationStatus* PlanningStatus::release_destination() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.destination)
  clear_has_destination();
  ::jmc_auto::planning::DestinationStatus* temp = destination_;
  destination_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_destination(::jmc_auto::planning::DestinationStatus* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.destination)
}

// optional .jmc_auto.planning.EmergencyStopStatus emergency_stop = 5;
bool PlanningStatus::has_emergency_stop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PlanningStatus::set_has_emergency_stop() {
  _has_bits_[0] |= 0x00000010u;
}
void PlanningStatus::clear_has_emergency_stop() {
  _has_bits_[0] &= ~0x00000010u;
}
void PlanningStatus::clear_emergency_stop() {
  if (emergency_stop_ != NULL) emergency_stop_->::jmc_auto::planning::EmergencyStopStatus::Clear();
  clear_has_emergency_stop();
}
const ::jmc_auto::planning::EmergencyStopStatus& PlanningStatus::emergency_stop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.emergency_stop)
  return emergency_stop_ != NULL ? *emergency_stop_
                         : *::jmc_auto::planning::EmergencyStopStatus::internal_default_instance();
}
::jmc_auto::planning::EmergencyStopStatus* PlanningStatus::mutable_emergency_stop() {
  set_has_emergency_stop();
  if (emergency_stop_ == NULL) {
    emergency_stop_ = new ::jmc_auto::planning::EmergencyStopStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.emergency_stop)
  return emergency_stop_;
}
::jmc_auto::planning::EmergencyStopStatus* PlanningStatus::release_emergency_stop() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.emergency_stop)
  clear_has_emergency_stop();
  ::jmc_auto::planning::EmergencyStopStatus* temp = emergency_stop_;
  emergency_stop_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_emergency_stop(::jmc_auto::planning::EmergencyStopStatus* emergency_stop) {
  delete emergency_stop_;
  emergency_stop_ = emergency_stop;
  if (emergency_stop) {
    set_has_emergency_stop();
  } else {
    clear_has_emergency_stop();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.emergency_stop)
}

// optional .jmc_auto.planning.OpenSpaceStatus open_space = 6;
bool PlanningStatus::has_open_space() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void PlanningStatus::set_has_open_space() {
  _has_bits_[0] |= 0x00000020u;
}
void PlanningStatus::clear_has_open_space() {
  _has_bits_[0] &= ~0x00000020u;
}
void PlanningStatus::clear_open_space() {
  if (open_space_ != NULL) open_space_->::jmc_auto::planning::OpenSpaceStatus::Clear();
  clear_has_open_space();
}
const ::jmc_auto::planning::OpenSpaceStatus& PlanningStatus::open_space() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.open_space)
  return open_space_ != NULL ? *open_space_
                         : *::jmc_auto::planning::OpenSpaceStatus::internal_default_instance();
}
::jmc_auto::planning::OpenSpaceStatus* PlanningStatus::mutable_open_space() {
  set_has_open_space();
  if (open_space_ == NULL) {
    open_space_ = new ::jmc_auto::planning::OpenSpaceStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.open_space)
  return open_space_;
}
::jmc_auto::planning::OpenSpaceStatus* PlanningStatus::release_open_space() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.open_space)
  clear_has_open_space();
  ::jmc_auto::planning::OpenSpaceStatus* temp = open_space_;
  open_space_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_open_space(::jmc_auto::planning::OpenSpaceStatus* open_space) {
  delete open_space_;
  open_space_ = open_space;
  if (open_space) {
    set_has_open_space();
  } else {
    clear_has_open_space();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.open_space)
}

// optional .jmc_auto.planning.ParkAndGoStatus park_and_go = 7;
bool PlanningStatus::has_park_and_go() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void PlanningStatus::set_has_park_and_go() {
  _has_bits_[0] |= 0x00000040u;
}
void PlanningStatus::clear_has_park_and_go() {
  _has_bits_[0] &= ~0x00000040u;
}
void PlanningStatus::clear_park_and_go() {
  if (park_and_go_ != NULL) park_and_go_->::jmc_auto::planning::ParkAndGoStatus::Clear();
  clear_has_park_and_go();
}
const ::jmc_auto::planning::ParkAndGoStatus& PlanningStatus::park_and_go() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.park_and_go)
  return park_and_go_ != NULL ? *park_and_go_
                         : *::jmc_auto::planning::ParkAndGoStatus::internal_default_instance();
}
::jmc_auto::planning::ParkAndGoStatus* PlanningStatus::mutable_park_and_go() {
  set_has_park_and_go();
  if (park_and_go_ == NULL) {
    park_and_go_ = new ::jmc_auto::planning::ParkAndGoStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.park_and_go)
  return park_and_go_;
}
::jmc_auto::planning::ParkAndGoStatus* PlanningStatus::release_park_and_go() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.park_and_go)
  clear_has_park_and_go();
  ::jmc_auto::planning::ParkAndGoStatus* temp = park_and_go_;
  park_and_go_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_park_and_go(::jmc_auto::planning::ParkAndGoStatus* park_and_go) {
  delete park_and_go_;
  park_and_go_ = park_and_go;
  if (park_and_go) {
    set_has_park_and_go();
  } else {
    clear_has_park_and_go();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.park_and_go)
}

// optional .jmc_auto.planning.PathDeciderStatus path_decider = 8;
bool PlanningStatus::has_path_decider() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void PlanningStatus::set_has_path_decider() {
  _has_bits_[0] |= 0x00000080u;
}
void PlanningStatus::clear_has_path_decider() {
  _has_bits_[0] &= ~0x00000080u;
}
void PlanningStatus::clear_path_decider() {
  if (path_decider_ != NULL) path_decider_->::jmc_auto::planning::PathDeciderStatus::Clear();
  clear_has_path_decider();
}
const ::jmc_auto::planning::PathDeciderStatus& PlanningStatus::path_decider() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.path_decider)
  return path_decider_ != NULL ? *path_decider_
                         : *::jmc_auto::planning::PathDeciderStatus::internal_default_instance();
}
::jmc_auto::planning::PathDeciderStatus* PlanningStatus::mutable_path_decider() {
  set_has_path_decider();
  if (path_decider_ == NULL) {
    path_decider_ = new ::jmc_auto::planning::PathDeciderStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.path_decider)
  return path_decider_;
}
::jmc_auto::planning::PathDeciderStatus* PlanningStatus::release_path_decider() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.path_decider)
  clear_has_path_decider();
  ::jmc_auto::planning::PathDeciderStatus* temp = path_decider_;
  path_decider_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_path_decider(::jmc_auto::planning::PathDeciderStatus* path_decider) {
  delete path_decider_;
  path_decider_ = path_decider;
  if (path_decider) {
    set_has_path_decider();
  } else {
    clear_has_path_decider();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.path_decider)
}

// optional .jmc_auto.planning.PullOverStatus pull_over = 9;
bool PlanningStatus::has_pull_over() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void PlanningStatus::set_has_pull_over() {
  _has_bits_[0] |= 0x00000100u;
}
void PlanningStatus::clear_has_pull_over() {
  _has_bits_[0] &= ~0x00000100u;
}
void PlanningStatus::clear_pull_over() {
  if (pull_over_ != NULL) pull_over_->::jmc_auto::planning::PullOverStatus::Clear();
  clear_has_pull_over();
}
const ::jmc_auto::planning::PullOverStatus& PlanningStatus::pull_over() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.pull_over)
  return pull_over_ != NULL ? *pull_over_
                         : *::jmc_auto::planning::PullOverStatus::internal_default_instance();
}
::jmc_auto::planning::PullOverStatus* PlanningStatus::mutable_pull_over() {
  set_has_pull_over();
  if (pull_over_ == NULL) {
    pull_over_ = new ::jmc_auto::planning::PullOverStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.pull_over)
  return pull_over_;
}
::jmc_auto::planning::PullOverStatus* PlanningStatus::release_pull_over() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.pull_over)
  clear_has_pull_over();
  ::jmc_auto::planning::PullOverStatus* temp = pull_over_;
  pull_over_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_pull_over(::jmc_auto::planning::PullOverStatus* pull_over) {
  delete pull_over_;
  pull_over_ = pull_over;
  if (pull_over) {
    set_has_pull_over();
  } else {
    clear_has_pull_over();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.pull_over)
}

// optional .jmc_auto.planning.ReroutingStatus rerouting = 10;
bool PlanningStatus::has_rerouting() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void PlanningStatus::set_has_rerouting() {
  _has_bits_[0] |= 0x00000200u;
}
void PlanningStatus::clear_has_rerouting() {
  _has_bits_[0] &= ~0x00000200u;
}
void PlanningStatus::clear_rerouting() {
  if (rerouting_ != NULL) rerouting_->::jmc_auto::planning::ReroutingStatus::Clear();
  clear_has_rerouting();
}
const ::jmc_auto::planning::ReroutingStatus& PlanningStatus::rerouting() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.rerouting)
  return rerouting_ != NULL ? *rerouting_
                         : *::jmc_auto::planning::ReroutingStatus::internal_default_instance();
}
::jmc_auto::planning::ReroutingStatus* PlanningStatus::mutable_rerouting() {
  set_has_rerouting();
  if (rerouting_ == NULL) {
    rerouting_ = new ::jmc_auto::planning::ReroutingStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.rerouting)
  return rerouting_;
}
::jmc_auto::planning::ReroutingStatus* PlanningStatus::release_rerouting() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.rerouting)
  clear_has_rerouting();
  ::jmc_auto::planning::ReroutingStatus* temp = rerouting_;
  rerouting_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_rerouting(::jmc_auto::planning::ReroutingStatus* rerouting) {
  delete rerouting_;
  rerouting_ = rerouting;
  if (rerouting) {
    set_has_rerouting();
  } else {
    clear_has_rerouting();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.rerouting)
}

// optional .jmc_auto.planning.ScenarioStatus scenario = 11;
bool PlanningStatus::has_scenario() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void PlanningStatus::set_has_scenario() {
  _has_bits_[0] |= 0x00000400u;
}
void PlanningStatus::clear_has_scenario() {
  _has_bits_[0] &= ~0x00000400u;
}
void PlanningStatus::clear_scenario() {
  if (scenario_ != NULL) scenario_->::jmc_auto::planning::ScenarioStatus::Clear();
  clear_has_scenario();
}
const ::jmc_auto::planning::ScenarioStatus& PlanningStatus::scenario() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.scenario)
  return scenario_ != NULL ? *scenario_
                         : *::jmc_auto::planning::ScenarioStatus::internal_default_instance();
}
::jmc_auto::planning::ScenarioStatus* PlanningStatus::mutable_scenario() {
  set_has_scenario();
  if (scenario_ == NULL) {
    scenario_ = new ::jmc_auto::planning::ScenarioStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.scenario)
  return scenario_;
}
::jmc_auto::planning::ScenarioStatus* PlanningStatus::release_scenario() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.scenario)
  clear_has_scenario();
  ::jmc_auto::planning::ScenarioStatus* temp = scenario_;
  scenario_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_scenario(::jmc_auto::planning::ScenarioStatus* scenario) {
  delete scenario_;
  scenario_ = scenario;
  if (scenario) {
    set_has_scenario();
  } else {
    clear_has_scenario();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.scenario)
}

// optional .jmc_auto.planning.StopSignStatus stop_sign = 12;
bool PlanningStatus::has_stop_sign() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void PlanningStatus::set_has_stop_sign() {
  _has_bits_[0] |= 0x00000800u;
}
void PlanningStatus::clear_has_stop_sign() {
  _has_bits_[0] &= ~0x00000800u;
}
void PlanningStatus::clear_stop_sign() {
  if (stop_sign_ != NULL) stop_sign_->::jmc_auto::planning::StopSignStatus::Clear();
  clear_has_stop_sign();
}
const ::jmc_auto::planning::StopSignStatus& PlanningStatus::stop_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.stop_sign)
  return stop_sign_ != NULL ? *stop_sign_
                         : *::jmc_auto::planning::StopSignStatus::internal_default_instance();
}
::jmc_auto::planning::StopSignStatus* PlanningStatus::mutable_stop_sign() {
  set_has_stop_sign();
  if (stop_sign_ == NULL) {
    stop_sign_ = new ::jmc_auto::planning::StopSignStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.stop_sign)
  return stop_sign_;
}
::jmc_auto::planning::StopSignStatus* PlanningStatus::release_stop_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.stop_sign)
  clear_has_stop_sign();
  ::jmc_auto::planning::StopSignStatus* temp = stop_sign_;
  stop_sign_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_stop_sign(::jmc_auto::planning::StopSignStatus* stop_sign) {
  delete stop_sign_;
  stop_sign_ = stop_sign;
  if (stop_sign) {
    set_has_stop_sign();
  } else {
    clear_has_stop_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.stop_sign)
}

// optional .jmc_auto.planning.TrafficLightStatus traffic_light = 13;
bool PlanningStatus::has_traffic_light() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void PlanningStatus::set_has_traffic_light() {
  _has_bits_[0] |= 0x00001000u;
}
void PlanningStatus::clear_has_traffic_light() {
  _has_bits_[0] &= ~0x00001000u;
}
void PlanningStatus::clear_traffic_light() {
  if (traffic_light_ != NULL) traffic_light_->::jmc_auto::planning::TrafficLightStatus::Clear();
  clear_has_traffic_light();
}
const ::jmc_auto::planning::TrafficLightStatus& PlanningStatus::traffic_light() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.traffic_light)
  return traffic_light_ != NULL ? *traffic_light_
                         : *::jmc_auto::planning::TrafficLightStatus::internal_default_instance();
}
::jmc_auto::planning::TrafficLightStatus* PlanningStatus::mutable_traffic_light() {
  set_has_traffic_light();
  if (traffic_light_ == NULL) {
    traffic_light_ = new ::jmc_auto::planning::TrafficLightStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.traffic_light)
  return traffic_light_;
}
::jmc_auto::planning::TrafficLightStatus* PlanningStatus::release_traffic_light() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.traffic_light)
  clear_has_traffic_light();
  ::jmc_auto::planning::TrafficLightStatus* temp = traffic_light_;
  traffic_light_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_traffic_light(::jmc_auto::planning::TrafficLightStatus* traffic_light) {
  delete traffic_light_;
  traffic_light_ = traffic_light;
  if (traffic_light) {
    set_has_traffic_light();
  } else {
    clear_has_traffic_light();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.traffic_light)
}

// optional .jmc_auto.planning.YieldSignStatus yield_sign = 14;
bool PlanningStatus::has_yield_sign() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void PlanningStatus::set_has_yield_sign() {
  _has_bits_[0] |= 0x00002000u;
}
void PlanningStatus::clear_has_yield_sign() {
  _has_bits_[0] &= ~0x00002000u;
}
void PlanningStatus::clear_yield_sign() {
  if (yield_sign_ != NULL) yield_sign_->::jmc_auto::planning::YieldSignStatus::Clear();
  clear_has_yield_sign();
}
const ::jmc_auto::planning::YieldSignStatus& PlanningStatus::yield_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningStatus.yield_sign)
  return yield_sign_ != NULL ? *yield_sign_
                         : *::jmc_auto::planning::YieldSignStatus::internal_default_instance();
}
::jmc_auto::planning::YieldSignStatus* PlanningStatus::mutable_yield_sign() {
  set_has_yield_sign();
  if (yield_sign_ == NULL) {
    yield_sign_ = new ::jmc_auto::planning::YieldSignStatus;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningStatus.yield_sign)
  return yield_sign_;
}
::jmc_auto::planning::YieldSignStatus* PlanningStatus::release_yield_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningStatus.yield_sign)
  clear_has_yield_sign();
  ::jmc_auto::planning::YieldSignStatus* temp = yield_sign_;
  yield_sign_ = NULL;
  return temp;
}
void PlanningStatus::set_allocated_yield_sign(::jmc_auto::planning::YieldSignStatus* yield_sign) {
  delete yield_sign_;
  yield_sign_ = yield_sign;
  if (yield_sign) {
    set_has_yield_sign();
  } else {
    clear_has_yield_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningStatus.yield_sign)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace jmc_auto

// @@protoc_insertion_point(global_scope)
