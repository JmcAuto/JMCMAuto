// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "modules/planning/proto/planning_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace jmc_auto {
namespace planning {
class TaskConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TaskConfig> {
  public:
  const ::jmc_auto::planning::SpeedHeuristicConfig* speed_heuristic_config_;
  const ::jmc_auto::planning::PathDeciderConfig* path_decider_config_;
  const ::jmc_auto::planning::CreepDeciderConfig* creep_decider_config_;
  const ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config_;
  const ::jmc_auto::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config_;
  const ::jmc_auto::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config_;
  const ::jmc_auto::planning::PathBoundsDeciderConfig* path_bounds_decider_config_;
  const ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config_;
  const ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config_;
  const ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config_;
  const ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config_;
  const ::jmc_auto::planning::PathAssessmentDeciderConfig* path_assessment_decider_config_;
  const ::jmc_auto::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config_;
  const ::jmc_auto::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config_;
  const ::jmc_auto::planning::LaneChangeDeciderConfig* lane_change_decider_config_;
  const ::jmc_auto::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config_;
  const ::jmc_auto::planning::PathReuseDeciderConfig* path_reuse_decider_config_;
  const ::jmc_auto::planning::STBoundsDeciderConfig* st_bounds_decider_config_;
  const ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* piecewise_jerk_nonlinear_speed_config_;
} _TaskConfig_default_instance_;
class ScenarioLaneFollowConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioLaneFollowConfig> {
} _ScenarioLaneFollowConfig_default_instance_;
class ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioBareIntersectionUnprotectedConfig> {
} _ScenarioBareIntersectionUnprotectedConfig_default_instance_;
class ScenarioStopSignUnprotectedConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioStopSignUnprotectedConfig> {
} _ScenarioStopSignUnprotectedConfig_default_instance_;
class ScenarioTrafficLightProtectedConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioTrafficLightProtectedConfig> {
} _ScenarioTrafficLightProtectedConfig_default_instance_;
class ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioTrafficLightUnprotectedLeftTurnConfig> {
} _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_;
class ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioTrafficLightUnprotectedRightTurnConfig> {
} _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_;
class ScenarioPullOverConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioPullOverConfig> {
} _ScenarioPullOverConfig_default_instance_;
class ScenarioEmergencyPullOverConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioEmergencyPullOverConfig> {
} _ScenarioEmergencyPullOverConfig_default_instance_;
class ScenarioEmergencyStopConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioEmergencyStopConfig> {
} _ScenarioEmergencyStopConfig_default_instance_;
class ScenarioValetParkingConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioValetParkingConfig> {
} _ScenarioValetParkingConfig_default_instance_;
class ScenarioNarrowStreetUTurnConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioNarrowStreetUTurnConfig> {
} _ScenarioNarrowStreetUTurnConfig_default_instance_;
class ScenarioParkAndGoConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioParkAndGoConfig> {
} _ScenarioParkAndGoConfig_default_instance_;
class ScenarioYieldSignConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioYieldSignConfig> {
} _ScenarioYieldSignConfig_default_instance_;
class ScenarioTestLearningModelConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioTestLearningModelConfig> {
} _ScenarioTestLearningModelConfig_default_instance_;
class ScenarioConfig_StageConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioConfig_StageConfig> {
} _ScenarioConfig_StageConfig_default_instance_;
class ScenarioConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ScenarioConfig> {
  public:
  const ::jmc_auto::planning::ScenarioLaneFollowConfig* lane_follow_config_;
  const ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config_;
  const ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config_;
  const ::jmc_auto::planning::ScenarioEmergencyStopConfig* emergency_stop_config_;
  const ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config_;
  const ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config_;
  const ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config_;
  const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config_;
  const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config_;
  const ::jmc_auto::planning::ScenarioParkAndGoConfig* park_and_go_config_;
  const ::jmc_auto::planning::ScenarioPullOverConfig* pull_over_config_;
  const ::jmc_auto::planning::ScenarioValetParkingConfig* valet_parking_config_;
  const ::jmc_auto::planning::ScenarioYieldSignConfig* yield_sign_config_;
  const ::jmc_auto::planning::ScenarioTestLearningModelConfig* test_learning_model_config_;
} _ScenarioConfig_default_instance_;
class PlannerPublicRoadConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PlannerPublicRoadConfig> {
} _PlannerPublicRoadConfig_default_instance_;
class PlannerNaviConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PlannerNaviConfig> {
} _PlannerNaviConfig_default_instance_;
class RtkPlanningConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RtkPlanningConfig> {
} _RtkPlanningConfig_default_instance_;
class StandardPlanningConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StandardPlanningConfig> {
} _StandardPlanningConfig_default_instance_;
class NavigationPlanningConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<NavigationPlanningConfig> {
} _NavigationPlanningConfig_default_instance_;
class PlanningConfigDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PlanningConfig> {
  public:
  const ::jmc_auto::planning::RtkPlanningConfig* rtk_planning_config_;
  const ::jmc_auto::planning::StandardPlanningConfig* standard_planning_config_;
  const ::jmc_auto::planning::NavigationPlanningConfig* navigation_planning_config_;
} _PlanningConfig_default_instance_;

namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[23];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[4];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskConfig, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskConfig, task_type_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), speed_heuristic_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), path_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), creep_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), open_space_pre_stop_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), speed_bounds_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), piecewise_jerk_path_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), path_bounds_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), open_space_fallback_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), open_space_roi_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), open_space_trajectory_provider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), open_space_trajectory_partition_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), path_assessment_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), piecewise_jerk_speed_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), path_lane_borrow_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), lane_change_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), rule_based_stop_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), path_reuse_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), st_bounds_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_TaskConfig_default_instance_), piecewise_jerk_nonlinear_speed_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskConfig, task_config_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioLaneFollowConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioLaneFollowConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, start_bare_intersection_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, enable_explicit_stop_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, min_pass_s_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, approach_cruise_speed_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, stop_timeout_sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioBareIntersectionUnprotectedConfig, creep_timeout_sec_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, start_stop_sign_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, watch_vehicle_max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, stop_duration_sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, min_pass_s_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, stop_timeout_sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioStopSignUnprotectedConfig, creep_timeout_sec_),
  1,
  2,
  3,
  5,
  4,
  6,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightProtectedConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightProtectedConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightProtectedConfig, start_traffic_light_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightProtectedConfig, max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightProtectedConfig, min_pass_s_distance_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, start_traffic_light_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, approach_cruise_speed_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, min_pass_s_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, creep_timeout_sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedLeftTurnConfig, max_adc_speed_before_creep_),
  1,
  2,
  3,
  4,
  0,
  5,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, start_traffic_light_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, enable_right_turn_on_red_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, min_pass_s_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, red_light_right_turn_stop_duration_sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, creep_timeout_sec_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTrafficLightUnprotectedRightTurnConfig, max_adc_speed_before_creep_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, start_pull_over_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, pull_over_min_distance_buffer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, max_distance_stop_search_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, max_s_error_to_end_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, max_l_error_to_end_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, max_theta_error_to_end_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, max_distance_error_to_end_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, pass_destination_threshold_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioPullOverConfig, s_distance_to_stop_for_open_space_parking_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyPullOverConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyPullOverConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyPullOverConfig, max_stop_deceleration_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyPullOverConfig, slow_down_deceleration_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyPullOverConfig, target_slow_down_speed_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyPullOverConfig, stop_distance_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyStopConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyStopConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyStopConfig, max_stop_deceleration_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioEmergencyStopConfig, stop_distance_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioValetParkingConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioValetParkingConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioValetParkingConfig, parking_spot_range_to_start_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioValetParkingConfig, max_valid_stop_distance_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioNarrowStreetUTurnConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioNarrowStreetUTurnConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioParkAndGoConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioParkAndGoConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioParkAndGoConfig, front_obstacle_buffer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioParkAndGoConfig, heading_buffer_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioParkAndGoConfig, min_dist_to_dest_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioParkAndGoConfig, max_steering_percentage_when_cruise_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioYieldSignConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioYieldSignConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioYieldSignConfig, start_yield_sign_scenario_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioYieldSignConfig, max_valid_stop_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioYieldSignConfig, min_pass_s_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioYieldSignConfig, creep_timeout_sec_),
  1,
  2,
  3,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTestLearningModelConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTestLearningModelConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTestLearningModelConfig, model_file_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioTestLearningModelConfig, input_feature_num_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig_StageConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig_StageConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig_StageConfig, stage_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig_StageConfig, enabled_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig_StageConfig, task_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig_StageConfig, task_config_),
  0,
  1,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, scenario_type_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), lane_follow_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), bare_intersection_unprotected_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), emergency_pull_over_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), emergency_stop_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), narrow_street_u_turn_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), stop_sign_unprotected_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), traffic_light_protected_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), traffic_light_unprotected_right_turn_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), traffic_light_unprotected_left_turn_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), park_and_go_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), pull_over_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), valet_parking_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), yield_sign_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ScenarioConfig_default_instance_), test_learning_model_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, stage_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, stage_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScenarioConfig, scenario_config_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerPublicRoadConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerPublicRoadConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerNaviConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerNaviConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerNaviConfig, task_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerNaviConfig, navi_path_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerNaviConfig, navi_speed_decider_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlannerNaviConfig, navi_obstacle_decider_config_),
  ~0u,
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RtkPlanningConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RtkPlanningConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RtkPlanningConfig, planner_type_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardPlanningConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardPlanningConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardPlanningConfig, planner_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StandardPlanningConfig, planner_public_road_config_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationPlanningConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationPlanningConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationPlanningConfig, planner_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NavigationPlanningConfig, planner_navi_config_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningConfig, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningConfig, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_PlanningConfig_default_instance_), rtk_planning_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_PlanningConfig_default_instance_), standard_planning_config_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_PlanningConfig_default_instance_), navigation_planning_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningConfig, default_task_config_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlanningConfig, planning_config_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 26, sizeof(TaskConfig)},
  { 46, 51, sizeof(ScenarioLaneFollowConfig)},
  { 51, 63, sizeof(ScenarioBareIntersectionUnprotectedConfig)},
  { 70, 82, sizeof(ScenarioStopSignUnprotectedConfig)},
  { 89, 97, sizeof(ScenarioTrafficLightProtectedConfig)},
  { 100, 111, sizeof(ScenarioTrafficLightUnprotectedLeftTurnConfig)},
  { 117, 129, sizeof(ScenarioTrafficLightUnprotectedRightTurnConfig)},
  { 136, 151, sizeof(ScenarioPullOverConfig)},
  { 161, 170, sizeof(ScenarioEmergencyPullOverConfig)},
  { 174, 181, sizeof(ScenarioEmergencyStopConfig)},
  { 183, 190, sizeof(ScenarioValetParkingConfig)},
  { 192, 197, sizeof(ScenarioNarrowStreetUTurnConfig)},
  { 197, 206, sizeof(ScenarioParkAndGoConfig)},
  { 210, 219, sizeof(ScenarioYieldSignConfig)},
  { 223, 230, sizeof(ScenarioTestLearningModelConfig)},
  { 232, 241, sizeof(ScenarioConfig_StageConfig)},
  { 245, 268, sizeof(ScenarioConfig)},
  { 285, 290, sizeof(PlannerPublicRoadConfig)},
  { 290, 299, sizeof(PlannerNaviConfig)},
  { 303, 309, sizeof(RtkPlanningConfig)},
  { 310, 317, sizeof(StandardPlanningConfig)},
  { 319, 326, sizeof(NavigationPlanningConfig)},
  { 328, 338, sizeof(PlanningConfig)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_TaskConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioLaneFollowConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioBareIntersectionUnprotectedConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioStopSignUnprotectedConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioTrafficLightProtectedConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioPullOverConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioEmergencyPullOverConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioEmergencyStopConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioValetParkingConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioNarrowStreetUTurnConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioParkAndGoConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioYieldSignConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioTestLearningModelConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioConfig_StageConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ScenarioConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PlannerPublicRoadConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PlannerNaviConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_RtkPlanningConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_StandardPlanningConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_NavigationPlanningConfig_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PlanningConfig_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "modules/planning/proto/planning_config.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 23);
}

}  // namespace

void TableStruct::Shutdown() {
  _TaskConfig_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _ScenarioLaneFollowConfig_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _ScenarioBareIntersectionUnprotectedConfig_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _ScenarioStopSignUnprotectedConfig_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _ScenarioTrafficLightProtectedConfig_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _ScenarioPullOverConfig_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _ScenarioEmergencyPullOverConfig_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _ScenarioEmergencyStopConfig_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  _ScenarioValetParkingConfig_default_instance_.Shutdown();
  delete file_level_metadata[10].reflection;
  _ScenarioNarrowStreetUTurnConfig_default_instance_.Shutdown();
  delete file_level_metadata[11].reflection;
  _ScenarioParkAndGoConfig_default_instance_.Shutdown();
  delete file_level_metadata[12].reflection;
  _ScenarioYieldSignConfig_default_instance_.Shutdown();
  delete file_level_metadata[13].reflection;
  _ScenarioTestLearningModelConfig_default_instance_.Shutdown();
  delete file_level_metadata[14].reflection;
  _ScenarioConfig_StageConfig_default_instance_.Shutdown();
  delete file_level_metadata[15].reflection;
  _ScenarioConfig_default_instance_.Shutdown();
  delete file_level_metadata[16].reflection;
  _PlannerPublicRoadConfig_default_instance_.Shutdown();
  delete file_level_metadata[17].reflection;
  _PlannerNaviConfig_default_instance_.Shutdown();
  delete file_level_metadata[18].reflection;
  _RtkPlanningConfig_default_instance_.Shutdown();
  delete file_level_metadata[19].reflection;
  _StandardPlanningConfig_default_instance_.Shutdown();
  delete file_level_metadata[20].reflection;
  _NavigationPlanningConfig_default_instance_.Shutdown();
  delete file_level_metadata[21].reflection;
  _PlanningConfig_default_instance_.Shutdown();
  delete file_level_metadata[22].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fcreep_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fdp_5fst_5fspeed_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2flane_5fchange_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5ffallback_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5fpre_5fstop_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5ftrajectory_5fprovider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5ftrajectory_5fpartition_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5fassessment_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5fbounds_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5flane_5fborrow_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpiecewise_5fjerk_5fpath_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpiecewise_5fjerk_5fspeed_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpiecewise_5fjerk_5fnonlinear_5fspeed_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2frule_5fbased_5fstop_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fspeed_5fbounds_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fnavi_5fpath_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fnavi_5fspeed_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fnavi_5fobstacle_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5freuse_5fdecider_5fconfig_2eproto::InitDefaults();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fst_5fbounds_5fdecider_5fconfig_2eproto::InitDefaults();
  _TaskConfig_default_instance_.DefaultConstruct();
  _ScenarioLaneFollowConfig_default_instance_.DefaultConstruct();
  _ScenarioBareIntersectionUnprotectedConfig_default_instance_.DefaultConstruct();
  _ScenarioStopSignUnprotectedConfig_default_instance_.DefaultConstruct();
  _ScenarioTrafficLightProtectedConfig_default_instance_.DefaultConstruct();
  _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_.DefaultConstruct();
  _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_.DefaultConstruct();
  _ScenarioPullOverConfig_default_instance_.DefaultConstruct();
  _ScenarioEmergencyPullOverConfig_default_instance_.DefaultConstruct();
  _ScenarioEmergencyStopConfig_default_instance_.DefaultConstruct();
  _ScenarioValetParkingConfig_default_instance_.DefaultConstruct();
  _ScenarioNarrowStreetUTurnConfig_default_instance_.DefaultConstruct();
  _ScenarioParkAndGoConfig_default_instance_.DefaultConstruct();
  _ScenarioYieldSignConfig_default_instance_.DefaultConstruct();
  _ScenarioTestLearningModelConfig_default_instance_.DefaultConstruct();
  _ScenarioConfig_StageConfig_default_instance_.DefaultConstruct();
  _ScenarioConfig_default_instance_.DefaultConstruct();
  _PlannerPublicRoadConfig_default_instance_.DefaultConstruct();
  _PlannerNaviConfig_default_instance_.DefaultConstruct();
  _RtkPlanningConfig_default_instance_.DefaultConstruct();
  _StandardPlanningConfig_default_instance_.DefaultConstruct();
  _NavigationPlanningConfig_default_instance_.DefaultConstruct();
  _PlanningConfig_default_instance_.DefaultConstruct();
  _TaskConfig_default_instance_.speed_heuristic_config_ = const_cast< ::jmc_auto::planning::SpeedHeuristicConfig*>(
      ::jmc_auto::planning::SpeedHeuristicConfig::internal_default_instance());
  _TaskConfig_default_instance_.path_decider_config_ = const_cast< ::jmc_auto::planning::PathDeciderConfig*>(
      ::jmc_auto::planning::PathDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.creep_decider_config_ = const_cast< ::jmc_auto::planning::CreepDeciderConfig*>(
      ::jmc_auto::planning::CreepDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.open_space_pre_stop_decider_config_ = const_cast< ::jmc_auto::planning::OpenSpacePreStopDeciderConfig*>(
      ::jmc_auto::planning::OpenSpacePreStopDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.speed_bounds_decider_config_ = const_cast< ::jmc_auto::planning::SpeedBoundsDeciderConfig*>(
      ::jmc_auto::planning::SpeedBoundsDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.piecewise_jerk_path_config_ = const_cast< ::jmc_auto::planning::PiecewiseJerkPathConfig*>(
      ::jmc_auto::planning::PiecewiseJerkPathConfig::internal_default_instance());
  _TaskConfig_default_instance_.path_bounds_decider_config_ = const_cast< ::jmc_auto::planning::PathBoundsDeciderConfig*>(
      ::jmc_auto::planning::PathBoundsDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.open_space_fallback_decider_config_ = const_cast< ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig*>(
      ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.open_space_roi_decider_config_ = const_cast< ::jmc_auto::planning::OpenSpaceRoiDeciderConfig*>(
      ::jmc_auto::planning::OpenSpaceRoiDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.open_space_trajectory_provider_config_ = const_cast< ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig*>(
      ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig::internal_default_instance());
  _TaskConfig_default_instance_.open_space_trajectory_partition_config_ = const_cast< ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig*>(
      ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig::internal_default_instance());
  _TaskConfig_default_instance_.path_assessment_decider_config_ = const_cast< ::jmc_auto::planning::PathAssessmentDeciderConfig*>(
      ::jmc_auto::planning::PathAssessmentDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.piecewise_jerk_speed_config_ = const_cast< ::jmc_auto::planning::PiecewiseJerkSpeedConfig*>(
      ::jmc_auto::planning::PiecewiseJerkSpeedConfig::internal_default_instance());
  _TaskConfig_default_instance_.path_lane_borrow_decider_config_ = const_cast< ::jmc_auto::planning::PathLaneBorrowDeciderConfig*>(
      ::jmc_auto::planning::PathLaneBorrowDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.lane_change_decider_config_ = const_cast< ::jmc_auto::planning::LaneChangeDeciderConfig*>(
      ::jmc_auto::planning::LaneChangeDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.rule_based_stop_decider_config_ = const_cast< ::jmc_auto::planning::RuleBasedStopDeciderConfig*>(
      ::jmc_auto::planning::RuleBasedStopDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.path_reuse_decider_config_ = const_cast< ::jmc_auto::planning::PathReuseDeciderConfig*>(
      ::jmc_auto::planning::PathReuseDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.st_bounds_decider_config_ = const_cast< ::jmc_auto::planning::STBoundsDeciderConfig*>(
      ::jmc_auto::planning::STBoundsDeciderConfig::internal_default_instance());
  _TaskConfig_default_instance_.piecewise_jerk_nonlinear_speed_config_ = const_cast< ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig*>(
      ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.lane_follow_config_ = const_cast< ::jmc_auto::planning::ScenarioLaneFollowConfig*>(
      ::jmc_auto::planning::ScenarioLaneFollowConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.bare_intersection_unprotected_config_ = const_cast< ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig*>(
      ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.emergency_pull_over_config_ = const_cast< ::jmc_auto::planning::ScenarioEmergencyPullOverConfig*>(
      ::jmc_auto::planning::ScenarioEmergencyPullOverConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.emergency_stop_config_ = const_cast< ::jmc_auto::planning::ScenarioEmergencyStopConfig*>(
      ::jmc_auto::planning::ScenarioEmergencyStopConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.narrow_street_u_turn_config_ = const_cast< ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig*>(
      ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.stop_sign_unprotected_config_ = const_cast< ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig*>(
      ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.traffic_light_protected_config_ = const_cast< ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig*>(
      ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.traffic_light_unprotected_right_turn_config_ = const_cast< ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig*>(
      ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.traffic_light_unprotected_left_turn_config_ = const_cast< ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig*>(
      ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.park_and_go_config_ = const_cast< ::jmc_auto::planning::ScenarioParkAndGoConfig*>(
      ::jmc_auto::planning::ScenarioParkAndGoConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.pull_over_config_ = const_cast< ::jmc_auto::planning::ScenarioPullOverConfig*>(
      ::jmc_auto::planning::ScenarioPullOverConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.valet_parking_config_ = const_cast< ::jmc_auto::planning::ScenarioValetParkingConfig*>(
      ::jmc_auto::planning::ScenarioValetParkingConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.yield_sign_config_ = const_cast< ::jmc_auto::planning::ScenarioYieldSignConfig*>(
      ::jmc_auto::planning::ScenarioYieldSignConfig::internal_default_instance());
  _ScenarioConfig_default_instance_.test_learning_model_config_ = const_cast< ::jmc_auto::planning::ScenarioTestLearningModelConfig*>(
      ::jmc_auto::planning::ScenarioTestLearningModelConfig::internal_default_instance());
  _PlannerNaviConfig_default_instance_.get_mutable()->navi_path_decider_config_ = const_cast< ::jmc_auto::planning::NaviPathDeciderConfig*>(
      ::jmc_auto::planning::NaviPathDeciderConfig::internal_default_instance());
  _PlannerNaviConfig_default_instance_.get_mutable()->navi_speed_decider_config_ = const_cast< ::jmc_auto::planning::NaviSpeedDeciderConfig*>(
      ::jmc_auto::planning::NaviSpeedDeciderConfig::internal_default_instance());
  _PlannerNaviConfig_default_instance_.get_mutable()->navi_obstacle_decider_config_ = const_cast< ::jmc_auto::planning::NaviObstacleDeciderConfig*>(
      ::jmc_auto::planning::NaviObstacleDeciderConfig::internal_default_instance());
  _StandardPlanningConfig_default_instance_.get_mutable()->planner_public_road_config_ = const_cast< ::jmc_auto::planning::PlannerPublicRoadConfig*>(
      ::jmc_auto::planning::PlannerPublicRoadConfig::internal_default_instance());
  _NavigationPlanningConfig_default_instance_.get_mutable()->planner_navi_config_ = const_cast< ::jmc_auto::planning::PlannerNaviConfig*>(
      ::jmc_auto::planning::PlannerNaviConfig::internal_default_instance());
  _PlanningConfig_default_instance_.rtk_planning_config_ = const_cast< ::jmc_auto::planning::RtkPlanningConfig*>(
      ::jmc_auto::planning::RtkPlanningConfig::internal_default_instance());
  _PlanningConfig_default_instance_.standard_planning_config_ = const_cast< ::jmc_auto::planning::StandardPlanningConfig*>(
      ::jmc_auto::planning::StandardPlanningConfig::internal_default_instance());
  _PlanningConfig_default_instance_.navigation_planning_config_ = const_cast< ::jmc_auto::planning::NavigationPlanningConfig*>(
      ::jmc_auto::planning::NavigationPlanningConfig::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n,modules/planning/proto/planning_config"
      ".proto\022\021jmc_auto.planning\0321modules/plann"
      "ing/proto/creep_decider_config.proto\032/mo"
      "dules/planning/proto/dp_st_speed_config."
      "proto\0327modules/planning/proto/lane_chang"
      "e_decider_config.proto\032\?modules/planning"
      "/proto/open_space_fallback_decider_confi"
      "g.proto\032\?modules/planning/proto/open_spa"
      "ce_pre_stop_decider_config.proto\032:module"
      "s/planning/proto/open_space_roi_decider_"
      "config.proto\032Bmodules/planning/proto/ope"
      "n_space_trajectory_provider_config.proto"
      "\032Cmodules/planning/proto/open_space_traj"
      "ectory_partition_config.proto\032;modules/p"
      "lanning/proto/path_assessment_decider_co"
      "nfig.proto\0327modules/planning/proto/path_"
      "bounds_decider_config.proto\0320modules/pla"
      "nning/proto/path_decider_config.proto\032<m"
      "odules/planning/proto/path_lane_borrow_d"
      "ecider_config.proto\0327modules/planning/pr"
      "oto/piecewise_jerk_path_config.proto\0328mo"
      "dules/planning/proto/piecewise_jerk_spee"
      "d_config.proto\032Bmodules/planning/proto/p"
      "iecewise_jerk_nonlinear_speed_config.pro"
      "to\032;modules/planning/proto/rule_based_st"
      "op_decider_config.proto\0328modules/plannin"
      "g/proto/speed_bounds_decider_config.prot"
      "o\0325modules/planning/proto/navi_path_deci"
      "der_config.proto\0326modules/planning/proto"
      "/navi_speed_decider_config.proto\0329module"
      "s/planning/proto/navi_obstacle_decider_c"
      "onfig.proto\0326modules/planning/proto/path"
      "_reuse_decider_config.proto\0325modules/pla"
      "nning/proto/st_bounds_decider_config.pro"
      "to\"\227\023\n\nTaskConfig\0229\n\ttask_type\030\001 \001(\0162&.j"
      "mc_auto.planning.TaskConfig.TaskType\022I\n\026"
      "speed_heuristic_config\030\003 \001(\0132\'.jmc_auto."
      "planning.SpeedHeuristicConfigH\000\022C\n\023path_"
      "decider_config\030\007 \001(\0132$.jmc_auto.planning"
      ".PathDeciderConfigH\000\022E\n\024creep_decider_co"
      "nfig\030\n \001(\0132%.jmc_auto.planning.CreepDeci"
      "derConfigH\000\022^\n\"open_space_pre_stop_decid"
      "er_config\030\013 \001(\01320.jmc_auto.planning.Open"
      "SpacePreStopDeciderConfigH\000\022R\n\033speed_bou"
      "nds_decider_config\030\017 \001(\0132+.jmc_auto.plan"
      "ning.SpeedBoundsDeciderConfigH\000\022P\n\032piece"
      "wise_jerk_path_config\030\020 \001(\0132*.jmc_auto.p"
      "lanning.PiecewiseJerkPathConfigH\000\022P\n\032pat"
      "h_bounds_decider_config\030\021 \001(\0132*.jmc_auto"
      ".planning.PathBoundsDeciderConfigH\000\022_\n\"o"
      "pen_space_fallback_decider_config\030\022 \001(\0132"
      "1.jmc_auto.planning.OpenSpaceFallBackDec"
      "iderConfigH\000\022U\n\035open_space_roi_decider_c"
      "onfig\030\023 \001(\0132,.jmc_auto.planning.OpenSpac"
      "eRoiDeciderConfigH\000\022e\n%open_space_trajec"
      "tory_provider_config\030\024 \001(\01324.jmc_auto.pl"
      "anning.OpenSpaceTrajectoryProviderConfig"
      "H\000\022g\n&open_space_trajectory_partition_co"
      "nfig\030\025 \001(\01325.jmc_auto.planning.OpenSpace"
      "TrajectoryPartitionConfigH\000\022X\n\036path_asse"
      "ssment_decider_config\030\026 \001(\0132..jmc_auto.p"
      "lanning.PathAssessmentDeciderConfigH\000\022R\n"
      "\033piecewise_jerk_speed_config\030\027 \001(\0132+.jmc"
      "_auto.planning.PiecewiseJerkSpeedConfigH"
      "\000\022Y\n\037path_lane_borrow_decider_config\030\030 \001"
      "(\0132..jmc_auto.planning.PathLaneBorrowDec"
      "iderConfigH\000\022P\n\032lane_change_decider_conf"
      "ig\030\031 \001(\0132*.jmc_auto.planning.LaneChangeD"
      "eciderConfigH\000\022W\n\036rule_based_stop_decide"
      "r_config\030\032 \001(\0132-.jmc_auto.planning.RuleB"
      "asedStopDeciderConfigH\000\022N\n\031path_reuse_de"
      "cider_config\030\033 \001(\0132).jmc_auto.planning.P"
      "athReuseDeciderConfigH\000\022L\n\030st_bounds_dec"
      "ider_config\030\034 \001(\0132(.jmc_auto.planning.ST"
      "BoundsDeciderConfigH\000\022e\n%piecewise_jerk_"
      "nonlinear_speed_config\030\035 \001(\01324.jmc_auto."
      "planning.PiecewiseJerkNonlinearSpeedConf"
      "igH\000\"\316\005\n\010TaskType\022\031\n\025DP_ST_SPEED_OPTIMIZ"
      "ER\020\001\022\020\n\014PATH_DECIDER\020\004\022\021\n\rSPEED_DECIDER\020"
      "\005\022\025\n\021NAVI_PATH_DECIDER\020\007\022\026\n\022NAVI_SPEED_D"
      "ECIDER\020\010\022\031\n\025NAVI_OBSTACLE_DECIDER\020\t\022\021\n\rC"
      "REEP_DECIDER\020\013\022\037\n\033OPEN_SPACE_PRE_STOP_DE"
      "CIDER\020\014\022\017\n\013DECIDER_RSS\020\020\022\037\n\033SPEED_BOUNDS"
      "_PRIORI_DECIDER\020\021\022\036\n\032SPEED_BOUNDS_FINAL_"
      "DECIDER\020\022\022!\n\035PIECEWISE_JERK_PATH_OPTIMIZ"
      "ER\020\023\022\027\n\023PATH_BOUNDS_DECIDER\020\024\022\032\n\026OPEN_SP"
      "ACE_ROI_DECIDER\020\025\022\"\n\036OPEN_SPACE_TRAJECTO"
      "RY_PROVIDER\020\026\022#\n\037OPEN_SPACE_TRAJECTORY_P"
      "ARTITION\020\027\022\037\n\033OPEN_SPACE_FALLBACK_DECIDE"
      "R\020\030\022\033\n\027PATH_ASSESSMENT_DECIDER\020\031\022\034\n\030PATH"
      "_LANE_BORROW_DECIDER\020\032\022\"\n\036PIECEWISE_JERK"
      "_SPEED_OPTIMIZER\020\033\022\027\n\023LANE_CHANGE_DECIDE"
      "R\020\034\022\033\n\027RULE_BASED_STOP_DECIDER\020\035\022\026\n\022PATH"
      "_REUSE_DECIDER\020\036\022\025\n\021ST_BOUNDS_DECIDER\020\037\022"
      ",\n(PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMI"
      "ZER\020 B\r\n\013task_config\"\032\n\030ScenarioLaneFoll"
      "owConfig\"\246\002\n)ScenarioBareIntersectionUnp"
      "rotectedConfig\0225\n)start_bare_intersectio"
      "n_scenario_distance\030\001 \001(\001:\00225\022#\n\024enable_"
      "explicit_stop\030\002 \001(\010:\005false\022\036\n\023min_pass_s"
      "_distance\030\003 \001(\001:\0013\022%\n\025approach_cruise_sp"
      "eed\030\004 \001(\001:\0066.7056\022\032\n\rstop_distance\030\005 \001(\001"
      ":\0030.5\022\033\n\020stop_timeout_sec\030\006 \001(\002:\0018\022\035\n\021cr"
      "eep_timeout_sec\030\007 \001(\002:\00210\"\243\002\n!ScenarioSt"
      "opSignUnprotectedConfig\022,\n!start_stop_si"
      "gn_scenario_distance\030\001 \001(\001:\0015\0220\n%watch_v"
      "ehicle_max_valid_stop_distance\030\002 \001(\001:\0015\022"
      "$\n\027max_valid_stop_distance\030\003 \001(\001:\0033.5\022\034\n"
      "\021stop_duration_sec\030\004 \001(\002:\0011\022\036\n\023min_pass_"
      "s_distance\030\005 \001(\001:\0013\022\033\n\020stop_timeout_sec\030"
      "\006 \001(\002:\0018\022\035\n\021creep_timeout_sec\030\007 \001(\002:\00210\""
      "\233\001\n#ScenarioTrafficLightProtectedConfig\022"
      "0\n%start_traffic_light_scenario_distance"
      "\030\001 \001(\001:\0015\022\"\n\027max_valid_stop_distance\030\002 \001"
      "(\001:\0012\022\036\n\023min_pass_s_distance\030\003 \001(\001:\0013\"\225\002"
      "\n-ScenarioTrafficLightUnprotectedLeftTur"
      "nConfig\0220\n%start_traffic_light_scenario_"
      "distance\030\001 \001(\001:\0015\022#\n\025approach_cruise_spe"
      "ed\030\002 \001(\001:\0042.78\022$\n\027max_valid_stop_distanc"
      "e\030\003 \001(\001:\0033.5\022\036\n\023min_pass_s_distance\030\004 \001("
      "\001:\0013\022\035\n\021creep_timeout_sec\030\005 \001(\002:\00210\022(\n\032m"
      "ax_adc_speed_before_creep\030\006 \001(\001:\0045.56\"\312\002"
      "\n.ScenarioTrafficLightUnprotectedRightTu"
      "rnConfig\0220\n%start_traffic_light_scenario"
      "_distance\030\001 \001(\001:\0015\022\'\n\030enable_right_turn_"
      "on_red\030\002 \001(\010:\005false\022$\n\027max_valid_stop_di"
      "stance\030\003 \001(\001:\0033.5\022\036\n\023min_pass_s_distance"
      "\030\004 \001(\001:\0013\0221\n&red_light_right_turn_stop_d"
      "uration_sec\030\005 \001(\002:\0013\022\035\n\021creep_timeout_se"
      "c\030\006 \001(\002:\00210\022%\n\032max_adc_speed_before_cree"
      "p\030\007 \001(\001:\0013\"\301\003\n\026ScenarioPullOverConfig\022-\n"
      "!start_pull_over_scenario_distance\030\001 \001(\001"
      ":\00250\022)\n\035pull_over_min_distance_buffer\030\002 "
      "\001(\001:\00210\022$\n\030max_distance_stop_search\030\003 \001("
      "\001:\00225\022%\n\030max_s_error_to_end_point\030\004 \001(\001:"
      "\0030.2\022%\n\030max_l_error_to_end_point\030\005 \001(\001:\003"
      "0.5\022)\n\034max_theta_error_to_end_point\030\006 \001("
      "\001:\0030.2\022,\n\037max_distance_error_to_end_poin"
      "t\030\007 \001(\001:\0030.2\022&\n\032pass_destination_thresho"
      "ld\030\010 \001(\001:\00210\022\"\n\027max_valid_stop_distance\030"
      "\t \001(\001:\0011\0224\n)s_distance_to_stop_for_open_"
      "space_parking\030\n \001(\001:\0017\"\254\001\n\037ScenarioEmerg"
      "encyPullOverConfig\022 \n\025max_stop_decelerat"
      "ion\030\001 \001(\001:\0013\022&\n\033slow_down_deceleration_t"
      "ime\030\002 \001(\001:\0013\022#\n\026target_slow_down_speed\030\003"
      " \001(\001:\0032.5\022\032\n\rstop_distance\030\004 \001(\001:\0031.5\"Y\n"
      "\033ScenarioEmergencyStopConfig\022 \n\025max_stop"
      "_deceleration\030\001 \001(\001:\0016\022\030\n\rstop_distance\030"
      "\002 \001(\001:\0011\"i\n\032ScenarioValetParkingConfig\022\'"
      "\n\033parking_spot_range_to_start\030\001 \001(\001:\00220\022"
      "\"\n\027max_valid_stop_distance\030\002 \001(\001:\0011\"!\n\037S"
      "cenarioNarrowStreetUTurnConfig\"\247\001\n\027Scena"
      "rioParkAndGoConfig\022 \n\025front_obstacle_buf"
      "fer\030\001 \001(\001:\0014\022\033\n\016heading_buffer\030\002 \001(\001:\0030."
      "5\022\034\n\020min_dist_to_dest\030\003 \001(\001:\00225\022/\n#max_s"
      "teering_percentage_when_cruise\030\004 \001(\001:\00290"
      "\"\256\001\n\027ScenarioYieldSignConfig\022.\n\"start_yi"
      "eld_sign_scenario_distance\030\001 \001(\001:\00210\022$\n\027"
      "max_valid_stop_distance\030\002 \001(\001:\0034.5\022\036\n\023mi"
      "n_pass_s_distance\030\003 \001(\001:\0013\022\035\n\021creep_time"
      "out_sec\030\004 \001(\002:\00210\"P\n\037ScenarioTestLearnin"
      "gModelConfig\022\022\n\nmodel_file\030\001 \001(\t\022\031\n\021inpu"
      "t_feature_num\030\002 \001(\005\"\374\031\n\016ScenarioConfig\022E"
      "\n\rscenario_type\030\001 \001(\0162..jmc_auto.plannin"
      "g.ScenarioConfig.ScenarioType\022I\n\022lane_fo"
      "llow_config\030\002 \001(\0132+.jmc_auto.planning.Sc"
      "enarioLaneFollowConfigH\000\022l\n$bare_interse"
      "ction_unprotected_config\030\004 \001(\0132<.jmc_aut"
      "o.planning.ScenarioBareIntersectionUnpro"
      "tectedConfigH\000\022X\n\032emergency_pull_over_co"
      "nfig\030\005 \001(\01322.jmc_auto.planning.ScenarioE"
      "mergencyPullOverConfigH\000\022O\n\025emergency_st"
      "op_config\030\006 \001(\0132..jmc_auto.planning.Scen"
      "arioEmergencyStopConfigH\000\022Y\n\033narrow_stre"
      "et_u_turn_config\030\007 \001(\01322.jmc_auto.planni"
      "ng.ScenarioNarrowStreetUTurnConfigH\000\022\\\n\034"
      "stop_sign_unprotected_config\030\010 \001(\01324.jmc"
      "_auto.planning.ScenarioStopSignUnprotect"
      "edConfigH\000\022`\n\036traffic_light_protected_co"
      "nfig\030\t \001(\01326.jmc_auto.planning.ScenarioT"
      "rafficLightProtectedConfigH\000\022x\n+traffic_"
      "light_unprotected_right_turn_config\030\n \001("
      "\0132A.jmc_auto.planning.ScenarioTrafficLig"
      "htUnprotectedRightTurnConfigH\000\022v\n*traffi"
      "c_light_unprotected_left_turn_config\030\013 \001"
      "(\0132@.jmc_auto.planning.ScenarioTrafficLi"
      "ghtUnprotectedLeftTurnConfigH\000\022H\n\022park_a"
      "nd_go_config\030\014 \001(\0132*.jmc_auto.planning.S"
      "cenarioParkAndGoConfigH\000\022E\n\020pull_over_co"
      "nfig\030\r \001(\0132).jmc_auto.planning.ScenarioP"
      "ullOverConfigH\000\022M\n\024valet_parking_config\030"
      "\016 \001(\0132-.jmc_auto.planning.ScenarioValetP"
      "arkingConfigH\000\022G\n\021yield_sign_config\030\017 \001("
      "\0132*.jmc_auto.planning.ScenarioYieldSignC"
      "onfigH\000\022X\n\032test_learning_model_config\030\022 "
      "\001(\01322.jmc_auto.planning.ScenarioTestLear"
      "ningModelConfigH\000\022\?\n\nstage_type\030\020 \003(\0162+."
      "jmc_auto.planning.ScenarioConfig.StageTy"
      "pe\022C\n\014stage_config\030\021 \003(\0132-.jmc_auto.plan"
      "ning.ScenarioConfig.StageConfig\032\324\001\n\013Stag"
      "eConfig\022\?\n\nstage_type\030\001 \001(\0162+.jmc_auto.p"
      "lanning.ScenarioConfig.StageType\022\025\n\007enab"
      "led\030\002 \001(\010:\004true\0229\n\ttask_type\030\003 \003(\0162&.jmc"
      "_auto.planning.TaskConfig.TaskType\0222\n\013ta"
      "sk_config\030\004 \003(\0132\035.jmc_auto.planning.Task"
      "Config\"\211\003\n\014ScenarioType\022\017\n\013LANE_FOLLOW\020\000"
      "\022!\n\035BARE_INTERSECTION_UNPROTECTED\020\002\022\027\n\023S"
      "TOP_SIGN_PROTECTED\020\003\022\031\n\025STOP_SIGN_UNPROT"
      "ECTED\020\004\022\033\n\027TRAFFIC_LIGHT_PROTECTED\020\005\022\'\n#"
      "TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN\020\006\022(\n"
      "$TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN\020\007\022"
      "\016\n\nYIELD_SIGN\020\010\022\r\n\tPULL_OVER\020\t\022\021\n\rVALET_"
      "PARKING\020\n\022\027\n\023EMERGENCY_PULL_OVER\020\013\022\022\n\016EM"
      "ERGENCY_STOP\020\014\022\030\n\024NARROW_STREET_U_TURN\020\r"
      "\022\017\n\013PARK_AND_GO\020\016\022\027\n\023TEST_LEARNING_MODEL"
      "\020\017\"\262\t\n\tStageType\022\014\n\010NO_STAGE\020\000\022\035\n\031LANE_F"
      "OLLOW_DEFAULT_STAGE\020\001\022+\n&BARE_INTERSECTI"
      "ON_UNPROTECTED_APPROACH\020\310\001\0226\n1BARE_INTER"
      "SECTION_UNPROTECTED_INTERSECTION_CRUISE\020"
      "\311\001\022#\n\036STOP_SIGN_UNPROTECTED_PRE_STOP\020\254\002\022"
      "\037\n\032STOP_SIGN_UNPROTECTED_STOP\020\255\002\022 \n\033STOP"
      "_SIGN_UNPROTECTED_CREEP\020\256\002\022.\n)STOP_SIGN_"
      "UNPROTECTED_INTERSECTION_CRUISE\020\257\002\022%\n TR"
      "AFFIC_LIGHT_PROTECTED_APPROACH\020\220\003\0220\n+TRA"
      "FFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE"
      "\020\221\003\0221\n,TRAFFIC_LIGHT_UNPROTECTED_LEFT_TU"
      "RN_APPROACH\020\232\003\022.\n)TRAFFIC_LIGHT_UNPROTEC"
      "TED_LEFT_TURN_CREEP\020\233\003\022<\n7TRAFFIC_LIGHT_"
      "UNPROTECTED_LEFT_TURN_INTERSECTION_CRUIS"
      "E\020\234\003\022.\n)TRAFFIC_LIGHT_UNPROTECTED_RIGHT_"
      "TURN_STOP\020\244\003\022/\n*TRAFFIC_LIGHT_UNPROTECTE"
      "D_RIGHT_TURN_CREEP\020\245\003\022=\n8TRAFFIC_LIGHT_U"
      "NPROTECTED_RIGHT_TURN_INTERSECTION_CRUIS"
      "E\020\246\003\022\027\n\022PULL_OVER_APPROACH\020\364\003\022%\n PULL_OV"
      "ER_RETRY_APPROACH_PARKING\020\365\003\022\034\n\027PULL_OVE"
      "R_RETRY_PARKING\020\366\003\022\"\n\035EMERGENCY_PULL_OVE"
      "R_SLOW_DOWN\020\330\004\022!\n\034EMERGENCY_PULL_OVER_AP"
      "PROACH\020\331\004\022 \n\033EMERGENCY_PULL_OVER_STANDBY"
      "\020\332\004\022\034\n\027EMERGENCY_STOP_APPROACH\020\342\004\022\033\n\026EME"
      "RGENCY_STOP_STANDBY\020\343\004\022+\n&VALET_PARKING_"
      "APPROACHING_PARKING_SPOT\020\274\005\022\032\n\025VALET_PAR"
      "KING_PARKING\020\275\005\022\026\n\021PARK_AND_GO_CHECK\020\240\006\022"
      "\027\n\022PARK_AND_GO_CRUISE\020\241\006\022\027\n\022PARK_AND_GO_"
      "ADJUST\020\242\006\022\033\n\026PARK_AND_GO_PRE_CRUISE\020\243\006\022\030"
      "\n\023YIELD_SIGN_APPROACH\020\204\007\022\025\n\020YIELD_SIGN_C"
      "REEP\020\205\007B\021\n\017scenario_config\"\031\n\027PlannerPub"
      "licRoadConfig\"\267\002\n\021PlannerNaviConfig\0224\n\004t"
      "ask\030\001 \003(\0162&.jmc_auto.planning.TaskConfig"
      ".TaskType\022J\n\030navi_path_decider_config\030\002 "
      "\001(\0132(.jmc_auto.planning.NaviPathDeciderC"
      "onfig\022L\n\031navi_speed_decider_config\030\003 \001(\013"
      "2).jmc_auto.planning.NaviSpeedDeciderCon"
      "fig\022R\n\034navi_obstacle_decider_config\030\004 \001("
      "\0132,.jmc_auto.planning.NaviObstacleDecide"
      "rConfig\"I\n\021RtkPlanningConfig\0224\n\014planner_"
      "type\030\001 \001(\0162\036.jmc_auto.planning.PlannerTy"
      "pe\"\236\001\n\026StandardPlanningConfig\0224\n\014planner"
      "_type\030\001 \003(\0162\036.jmc_auto.planning.PlannerT"
      "ype\022N\n\032planner_public_road_config\030\002 \001(\0132"
      "*.jmc_auto.planning.PlannerPublicRoadCon"
      "fig\"\223\001\n\030NavigationPlanningConfig\0224\n\014plan"
      "ner_type\030\001 \003(\0162\036.jmc_auto.planning.Plann"
      "erType\022A\n\023planner_navi_config\030\004 \001(\0132$.jm"
      "c_auto.planning.PlannerNaviConfig\"\306\002\n\016Pl"
      "anningConfig\022C\n\023rtk_planning_config\030\001 \001("
      "\0132$.jmc_auto.planning.RtkPlanningConfigH"
      "\000\022M\n\030standard_planning_config\030\002 \001(\0132).jm"
      "c_auto.planning.StandardPlanningConfigH\000"
      "\022Q\n\032navigation_planning_config\030\003 \001(\0132+.j"
      "mc_auto.planning.NavigationPlanningConfi"
      "gH\000\022:\n\023default_task_config\030\005 \003(\0132\035.jmc_a"
      "uto.planning.TaskConfigB\021\n\017planning_conf"
      "ig*>\n\013PlannerType\022\007\n\003RTK\020\000\022\017\n\013PUBLIC_ROA"
      "D\020\001\022\010\n\004NAVI\020\002\022\013\n\007LATTICE\020\003"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 10946);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "modules/planning/proto/planning_config.proto", &protobuf_RegisterTypes);
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fcreep_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fdp_5fst_5fspeed_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2flane_5fchange_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5ffallback_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5fpre_5fstop_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5froi_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5ftrajectory_5fprovider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fopen_5fspace_5ftrajectory_5fpartition_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5fassessment_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5fbounds_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5flane_5fborrow_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpiecewise_5fjerk_5fpath_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpiecewise_5fjerk_5fspeed_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpiecewise_5fjerk_5fnonlinear_5fspeed_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2frule_5fbased_5fstop_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fspeed_5fbounds_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fnavi_5fpath_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fnavi_5fspeed_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fnavi_5fobstacle_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fpath_5freuse_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::jmc_auto::planning::protobuf_modules_2fplanning_2fproto_2fst_5fbounds_5fdecider_5fconfig_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto

const ::google::protobuf::EnumDescriptor* TaskConfig_TaskType_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_enum_descriptors[0];
}
bool TaskConfig_TaskType_IsValid(int value) {
  switch (value) {
    case 1:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TaskConfig_TaskType TaskConfig::DP_ST_SPEED_OPTIMIZER;
const TaskConfig_TaskType TaskConfig::PATH_DECIDER;
const TaskConfig_TaskType TaskConfig::SPEED_DECIDER;
const TaskConfig_TaskType TaskConfig::NAVI_PATH_DECIDER;
const TaskConfig_TaskType TaskConfig::NAVI_SPEED_DECIDER;
const TaskConfig_TaskType TaskConfig::NAVI_OBSTACLE_DECIDER;
const TaskConfig_TaskType TaskConfig::CREEP_DECIDER;
const TaskConfig_TaskType TaskConfig::OPEN_SPACE_PRE_STOP_DECIDER;
const TaskConfig_TaskType TaskConfig::DECIDER_RSS;
const TaskConfig_TaskType TaskConfig::SPEED_BOUNDS_PRIORI_DECIDER;
const TaskConfig_TaskType TaskConfig::SPEED_BOUNDS_FINAL_DECIDER;
const TaskConfig_TaskType TaskConfig::PIECEWISE_JERK_PATH_OPTIMIZER;
const TaskConfig_TaskType TaskConfig::PATH_BOUNDS_DECIDER;
const TaskConfig_TaskType TaskConfig::OPEN_SPACE_ROI_DECIDER;
const TaskConfig_TaskType TaskConfig::OPEN_SPACE_TRAJECTORY_PROVIDER;
const TaskConfig_TaskType TaskConfig::OPEN_SPACE_TRAJECTORY_PARTITION;
const TaskConfig_TaskType TaskConfig::OPEN_SPACE_FALLBACK_DECIDER;
const TaskConfig_TaskType TaskConfig::PATH_ASSESSMENT_DECIDER;
const TaskConfig_TaskType TaskConfig::PATH_LANE_BORROW_DECIDER;
const TaskConfig_TaskType TaskConfig::PIECEWISE_JERK_SPEED_OPTIMIZER;
const TaskConfig_TaskType TaskConfig::LANE_CHANGE_DECIDER;
const TaskConfig_TaskType TaskConfig::RULE_BASED_STOP_DECIDER;
const TaskConfig_TaskType TaskConfig::PATH_REUSE_DECIDER;
const TaskConfig_TaskType TaskConfig::ST_BOUNDS_DECIDER;
const TaskConfig_TaskType TaskConfig::PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER;
const TaskConfig_TaskType TaskConfig::TaskType_MIN;
const TaskConfig_TaskType TaskConfig::TaskType_MAX;
const int TaskConfig::TaskType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ScenarioConfig_ScenarioType_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_enum_descriptors[1];
}
bool ScenarioConfig_ScenarioType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ScenarioConfig_ScenarioType ScenarioConfig::LANE_FOLLOW;
const ScenarioConfig_ScenarioType ScenarioConfig::BARE_INTERSECTION_UNPROTECTED;
const ScenarioConfig_ScenarioType ScenarioConfig::STOP_SIGN_PROTECTED;
const ScenarioConfig_ScenarioType ScenarioConfig::STOP_SIGN_UNPROTECTED;
const ScenarioConfig_ScenarioType ScenarioConfig::TRAFFIC_LIGHT_PROTECTED;
const ScenarioConfig_ScenarioType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN;
const ScenarioConfig_ScenarioType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN;
const ScenarioConfig_ScenarioType ScenarioConfig::YIELD_SIGN;
const ScenarioConfig_ScenarioType ScenarioConfig::PULL_OVER;
const ScenarioConfig_ScenarioType ScenarioConfig::VALET_PARKING;
const ScenarioConfig_ScenarioType ScenarioConfig::EMERGENCY_PULL_OVER;
const ScenarioConfig_ScenarioType ScenarioConfig::EMERGENCY_STOP;
const ScenarioConfig_ScenarioType ScenarioConfig::NARROW_STREET_U_TURN;
const ScenarioConfig_ScenarioType ScenarioConfig::PARK_AND_GO;
const ScenarioConfig_ScenarioType ScenarioConfig::TEST_LEARNING_MODEL;
const ScenarioConfig_ScenarioType ScenarioConfig::ScenarioType_MIN;
const ScenarioConfig_ScenarioType ScenarioConfig::ScenarioType_MAX;
const int ScenarioConfig::ScenarioType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ScenarioConfig_StageType_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_enum_descriptors[2];
}
bool ScenarioConfig_StageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 200:
    case 201:
    case 300:
    case 301:
    case 302:
    case 303:
    case 400:
    case 401:
    case 410:
    case 411:
    case 412:
    case 420:
    case 421:
    case 422:
    case 500:
    case 501:
    case 502:
    case 600:
    case 601:
    case 602:
    case 610:
    case 611:
    case 700:
    case 701:
    case 800:
    case 801:
    case 802:
    case 803:
    case 900:
    case 901:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ScenarioConfig_StageType ScenarioConfig::NO_STAGE;
const ScenarioConfig_StageType ScenarioConfig::LANE_FOLLOW_DEFAULT_STAGE;
const ScenarioConfig_StageType ScenarioConfig::BARE_INTERSECTION_UNPROTECTED_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::STOP_SIGN_UNPROTECTED_PRE_STOP;
const ScenarioConfig_StageType ScenarioConfig::STOP_SIGN_UNPROTECTED_STOP;
const ScenarioConfig_StageType ScenarioConfig::STOP_SIGN_UNPROTECTED_CREEP;
const ScenarioConfig_StageType ScenarioConfig::STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_PROTECTED_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP;
const ScenarioConfig_StageType ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::PULL_OVER_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::PULL_OVER_RETRY_APPROACH_PARKING;
const ScenarioConfig_StageType ScenarioConfig::PULL_OVER_RETRY_PARKING;
const ScenarioConfig_StageType ScenarioConfig::EMERGENCY_PULL_OVER_SLOW_DOWN;
const ScenarioConfig_StageType ScenarioConfig::EMERGENCY_PULL_OVER_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::EMERGENCY_PULL_OVER_STANDBY;
const ScenarioConfig_StageType ScenarioConfig::EMERGENCY_STOP_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::EMERGENCY_STOP_STANDBY;
const ScenarioConfig_StageType ScenarioConfig::VALET_PARKING_APPROACHING_PARKING_SPOT;
const ScenarioConfig_StageType ScenarioConfig::VALET_PARKING_PARKING;
const ScenarioConfig_StageType ScenarioConfig::PARK_AND_GO_CHECK;
const ScenarioConfig_StageType ScenarioConfig::PARK_AND_GO_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::PARK_AND_GO_ADJUST;
const ScenarioConfig_StageType ScenarioConfig::PARK_AND_GO_PRE_CRUISE;
const ScenarioConfig_StageType ScenarioConfig::YIELD_SIGN_APPROACH;
const ScenarioConfig_StageType ScenarioConfig::YIELD_SIGN_CREEP;
const ScenarioConfig_StageType ScenarioConfig::StageType_MIN;
const ScenarioConfig_StageType ScenarioConfig::StageType_MAX;
const int ScenarioConfig::StageType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* PlannerType_descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_enum_descriptors[3];
}
bool PlannerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TaskConfig::kTaskTypeFieldNumber;
const int TaskConfig::kSpeedHeuristicConfigFieldNumber;
const int TaskConfig::kPathDeciderConfigFieldNumber;
const int TaskConfig::kCreepDeciderConfigFieldNumber;
const int TaskConfig::kOpenSpacePreStopDeciderConfigFieldNumber;
const int TaskConfig::kSpeedBoundsDeciderConfigFieldNumber;
const int TaskConfig::kPiecewiseJerkPathConfigFieldNumber;
const int TaskConfig::kPathBoundsDeciderConfigFieldNumber;
const int TaskConfig::kOpenSpaceFallbackDeciderConfigFieldNumber;
const int TaskConfig::kOpenSpaceRoiDeciderConfigFieldNumber;
const int TaskConfig::kOpenSpaceTrajectoryProviderConfigFieldNumber;
const int TaskConfig::kOpenSpaceTrajectoryPartitionConfigFieldNumber;
const int TaskConfig::kPathAssessmentDeciderConfigFieldNumber;
const int TaskConfig::kPiecewiseJerkSpeedConfigFieldNumber;
const int TaskConfig::kPathLaneBorrowDeciderConfigFieldNumber;
const int TaskConfig::kLaneChangeDeciderConfigFieldNumber;
const int TaskConfig::kRuleBasedStopDeciderConfigFieldNumber;
const int TaskConfig::kPathReuseDeciderConfigFieldNumber;
const int TaskConfig::kStBoundsDeciderConfigFieldNumber;
const int TaskConfig::kPiecewiseJerkNonlinearSpeedConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TaskConfig::TaskConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.TaskConfig)
}
TaskConfig::TaskConfig(const TaskConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  task_type_ = from.task_type_;
  clear_has_task_config();
  switch (from.task_config_case()) {
    case kSpeedHeuristicConfig: {
      mutable_speed_heuristic_config()->::jmc_auto::planning::SpeedHeuristicConfig::MergeFrom(from.speed_heuristic_config());
      break;
    }
    case kPathDeciderConfig: {
      mutable_path_decider_config()->::jmc_auto::planning::PathDeciderConfig::MergeFrom(from.path_decider_config());
      break;
    }
    case kCreepDeciderConfig: {
      mutable_creep_decider_config()->::jmc_auto::planning::CreepDeciderConfig::MergeFrom(from.creep_decider_config());
      break;
    }
    case kOpenSpacePreStopDeciderConfig: {
      mutable_open_space_pre_stop_decider_config()->::jmc_auto::planning::OpenSpacePreStopDeciderConfig::MergeFrom(from.open_space_pre_stop_decider_config());
      break;
    }
    case kSpeedBoundsDeciderConfig: {
      mutable_speed_bounds_decider_config()->::jmc_auto::planning::SpeedBoundsDeciderConfig::MergeFrom(from.speed_bounds_decider_config());
      break;
    }
    case kPiecewiseJerkPathConfig: {
      mutable_piecewise_jerk_path_config()->::jmc_auto::planning::PiecewiseJerkPathConfig::MergeFrom(from.piecewise_jerk_path_config());
      break;
    }
    case kPathBoundsDeciderConfig: {
      mutable_path_bounds_decider_config()->::jmc_auto::planning::PathBoundsDeciderConfig::MergeFrom(from.path_bounds_decider_config());
      break;
    }
    case kOpenSpaceFallbackDeciderConfig: {
      mutable_open_space_fallback_decider_config()->::jmc_auto::planning::OpenSpaceFallBackDeciderConfig::MergeFrom(from.open_space_fallback_decider_config());
      break;
    }
    case kOpenSpaceRoiDeciderConfig: {
      mutable_open_space_roi_decider_config()->::jmc_auto::planning::OpenSpaceRoiDeciderConfig::MergeFrom(from.open_space_roi_decider_config());
      break;
    }
    case kOpenSpaceTrajectoryProviderConfig: {
      mutable_open_space_trajectory_provider_config()->::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig::MergeFrom(from.open_space_trajectory_provider_config());
      break;
    }
    case kOpenSpaceTrajectoryPartitionConfig: {
      mutable_open_space_trajectory_partition_config()->::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig::MergeFrom(from.open_space_trajectory_partition_config());
      break;
    }
    case kPathAssessmentDeciderConfig: {
      mutable_path_assessment_decider_config()->::jmc_auto::planning::PathAssessmentDeciderConfig::MergeFrom(from.path_assessment_decider_config());
      break;
    }
    case kPiecewiseJerkSpeedConfig: {
      mutable_piecewise_jerk_speed_config()->::jmc_auto::planning::PiecewiseJerkSpeedConfig::MergeFrom(from.piecewise_jerk_speed_config());
      break;
    }
    case kPathLaneBorrowDeciderConfig: {
      mutable_path_lane_borrow_decider_config()->::jmc_auto::planning::PathLaneBorrowDeciderConfig::MergeFrom(from.path_lane_borrow_decider_config());
      break;
    }
    case kLaneChangeDeciderConfig: {
      mutable_lane_change_decider_config()->::jmc_auto::planning::LaneChangeDeciderConfig::MergeFrom(from.lane_change_decider_config());
      break;
    }
    case kRuleBasedStopDeciderConfig: {
      mutable_rule_based_stop_decider_config()->::jmc_auto::planning::RuleBasedStopDeciderConfig::MergeFrom(from.rule_based_stop_decider_config());
      break;
    }
    case kPathReuseDeciderConfig: {
      mutable_path_reuse_decider_config()->::jmc_auto::planning::PathReuseDeciderConfig::MergeFrom(from.path_reuse_decider_config());
      break;
    }
    case kStBoundsDeciderConfig: {
      mutable_st_bounds_decider_config()->::jmc_auto::planning::STBoundsDeciderConfig::MergeFrom(from.st_bounds_decider_config());
      break;
    }
    case kPiecewiseJerkNonlinearSpeedConfig: {
      mutable_piecewise_jerk_nonlinear_speed_config()->::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig::MergeFrom(from.piecewise_jerk_nonlinear_speed_config());
      break;
    }
    case TASK_CONFIG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.TaskConfig)
}

void TaskConfig::SharedCtor() {
  _cached_size_ = 0;
  task_type_ = 1;
  clear_has_task_config();
}

TaskConfig::~TaskConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.TaskConfig)
  SharedDtor();
}

void TaskConfig::SharedDtor() {
  if (has_task_config()) {
    clear_task_config();
  }
}

void TaskConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TaskConfig& TaskConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

TaskConfig* TaskConfig::New(::google::protobuf::Arena* arena) const {
  TaskConfig* n = new TaskConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TaskConfig::clear_task_config() {
// @@protoc_insertion_point(one_of_clear_start:jmc_auto.planning.TaskConfig)
  switch (task_config_case()) {
    case kSpeedHeuristicConfig: {
      delete task_config_.speed_heuristic_config_;
      break;
    }
    case kPathDeciderConfig: {
      delete task_config_.path_decider_config_;
      break;
    }
    case kCreepDeciderConfig: {
      delete task_config_.creep_decider_config_;
      break;
    }
    case kOpenSpacePreStopDeciderConfig: {
      delete task_config_.open_space_pre_stop_decider_config_;
      break;
    }
    case kSpeedBoundsDeciderConfig: {
      delete task_config_.speed_bounds_decider_config_;
      break;
    }
    case kPiecewiseJerkPathConfig: {
      delete task_config_.piecewise_jerk_path_config_;
      break;
    }
    case kPathBoundsDeciderConfig: {
      delete task_config_.path_bounds_decider_config_;
      break;
    }
    case kOpenSpaceFallbackDeciderConfig: {
      delete task_config_.open_space_fallback_decider_config_;
      break;
    }
    case kOpenSpaceRoiDeciderConfig: {
      delete task_config_.open_space_roi_decider_config_;
      break;
    }
    case kOpenSpaceTrajectoryProviderConfig: {
      delete task_config_.open_space_trajectory_provider_config_;
      break;
    }
    case kOpenSpaceTrajectoryPartitionConfig: {
      delete task_config_.open_space_trajectory_partition_config_;
      break;
    }
    case kPathAssessmentDeciderConfig: {
      delete task_config_.path_assessment_decider_config_;
      break;
    }
    case kPiecewiseJerkSpeedConfig: {
      delete task_config_.piecewise_jerk_speed_config_;
      break;
    }
    case kPathLaneBorrowDeciderConfig: {
      delete task_config_.path_lane_borrow_decider_config_;
      break;
    }
    case kLaneChangeDeciderConfig: {
      delete task_config_.lane_change_decider_config_;
      break;
    }
    case kRuleBasedStopDeciderConfig: {
      delete task_config_.rule_based_stop_decider_config_;
      break;
    }
    case kPathReuseDeciderConfig: {
      delete task_config_.path_reuse_decider_config_;
      break;
    }
    case kStBoundsDeciderConfig: {
      delete task_config_.st_bounds_decider_config_;
      break;
    }
    case kPiecewiseJerkNonlinearSpeedConfig: {
      delete task_config_.piecewise_jerk_nonlinear_speed_config_;
      break;
    }
    case TASK_CONFIG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TASK_CONFIG_NOT_SET;
}


void TaskConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.TaskConfig)
  task_type_ = 1;
  clear_task_config();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TaskConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.TaskConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::TaskConfig_TaskType_IsValid(value)) {
            set_task_type(static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.SpeedHeuristicConfig speed_heuristic_config = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_speed_heuristic_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PathDeciderConfig path_decider_config = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.CreepDeciderConfig creep_decider_config = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_creep_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_open_space_pre_stop_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(122u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_speed_bounds_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(130u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_piecewise_jerk_path_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(138u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path_bounds_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(146u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_open_space_fallback_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(154u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_open_space_roi_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_open_space_trajectory_provider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(170u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_open_space_trajectory_partition_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(178u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path_assessment_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
      case 23: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(186u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_piecewise_jerk_speed_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
      case 24: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(194u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path_lane_borrow_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
      case 25: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(202u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lane_change_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
      case 26: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(210u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rule_based_stop_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PathReuseDeciderConfig path_reuse_decider_config = 27;
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(218u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path_reuse_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.STBoundsDeciderConfig st_bounds_decider_config = 28;
      case 28: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(226u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_st_bounds_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PiecewiseJerkNonlinearSpeedConfig piecewise_jerk_nonlinear_speed_config = 29;
      case 29: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(234u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_piecewise_jerk_nonlinear_speed_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.TaskConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.TaskConfig)
  return false;
#undef DO_
}

void TaskConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.TaskConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->task_type(), output);
  }

  switch (task_config_case()) {
    case kSpeedHeuristicConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, *task_config_.speed_heuristic_config_, output);
      break;
    case kPathDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        7, *task_config_.path_decider_config_, output);
      break;
    case kCreepDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        10, *task_config_.creep_decider_config_, output);
      break;
    case kOpenSpacePreStopDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        11, *task_config_.open_space_pre_stop_decider_config_, output);
      break;
    case kSpeedBoundsDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        15, *task_config_.speed_bounds_decider_config_, output);
      break;
    case kPiecewiseJerkPathConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        16, *task_config_.piecewise_jerk_path_config_, output);
      break;
    case kPathBoundsDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        17, *task_config_.path_bounds_decider_config_, output);
      break;
    case kOpenSpaceFallbackDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        18, *task_config_.open_space_fallback_decider_config_, output);
      break;
    case kOpenSpaceRoiDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        19, *task_config_.open_space_roi_decider_config_, output);
      break;
    case kOpenSpaceTrajectoryProviderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        20, *task_config_.open_space_trajectory_provider_config_, output);
      break;
    case kOpenSpaceTrajectoryPartitionConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        21, *task_config_.open_space_trajectory_partition_config_, output);
      break;
    case kPathAssessmentDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        22, *task_config_.path_assessment_decider_config_, output);
      break;
    case kPiecewiseJerkSpeedConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        23, *task_config_.piecewise_jerk_speed_config_, output);
      break;
    case kPathLaneBorrowDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        24, *task_config_.path_lane_borrow_decider_config_, output);
      break;
    case kLaneChangeDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        25, *task_config_.lane_change_decider_config_, output);
      break;
    case kRuleBasedStopDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        26, *task_config_.rule_based_stop_decider_config_, output);
      break;
    case kPathReuseDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        27, *task_config_.path_reuse_decider_config_, output);
      break;
    case kStBoundsDeciderConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        28, *task_config_.st_bounds_decider_config_, output);
      break;
    case kPiecewiseJerkNonlinearSpeedConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        29, *task_config_.piecewise_jerk_nonlinear_speed_config_, output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.TaskConfig)
}

::google::protobuf::uint8* TaskConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.TaskConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->task_type(), target);
  }

  switch (task_config_case()) {
    case kSpeedHeuristicConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          3, *task_config_.speed_heuristic_config_, deterministic, target);
      break;
    case kPathDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          7, *task_config_.path_decider_config_, deterministic, target);
      break;
    case kCreepDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          10, *task_config_.creep_decider_config_, deterministic, target);
      break;
    case kOpenSpacePreStopDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          11, *task_config_.open_space_pre_stop_decider_config_, deterministic, target);
      break;
    case kSpeedBoundsDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          15, *task_config_.speed_bounds_decider_config_, deterministic, target);
      break;
    case kPiecewiseJerkPathConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          16, *task_config_.piecewise_jerk_path_config_, deterministic, target);
      break;
    case kPathBoundsDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          17, *task_config_.path_bounds_decider_config_, deterministic, target);
      break;
    case kOpenSpaceFallbackDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          18, *task_config_.open_space_fallback_decider_config_, deterministic, target);
      break;
    case kOpenSpaceRoiDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          19, *task_config_.open_space_roi_decider_config_, deterministic, target);
      break;
    case kOpenSpaceTrajectoryProviderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          20, *task_config_.open_space_trajectory_provider_config_, deterministic, target);
      break;
    case kOpenSpaceTrajectoryPartitionConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          21, *task_config_.open_space_trajectory_partition_config_, deterministic, target);
      break;
    case kPathAssessmentDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          22, *task_config_.path_assessment_decider_config_, deterministic, target);
      break;
    case kPiecewiseJerkSpeedConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          23, *task_config_.piecewise_jerk_speed_config_, deterministic, target);
      break;
    case kPathLaneBorrowDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          24, *task_config_.path_lane_borrow_decider_config_, deterministic, target);
      break;
    case kLaneChangeDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          25, *task_config_.lane_change_decider_config_, deterministic, target);
      break;
    case kRuleBasedStopDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          26, *task_config_.rule_based_stop_decider_config_, deterministic, target);
      break;
    case kPathReuseDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          27, *task_config_.path_reuse_decider_config_, deterministic, target);
      break;
    case kStBoundsDeciderConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          28, *task_config_.st_bounds_decider_config_, deterministic, target);
      break;
    case kPiecewiseJerkNonlinearSpeedConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          29, *task_config_.piecewise_jerk_nonlinear_speed_config_, deterministic, target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.TaskConfig)
  return target;
}

size_t TaskConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.TaskConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
  if (has_task_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->task_type());
  }

  switch (task_config_case()) {
    // optional .jmc_auto.planning.SpeedHeuristicConfig speed_heuristic_config = 3;
    case kSpeedHeuristicConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.speed_heuristic_config_);
      break;
    }
    // optional .jmc_auto.planning.PathDeciderConfig path_decider_config = 7;
    case kPathDeciderConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.path_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.CreepDeciderConfig creep_decider_config = 10;
    case kCreepDeciderConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.creep_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
    case kOpenSpacePreStopDeciderConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.open_space_pre_stop_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
    case kSpeedBoundsDeciderConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.speed_bounds_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
    case kPiecewiseJerkPathConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.piecewise_jerk_path_config_);
      break;
    }
    // optional .jmc_auto.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
    case kPathBoundsDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.path_bounds_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
    case kOpenSpaceFallbackDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.open_space_fallback_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
    case kOpenSpaceRoiDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.open_space_roi_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
    case kOpenSpaceTrajectoryProviderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.open_space_trajectory_provider_config_);
      break;
    }
    // optional .jmc_auto.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
    case kOpenSpaceTrajectoryPartitionConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.open_space_trajectory_partition_config_);
      break;
    }
    // optional .jmc_auto.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
    case kPathAssessmentDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.path_assessment_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
    case kPiecewiseJerkSpeedConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.piecewise_jerk_speed_config_);
      break;
    }
    // optional .jmc_auto.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
    case kPathLaneBorrowDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.path_lane_borrow_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
    case kLaneChangeDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.lane_change_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
    case kRuleBasedStopDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.rule_based_stop_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.PathReuseDeciderConfig path_reuse_decider_config = 27;
    case kPathReuseDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.path_reuse_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.STBoundsDeciderConfig st_bounds_decider_config = 28;
    case kStBoundsDeciderConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.st_bounds_decider_config_);
      break;
    }
    // optional .jmc_auto.planning.PiecewiseJerkNonlinearSpeedConfig piecewise_jerk_nonlinear_speed_config = 29;
    case kPiecewiseJerkNonlinearSpeedConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *task_config_.piecewise_jerk_nonlinear_speed_config_);
      break;
    }
    case TASK_CONFIG_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.TaskConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const TaskConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TaskConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.TaskConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.TaskConfig)
    MergeFrom(*source);
  }
}

void TaskConfig::MergeFrom(const TaskConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.TaskConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_task_type()) {
    set_task_type(from.task_type());
  }
  switch (from.task_config_case()) {
    case kSpeedHeuristicConfig: {
      mutable_speed_heuristic_config()->::jmc_auto::planning::SpeedHeuristicConfig::MergeFrom(from.speed_heuristic_config());
      break;
    }
    case kPathDeciderConfig: {
      mutable_path_decider_config()->::jmc_auto::planning::PathDeciderConfig::MergeFrom(from.path_decider_config());
      break;
    }
    case kCreepDeciderConfig: {
      mutable_creep_decider_config()->::jmc_auto::planning::CreepDeciderConfig::MergeFrom(from.creep_decider_config());
      break;
    }
    case kOpenSpacePreStopDeciderConfig: {
      mutable_open_space_pre_stop_decider_config()->::jmc_auto::planning::OpenSpacePreStopDeciderConfig::MergeFrom(from.open_space_pre_stop_decider_config());
      break;
    }
    case kSpeedBoundsDeciderConfig: {
      mutable_speed_bounds_decider_config()->::jmc_auto::planning::SpeedBoundsDeciderConfig::MergeFrom(from.speed_bounds_decider_config());
      break;
    }
    case kPiecewiseJerkPathConfig: {
      mutable_piecewise_jerk_path_config()->::jmc_auto::planning::PiecewiseJerkPathConfig::MergeFrom(from.piecewise_jerk_path_config());
      break;
    }
    case kPathBoundsDeciderConfig: {
      mutable_path_bounds_decider_config()->::jmc_auto::planning::PathBoundsDeciderConfig::MergeFrom(from.path_bounds_decider_config());
      break;
    }
    case kOpenSpaceFallbackDeciderConfig: {
      mutable_open_space_fallback_decider_config()->::jmc_auto::planning::OpenSpaceFallBackDeciderConfig::MergeFrom(from.open_space_fallback_decider_config());
      break;
    }
    case kOpenSpaceRoiDeciderConfig: {
      mutable_open_space_roi_decider_config()->::jmc_auto::planning::OpenSpaceRoiDeciderConfig::MergeFrom(from.open_space_roi_decider_config());
      break;
    }
    case kOpenSpaceTrajectoryProviderConfig: {
      mutable_open_space_trajectory_provider_config()->::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig::MergeFrom(from.open_space_trajectory_provider_config());
      break;
    }
    case kOpenSpaceTrajectoryPartitionConfig: {
      mutable_open_space_trajectory_partition_config()->::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig::MergeFrom(from.open_space_trajectory_partition_config());
      break;
    }
    case kPathAssessmentDeciderConfig: {
      mutable_path_assessment_decider_config()->::jmc_auto::planning::PathAssessmentDeciderConfig::MergeFrom(from.path_assessment_decider_config());
      break;
    }
    case kPiecewiseJerkSpeedConfig: {
      mutable_piecewise_jerk_speed_config()->::jmc_auto::planning::PiecewiseJerkSpeedConfig::MergeFrom(from.piecewise_jerk_speed_config());
      break;
    }
    case kPathLaneBorrowDeciderConfig: {
      mutable_path_lane_borrow_decider_config()->::jmc_auto::planning::PathLaneBorrowDeciderConfig::MergeFrom(from.path_lane_borrow_decider_config());
      break;
    }
    case kLaneChangeDeciderConfig: {
      mutable_lane_change_decider_config()->::jmc_auto::planning::LaneChangeDeciderConfig::MergeFrom(from.lane_change_decider_config());
      break;
    }
    case kRuleBasedStopDeciderConfig: {
      mutable_rule_based_stop_decider_config()->::jmc_auto::planning::RuleBasedStopDeciderConfig::MergeFrom(from.rule_based_stop_decider_config());
      break;
    }
    case kPathReuseDeciderConfig: {
      mutable_path_reuse_decider_config()->::jmc_auto::planning::PathReuseDeciderConfig::MergeFrom(from.path_reuse_decider_config());
      break;
    }
    case kStBoundsDeciderConfig: {
      mutable_st_bounds_decider_config()->::jmc_auto::planning::STBoundsDeciderConfig::MergeFrom(from.st_bounds_decider_config());
      break;
    }
    case kPiecewiseJerkNonlinearSpeedConfig: {
      mutable_piecewise_jerk_nonlinear_speed_config()->::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig::MergeFrom(from.piecewise_jerk_nonlinear_speed_config());
      break;
    }
    case TASK_CONFIG_NOT_SET: {
      break;
    }
  }
}

void TaskConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.TaskConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskConfig::CopyFrom(const TaskConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.TaskConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskConfig::IsInitialized() const {
  return true;
}

void TaskConfig::Swap(TaskConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TaskConfig::InternalSwap(TaskConfig* other) {
  std::swap(task_type_, other->task_type_);
  std::swap(task_config_, other->task_config_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TaskConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TaskConfig

// optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
bool TaskConfig::has_task_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TaskConfig::set_has_task_type() {
  _has_bits_[0] |= 0x00000001u;
}
void TaskConfig::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void TaskConfig::clear_task_type() {
  task_type_ = 1;
  clear_has_task_type();
}
::jmc_auto::planning::TaskConfig_TaskType TaskConfig::task_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.task_type)
  return static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(task_type_);
}
void TaskConfig::set_task_type(::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  set_has_task_type();
  task_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TaskConfig.task_type)
}

// optional .jmc_auto.planning.SpeedHeuristicConfig speed_heuristic_config = 3;
bool TaskConfig::has_speed_heuristic_config() const {
  return task_config_case() == kSpeedHeuristicConfig;
}
void TaskConfig::set_has_speed_heuristic_config() {
  _oneof_case_[0] = kSpeedHeuristicConfig;
}
void TaskConfig::clear_speed_heuristic_config() {
  if (has_speed_heuristic_config()) {
    delete task_config_.speed_heuristic_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::SpeedHeuristicConfig& TaskConfig::speed_heuristic_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.speed_heuristic_config)
  return has_speed_heuristic_config()
      ? *task_config_.speed_heuristic_config_
      : ::jmc_auto::planning::SpeedHeuristicConfig::default_instance();
}
::jmc_auto::planning::SpeedHeuristicConfig* TaskConfig::mutable_speed_heuristic_config() {
  if (!has_speed_heuristic_config()) {
    clear_task_config();
    set_has_speed_heuristic_config();
    task_config_.speed_heuristic_config_ = new ::jmc_auto::planning::SpeedHeuristicConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.speed_heuristic_config)
  return task_config_.speed_heuristic_config_;
}
::jmc_auto::planning::SpeedHeuristicConfig* TaskConfig::release_speed_heuristic_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.speed_heuristic_config)
  if (has_speed_heuristic_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::SpeedHeuristicConfig* temp = task_config_.speed_heuristic_config_;
    task_config_.speed_heuristic_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_speed_heuristic_config(::jmc_auto::planning::SpeedHeuristicConfig* speed_heuristic_config) {
  clear_task_config();
  if (speed_heuristic_config) {
    set_has_speed_heuristic_config();
    task_config_.speed_heuristic_config_ = speed_heuristic_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.speed_heuristic_config)
}

// optional .jmc_auto.planning.PathDeciderConfig path_decider_config = 7;
bool TaskConfig::has_path_decider_config() const {
  return task_config_case() == kPathDeciderConfig;
}
void TaskConfig::set_has_path_decider_config() {
  _oneof_case_[0] = kPathDeciderConfig;
}
void TaskConfig::clear_path_decider_config() {
  if (has_path_decider_config()) {
    delete task_config_.path_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PathDeciderConfig& TaskConfig::path_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_decider_config)
  return has_path_decider_config()
      ? *task_config_.path_decider_config_
      : ::jmc_auto::planning::PathDeciderConfig::default_instance();
}
::jmc_auto::planning::PathDeciderConfig* TaskConfig::mutable_path_decider_config() {
  if (!has_path_decider_config()) {
    clear_task_config();
    set_has_path_decider_config();
    task_config_.path_decider_config_ = new ::jmc_auto::planning::PathDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_decider_config)
  return task_config_.path_decider_config_;
}
::jmc_auto::planning::PathDeciderConfig* TaskConfig::release_path_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_decider_config)
  if (has_path_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathDeciderConfig* temp = task_config_.path_decider_config_;
    task_config_.path_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_path_decider_config(::jmc_auto::planning::PathDeciderConfig* path_decider_config) {
  clear_task_config();
  if (path_decider_config) {
    set_has_path_decider_config();
    task_config_.path_decider_config_ = path_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_decider_config)
}

// optional .jmc_auto.planning.CreepDeciderConfig creep_decider_config = 10;
bool TaskConfig::has_creep_decider_config() const {
  return task_config_case() == kCreepDeciderConfig;
}
void TaskConfig::set_has_creep_decider_config() {
  _oneof_case_[0] = kCreepDeciderConfig;
}
void TaskConfig::clear_creep_decider_config() {
  if (has_creep_decider_config()) {
    delete task_config_.creep_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::CreepDeciderConfig& TaskConfig::creep_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.creep_decider_config)
  return has_creep_decider_config()
      ? *task_config_.creep_decider_config_
      : ::jmc_auto::planning::CreepDeciderConfig::default_instance();
}
::jmc_auto::planning::CreepDeciderConfig* TaskConfig::mutable_creep_decider_config() {
  if (!has_creep_decider_config()) {
    clear_task_config();
    set_has_creep_decider_config();
    task_config_.creep_decider_config_ = new ::jmc_auto::planning::CreepDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.creep_decider_config)
  return task_config_.creep_decider_config_;
}
::jmc_auto::planning::CreepDeciderConfig* TaskConfig::release_creep_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.creep_decider_config)
  if (has_creep_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::CreepDeciderConfig* temp = task_config_.creep_decider_config_;
    task_config_.creep_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_creep_decider_config(::jmc_auto::planning::CreepDeciderConfig* creep_decider_config) {
  clear_task_config();
  if (creep_decider_config) {
    set_has_creep_decider_config();
    task_config_.creep_decider_config_ = creep_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.creep_decider_config)
}

// optional .jmc_auto.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
bool TaskConfig::has_open_space_pre_stop_decider_config() const {
  return task_config_case() == kOpenSpacePreStopDeciderConfig;
}
void TaskConfig::set_has_open_space_pre_stop_decider_config() {
  _oneof_case_[0] = kOpenSpacePreStopDeciderConfig;
}
void TaskConfig::clear_open_space_pre_stop_decider_config() {
  if (has_open_space_pre_stop_decider_config()) {
    delete task_config_.open_space_pre_stop_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::OpenSpacePreStopDeciderConfig& TaskConfig::open_space_pre_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
  return has_open_space_pre_stop_decider_config()
      ? *task_config_.open_space_pre_stop_decider_config_
      : ::jmc_auto::planning::OpenSpacePreStopDeciderConfig::default_instance();
}
::jmc_auto::planning::OpenSpacePreStopDeciderConfig* TaskConfig::mutable_open_space_pre_stop_decider_config() {
  if (!has_open_space_pre_stop_decider_config()) {
    clear_task_config();
    set_has_open_space_pre_stop_decider_config();
    task_config_.open_space_pre_stop_decider_config_ = new ::jmc_auto::planning::OpenSpacePreStopDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
  return task_config_.open_space_pre_stop_decider_config_;
}
::jmc_auto::planning::OpenSpacePreStopDeciderConfig* TaskConfig::release_open_space_pre_stop_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
  if (has_open_space_pre_stop_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* temp = task_config_.open_space_pre_stop_decider_config_;
    task_config_.open_space_pre_stop_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_open_space_pre_stop_decider_config(::jmc_auto::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config) {
  clear_task_config();
  if (open_space_pre_stop_decider_config) {
    set_has_open_space_pre_stop_decider_config();
    task_config_.open_space_pre_stop_decider_config_ = open_space_pre_stop_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
}

// optional .jmc_auto.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
bool TaskConfig::has_speed_bounds_decider_config() const {
  return task_config_case() == kSpeedBoundsDeciderConfig;
}
void TaskConfig::set_has_speed_bounds_decider_config() {
  _oneof_case_[0] = kSpeedBoundsDeciderConfig;
}
void TaskConfig::clear_speed_bounds_decider_config() {
  if (has_speed_bounds_decider_config()) {
    delete task_config_.speed_bounds_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::SpeedBoundsDeciderConfig& TaskConfig::speed_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
  return has_speed_bounds_decider_config()
      ? *task_config_.speed_bounds_decider_config_
      : ::jmc_auto::planning::SpeedBoundsDeciderConfig::default_instance();
}
::jmc_auto::planning::SpeedBoundsDeciderConfig* TaskConfig::mutable_speed_bounds_decider_config() {
  if (!has_speed_bounds_decider_config()) {
    clear_task_config();
    set_has_speed_bounds_decider_config();
    task_config_.speed_bounds_decider_config_ = new ::jmc_auto::planning::SpeedBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
  return task_config_.speed_bounds_decider_config_;
}
::jmc_auto::planning::SpeedBoundsDeciderConfig* TaskConfig::release_speed_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
  if (has_speed_bounds_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::SpeedBoundsDeciderConfig* temp = task_config_.speed_bounds_decider_config_;
    task_config_.speed_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_speed_bounds_decider_config(::jmc_auto::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config) {
  clear_task_config();
  if (speed_bounds_decider_config) {
    set_has_speed_bounds_decider_config();
    task_config_.speed_bounds_decider_config_ = speed_bounds_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
}

// optional .jmc_auto.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
bool TaskConfig::has_piecewise_jerk_path_config() const {
  return task_config_case() == kPiecewiseJerkPathConfig;
}
void TaskConfig::set_has_piecewise_jerk_path_config() {
  _oneof_case_[0] = kPiecewiseJerkPathConfig;
}
void TaskConfig::clear_piecewise_jerk_path_config() {
  if (has_piecewise_jerk_path_config()) {
    delete task_config_.piecewise_jerk_path_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PiecewiseJerkPathConfig& TaskConfig::piecewise_jerk_path_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
  return has_piecewise_jerk_path_config()
      ? *task_config_.piecewise_jerk_path_config_
      : ::jmc_auto::planning::PiecewiseJerkPathConfig::default_instance();
}
::jmc_auto::planning::PiecewiseJerkPathConfig* TaskConfig::mutable_piecewise_jerk_path_config() {
  if (!has_piecewise_jerk_path_config()) {
    clear_task_config();
    set_has_piecewise_jerk_path_config();
    task_config_.piecewise_jerk_path_config_ = new ::jmc_auto::planning::PiecewiseJerkPathConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
  return task_config_.piecewise_jerk_path_config_;
}
::jmc_auto::planning::PiecewiseJerkPathConfig* TaskConfig::release_piecewise_jerk_path_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
  if (has_piecewise_jerk_path_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PiecewiseJerkPathConfig* temp = task_config_.piecewise_jerk_path_config_;
    task_config_.piecewise_jerk_path_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_piecewise_jerk_path_config(::jmc_auto::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config) {
  clear_task_config();
  if (piecewise_jerk_path_config) {
    set_has_piecewise_jerk_path_config();
    task_config_.piecewise_jerk_path_config_ = piecewise_jerk_path_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
}

// optional .jmc_auto.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
bool TaskConfig::has_path_bounds_decider_config() const {
  return task_config_case() == kPathBoundsDeciderConfig;
}
void TaskConfig::set_has_path_bounds_decider_config() {
  _oneof_case_[0] = kPathBoundsDeciderConfig;
}
void TaskConfig::clear_path_bounds_decider_config() {
  if (has_path_bounds_decider_config()) {
    delete task_config_.path_bounds_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PathBoundsDeciderConfig& TaskConfig::path_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
  return has_path_bounds_decider_config()
      ? *task_config_.path_bounds_decider_config_
      : ::jmc_auto::planning::PathBoundsDeciderConfig::default_instance();
}
::jmc_auto::planning::PathBoundsDeciderConfig* TaskConfig::mutable_path_bounds_decider_config() {
  if (!has_path_bounds_decider_config()) {
    clear_task_config();
    set_has_path_bounds_decider_config();
    task_config_.path_bounds_decider_config_ = new ::jmc_auto::planning::PathBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
  return task_config_.path_bounds_decider_config_;
}
::jmc_auto::planning::PathBoundsDeciderConfig* TaskConfig::release_path_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
  if (has_path_bounds_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathBoundsDeciderConfig* temp = task_config_.path_bounds_decider_config_;
    task_config_.path_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_path_bounds_decider_config(::jmc_auto::planning::PathBoundsDeciderConfig* path_bounds_decider_config) {
  clear_task_config();
  if (path_bounds_decider_config) {
    set_has_path_bounds_decider_config();
    task_config_.path_bounds_decider_config_ = path_bounds_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
}

// optional .jmc_auto.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
bool TaskConfig::has_open_space_fallback_decider_config() const {
  return task_config_case() == kOpenSpaceFallbackDeciderConfig;
}
void TaskConfig::set_has_open_space_fallback_decider_config() {
  _oneof_case_[0] = kOpenSpaceFallbackDeciderConfig;
}
void TaskConfig::clear_open_space_fallback_decider_config() {
  if (has_open_space_fallback_decider_config()) {
    delete task_config_.open_space_fallback_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig& TaskConfig::open_space_fallback_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
  return has_open_space_fallback_decider_config()
      ? *task_config_.open_space_fallback_decider_config_
      : ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig::default_instance();
}
::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::mutable_open_space_fallback_decider_config() {
  if (!has_open_space_fallback_decider_config()) {
    clear_task_config();
    set_has_open_space_fallback_decider_config();
    task_config_.open_space_fallback_decider_config_ = new ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
  return task_config_.open_space_fallback_decider_config_;
}
::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::release_open_space_fallback_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
  if (has_open_space_fallback_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* temp = task_config_.open_space_fallback_decider_config_;
    task_config_.open_space_fallback_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_open_space_fallback_decider_config(::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config) {
  clear_task_config();
  if (open_space_fallback_decider_config) {
    set_has_open_space_fallback_decider_config();
    task_config_.open_space_fallback_decider_config_ = open_space_fallback_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
}

// optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
bool TaskConfig::has_open_space_roi_decider_config() const {
  return task_config_case() == kOpenSpaceRoiDeciderConfig;
}
void TaskConfig::set_has_open_space_roi_decider_config() {
  _oneof_case_[0] = kOpenSpaceRoiDeciderConfig;
}
void TaskConfig::clear_open_space_roi_decider_config() {
  if (has_open_space_roi_decider_config()) {
    delete task_config_.open_space_roi_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::OpenSpaceRoiDeciderConfig& TaskConfig::open_space_roi_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
  return has_open_space_roi_decider_config()
      ? *task_config_.open_space_roi_decider_config_
      : ::jmc_auto::planning::OpenSpaceRoiDeciderConfig::default_instance();
}
::jmc_auto::planning::OpenSpaceRoiDeciderConfig* TaskConfig::mutable_open_space_roi_decider_config() {
  if (!has_open_space_roi_decider_config()) {
    clear_task_config();
    set_has_open_space_roi_decider_config();
    task_config_.open_space_roi_decider_config_ = new ::jmc_auto::planning::OpenSpaceRoiDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
  return task_config_.open_space_roi_decider_config_;
}
::jmc_auto::planning::OpenSpaceRoiDeciderConfig* TaskConfig::release_open_space_roi_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
  if (has_open_space_roi_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* temp = task_config_.open_space_roi_decider_config_;
    task_config_.open_space_roi_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_open_space_roi_decider_config(::jmc_auto::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config) {
  clear_task_config();
  if (open_space_roi_decider_config) {
    set_has_open_space_roi_decider_config();
    task_config_.open_space_roi_decider_config_ = open_space_roi_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
}

// optional .jmc_auto.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
bool TaskConfig::has_open_space_trajectory_provider_config() const {
  return task_config_case() == kOpenSpaceTrajectoryProviderConfig;
}
void TaskConfig::set_has_open_space_trajectory_provider_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryProviderConfig;
}
void TaskConfig::clear_open_space_trajectory_provider_config() {
  if (has_open_space_trajectory_provider_config()) {
    delete task_config_.open_space_trajectory_provider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig& TaskConfig::open_space_trajectory_provider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
  return has_open_space_trajectory_provider_config()
      ? *task_config_.open_space_trajectory_provider_config_
      : ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig::default_instance();
}
::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::mutable_open_space_trajectory_provider_config() {
  if (!has_open_space_trajectory_provider_config()) {
    clear_task_config();
    set_has_open_space_trajectory_provider_config();
    task_config_.open_space_trajectory_provider_config_ = new ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
  return task_config_.open_space_trajectory_provider_config_;
}
::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::release_open_space_trajectory_provider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
  if (has_open_space_trajectory_provider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* temp = task_config_.open_space_trajectory_provider_config_;
    task_config_.open_space_trajectory_provider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_open_space_trajectory_provider_config(::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config) {
  clear_task_config();
  if (open_space_trajectory_provider_config) {
    set_has_open_space_trajectory_provider_config();
    task_config_.open_space_trajectory_provider_config_ = open_space_trajectory_provider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
}

// optional .jmc_auto.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
bool TaskConfig::has_open_space_trajectory_partition_config() const {
  return task_config_case() == kOpenSpaceTrajectoryPartitionConfig;
}
void TaskConfig::set_has_open_space_trajectory_partition_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryPartitionConfig;
}
void TaskConfig::clear_open_space_trajectory_partition_config() {
  if (has_open_space_trajectory_partition_config()) {
    delete task_config_.open_space_trajectory_partition_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig& TaskConfig::open_space_trajectory_partition_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
  return has_open_space_trajectory_partition_config()
      ? *task_config_.open_space_trajectory_partition_config_
      : ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig::default_instance();
}
::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::mutable_open_space_trajectory_partition_config() {
  if (!has_open_space_trajectory_partition_config()) {
    clear_task_config();
    set_has_open_space_trajectory_partition_config();
    task_config_.open_space_trajectory_partition_config_ = new ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
  return task_config_.open_space_trajectory_partition_config_;
}
::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::release_open_space_trajectory_partition_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
  if (has_open_space_trajectory_partition_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* temp = task_config_.open_space_trajectory_partition_config_;
    task_config_.open_space_trajectory_partition_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_open_space_trajectory_partition_config(::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config) {
  clear_task_config();
  if (open_space_trajectory_partition_config) {
    set_has_open_space_trajectory_partition_config();
    task_config_.open_space_trajectory_partition_config_ = open_space_trajectory_partition_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
}

// optional .jmc_auto.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
bool TaskConfig::has_path_assessment_decider_config() const {
  return task_config_case() == kPathAssessmentDeciderConfig;
}
void TaskConfig::set_has_path_assessment_decider_config() {
  _oneof_case_[0] = kPathAssessmentDeciderConfig;
}
void TaskConfig::clear_path_assessment_decider_config() {
  if (has_path_assessment_decider_config()) {
    delete task_config_.path_assessment_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PathAssessmentDeciderConfig& TaskConfig::path_assessment_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
  return has_path_assessment_decider_config()
      ? *task_config_.path_assessment_decider_config_
      : ::jmc_auto::planning::PathAssessmentDeciderConfig::default_instance();
}
::jmc_auto::planning::PathAssessmentDeciderConfig* TaskConfig::mutable_path_assessment_decider_config() {
  if (!has_path_assessment_decider_config()) {
    clear_task_config();
    set_has_path_assessment_decider_config();
    task_config_.path_assessment_decider_config_ = new ::jmc_auto::planning::PathAssessmentDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
  return task_config_.path_assessment_decider_config_;
}
::jmc_auto::planning::PathAssessmentDeciderConfig* TaskConfig::release_path_assessment_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
  if (has_path_assessment_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathAssessmentDeciderConfig* temp = task_config_.path_assessment_decider_config_;
    task_config_.path_assessment_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_path_assessment_decider_config(::jmc_auto::planning::PathAssessmentDeciderConfig* path_assessment_decider_config) {
  clear_task_config();
  if (path_assessment_decider_config) {
    set_has_path_assessment_decider_config();
    task_config_.path_assessment_decider_config_ = path_assessment_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
}

// optional .jmc_auto.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
bool TaskConfig::has_piecewise_jerk_speed_config() const {
  return task_config_case() == kPiecewiseJerkSpeedConfig;
}
void TaskConfig::set_has_piecewise_jerk_speed_config() {
  _oneof_case_[0] = kPiecewiseJerkSpeedConfig;
}
void TaskConfig::clear_piecewise_jerk_speed_config() {
  if (has_piecewise_jerk_speed_config()) {
    delete task_config_.piecewise_jerk_speed_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PiecewiseJerkSpeedConfig& TaskConfig::piecewise_jerk_speed_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
  return has_piecewise_jerk_speed_config()
      ? *task_config_.piecewise_jerk_speed_config_
      : ::jmc_auto::planning::PiecewiseJerkSpeedConfig::default_instance();
}
::jmc_auto::planning::PiecewiseJerkSpeedConfig* TaskConfig::mutable_piecewise_jerk_speed_config() {
  if (!has_piecewise_jerk_speed_config()) {
    clear_task_config();
    set_has_piecewise_jerk_speed_config();
    task_config_.piecewise_jerk_speed_config_ = new ::jmc_auto::planning::PiecewiseJerkSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
  return task_config_.piecewise_jerk_speed_config_;
}
::jmc_auto::planning::PiecewiseJerkSpeedConfig* TaskConfig::release_piecewise_jerk_speed_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
  if (has_piecewise_jerk_speed_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PiecewiseJerkSpeedConfig* temp = task_config_.piecewise_jerk_speed_config_;
    task_config_.piecewise_jerk_speed_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_piecewise_jerk_speed_config(::jmc_auto::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config) {
  clear_task_config();
  if (piecewise_jerk_speed_config) {
    set_has_piecewise_jerk_speed_config();
    task_config_.piecewise_jerk_speed_config_ = piecewise_jerk_speed_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
}

// optional .jmc_auto.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
bool TaskConfig::has_path_lane_borrow_decider_config() const {
  return task_config_case() == kPathLaneBorrowDeciderConfig;
}
void TaskConfig::set_has_path_lane_borrow_decider_config() {
  _oneof_case_[0] = kPathLaneBorrowDeciderConfig;
}
void TaskConfig::clear_path_lane_borrow_decider_config() {
  if (has_path_lane_borrow_decider_config()) {
    delete task_config_.path_lane_borrow_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PathLaneBorrowDeciderConfig& TaskConfig::path_lane_borrow_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
  return has_path_lane_borrow_decider_config()
      ? *task_config_.path_lane_borrow_decider_config_
      : ::jmc_auto::planning::PathLaneBorrowDeciderConfig::default_instance();
}
::jmc_auto::planning::PathLaneBorrowDeciderConfig* TaskConfig::mutable_path_lane_borrow_decider_config() {
  if (!has_path_lane_borrow_decider_config()) {
    clear_task_config();
    set_has_path_lane_borrow_decider_config();
    task_config_.path_lane_borrow_decider_config_ = new ::jmc_auto::planning::PathLaneBorrowDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
  return task_config_.path_lane_borrow_decider_config_;
}
::jmc_auto::planning::PathLaneBorrowDeciderConfig* TaskConfig::release_path_lane_borrow_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
  if (has_path_lane_borrow_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathLaneBorrowDeciderConfig* temp = task_config_.path_lane_borrow_decider_config_;
    task_config_.path_lane_borrow_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_path_lane_borrow_decider_config(::jmc_auto::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config) {
  clear_task_config();
  if (path_lane_borrow_decider_config) {
    set_has_path_lane_borrow_decider_config();
    task_config_.path_lane_borrow_decider_config_ = path_lane_borrow_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
}

// optional .jmc_auto.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
bool TaskConfig::has_lane_change_decider_config() const {
  return task_config_case() == kLaneChangeDeciderConfig;
}
void TaskConfig::set_has_lane_change_decider_config() {
  _oneof_case_[0] = kLaneChangeDeciderConfig;
}
void TaskConfig::clear_lane_change_decider_config() {
  if (has_lane_change_decider_config()) {
    delete task_config_.lane_change_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::LaneChangeDeciderConfig& TaskConfig::lane_change_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.lane_change_decider_config)
  return has_lane_change_decider_config()
      ? *task_config_.lane_change_decider_config_
      : ::jmc_auto::planning::LaneChangeDeciderConfig::default_instance();
}
::jmc_auto::planning::LaneChangeDeciderConfig* TaskConfig::mutable_lane_change_decider_config() {
  if (!has_lane_change_decider_config()) {
    clear_task_config();
    set_has_lane_change_decider_config();
    task_config_.lane_change_decider_config_ = new ::jmc_auto::planning::LaneChangeDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.lane_change_decider_config)
  return task_config_.lane_change_decider_config_;
}
::jmc_auto::planning::LaneChangeDeciderConfig* TaskConfig::release_lane_change_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.lane_change_decider_config)
  if (has_lane_change_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::LaneChangeDeciderConfig* temp = task_config_.lane_change_decider_config_;
    task_config_.lane_change_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_lane_change_decider_config(::jmc_auto::planning::LaneChangeDeciderConfig* lane_change_decider_config) {
  clear_task_config();
  if (lane_change_decider_config) {
    set_has_lane_change_decider_config();
    task_config_.lane_change_decider_config_ = lane_change_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.lane_change_decider_config)
}

// optional .jmc_auto.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
bool TaskConfig::has_rule_based_stop_decider_config() const {
  return task_config_case() == kRuleBasedStopDeciderConfig;
}
void TaskConfig::set_has_rule_based_stop_decider_config() {
  _oneof_case_[0] = kRuleBasedStopDeciderConfig;
}
void TaskConfig::clear_rule_based_stop_decider_config() {
  if (has_rule_based_stop_decider_config()) {
    delete task_config_.rule_based_stop_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::RuleBasedStopDeciderConfig& TaskConfig::rule_based_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
  return has_rule_based_stop_decider_config()
      ? *task_config_.rule_based_stop_decider_config_
      : ::jmc_auto::planning::RuleBasedStopDeciderConfig::default_instance();
}
::jmc_auto::planning::RuleBasedStopDeciderConfig* TaskConfig::mutable_rule_based_stop_decider_config() {
  if (!has_rule_based_stop_decider_config()) {
    clear_task_config();
    set_has_rule_based_stop_decider_config();
    task_config_.rule_based_stop_decider_config_ = new ::jmc_auto::planning::RuleBasedStopDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
  return task_config_.rule_based_stop_decider_config_;
}
::jmc_auto::planning::RuleBasedStopDeciderConfig* TaskConfig::release_rule_based_stop_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
  if (has_rule_based_stop_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::RuleBasedStopDeciderConfig* temp = task_config_.rule_based_stop_decider_config_;
    task_config_.rule_based_stop_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_rule_based_stop_decider_config(::jmc_auto::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config) {
  clear_task_config();
  if (rule_based_stop_decider_config) {
    set_has_rule_based_stop_decider_config();
    task_config_.rule_based_stop_decider_config_ = rule_based_stop_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
}

// optional .jmc_auto.planning.PathReuseDeciderConfig path_reuse_decider_config = 27;
bool TaskConfig::has_path_reuse_decider_config() const {
  return task_config_case() == kPathReuseDeciderConfig;
}
void TaskConfig::set_has_path_reuse_decider_config() {
  _oneof_case_[0] = kPathReuseDeciderConfig;
}
void TaskConfig::clear_path_reuse_decider_config() {
  if (has_path_reuse_decider_config()) {
    delete task_config_.path_reuse_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PathReuseDeciderConfig& TaskConfig::path_reuse_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
  return has_path_reuse_decider_config()
      ? *task_config_.path_reuse_decider_config_
      : ::jmc_auto::planning::PathReuseDeciderConfig::default_instance();
}
::jmc_auto::planning::PathReuseDeciderConfig* TaskConfig::mutable_path_reuse_decider_config() {
  if (!has_path_reuse_decider_config()) {
    clear_task_config();
    set_has_path_reuse_decider_config();
    task_config_.path_reuse_decider_config_ = new ::jmc_auto::planning::PathReuseDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
  return task_config_.path_reuse_decider_config_;
}
::jmc_auto::planning::PathReuseDeciderConfig* TaskConfig::release_path_reuse_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
  if (has_path_reuse_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathReuseDeciderConfig* temp = task_config_.path_reuse_decider_config_;
    task_config_.path_reuse_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_path_reuse_decider_config(::jmc_auto::planning::PathReuseDeciderConfig* path_reuse_decider_config) {
  clear_task_config();
  if (path_reuse_decider_config) {
    set_has_path_reuse_decider_config();
    task_config_.path_reuse_decider_config_ = path_reuse_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
}

// optional .jmc_auto.planning.STBoundsDeciderConfig st_bounds_decider_config = 28;
bool TaskConfig::has_st_bounds_decider_config() const {
  return task_config_case() == kStBoundsDeciderConfig;
}
void TaskConfig::set_has_st_bounds_decider_config() {
  _oneof_case_[0] = kStBoundsDeciderConfig;
}
void TaskConfig::clear_st_bounds_decider_config() {
  if (has_st_bounds_decider_config()) {
    delete task_config_.st_bounds_decider_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::STBoundsDeciderConfig& TaskConfig::st_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
  return has_st_bounds_decider_config()
      ? *task_config_.st_bounds_decider_config_
      : ::jmc_auto::planning::STBoundsDeciderConfig::default_instance();
}
::jmc_auto::planning::STBoundsDeciderConfig* TaskConfig::mutable_st_bounds_decider_config() {
  if (!has_st_bounds_decider_config()) {
    clear_task_config();
    set_has_st_bounds_decider_config();
    task_config_.st_bounds_decider_config_ = new ::jmc_auto::planning::STBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
  return task_config_.st_bounds_decider_config_;
}
::jmc_auto::planning::STBoundsDeciderConfig* TaskConfig::release_st_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
  if (has_st_bounds_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::STBoundsDeciderConfig* temp = task_config_.st_bounds_decider_config_;
    task_config_.st_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_st_bounds_decider_config(::jmc_auto::planning::STBoundsDeciderConfig* st_bounds_decider_config) {
  clear_task_config();
  if (st_bounds_decider_config) {
    set_has_st_bounds_decider_config();
    task_config_.st_bounds_decider_config_ = st_bounds_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
}

// optional .jmc_auto.planning.PiecewiseJerkNonlinearSpeedConfig piecewise_jerk_nonlinear_speed_config = 29;
bool TaskConfig::has_piecewise_jerk_nonlinear_speed_config() const {
  return task_config_case() == kPiecewiseJerkNonlinearSpeedConfig;
}
void TaskConfig::set_has_piecewise_jerk_nonlinear_speed_config() {
  _oneof_case_[0] = kPiecewiseJerkNonlinearSpeedConfig;
}
void TaskConfig::clear_piecewise_jerk_nonlinear_speed_config() {
  if (has_piecewise_jerk_nonlinear_speed_config()) {
    delete task_config_.piecewise_jerk_nonlinear_speed_config_;
    clear_has_task_config();
  }
}
 const ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig& TaskConfig::piecewise_jerk_nonlinear_speed_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
  return has_piecewise_jerk_nonlinear_speed_config()
      ? *task_config_.piecewise_jerk_nonlinear_speed_config_
      : ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig::default_instance();
}
::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* TaskConfig::mutable_piecewise_jerk_nonlinear_speed_config() {
  if (!has_piecewise_jerk_nonlinear_speed_config()) {
    clear_task_config();
    set_has_piecewise_jerk_nonlinear_speed_config();
    task_config_.piecewise_jerk_nonlinear_speed_config_ = new ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
  return task_config_.piecewise_jerk_nonlinear_speed_config_;
}
::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* TaskConfig::release_piecewise_jerk_nonlinear_speed_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
  if (has_piecewise_jerk_nonlinear_speed_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* temp = task_config_.piecewise_jerk_nonlinear_speed_config_;
    task_config_.piecewise_jerk_nonlinear_speed_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void TaskConfig::set_allocated_piecewise_jerk_nonlinear_speed_config(::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* piecewise_jerk_nonlinear_speed_config) {
  clear_task_config();
  if (piecewise_jerk_nonlinear_speed_config) {
    set_has_piecewise_jerk_nonlinear_speed_config();
    task_config_.piecewise_jerk_nonlinear_speed_config_ = piecewise_jerk_nonlinear_speed_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
}

bool TaskConfig::has_task_config() const {
  return task_config_case() != TASK_CONFIG_NOT_SET;
}
void TaskConfig::clear_has_task_config() {
  _oneof_case_[0] = TASK_CONFIG_NOT_SET;
}
TaskConfig::TaskConfigCase TaskConfig::task_config_case() const {
  return TaskConfig::TaskConfigCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioLaneFollowConfig::ScenarioLaneFollowConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioLaneFollowConfig)
}
ScenarioLaneFollowConfig::ScenarioLaneFollowConfig(const ScenarioLaneFollowConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioLaneFollowConfig)
}

void ScenarioLaneFollowConfig::SharedCtor() {
  _cached_size_ = 0;
}

ScenarioLaneFollowConfig::~ScenarioLaneFollowConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioLaneFollowConfig)
  SharedDtor();
}

void ScenarioLaneFollowConfig::SharedDtor() {
}

void ScenarioLaneFollowConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioLaneFollowConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioLaneFollowConfig& ScenarioLaneFollowConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioLaneFollowConfig* ScenarioLaneFollowConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioLaneFollowConfig* n = new ScenarioLaneFollowConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioLaneFollowConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioLaneFollowConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioLaneFollowConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioLaneFollowConfig)
  return false;
#undef DO_
}

void ScenarioLaneFollowConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioLaneFollowConfig)
}

::google::protobuf::uint8* ScenarioLaneFollowConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioLaneFollowConfig)
  return target;
}

size_t ScenarioLaneFollowConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioLaneFollowConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioLaneFollowConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioLaneFollowConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioLaneFollowConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioLaneFollowConfig)
    MergeFrom(*source);
  }
}

void ScenarioLaneFollowConfig::MergeFrom(const ScenarioLaneFollowConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ScenarioLaneFollowConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioLaneFollowConfig::CopyFrom(const ScenarioLaneFollowConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioLaneFollowConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioLaneFollowConfig::IsInitialized() const {
  return true;
}

void ScenarioLaneFollowConfig::Swap(ScenarioLaneFollowConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioLaneFollowConfig::InternalSwap(ScenarioLaneFollowConfig* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioLaneFollowConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioLaneFollowConfig

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioBareIntersectionUnprotectedConfig::kStartBareIntersectionScenarioDistanceFieldNumber;
const int ScenarioBareIntersectionUnprotectedConfig::kEnableExplicitStopFieldNumber;
const int ScenarioBareIntersectionUnprotectedConfig::kMinPassSDistanceFieldNumber;
const int ScenarioBareIntersectionUnprotectedConfig::kApproachCruiseSpeedFieldNumber;
const int ScenarioBareIntersectionUnprotectedConfig::kStopDistanceFieldNumber;
const int ScenarioBareIntersectionUnprotectedConfig::kStopTimeoutSecFieldNumber;
const int ScenarioBareIntersectionUnprotectedConfig::kCreepTimeoutSecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioBareIntersectionUnprotectedConfig::ScenarioBareIntersectionUnprotectedConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
}
ScenarioBareIntersectionUnprotectedConfig::ScenarioBareIntersectionUnprotectedConfig(const ScenarioBareIntersectionUnprotectedConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&enable_explicit_stop_, &from.enable_explicit_stop_,
    reinterpret_cast<char*>(&creep_timeout_sec_) -
    reinterpret_cast<char*>(&enable_explicit_stop_) + sizeof(creep_timeout_sec_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
}

void ScenarioBareIntersectionUnprotectedConfig::SharedCtor() {
  _cached_size_ = 0;
  enable_explicit_stop_ = false;
  start_bare_intersection_scenario_distance_ = 25;
  min_pass_s_distance_ = 3;
  approach_cruise_speed_ = 6.7056;
  stop_distance_ = 0.5;
  stop_timeout_sec_ = 8;
  creep_timeout_sec_ = 10;
}

ScenarioBareIntersectionUnprotectedConfig::~ScenarioBareIntersectionUnprotectedConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  SharedDtor();
}

void ScenarioBareIntersectionUnprotectedConfig::SharedDtor() {
}

void ScenarioBareIntersectionUnprotectedConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioBareIntersectionUnprotectedConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioBareIntersectionUnprotectedConfig& ScenarioBareIntersectionUnprotectedConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioBareIntersectionUnprotectedConfig* ScenarioBareIntersectionUnprotectedConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioBareIntersectionUnprotectedConfig* n = new ScenarioBareIntersectionUnprotectedConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioBareIntersectionUnprotectedConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  if (_has_bits_[0 / 32] & 127u) {
    enable_explicit_stop_ = false;
    start_bare_intersection_scenario_distance_ = 25;
    min_pass_s_distance_ = 3;
    approach_cruise_speed_ = 6.7056;
    stop_distance_ = 0.5;
    stop_timeout_sec_ = 8;
    creep_timeout_sec_ = 10;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioBareIntersectionUnprotectedConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_bare_intersection_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_bare_intersection_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_explicit_stop = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_enable_explicit_stop();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_explicit_stop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_pass_s_distance = 3 [default = 3];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_min_pass_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_pass_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double approach_cruise_speed = 4 [default = 6.7056];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_approach_cruise_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &approach_cruise_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double stop_distance = 5 [default = 0.5];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(41u)) {
          set_has_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float stop_timeout_sec = 6 [default = 8];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u)) {
          set_has_stop_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stop_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float creep_timeout_sec = 7 [default = 10];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u)) {
          set_has_creep_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &creep_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  return false;
#undef DO_
}

void ScenarioBareIntersectionUnprotectedConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_bare_intersection_scenario_distance(), output);
  }

  // optional bool enable_explicit_stop = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->enable_explicit_stop(), output);
  }

  // optional double min_pass_s_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->min_pass_s_distance(), output);
  }

  // optional double approach_cruise_speed = 4 [default = 6.7056];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->approach_cruise_speed(), output);
  }

  // optional double stop_distance = 5 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->stop_distance(), output);
  }

  // optional float stop_timeout_sec = 6 [default = 8];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->stop_timeout_sec(), output);
  }

  // optional float creep_timeout_sec = 7 [default = 10];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->creep_timeout_sec(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
}

::google::protobuf::uint8* ScenarioBareIntersectionUnprotectedConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_bare_intersection_scenario_distance(), target);
  }

  // optional bool enable_explicit_stop = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->enable_explicit_stop(), target);
  }

  // optional double min_pass_s_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->min_pass_s_distance(), target);
  }

  // optional double approach_cruise_speed = 4 [default = 6.7056];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->approach_cruise_speed(), target);
  }

  // optional double stop_distance = 5 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->stop_distance(), target);
  }

  // optional float stop_timeout_sec = 6 [default = 8];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->stop_timeout_sec(), target);
  }

  // optional float creep_timeout_sec = 7 [default = 10];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->creep_timeout_sec(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  return target;
}

size_t ScenarioBareIntersectionUnprotectedConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 127u) {
    // optional bool enable_explicit_stop = 2 [default = false];
    if (has_enable_explicit_stop()) {
      total_size += 1 + 1;
    }

    // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
    if (has_start_bare_intersection_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 3 [default = 3];
    if (has_min_pass_s_distance()) {
      total_size += 1 + 8;
    }

    // optional double approach_cruise_speed = 4 [default = 6.7056];
    if (has_approach_cruise_speed()) {
      total_size += 1 + 8;
    }

    // optional double stop_distance = 5 [default = 0.5];
    if (has_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional float stop_timeout_sec = 6 [default = 8];
    if (has_stop_timeout_sec()) {
      total_size += 1 + 4;
    }

    // optional float creep_timeout_sec = 7 [default = 10];
    if (has_creep_timeout_sec()) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioBareIntersectionUnprotectedConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioBareIntersectionUnprotectedConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioBareIntersectionUnprotectedConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
    MergeFrom(*source);
  }
}

void ScenarioBareIntersectionUnprotectedConfig::MergeFrom(const ScenarioBareIntersectionUnprotectedConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      enable_explicit_stop_ = from.enable_explicit_stop_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_bare_intersection_scenario_distance_ = from.start_bare_intersection_scenario_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_pass_s_distance_ = from.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      approach_cruise_speed_ = from.approach_cruise_speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      stop_distance_ = from.stop_distance_;
    }
    if (cached_has_bits & 0x00000020u) {
      stop_timeout_sec_ = from.stop_timeout_sec_;
    }
    if (cached_has_bits & 0x00000040u) {
      creep_timeout_sec_ = from.creep_timeout_sec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioBareIntersectionUnprotectedConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioBareIntersectionUnprotectedConfig::CopyFrom(const ScenarioBareIntersectionUnprotectedConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioBareIntersectionUnprotectedConfig::IsInitialized() const {
  return true;
}

void ScenarioBareIntersectionUnprotectedConfig::Swap(ScenarioBareIntersectionUnprotectedConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioBareIntersectionUnprotectedConfig::InternalSwap(ScenarioBareIntersectionUnprotectedConfig* other) {
  std::swap(enable_explicit_stop_, other->enable_explicit_stop_);
  std::swap(start_bare_intersection_scenario_distance_, other->start_bare_intersection_scenario_distance_);
  std::swap(min_pass_s_distance_, other->min_pass_s_distance_);
  std::swap(approach_cruise_speed_, other->approach_cruise_speed_);
  std::swap(stop_distance_, other->stop_distance_);
  std::swap(stop_timeout_sec_, other->stop_timeout_sec_);
  std::swap(creep_timeout_sec_, other->creep_timeout_sec_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioBareIntersectionUnprotectedConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioBareIntersectionUnprotectedConfig

// optional double start_bare_intersection_scenario_distance = 1 [default = 25];
bool ScenarioBareIntersectionUnprotectedConfig::has_start_bare_intersection_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_start_bare_intersection_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_start_bare_intersection_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_start_bare_intersection_scenario_distance() {
  start_bare_intersection_scenario_distance_ = 25;
  clear_has_start_bare_intersection_scenario_distance();
}
double ScenarioBareIntersectionUnprotectedConfig::start_bare_intersection_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
  return start_bare_intersection_scenario_distance_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_start_bare_intersection_scenario_distance(double value) {
  set_has_start_bare_intersection_scenario_distance();
  start_bare_intersection_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
}

// optional bool enable_explicit_stop = 2 [default = false];
bool ScenarioBareIntersectionUnprotectedConfig::has_enable_explicit_stop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_enable_explicit_stop() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_enable_explicit_stop() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_enable_explicit_stop() {
  enable_explicit_stop_ = false;
  clear_has_enable_explicit_stop();
}
bool ScenarioBareIntersectionUnprotectedConfig::enable_explicit_stop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
  return enable_explicit_stop_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_enable_explicit_stop(bool value) {
  set_has_enable_explicit_stop();
  enable_explicit_stop_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
}

// optional double min_pass_s_distance = 3 [default = 3];
bool ScenarioBareIntersectionUnprotectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
double ScenarioBareIntersectionUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
}

// optional double approach_cruise_speed = 4 [default = 6.7056];
bool ScenarioBareIntersectionUnprotectedConfig::has_approach_cruise_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_approach_cruise_speed() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_approach_cruise_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_approach_cruise_speed() {
  approach_cruise_speed_ = 6.7056;
  clear_has_approach_cruise_speed();
}
double ScenarioBareIntersectionUnprotectedConfig::approach_cruise_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.approach_cruise_speed)
  return approach_cruise_speed_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_approach_cruise_speed(double value) {
  set_has_approach_cruise_speed();
  approach_cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.approach_cruise_speed)
}

// optional double stop_distance = 5 [default = 0.5];
bool ScenarioBareIntersectionUnprotectedConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000010u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
double ScenarioBareIntersectionUnprotectedConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
  return stop_distance_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
bool ScenarioBareIntersectionUnprotectedConfig::has_stop_timeout_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_stop_timeout_sec() {
  _has_bits_[0] |= 0x00000020u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_stop_timeout_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  clear_has_stop_timeout_sec();
}
float ScenarioBareIntersectionUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
  return stop_timeout_sec_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_stop_timeout_sec(float value) {
  set_has_stop_timeout_sec();
  stop_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
bool ScenarioBareIntersectionUnprotectedConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ScenarioBareIntersectionUnprotectedConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000040u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
void ScenarioBareIntersectionUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
float ScenarioBareIntersectionUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
void ScenarioBareIntersectionUnprotectedConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioStopSignUnprotectedConfig::kStartStopSignScenarioDistanceFieldNumber;
const int ScenarioStopSignUnprotectedConfig::kWatchVehicleMaxValidStopDistanceFieldNumber;
const int ScenarioStopSignUnprotectedConfig::kMaxValidStopDistanceFieldNumber;
const int ScenarioStopSignUnprotectedConfig::kStopDurationSecFieldNumber;
const int ScenarioStopSignUnprotectedConfig::kMinPassSDistanceFieldNumber;
const int ScenarioStopSignUnprotectedConfig::kStopTimeoutSecFieldNumber;
const int ScenarioStopSignUnprotectedConfig::kCreepTimeoutSecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioStopSignUnprotectedConfig::ScenarioStopSignUnprotectedConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
}
ScenarioStopSignUnprotectedConfig::ScenarioStopSignUnprotectedConfig(const ScenarioStopSignUnprotectedConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&creep_timeout_sec_, &from.creep_timeout_sec_,
    reinterpret_cast<char*>(&stop_timeout_sec_) -
    reinterpret_cast<char*>(&creep_timeout_sec_) + sizeof(stop_timeout_sec_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
}

void ScenarioStopSignUnprotectedConfig::SharedCtor() {
  _cached_size_ = 0;
  creep_timeout_sec_ = 10;
  start_stop_sign_scenario_distance_ = 5;
  watch_vehicle_max_valid_stop_distance_ = 5;
  max_valid_stop_distance_ = 3.5;
  min_pass_s_distance_ = 3;
  stop_duration_sec_ = 1;
  stop_timeout_sec_ = 8;
}

ScenarioStopSignUnprotectedConfig::~ScenarioStopSignUnprotectedConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  SharedDtor();
}

void ScenarioStopSignUnprotectedConfig::SharedDtor() {
}

void ScenarioStopSignUnprotectedConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioStopSignUnprotectedConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioStopSignUnprotectedConfig& ScenarioStopSignUnprotectedConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioStopSignUnprotectedConfig* ScenarioStopSignUnprotectedConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioStopSignUnprotectedConfig* n = new ScenarioStopSignUnprotectedConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioStopSignUnprotectedConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  if (_has_bits_[0 / 32] & 127u) {
    creep_timeout_sec_ = 10;
    start_stop_sign_scenario_distance_ = 5;
    watch_vehicle_max_valid_stop_distance_ = 5;
    max_valid_stop_distance_ = 3.5;
    min_pass_s_distance_ = 3;
    stop_duration_sec_ = 1;
    stop_timeout_sec_ = 8;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioStopSignUnprotectedConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_stop_sign_scenario_distance = 1 [default = 5];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_stop_sign_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_stop_sign_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_watch_vehicle_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &watch_vehicle_max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 3 [default = 3.5];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float stop_duration_sec = 4 [default = 1];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {
          set_has_stop_duration_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stop_duration_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_pass_s_distance = 5 [default = 3];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(41u)) {
          set_has_min_pass_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_pass_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float stop_timeout_sec = 6 [default = 8];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u)) {
          set_has_stop_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stop_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float creep_timeout_sec = 7 [default = 10];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u)) {
          set_has_creep_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &creep_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  return false;
#undef DO_
}

void ScenarioStopSignUnprotectedConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_stop_sign_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_stop_sign_scenario_distance(), output);
  }

  // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->watch_vehicle_max_valid_stop_distance(), output);
  }

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->max_valid_stop_distance(), output);
  }

  // optional float stop_duration_sec = 4 [default = 1];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->stop_duration_sec(), output);
  }

  // optional double min_pass_s_distance = 5 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->min_pass_s_distance(), output);
  }

  // optional float stop_timeout_sec = 6 [default = 8];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->stop_timeout_sec(), output);
  }

  // optional float creep_timeout_sec = 7 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->creep_timeout_sec(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
}

::google::protobuf::uint8* ScenarioStopSignUnprotectedConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_stop_sign_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_stop_sign_scenario_distance(), target);
  }

  // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->watch_vehicle_max_valid_stop_distance(), target);
  }

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->max_valid_stop_distance(), target);
  }

  // optional float stop_duration_sec = 4 [default = 1];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->stop_duration_sec(), target);
  }

  // optional double min_pass_s_distance = 5 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->min_pass_s_distance(), target);
  }

  // optional float stop_timeout_sec = 6 [default = 8];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->stop_timeout_sec(), target);
  }

  // optional float creep_timeout_sec = 7 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->creep_timeout_sec(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  return target;
}

size_t ScenarioStopSignUnprotectedConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 127u) {
    // optional float creep_timeout_sec = 7 [default = 10];
    if (has_creep_timeout_sec()) {
      total_size += 1 + 4;
    }

    // optional double start_stop_sign_scenario_distance = 1 [default = 5];
    if (has_start_stop_sign_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
    if (has_watch_vehicle_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 3 [default = 3.5];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 5 [default = 3];
    if (has_min_pass_s_distance()) {
      total_size += 1 + 8;
    }

    // optional float stop_duration_sec = 4 [default = 1];
    if (has_stop_duration_sec()) {
      total_size += 1 + 4;
    }

    // optional float stop_timeout_sec = 6 [default = 8];
    if (has_stop_timeout_sec()) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioStopSignUnprotectedConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioStopSignUnprotectedConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioStopSignUnprotectedConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
    MergeFrom(*source);
  }
}

void ScenarioStopSignUnprotectedConfig::MergeFrom(const ScenarioStopSignUnprotectedConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      creep_timeout_sec_ = from.creep_timeout_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_stop_sign_scenario_distance_ = from.start_stop_sign_scenario_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      watch_vehicle_max_valid_stop_distance_ = from.watch_vehicle_max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      min_pass_s_distance_ = from.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000020u) {
      stop_duration_sec_ = from.stop_duration_sec_;
    }
    if (cached_has_bits & 0x00000040u) {
      stop_timeout_sec_ = from.stop_timeout_sec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioStopSignUnprotectedConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioStopSignUnprotectedConfig::CopyFrom(const ScenarioStopSignUnprotectedConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioStopSignUnprotectedConfig::IsInitialized() const {
  return true;
}

void ScenarioStopSignUnprotectedConfig::Swap(ScenarioStopSignUnprotectedConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioStopSignUnprotectedConfig::InternalSwap(ScenarioStopSignUnprotectedConfig* other) {
  std::swap(creep_timeout_sec_, other->creep_timeout_sec_);
  std::swap(start_stop_sign_scenario_distance_, other->start_stop_sign_scenario_distance_);
  std::swap(watch_vehicle_max_valid_stop_distance_, other->watch_vehicle_max_valid_stop_distance_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(min_pass_s_distance_, other->min_pass_s_distance_);
  std::swap(stop_duration_sec_, other->stop_duration_sec_);
  std::swap(stop_timeout_sec_, other->stop_timeout_sec_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioStopSignUnprotectedConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioStopSignUnprotectedConfig

// optional double start_stop_sign_scenario_distance = 1 [default = 5];
bool ScenarioStopSignUnprotectedConfig::has_start_stop_sign_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_start_stop_sign_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_start_stop_sign_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioStopSignUnprotectedConfig::clear_start_stop_sign_scenario_distance() {
  start_stop_sign_scenario_distance_ = 5;
  clear_has_start_stop_sign_scenario_distance();
}
double ScenarioStopSignUnprotectedConfig::start_stop_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
  return start_stop_sign_scenario_distance_;
}
void ScenarioStopSignUnprotectedConfig::set_start_stop_sign_scenario_distance(double value) {
  set_has_start_stop_sign_scenario_distance();
  start_stop_sign_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
}

// optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
bool ScenarioStopSignUnprotectedConfig::has_watch_vehicle_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioStopSignUnprotectedConfig::clear_watch_vehicle_max_valid_stop_distance() {
  watch_vehicle_max_valid_stop_distance_ = 5;
  clear_has_watch_vehicle_max_valid_stop_distance();
}
double ScenarioStopSignUnprotectedConfig::watch_vehicle_max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
  return watch_vehicle_max_valid_stop_distance_;
}
void ScenarioStopSignUnprotectedConfig::set_watch_vehicle_max_valid_stop_distance(double value) {
  set_has_watch_vehicle_max_valid_stop_distance();
  watch_vehicle_max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
bool ScenarioStopSignUnprotectedConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioStopSignUnprotectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
double ScenarioStopSignUnprotectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioStopSignUnprotectedConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
}

// optional float stop_duration_sec = 4 [default = 1];
bool ScenarioStopSignUnprotectedConfig::has_stop_duration_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_stop_duration_sec() {
  _has_bits_[0] |= 0x00000020u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_stop_duration_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
void ScenarioStopSignUnprotectedConfig::clear_stop_duration_sec() {
  stop_duration_sec_ = 1;
  clear_has_stop_duration_sec();
}
float ScenarioStopSignUnprotectedConfig::stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
  return stop_duration_sec_;
}
void ScenarioStopSignUnprotectedConfig::set_stop_duration_sec(float value) {
  set_has_stop_duration_sec();
  stop_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
}

// optional double min_pass_s_distance = 5 [default = 3];
bool ScenarioStopSignUnprotectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
void ScenarioStopSignUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
double ScenarioStopSignUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
void ScenarioStopSignUnprotectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
bool ScenarioStopSignUnprotectedConfig::has_stop_timeout_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_stop_timeout_sec() {
  _has_bits_[0] |= 0x00000040u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_stop_timeout_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
void ScenarioStopSignUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  clear_has_stop_timeout_sec();
}
float ScenarioStopSignUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
  return stop_timeout_sec_;
}
void ScenarioStopSignUnprotectedConfig::set_stop_timeout_sec(float value) {
  set_has_stop_timeout_sec();
  stop_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
bool ScenarioStopSignUnprotectedConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioStopSignUnprotectedConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioStopSignUnprotectedConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioStopSignUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
float ScenarioStopSignUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
void ScenarioStopSignUnprotectedConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioTrafficLightProtectedConfig::kStartTrafficLightScenarioDistanceFieldNumber;
const int ScenarioTrafficLightProtectedConfig::kMaxValidStopDistanceFieldNumber;
const int ScenarioTrafficLightProtectedConfig::kMinPassSDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioTrafficLightProtectedConfig::ScenarioTrafficLightProtectedConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
}
ScenarioTrafficLightProtectedConfig::ScenarioTrafficLightProtectedConfig(const ScenarioTrafficLightProtectedConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&start_traffic_light_scenario_distance_, &from.start_traffic_light_scenario_distance_,
    reinterpret_cast<char*>(&min_pass_s_distance_) -
    reinterpret_cast<char*>(&start_traffic_light_scenario_distance_) + sizeof(min_pass_s_distance_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
}

void ScenarioTrafficLightProtectedConfig::SharedCtor() {
  _cached_size_ = 0;
  start_traffic_light_scenario_distance_ = 5;
  max_valid_stop_distance_ = 2;
  min_pass_s_distance_ = 3;
}

ScenarioTrafficLightProtectedConfig::~ScenarioTrafficLightProtectedConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  SharedDtor();
}

void ScenarioTrafficLightProtectedConfig::SharedDtor() {
}

void ScenarioTrafficLightProtectedConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioTrafficLightProtectedConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioTrafficLightProtectedConfig& ScenarioTrafficLightProtectedConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioTrafficLightProtectedConfig* ScenarioTrafficLightProtectedConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioTrafficLightProtectedConfig* n = new ScenarioTrafficLightProtectedConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioTrafficLightProtectedConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  if (_has_bits_[0 / 32] & 7u) {
    start_traffic_light_scenario_distance_ = 5;
    max_valid_stop_distance_ = 2;
    min_pass_s_distance_ = 3;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioTrafficLightProtectedConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_traffic_light_scenario_distance = 1 [default = 5];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_traffic_light_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_traffic_light_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 2 [default = 2];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_pass_s_distance = 3 [default = 3];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_min_pass_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_pass_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  return false;
#undef DO_
}

void ScenarioTrafficLightProtectedConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_traffic_light_scenario_distance(), output);
  }

  // optional double max_valid_stop_distance = 2 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->max_valid_stop_distance(), output);
  }

  // optional double min_pass_s_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->min_pass_s_distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
}

::google::protobuf::uint8* ScenarioTrafficLightProtectedConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_traffic_light_scenario_distance(), target);
  }

  // optional double max_valid_stop_distance = 2 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->max_valid_stop_distance(), target);
  }

  // optional double min_pass_s_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->min_pass_s_distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  return target;
}

size_t ScenarioTrafficLightProtectedConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional double start_traffic_light_scenario_distance = 1 [default = 5];
    if (has_start_traffic_light_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 2 [default = 2];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 3 [default = 3];
    if (has_min_pass_s_distance()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioTrafficLightProtectedConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioTrafficLightProtectedConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioTrafficLightProtectedConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
    MergeFrom(*source);
  }
}

void ScenarioTrafficLightProtectedConfig::MergeFrom(const ScenarioTrafficLightProtectedConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      start_traffic_light_scenario_distance_ = from.start_traffic_light_scenario_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_pass_s_distance_ = from.min_pass_s_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioTrafficLightProtectedConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioTrafficLightProtectedConfig::CopyFrom(const ScenarioTrafficLightProtectedConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioTrafficLightProtectedConfig::IsInitialized() const {
  return true;
}

void ScenarioTrafficLightProtectedConfig::Swap(ScenarioTrafficLightProtectedConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioTrafficLightProtectedConfig::InternalSwap(ScenarioTrafficLightProtectedConfig* other) {
  std::swap(start_traffic_light_scenario_distance_, other->start_traffic_light_scenario_distance_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(min_pass_s_distance_, other->min_pass_s_distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioTrafficLightProtectedConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioTrafficLightProtectedConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
bool ScenarioTrafficLightProtectedConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioTrafficLightProtectedConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioTrafficLightProtectedConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioTrafficLightProtectedConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
double ScenarioTrafficLightProtectedConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
void ScenarioTrafficLightProtectedConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 2];
bool ScenarioTrafficLightProtectedConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioTrafficLightProtectedConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioTrafficLightProtectedConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioTrafficLightProtectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 2;
  clear_has_max_valid_stop_distance();
}
double ScenarioTrafficLightProtectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioTrafficLightProtectedConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 3 [default = 3];
bool ScenarioTrafficLightProtectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioTrafficLightProtectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioTrafficLightProtectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioTrafficLightProtectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
double ScenarioTrafficLightProtectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
void ScenarioTrafficLightProtectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioTrafficLightUnprotectedLeftTurnConfig::kStartTrafficLightScenarioDistanceFieldNumber;
const int ScenarioTrafficLightUnprotectedLeftTurnConfig::kApproachCruiseSpeedFieldNumber;
const int ScenarioTrafficLightUnprotectedLeftTurnConfig::kMaxValidStopDistanceFieldNumber;
const int ScenarioTrafficLightUnprotectedLeftTurnConfig::kMinPassSDistanceFieldNumber;
const int ScenarioTrafficLightUnprotectedLeftTurnConfig::kCreepTimeoutSecFieldNumber;
const int ScenarioTrafficLightUnprotectedLeftTurnConfig::kMaxAdcSpeedBeforeCreepFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioTrafficLightUnprotectedLeftTurnConfig::ScenarioTrafficLightUnprotectedLeftTurnConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
}
ScenarioTrafficLightUnprotectedLeftTurnConfig::ScenarioTrafficLightUnprotectedLeftTurnConfig(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&creep_timeout_sec_, &from.creep_timeout_sec_,
    reinterpret_cast<char*>(&max_adc_speed_before_creep_) -
    reinterpret_cast<char*>(&creep_timeout_sec_) + sizeof(max_adc_speed_before_creep_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::SharedCtor() {
  _cached_size_ = 0;
  creep_timeout_sec_ = 10;
  start_traffic_light_scenario_distance_ = 5;
  approach_cruise_speed_ = 2.78;
  max_valid_stop_distance_ = 3.5;
  min_pass_s_distance_ = 3;
  max_adc_speed_before_creep_ = 5.56;
}

ScenarioTrafficLightUnprotectedLeftTurnConfig::~ScenarioTrafficLightUnprotectedLeftTurnConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  SharedDtor();
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::SharedDtor() {
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioTrafficLightUnprotectedLeftTurnConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioTrafficLightUnprotectedLeftTurnConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioTrafficLightUnprotectedLeftTurnConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioTrafficLightUnprotectedLeftTurnConfig* n = new ScenarioTrafficLightUnprotectedLeftTurnConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  if (_has_bits_[0 / 32] & 63u) {
    creep_timeout_sec_ = 10;
    start_traffic_light_scenario_distance_ = 5;
    approach_cruise_speed_ = 2.78;
    max_valid_stop_distance_ = 3.5;
    min_pass_s_distance_ = 3;
    max_adc_speed_before_creep_ = 5.56;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioTrafficLightUnprotectedLeftTurnConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_traffic_light_scenario_distance = 1 [default = 5];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_traffic_light_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_traffic_light_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double approach_cruise_speed = 2 [default = 2.78];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_approach_cruise_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &approach_cruise_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 3 [default = 3.5];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_pass_s_distance = 4 [default = 3];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_min_pass_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_pass_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float creep_timeout_sec = 5 [default = 10];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u)) {
          set_has_creep_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &creep_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_adc_speed_before_creep = 6 [default = 5.56];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(49u)) {
          set_has_max_adc_speed_before_creep();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_adc_speed_before_creep_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  return false;
#undef DO_
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_traffic_light_scenario_distance(), output);
  }

  // optional double approach_cruise_speed = 2 [default = 2.78];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->approach_cruise_speed(), output);
  }

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->max_valid_stop_distance(), output);
  }

  // optional double min_pass_s_distance = 4 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->min_pass_s_distance(), output);
  }

  // optional float creep_timeout_sec = 5 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->creep_timeout_sec(), output);
  }

  // optional double max_adc_speed_before_creep = 6 [default = 5.56];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->max_adc_speed_before_creep(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
}

::google::protobuf::uint8* ScenarioTrafficLightUnprotectedLeftTurnConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_traffic_light_scenario_distance(), target);
  }

  // optional double approach_cruise_speed = 2 [default = 2.78];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->approach_cruise_speed(), target);
  }

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->max_valid_stop_distance(), target);
  }

  // optional double min_pass_s_distance = 4 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->min_pass_s_distance(), target);
  }

  // optional float creep_timeout_sec = 5 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->creep_timeout_sec(), target);
  }

  // optional double max_adc_speed_before_creep = 6 [default = 5.56];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->max_adc_speed_before_creep(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  return target;
}

size_t ScenarioTrafficLightUnprotectedLeftTurnConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 63u) {
    // optional float creep_timeout_sec = 5 [default = 10];
    if (has_creep_timeout_sec()) {
      total_size += 1 + 4;
    }

    // optional double start_traffic_light_scenario_distance = 1 [default = 5];
    if (has_start_traffic_light_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double approach_cruise_speed = 2 [default = 2.78];
    if (has_approach_cruise_speed()) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 3 [default = 3.5];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 4 [default = 3];
    if (has_min_pass_s_distance()) {
      total_size += 1 + 8;
    }

    // optional double max_adc_speed_before_creep = 6 [default = 5.56];
    if (has_max_adc_speed_before_creep()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioTrafficLightUnprotectedLeftTurnConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioTrafficLightUnprotectedLeftTurnConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
    MergeFrom(*source);
  }
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::MergeFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      creep_timeout_sec_ = from.creep_timeout_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_traffic_light_scenario_distance_ = from.start_traffic_light_scenario_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      approach_cruise_speed_ = from.approach_cruise_speed_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      min_pass_s_distance_ = from.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_adc_speed_before_creep_ = from.max_adc_speed_before_creep_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::CopyFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioTrafficLightUnprotectedLeftTurnConfig::IsInitialized() const {
  return true;
}

void ScenarioTrafficLightUnprotectedLeftTurnConfig::Swap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::InternalSwap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other) {
  std::swap(creep_timeout_sec_, other->creep_timeout_sec_);
  std::swap(start_traffic_light_scenario_distance_, other->start_traffic_light_scenario_distance_);
  std::swap(approach_cruise_speed_, other->approach_cruise_speed_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(min_pass_s_distance_, other->min_pass_s_distance_);
  std::swap(max_adc_speed_before_creep_, other->max_adc_speed_before_creep_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioTrafficLightUnprotectedLeftTurnConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioTrafficLightUnprotectedLeftTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
double ScenarioTrafficLightUnprotectedLeftTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
}

// optional double approach_cruise_speed = 2 [default = 2.78];
bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_approach_cruise_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_approach_cruise_speed() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_approach_cruise_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_approach_cruise_speed() {
  approach_cruise_speed_ = 2.78;
  clear_has_approach_cruise_speed();
}
double ScenarioTrafficLightUnprotectedLeftTurnConfig::approach_cruise_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.approach_cruise_speed)
  return approach_cruise_speed_;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_approach_cruise_speed(double value) {
  set_has_approach_cruise_speed();
  approach_cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.approach_cruise_speed)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 4 [default = 3];
bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
double ScenarioTrafficLightUnprotectedLeftTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 5 [default = 10];
bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
float ScenarioTrafficLightUnprotectedLeftTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
}

// optional double max_adc_speed_before_creep = 6 [default = 5.56];
bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_adc_speed_before_creep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_max_adc_speed_before_creep() {
  _has_bits_[0] |= 0x00000020u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_max_adc_speed_before_creep() {
  _has_bits_[0] &= ~0x00000020u;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_adc_speed_before_creep() {
  max_adc_speed_before_creep_ = 5.56;
  clear_has_max_adc_speed_before_creep();
}
double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_adc_speed_before_creep() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_speed_before_creep)
  return max_adc_speed_before_creep_;
}
void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_adc_speed_before_creep(double value) {
  set_has_max_adc_speed_before_creep();
  max_adc_speed_before_creep_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_speed_before_creep)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kStartTrafficLightScenarioDistanceFieldNumber;
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kEnableRightTurnOnRedFieldNumber;
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kMaxValidStopDistanceFieldNumber;
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kMinPassSDistanceFieldNumber;
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kRedLightRightTurnStopDurationSecFieldNumber;
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kCreepTimeoutSecFieldNumber;
const int ScenarioTrafficLightUnprotectedRightTurnConfig::kMaxAdcSpeedBeforeCreepFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioTrafficLightUnprotectedRightTurnConfig::ScenarioTrafficLightUnprotectedRightTurnConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
}
ScenarioTrafficLightUnprotectedRightTurnConfig::ScenarioTrafficLightUnprotectedRightTurnConfig(const ScenarioTrafficLightUnprotectedRightTurnConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&enable_right_turn_on_red_, &from.enable_right_turn_on_red_,
    reinterpret_cast<char*>(&max_adc_speed_before_creep_) -
    reinterpret_cast<char*>(&enable_right_turn_on_red_) + sizeof(max_adc_speed_before_creep_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::SharedCtor() {
  _cached_size_ = 0;
  enable_right_turn_on_red_ = false;
  start_traffic_light_scenario_distance_ = 5;
  max_valid_stop_distance_ = 3.5;
  min_pass_s_distance_ = 3;
  red_light_right_turn_stop_duration_sec_ = 3;
  creep_timeout_sec_ = 10;
  max_adc_speed_before_creep_ = 3;
}

ScenarioTrafficLightUnprotectedRightTurnConfig::~ScenarioTrafficLightUnprotectedRightTurnConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  SharedDtor();
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::SharedDtor() {
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioTrafficLightUnprotectedRightTurnConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioTrafficLightUnprotectedRightTurnConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioTrafficLightUnprotectedRightTurnConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioTrafficLightUnprotectedRightTurnConfig* n = new ScenarioTrafficLightUnprotectedRightTurnConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  if (_has_bits_[0 / 32] & 127u) {
    enable_right_turn_on_red_ = false;
    start_traffic_light_scenario_distance_ = 5;
    max_valid_stop_distance_ = 3.5;
    min_pass_s_distance_ = 3;
    red_light_right_turn_stop_duration_sec_ = 3;
    creep_timeout_sec_ = 10;
    max_adc_speed_before_creep_ = 3;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioTrafficLightUnprotectedRightTurnConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_traffic_light_scenario_distance = 1 [default = 5];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_traffic_light_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_traffic_light_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enable_right_turn_on_red = 2 [default = false];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_enable_right_turn_on_red();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_right_turn_on_red_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 3 [default = 3.5];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_pass_s_distance = 4 [default = 3];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_min_pass_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_pass_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u)) {
          set_has_red_light_right_turn_stop_duration_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &red_light_right_turn_stop_duration_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float creep_timeout_sec = 6 [default = 10];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u)) {
          set_has_creep_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &creep_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_adc_speed_before_creep = 7 [default = 3];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(57u)) {
          set_has_max_adc_speed_before_creep();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_adc_speed_before_creep_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  return false;
#undef DO_
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_traffic_light_scenario_distance(), output);
  }

  // optional bool enable_right_turn_on_red = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->enable_right_turn_on_red(), output);
  }

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->max_valid_stop_distance(), output);
  }

  // optional double min_pass_s_distance = 4 [default = 3];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->min_pass_s_distance(), output);
  }

  // optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->red_light_right_turn_stop_duration_sec(), output);
  }

  // optional float creep_timeout_sec = 6 [default = 10];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->creep_timeout_sec(), output);
  }

  // optional double max_adc_speed_before_creep = 7 [default = 3];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->max_adc_speed_before_creep(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
}

::google::protobuf::uint8* ScenarioTrafficLightUnprotectedRightTurnConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_traffic_light_scenario_distance(), target);
  }

  // optional bool enable_right_turn_on_red = 2 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->enable_right_turn_on_red(), target);
  }

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->max_valid_stop_distance(), target);
  }

  // optional double min_pass_s_distance = 4 [default = 3];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->min_pass_s_distance(), target);
  }

  // optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->red_light_right_turn_stop_duration_sec(), target);
  }

  // optional float creep_timeout_sec = 6 [default = 10];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->creep_timeout_sec(), target);
  }

  // optional double max_adc_speed_before_creep = 7 [default = 3];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->max_adc_speed_before_creep(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  return target;
}

size_t ScenarioTrafficLightUnprotectedRightTurnConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 127u) {
    // optional bool enable_right_turn_on_red = 2 [default = false];
    if (has_enable_right_turn_on_red()) {
      total_size += 1 + 1;
    }

    // optional double start_traffic_light_scenario_distance = 1 [default = 5];
    if (has_start_traffic_light_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 3 [default = 3.5];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 4 [default = 3];
    if (has_min_pass_s_distance()) {
      total_size += 1 + 8;
    }

    // optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
    if (has_red_light_right_turn_stop_duration_sec()) {
      total_size += 1 + 4;
    }

    // optional float creep_timeout_sec = 6 [default = 10];
    if (has_creep_timeout_sec()) {
      total_size += 1 + 4;
    }

    // optional double max_adc_speed_before_creep = 7 [default = 3];
    if (has_max_adc_speed_before_creep()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioTrafficLightUnprotectedRightTurnConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioTrafficLightUnprotectedRightTurnConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
    MergeFrom(*source);
  }
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::MergeFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      enable_right_turn_on_red_ = from.enable_right_turn_on_red_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_traffic_light_scenario_distance_ = from.start_traffic_light_scenario_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_pass_s_distance_ = from.min_pass_s_distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      red_light_right_turn_stop_duration_sec_ = from.red_light_right_turn_stop_duration_sec_;
    }
    if (cached_has_bits & 0x00000020u) {
      creep_timeout_sec_ = from.creep_timeout_sec_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_adc_speed_before_creep_ = from.max_adc_speed_before_creep_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::CopyFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioTrafficLightUnprotectedRightTurnConfig::IsInitialized() const {
  return true;
}

void ScenarioTrafficLightUnprotectedRightTurnConfig::Swap(ScenarioTrafficLightUnprotectedRightTurnConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::InternalSwap(ScenarioTrafficLightUnprotectedRightTurnConfig* other) {
  std::swap(enable_right_turn_on_red_, other->enable_right_turn_on_red_);
  std::swap(start_traffic_light_scenario_distance_, other->start_traffic_light_scenario_distance_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(min_pass_s_distance_, other->min_pass_s_distance_);
  std::swap(red_light_right_turn_stop_duration_sec_, other->red_light_right_turn_stop_duration_sec_);
  std::swap(creep_timeout_sec_, other->creep_timeout_sec_);
  std::swap(max_adc_speed_before_creep_, other->max_adc_speed_before_creep_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioTrafficLightUnprotectedRightTurnConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioTrafficLightUnprotectedRightTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
double ScenarioTrafficLightUnprotectedRightTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
}

// optional bool enable_right_turn_on_red = 2 [default = false];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_enable_right_turn_on_red() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_enable_right_turn_on_red() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_enable_right_turn_on_red() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_enable_right_turn_on_red() {
  enable_right_turn_on_red_ = false;
  clear_has_enable_right_turn_on_red();
}
bool ScenarioTrafficLightUnprotectedRightTurnConfig::enable_right_turn_on_red() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
  return enable_right_turn_on_red_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_enable_right_turn_on_red(bool value) {
  set_has_enable_right_turn_on_red();
  enable_right_turn_on_red_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
double ScenarioTrafficLightUnprotectedRightTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 4 [default = 3];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
double ScenarioTrafficLightUnprotectedRightTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
}

// optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_red_light_right_turn_stop_duration_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_red_light_right_turn_stop_duration_sec() {
  _has_bits_[0] |= 0x00000010u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_red_light_right_turn_stop_duration_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_red_light_right_turn_stop_duration_sec() {
  red_light_right_turn_stop_duration_sec_ = 3;
  clear_has_red_light_right_turn_stop_duration_sec();
}
float ScenarioTrafficLightUnprotectedRightTurnConfig::red_light_right_turn_stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
  return red_light_right_turn_stop_duration_sec_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_red_light_right_turn_stop_duration_sec(float value) {
  set_has_red_light_right_turn_stop_duration_sec();
  red_light_right_turn_stop_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
}

// optional float creep_timeout_sec = 6 [default = 10];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000020u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
float ScenarioTrafficLightUnprotectedRightTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
}

// optional double max_adc_speed_before_creep = 7 [default = 3];
bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_adc_speed_before_creep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_max_adc_speed_before_creep() {
  _has_bits_[0] |= 0x00000040u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_max_adc_speed_before_creep() {
  _has_bits_[0] &= ~0x00000040u;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_adc_speed_before_creep() {
  max_adc_speed_before_creep_ = 3;
  clear_has_max_adc_speed_before_creep();
}
double ScenarioTrafficLightUnprotectedRightTurnConfig::max_adc_speed_before_creep() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_speed_before_creep)
  return max_adc_speed_before_creep_;
}
void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_adc_speed_before_creep(double value) {
  set_has_max_adc_speed_before_creep();
  max_adc_speed_before_creep_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_speed_before_creep)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioPullOverConfig::kStartPullOverScenarioDistanceFieldNumber;
const int ScenarioPullOverConfig::kPullOverMinDistanceBufferFieldNumber;
const int ScenarioPullOverConfig::kMaxDistanceStopSearchFieldNumber;
const int ScenarioPullOverConfig::kMaxSErrorToEndPointFieldNumber;
const int ScenarioPullOverConfig::kMaxLErrorToEndPointFieldNumber;
const int ScenarioPullOverConfig::kMaxThetaErrorToEndPointFieldNumber;
const int ScenarioPullOverConfig::kMaxDistanceErrorToEndPointFieldNumber;
const int ScenarioPullOverConfig::kPassDestinationThresholdFieldNumber;
const int ScenarioPullOverConfig::kMaxValidStopDistanceFieldNumber;
const int ScenarioPullOverConfig::kSDistanceToStopForOpenSpaceParkingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioPullOverConfig::ScenarioPullOverConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioPullOverConfig)
}
ScenarioPullOverConfig::ScenarioPullOverConfig(const ScenarioPullOverConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&start_pull_over_scenario_distance_, &from.start_pull_over_scenario_distance_,
    reinterpret_cast<char*>(&s_distance_to_stop_for_open_space_parking_) -
    reinterpret_cast<char*>(&start_pull_over_scenario_distance_) + sizeof(s_distance_to_stop_for_open_space_parking_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioPullOverConfig)
}

void ScenarioPullOverConfig::SharedCtor() {
  _cached_size_ = 0;
  start_pull_over_scenario_distance_ = 50;
  pull_over_min_distance_buffer_ = 10;
  max_distance_stop_search_ = 25;
  max_s_error_to_end_point_ = 0.2;
  max_l_error_to_end_point_ = 0.5;
  max_theta_error_to_end_point_ = 0.2;
  max_distance_error_to_end_point_ = 0.2;
  pass_destination_threshold_ = 10;
  max_valid_stop_distance_ = 1;
  s_distance_to_stop_for_open_space_parking_ = 7;
}

ScenarioPullOverConfig::~ScenarioPullOverConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioPullOverConfig)
  SharedDtor();
}

void ScenarioPullOverConfig::SharedDtor() {
}

void ScenarioPullOverConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioPullOverConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioPullOverConfig& ScenarioPullOverConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioPullOverConfig* ScenarioPullOverConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioPullOverConfig* n = new ScenarioPullOverConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioPullOverConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioPullOverConfig)
  if (_has_bits_[0 / 32] & 255u) {
    start_pull_over_scenario_distance_ = 50;
    pull_over_min_distance_buffer_ = 10;
    max_distance_stop_search_ = 25;
    max_s_error_to_end_point_ = 0.2;
    max_l_error_to_end_point_ = 0.5;
    max_theta_error_to_end_point_ = 0.2;
    max_distance_error_to_end_point_ = 0.2;
    pass_destination_threshold_ = 10;
  }
  if (_has_bits_[8 / 32] & 768u) {
    max_valid_stop_distance_ = 1;
    s_distance_to_stop_for_open_space_parking_ = 7;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioPullOverConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioPullOverConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_pull_over_scenario_distance = 1 [default = 50];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_pull_over_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_pull_over_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double pull_over_min_distance_buffer = 2 [default = 10];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_pull_over_min_distance_buffer();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &pull_over_min_distance_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_distance_stop_search = 3 [default = 25];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_max_distance_stop_search();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_distance_stop_search_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_s_error_to_end_point = 4 [default = 0.2];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_max_s_error_to_end_point();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_s_error_to_end_point_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_l_error_to_end_point = 5 [default = 0.5];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(41u)) {
          set_has_max_l_error_to_end_point();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_l_error_to_end_point_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_theta_error_to_end_point = 6 [default = 0.2];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(49u)) {
          set_has_max_theta_error_to_end_point();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_theta_error_to_end_point_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_distance_error_to_end_point = 7 [default = 0.2];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(57u)) {
          set_has_max_distance_error_to_end_point();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_distance_error_to_end_point_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double pass_destination_threshold = 8 [default = 10];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(65u)) {
          set_has_pass_destination_threshold();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &pass_destination_threshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 9 [default = 1];
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(73u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(81u)) {
          set_has_s_distance_to_stop_for_open_space_parking();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &s_distance_to_stop_for_open_space_parking_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioPullOverConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioPullOverConfig)
  return false;
#undef DO_
}

void ScenarioPullOverConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioPullOverConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_pull_over_scenario_distance = 1 [default = 50];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_pull_over_scenario_distance(), output);
  }

  // optional double pull_over_min_distance_buffer = 2 [default = 10];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->pull_over_min_distance_buffer(), output);
  }

  // optional double max_distance_stop_search = 3 [default = 25];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->max_distance_stop_search(), output);
  }

  // optional double max_s_error_to_end_point = 4 [default = 0.2];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->max_s_error_to_end_point(), output);
  }

  // optional double max_l_error_to_end_point = 5 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->max_l_error_to_end_point(), output);
  }

  // optional double max_theta_error_to_end_point = 6 [default = 0.2];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->max_theta_error_to_end_point(), output);
  }

  // optional double max_distance_error_to_end_point = 7 [default = 0.2];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->max_distance_error_to_end_point(), output);
  }

  // optional double pass_destination_threshold = 8 [default = 10];
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->pass_destination_threshold(), output);
  }

  // optional double max_valid_stop_distance = 9 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->max_valid_stop_distance(), output);
  }

  // optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->s_distance_to_stop_for_open_space_parking(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioPullOverConfig)
}

::google::protobuf::uint8* ScenarioPullOverConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioPullOverConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_pull_over_scenario_distance = 1 [default = 50];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_pull_over_scenario_distance(), target);
  }

  // optional double pull_over_min_distance_buffer = 2 [default = 10];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->pull_over_min_distance_buffer(), target);
  }

  // optional double max_distance_stop_search = 3 [default = 25];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->max_distance_stop_search(), target);
  }

  // optional double max_s_error_to_end_point = 4 [default = 0.2];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->max_s_error_to_end_point(), target);
  }

  // optional double max_l_error_to_end_point = 5 [default = 0.5];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->max_l_error_to_end_point(), target);
  }

  // optional double max_theta_error_to_end_point = 6 [default = 0.2];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->max_theta_error_to_end_point(), target);
  }

  // optional double max_distance_error_to_end_point = 7 [default = 0.2];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->max_distance_error_to_end_point(), target);
  }

  // optional double pass_destination_threshold = 8 [default = 10];
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->pass_destination_threshold(), target);
  }

  // optional double max_valid_stop_distance = 9 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->max_valid_stop_distance(), target);
  }

  // optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->s_distance_to_stop_for_open_space_parking(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioPullOverConfig)
  return target;
}

size_t ScenarioPullOverConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioPullOverConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional double start_pull_over_scenario_distance = 1 [default = 50];
    if (has_start_pull_over_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double pull_over_min_distance_buffer = 2 [default = 10];
    if (has_pull_over_min_distance_buffer()) {
      total_size += 1 + 8;
    }

    // optional double max_distance_stop_search = 3 [default = 25];
    if (has_max_distance_stop_search()) {
      total_size += 1 + 8;
    }

    // optional double max_s_error_to_end_point = 4 [default = 0.2];
    if (has_max_s_error_to_end_point()) {
      total_size += 1 + 8;
    }

    // optional double max_l_error_to_end_point = 5 [default = 0.5];
    if (has_max_l_error_to_end_point()) {
      total_size += 1 + 8;
    }

    // optional double max_theta_error_to_end_point = 6 [default = 0.2];
    if (has_max_theta_error_to_end_point()) {
      total_size += 1 + 8;
    }

    // optional double max_distance_error_to_end_point = 7 [default = 0.2];
    if (has_max_distance_error_to_end_point()) {
      total_size += 1 + 8;
    }

    // optional double pass_destination_threshold = 8 [default = 10];
    if (has_pass_destination_threshold()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional double max_valid_stop_distance = 9 [default = 1];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
    if (has_s_distance_to_stop_for_open_space_parking()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioPullOverConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioPullOverConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioPullOverConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioPullOverConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioPullOverConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioPullOverConfig)
    MergeFrom(*source);
  }
}

void ScenarioPullOverConfig::MergeFrom(const ScenarioPullOverConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioPullOverConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      start_pull_over_scenario_distance_ = from.start_pull_over_scenario_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      pull_over_min_distance_buffer_ = from.pull_over_min_distance_buffer_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_distance_stop_search_ = from.max_distance_stop_search_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_s_error_to_end_point_ = from.max_s_error_to_end_point_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_l_error_to_end_point_ = from.max_l_error_to_end_point_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_theta_error_to_end_point_ = from.max_theta_error_to_end_point_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_distance_error_to_end_point_ = from.max_distance_error_to_end_point_;
    }
    if (cached_has_bits & 0x00000080u) {
      pass_destination_threshold_ = from.pass_destination_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 768u) {
    if (cached_has_bits & 0x00000100u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000200u) {
      s_distance_to_stop_for_open_space_parking_ = from.s_distance_to_stop_for_open_space_parking_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioPullOverConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioPullOverConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioPullOverConfig::CopyFrom(const ScenarioPullOverConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioPullOverConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioPullOverConfig::IsInitialized() const {
  return true;
}

void ScenarioPullOverConfig::Swap(ScenarioPullOverConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioPullOverConfig::InternalSwap(ScenarioPullOverConfig* other) {
  std::swap(start_pull_over_scenario_distance_, other->start_pull_over_scenario_distance_);
  std::swap(pull_over_min_distance_buffer_, other->pull_over_min_distance_buffer_);
  std::swap(max_distance_stop_search_, other->max_distance_stop_search_);
  std::swap(max_s_error_to_end_point_, other->max_s_error_to_end_point_);
  std::swap(max_l_error_to_end_point_, other->max_l_error_to_end_point_);
  std::swap(max_theta_error_to_end_point_, other->max_theta_error_to_end_point_);
  std::swap(max_distance_error_to_end_point_, other->max_distance_error_to_end_point_);
  std::swap(pass_destination_threshold_, other->pass_destination_threshold_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(s_distance_to_stop_for_open_space_parking_, other->s_distance_to_stop_for_open_space_parking_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioPullOverConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioPullOverConfig

// optional double start_pull_over_scenario_distance = 1 [default = 50];
bool ScenarioPullOverConfig::has_start_pull_over_scenario_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioPullOverConfig::set_has_start_pull_over_scenario_distance() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioPullOverConfig::clear_has_start_pull_over_scenario_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioPullOverConfig::clear_start_pull_over_scenario_distance() {
  start_pull_over_scenario_distance_ = 50;
  clear_has_start_pull_over_scenario_distance();
}
double ScenarioPullOverConfig::start_pull_over_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
  return start_pull_over_scenario_distance_;
}
void ScenarioPullOverConfig::set_start_pull_over_scenario_distance(double value) {
  set_has_start_pull_over_scenario_distance();
  start_pull_over_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
}

// optional double pull_over_min_distance_buffer = 2 [default = 10];
bool ScenarioPullOverConfig::has_pull_over_min_distance_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioPullOverConfig::set_has_pull_over_min_distance_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioPullOverConfig::clear_has_pull_over_min_distance_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioPullOverConfig::clear_pull_over_min_distance_buffer() {
  pull_over_min_distance_buffer_ = 10;
  clear_has_pull_over_min_distance_buffer();
}
double ScenarioPullOverConfig::pull_over_min_distance_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
  return pull_over_min_distance_buffer_;
}
void ScenarioPullOverConfig::set_pull_over_min_distance_buffer(double value) {
  set_has_pull_over_min_distance_buffer();
  pull_over_min_distance_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
}

// optional double max_distance_stop_search = 3 [default = 25];
bool ScenarioPullOverConfig::has_max_distance_stop_search() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioPullOverConfig::set_has_max_distance_stop_search() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioPullOverConfig::clear_has_max_distance_stop_search() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioPullOverConfig::clear_max_distance_stop_search() {
  max_distance_stop_search_ = 25;
  clear_has_max_distance_stop_search();
}
double ScenarioPullOverConfig::max_distance_stop_search() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_distance_stop_search)
  return max_distance_stop_search_;
}
void ScenarioPullOverConfig::set_max_distance_stop_search(double value) {
  set_has_max_distance_stop_search();
  max_distance_stop_search_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_distance_stop_search)
}

// optional double max_s_error_to_end_point = 4 [default = 0.2];
bool ScenarioPullOverConfig::has_max_s_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioPullOverConfig::set_has_max_s_error_to_end_point() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioPullOverConfig::clear_has_max_s_error_to_end_point() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioPullOverConfig::clear_max_s_error_to_end_point() {
  max_s_error_to_end_point_ = 0.2;
  clear_has_max_s_error_to_end_point();
}
double ScenarioPullOverConfig::max_s_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
  return max_s_error_to_end_point_;
}
void ScenarioPullOverConfig::set_max_s_error_to_end_point(double value) {
  set_has_max_s_error_to_end_point();
  max_s_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
}

// optional double max_l_error_to_end_point = 5 [default = 0.5];
bool ScenarioPullOverConfig::has_max_l_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ScenarioPullOverConfig::set_has_max_l_error_to_end_point() {
  _has_bits_[0] |= 0x00000010u;
}
void ScenarioPullOverConfig::clear_has_max_l_error_to_end_point() {
  _has_bits_[0] &= ~0x00000010u;
}
void ScenarioPullOverConfig::clear_max_l_error_to_end_point() {
  max_l_error_to_end_point_ = 0.5;
  clear_has_max_l_error_to_end_point();
}
double ScenarioPullOverConfig::max_l_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
  return max_l_error_to_end_point_;
}
void ScenarioPullOverConfig::set_max_l_error_to_end_point(double value) {
  set_has_max_l_error_to_end_point();
  max_l_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
}

// optional double max_theta_error_to_end_point = 6 [default = 0.2];
bool ScenarioPullOverConfig::has_max_theta_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ScenarioPullOverConfig::set_has_max_theta_error_to_end_point() {
  _has_bits_[0] |= 0x00000020u;
}
void ScenarioPullOverConfig::clear_has_max_theta_error_to_end_point() {
  _has_bits_[0] &= ~0x00000020u;
}
void ScenarioPullOverConfig::clear_max_theta_error_to_end_point() {
  max_theta_error_to_end_point_ = 0.2;
  clear_has_max_theta_error_to_end_point();
}
double ScenarioPullOverConfig::max_theta_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
  return max_theta_error_to_end_point_;
}
void ScenarioPullOverConfig::set_max_theta_error_to_end_point(double value) {
  set_has_max_theta_error_to_end_point();
  max_theta_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
}

// optional double max_distance_error_to_end_point = 7 [default = 0.2];
bool ScenarioPullOverConfig::has_max_distance_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ScenarioPullOverConfig::set_has_max_distance_error_to_end_point() {
  _has_bits_[0] |= 0x00000040u;
}
void ScenarioPullOverConfig::clear_has_max_distance_error_to_end_point() {
  _has_bits_[0] &= ~0x00000040u;
}
void ScenarioPullOverConfig::clear_max_distance_error_to_end_point() {
  max_distance_error_to_end_point_ = 0.2;
  clear_has_max_distance_error_to_end_point();
}
double ScenarioPullOverConfig::max_distance_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
  return max_distance_error_to_end_point_;
}
void ScenarioPullOverConfig::set_max_distance_error_to_end_point(double value) {
  set_has_max_distance_error_to_end_point();
  max_distance_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
}

// optional double pass_destination_threshold = 8 [default = 10];
bool ScenarioPullOverConfig::has_pass_destination_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ScenarioPullOverConfig::set_has_pass_destination_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
void ScenarioPullOverConfig::clear_has_pass_destination_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
void ScenarioPullOverConfig::clear_pass_destination_threshold() {
  pass_destination_threshold_ = 10;
  clear_has_pass_destination_threshold();
}
double ScenarioPullOverConfig::pass_destination_threshold() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.pass_destination_threshold)
  return pass_destination_threshold_;
}
void ScenarioPullOverConfig::set_pass_destination_threshold(double value) {
  set_has_pass_destination_threshold();
  pass_destination_threshold_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.pass_destination_threshold)
}

// optional double max_valid_stop_distance = 9 [default = 1];
bool ScenarioPullOverConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ScenarioPullOverConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000100u;
}
void ScenarioPullOverConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000100u;
}
void ScenarioPullOverConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
double ScenarioPullOverConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioPullOverConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_valid_stop_distance)
}

// optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
bool ScenarioPullOverConfig::has_s_distance_to_stop_for_open_space_parking() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ScenarioPullOverConfig::set_has_s_distance_to_stop_for_open_space_parking() {
  _has_bits_[0] |= 0x00000200u;
}
void ScenarioPullOverConfig::clear_has_s_distance_to_stop_for_open_space_parking() {
  _has_bits_[0] &= ~0x00000200u;
}
void ScenarioPullOverConfig::clear_s_distance_to_stop_for_open_space_parking() {
  s_distance_to_stop_for_open_space_parking_ = 7;
  clear_has_s_distance_to_stop_for_open_space_parking();
}
double ScenarioPullOverConfig::s_distance_to_stop_for_open_space_parking() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
  return s_distance_to_stop_for_open_space_parking_;
}
void ScenarioPullOverConfig::set_s_distance_to_stop_for_open_space_parking(double value) {
  set_has_s_distance_to_stop_for_open_space_parking();
  s_distance_to_stop_for_open_space_parking_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioEmergencyPullOverConfig::kMaxStopDecelerationFieldNumber;
const int ScenarioEmergencyPullOverConfig::kSlowDownDecelerationTimeFieldNumber;
const int ScenarioEmergencyPullOverConfig::kTargetSlowDownSpeedFieldNumber;
const int ScenarioEmergencyPullOverConfig::kStopDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioEmergencyPullOverConfig::ScenarioEmergencyPullOverConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
}
ScenarioEmergencyPullOverConfig::ScenarioEmergencyPullOverConfig(const ScenarioEmergencyPullOverConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&max_stop_deceleration_, &from.max_stop_deceleration_,
    reinterpret_cast<char*>(&stop_distance_) -
    reinterpret_cast<char*>(&max_stop_deceleration_) + sizeof(stop_distance_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
}

void ScenarioEmergencyPullOverConfig::SharedCtor() {
  _cached_size_ = 0;
  max_stop_deceleration_ = 3;
  slow_down_deceleration_time_ = 3;
  target_slow_down_speed_ = 2.5;
  stop_distance_ = 1.5;
}

ScenarioEmergencyPullOverConfig::~ScenarioEmergencyPullOverConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  SharedDtor();
}

void ScenarioEmergencyPullOverConfig::SharedDtor() {
}

void ScenarioEmergencyPullOverConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioEmergencyPullOverConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioEmergencyPullOverConfig& ScenarioEmergencyPullOverConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioEmergencyPullOverConfig* ScenarioEmergencyPullOverConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioEmergencyPullOverConfig* n = new ScenarioEmergencyPullOverConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioEmergencyPullOverConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  if (_has_bits_[0 / 32] & 15u) {
    max_stop_deceleration_ = 3;
    slow_down_deceleration_time_ = 3;
    target_slow_down_speed_ = 2.5;
    stop_distance_ = 1.5;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioEmergencyPullOverConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double max_stop_deceleration = 1 [default = 3];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_max_stop_deceleration();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_stop_deceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double slow_down_deceleration_time = 2 [default = 3];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_slow_down_deceleration_time();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &slow_down_deceleration_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double target_slow_down_speed = 3 [default = 2.5];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_target_slow_down_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &target_slow_down_speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double stop_distance = 4 [default = 1.5];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  return false;
#undef DO_
}

void ScenarioEmergencyPullOverConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double max_stop_deceleration = 1 [default = 3];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->max_stop_deceleration(), output);
  }

  // optional double slow_down_deceleration_time = 2 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->slow_down_deceleration_time(), output);
  }

  // optional double target_slow_down_speed = 3 [default = 2.5];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->target_slow_down_speed(), output);
  }

  // optional double stop_distance = 4 [default = 1.5];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->stop_distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
}

::google::protobuf::uint8* ScenarioEmergencyPullOverConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double max_stop_deceleration = 1 [default = 3];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->max_stop_deceleration(), target);
  }

  // optional double slow_down_deceleration_time = 2 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->slow_down_deceleration_time(), target);
  }

  // optional double target_slow_down_speed = 3 [default = 2.5];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->target_slow_down_speed(), target);
  }

  // optional double stop_distance = 4 [default = 1.5];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->stop_distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  return target;
}

size_t ScenarioEmergencyPullOverConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional double max_stop_deceleration = 1 [default = 3];
    if (has_max_stop_deceleration()) {
      total_size += 1 + 8;
    }

    // optional double slow_down_deceleration_time = 2 [default = 3];
    if (has_slow_down_deceleration_time()) {
      total_size += 1 + 8;
    }

    // optional double target_slow_down_speed = 3 [default = 2.5];
    if (has_target_slow_down_speed()) {
      total_size += 1 + 8;
    }

    // optional double stop_distance = 4 [default = 1.5];
    if (has_stop_distance()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioEmergencyPullOverConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioEmergencyPullOverConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioEmergencyPullOverConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
    MergeFrom(*source);
  }
}

void ScenarioEmergencyPullOverConfig::MergeFrom(const ScenarioEmergencyPullOverConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      max_stop_deceleration_ = from.max_stop_deceleration_;
    }
    if (cached_has_bits & 0x00000002u) {
      slow_down_deceleration_time_ = from.slow_down_deceleration_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      target_slow_down_speed_ = from.target_slow_down_speed_;
    }
    if (cached_has_bits & 0x00000008u) {
      stop_distance_ = from.stop_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioEmergencyPullOverConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioEmergencyPullOverConfig::CopyFrom(const ScenarioEmergencyPullOverConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioEmergencyPullOverConfig::IsInitialized() const {
  return true;
}

void ScenarioEmergencyPullOverConfig::Swap(ScenarioEmergencyPullOverConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioEmergencyPullOverConfig::InternalSwap(ScenarioEmergencyPullOverConfig* other) {
  std::swap(max_stop_deceleration_, other->max_stop_deceleration_);
  std::swap(slow_down_deceleration_time_, other->slow_down_deceleration_time_);
  std::swap(target_slow_down_speed_, other->target_slow_down_speed_);
  std::swap(stop_distance_, other->stop_distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioEmergencyPullOverConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioEmergencyPullOverConfig

// optional double max_stop_deceleration = 1 [default = 3];
bool ScenarioEmergencyPullOverConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioEmergencyPullOverConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioEmergencyPullOverConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioEmergencyPullOverConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 3;
  clear_has_max_stop_deceleration();
}
double ScenarioEmergencyPullOverConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
void ScenarioEmergencyPullOverConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.max_stop_deceleration)
}

// optional double slow_down_deceleration_time = 2 [default = 3];
bool ScenarioEmergencyPullOverConfig::has_slow_down_deceleration_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioEmergencyPullOverConfig::set_has_slow_down_deceleration_time() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioEmergencyPullOverConfig::clear_has_slow_down_deceleration_time() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioEmergencyPullOverConfig::clear_slow_down_deceleration_time() {
  slow_down_deceleration_time_ = 3;
  clear_has_slow_down_deceleration_time();
}
double ScenarioEmergencyPullOverConfig::slow_down_deceleration_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.slow_down_deceleration_time)
  return slow_down_deceleration_time_;
}
void ScenarioEmergencyPullOverConfig::set_slow_down_deceleration_time(double value) {
  set_has_slow_down_deceleration_time();
  slow_down_deceleration_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.slow_down_deceleration_time)
}

// optional double target_slow_down_speed = 3 [default = 2.5];
bool ScenarioEmergencyPullOverConfig::has_target_slow_down_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioEmergencyPullOverConfig::set_has_target_slow_down_speed() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioEmergencyPullOverConfig::clear_has_target_slow_down_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioEmergencyPullOverConfig::clear_target_slow_down_speed() {
  target_slow_down_speed_ = 2.5;
  clear_has_target_slow_down_speed();
}
double ScenarioEmergencyPullOverConfig::target_slow_down_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.target_slow_down_speed)
  return target_slow_down_speed_;
}
void ScenarioEmergencyPullOverConfig::set_target_slow_down_speed(double value) {
  set_has_target_slow_down_speed();
  target_slow_down_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.target_slow_down_speed)
}

// optional double stop_distance = 4 [default = 1.5];
bool ScenarioEmergencyPullOverConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioEmergencyPullOverConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioEmergencyPullOverConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioEmergencyPullOverConfig::clear_stop_distance() {
  stop_distance_ = 1.5;
  clear_has_stop_distance();
}
double ScenarioEmergencyPullOverConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.stop_distance)
  return stop_distance_;
}
void ScenarioEmergencyPullOverConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.stop_distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioEmergencyStopConfig::kMaxStopDecelerationFieldNumber;
const int ScenarioEmergencyStopConfig::kStopDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioEmergencyStopConfig::ScenarioEmergencyStopConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioEmergencyStopConfig)
}
ScenarioEmergencyStopConfig::ScenarioEmergencyStopConfig(const ScenarioEmergencyStopConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&max_stop_deceleration_, &from.max_stop_deceleration_,
    reinterpret_cast<char*>(&stop_distance_) -
    reinterpret_cast<char*>(&max_stop_deceleration_) + sizeof(stop_distance_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioEmergencyStopConfig)
}

void ScenarioEmergencyStopConfig::SharedCtor() {
  _cached_size_ = 0;
  max_stop_deceleration_ = 6;
  stop_distance_ = 1;
}

ScenarioEmergencyStopConfig::~ScenarioEmergencyStopConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioEmergencyStopConfig)
  SharedDtor();
}

void ScenarioEmergencyStopConfig::SharedDtor() {
}

void ScenarioEmergencyStopConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioEmergencyStopConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioEmergencyStopConfig& ScenarioEmergencyStopConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioEmergencyStopConfig* ScenarioEmergencyStopConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioEmergencyStopConfig* n = new ScenarioEmergencyStopConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioEmergencyStopConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  if (_has_bits_[0 / 32] & 3u) {
    max_stop_deceleration_ = 6;
    stop_distance_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioEmergencyStopConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double max_stop_deceleration = 1 [default = 6];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_max_stop_deceleration();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_stop_deceleration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double stop_distance = 2 [default = 1];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioEmergencyStopConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioEmergencyStopConfig)
  return false;
#undef DO_
}

void ScenarioEmergencyStopConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double max_stop_deceleration = 1 [default = 6];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->max_stop_deceleration(), output);
  }

  // optional double stop_distance = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->stop_distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioEmergencyStopConfig)
}

::google::protobuf::uint8* ScenarioEmergencyStopConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double max_stop_deceleration = 1 [default = 6];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->max_stop_deceleration(), target);
  }

  // optional double stop_distance = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->stop_distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioEmergencyStopConfig)
  return target;
}

size_t ScenarioEmergencyStopConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional double max_stop_deceleration = 1 [default = 6];
    if (has_max_stop_deceleration()) {
      total_size += 1 + 8;
    }

    // optional double stop_distance = 2 [default = 1];
    if (has_stop_distance()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioEmergencyStopConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioEmergencyStopConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioEmergencyStopConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioEmergencyStopConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioEmergencyStopConfig)
    MergeFrom(*source);
  }
}

void ScenarioEmergencyStopConfig::MergeFrom(const ScenarioEmergencyStopConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      max_stop_deceleration_ = from.max_stop_deceleration_;
    }
    if (cached_has_bits & 0x00000002u) {
      stop_distance_ = from.stop_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioEmergencyStopConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioEmergencyStopConfig::CopyFrom(const ScenarioEmergencyStopConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioEmergencyStopConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioEmergencyStopConfig::IsInitialized() const {
  return true;
}

void ScenarioEmergencyStopConfig::Swap(ScenarioEmergencyStopConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioEmergencyStopConfig::InternalSwap(ScenarioEmergencyStopConfig* other) {
  std::swap(max_stop_deceleration_, other->max_stop_deceleration_);
  std::swap(stop_distance_, other->stop_distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioEmergencyStopConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioEmergencyStopConfig

// optional double max_stop_deceleration = 1 [default = 6];
bool ScenarioEmergencyStopConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioEmergencyStopConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioEmergencyStopConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioEmergencyStopConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 6;
  clear_has_max_stop_deceleration();
}
double ScenarioEmergencyStopConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyStopConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
void ScenarioEmergencyStopConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyStopConfig.max_stop_deceleration)
}

// optional double stop_distance = 2 [default = 1];
bool ScenarioEmergencyStopConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioEmergencyStopConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioEmergencyStopConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioEmergencyStopConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
double ScenarioEmergencyStopConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyStopConfig.stop_distance)
  return stop_distance_;
}
void ScenarioEmergencyStopConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyStopConfig.stop_distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioValetParkingConfig::kParkingSpotRangeToStartFieldNumber;
const int ScenarioValetParkingConfig::kMaxValidStopDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioValetParkingConfig::ScenarioValetParkingConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioValetParkingConfig)
}
ScenarioValetParkingConfig::ScenarioValetParkingConfig(const ScenarioValetParkingConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&parking_spot_range_to_start_, &from.parking_spot_range_to_start_,
    reinterpret_cast<char*>(&max_valid_stop_distance_) -
    reinterpret_cast<char*>(&parking_spot_range_to_start_) + sizeof(max_valid_stop_distance_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioValetParkingConfig)
}

void ScenarioValetParkingConfig::SharedCtor() {
  _cached_size_ = 0;
  parking_spot_range_to_start_ = 20;
  max_valid_stop_distance_ = 1;
}

ScenarioValetParkingConfig::~ScenarioValetParkingConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioValetParkingConfig)
  SharedDtor();
}

void ScenarioValetParkingConfig::SharedDtor() {
}

void ScenarioValetParkingConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioValetParkingConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioValetParkingConfig& ScenarioValetParkingConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioValetParkingConfig* ScenarioValetParkingConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioValetParkingConfig* n = new ScenarioValetParkingConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioValetParkingConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioValetParkingConfig)
  if (_has_bits_[0 / 32] & 3u) {
    parking_spot_range_to_start_ = 20;
    max_valid_stop_distance_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioValetParkingConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioValetParkingConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double parking_spot_range_to_start = 1 [default = 20];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_parking_spot_range_to_start();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &parking_spot_range_to_start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 2 [default = 1];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioValetParkingConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioValetParkingConfig)
  return false;
#undef DO_
}

void ScenarioValetParkingConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioValetParkingConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double parking_spot_range_to_start = 1 [default = 20];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->parking_spot_range_to_start(), output);
  }

  // optional double max_valid_stop_distance = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->max_valid_stop_distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioValetParkingConfig)
}

::google::protobuf::uint8* ScenarioValetParkingConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioValetParkingConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double parking_spot_range_to_start = 1 [default = 20];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->parking_spot_range_to_start(), target);
  }

  // optional double max_valid_stop_distance = 2 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->max_valid_stop_distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioValetParkingConfig)
  return target;
}

size_t ScenarioValetParkingConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioValetParkingConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional double parking_spot_range_to_start = 1 [default = 20];
    if (has_parking_spot_range_to_start()) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 2 [default = 1];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioValetParkingConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioValetParkingConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioValetParkingConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioValetParkingConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioValetParkingConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioValetParkingConfig)
    MergeFrom(*source);
  }
}

void ScenarioValetParkingConfig::MergeFrom(const ScenarioValetParkingConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioValetParkingConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      parking_spot_range_to_start_ = from.parking_spot_range_to_start_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioValetParkingConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioValetParkingConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioValetParkingConfig::CopyFrom(const ScenarioValetParkingConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioValetParkingConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioValetParkingConfig::IsInitialized() const {
  return true;
}

void ScenarioValetParkingConfig::Swap(ScenarioValetParkingConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioValetParkingConfig::InternalSwap(ScenarioValetParkingConfig* other) {
  std::swap(parking_spot_range_to_start_, other->parking_spot_range_to_start_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioValetParkingConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioValetParkingConfig

// optional double parking_spot_range_to_start = 1 [default = 20];
bool ScenarioValetParkingConfig::has_parking_spot_range_to_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioValetParkingConfig::set_has_parking_spot_range_to_start() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioValetParkingConfig::clear_has_parking_spot_range_to_start() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioValetParkingConfig::clear_parking_spot_range_to_start() {
  parking_spot_range_to_start_ = 20;
  clear_has_parking_spot_range_to_start();
}
double ScenarioValetParkingConfig::parking_spot_range_to_start() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
  return parking_spot_range_to_start_;
}
void ScenarioValetParkingConfig::set_parking_spot_range_to_start(double value) {
  set_has_parking_spot_range_to_start();
  parking_spot_range_to_start_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
}

// optional double max_valid_stop_distance = 2 [default = 1];
bool ScenarioValetParkingConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioValetParkingConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioValetParkingConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioValetParkingConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
double ScenarioValetParkingConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioValetParkingConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioNarrowStreetUTurnConfig::ScenarioNarrowStreetUTurnConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
}
ScenarioNarrowStreetUTurnConfig::ScenarioNarrowStreetUTurnConfig(const ScenarioNarrowStreetUTurnConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
}

void ScenarioNarrowStreetUTurnConfig::SharedCtor() {
  _cached_size_ = 0;
}

ScenarioNarrowStreetUTurnConfig::~ScenarioNarrowStreetUTurnConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  SharedDtor();
}

void ScenarioNarrowStreetUTurnConfig::SharedDtor() {
}

void ScenarioNarrowStreetUTurnConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioNarrowStreetUTurnConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioNarrowStreetUTurnConfig& ScenarioNarrowStreetUTurnConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioNarrowStreetUTurnConfig* ScenarioNarrowStreetUTurnConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioNarrowStreetUTurnConfig* n = new ScenarioNarrowStreetUTurnConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioNarrowStreetUTurnConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioNarrowStreetUTurnConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  return false;
#undef DO_
}

void ScenarioNarrowStreetUTurnConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
}

::google::protobuf::uint8* ScenarioNarrowStreetUTurnConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  return target;
}

size_t ScenarioNarrowStreetUTurnConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioNarrowStreetUTurnConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioNarrowStreetUTurnConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioNarrowStreetUTurnConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
    MergeFrom(*source);
  }
}

void ScenarioNarrowStreetUTurnConfig::MergeFrom(const ScenarioNarrowStreetUTurnConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ScenarioNarrowStreetUTurnConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioNarrowStreetUTurnConfig::CopyFrom(const ScenarioNarrowStreetUTurnConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioNarrowStreetUTurnConfig::IsInitialized() const {
  return true;
}

void ScenarioNarrowStreetUTurnConfig::Swap(ScenarioNarrowStreetUTurnConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioNarrowStreetUTurnConfig::InternalSwap(ScenarioNarrowStreetUTurnConfig* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioNarrowStreetUTurnConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioNarrowStreetUTurnConfig

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioParkAndGoConfig::kFrontObstacleBufferFieldNumber;
const int ScenarioParkAndGoConfig::kHeadingBufferFieldNumber;
const int ScenarioParkAndGoConfig::kMinDistToDestFieldNumber;
const int ScenarioParkAndGoConfig::kMaxSteeringPercentageWhenCruiseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioParkAndGoConfig::ScenarioParkAndGoConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioParkAndGoConfig)
}
ScenarioParkAndGoConfig::ScenarioParkAndGoConfig(const ScenarioParkAndGoConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&front_obstacle_buffer_, &from.front_obstacle_buffer_,
    reinterpret_cast<char*>(&max_steering_percentage_when_cruise_) -
    reinterpret_cast<char*>(&front_obstacle_buffer_) + sizeof(max_steering_percentage_when_cruise_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioParkAndGoConfig)
}

void ScenarioParkAndGoConfig::SharedCtor() {
  _cached_size_ = 0;
  front_obstacle_buffer_ = 4;
  heading_buffer_ = 0.5;
  min_dist_to_dest_ = 25;
  max_steering_percentage_when_cruise_ = 90;
}

ScenarioParkAndGoConfig::~ScenarioParkAndGoConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioParkAndGoConfig)
  SharedDtor();
}

void ScenarioParkAndGoConfig::SharedDtor() {
}

void ScenarioParkAndGoConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioParkAndGoConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioParkAndGoConfig& ScenarioParkAndGoConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioParkAndGoConfig* ScenarioParkAndGoConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioParkAndGoConfig* n = new ScenarioParkAndGoConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioParkAndGoConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  if (_has_bits_[0 / 32] & 15u) {
    front_obstacle_buffer_ = 4;
    heading_buffer_ = 0.5;
    min_dist_to_dest_ = 25;
    max_steering_percentage_when_cruise_ = 90;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioParkAndGoConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double front_obstacle_buffer = 1 [default = 4];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_front_obstacle_buffer();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &front_obstacle_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double heading_buffer = 2 [default = 0.5];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_heading_buffer();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &heading_buffer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_dist_to_dest = 3 [default = 25];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_min_dist_to_dest();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_dist_to_dest_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_steering_percentage_when_cruise = 4 [default = 90];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u)) {
          set_has_max_steering_percentage_when_cruise();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_steering_percentage_when_cruise_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioParkAndGoConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioParkAndGoConfig)
  return false;
#undef DO_
}

void ScenarioParkAndGoConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double front_obstacle_buffer = 1 [default = 4];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->front_obstacle_buffer(), output);
  }

  // optional double heading_buffer = 2 [default = 0.5];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->heading_buffer(), output);
  }

  // optional double min_dist_to_dest = 3 [default = 25];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->min_dist_to_dest(), output);
  }

  // optional double max_steering_percentage_when_cruise = 4 [default = 90];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->max_steering_percentage_when_cruise(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioParkAndGoConfig)
}

::google::protobuf::uint8* ScenarioParkAndGoConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double front_obstacle_buffer = 1 [default = 4];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->front_obstacle_buffer(), target);
  }

  // optional double heading_buffer = 2 [default = 0.5];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->heading_buffer(), target);
  }

  // optional double min_dist_to_dest = 3 [default = 25];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->min_dist_to_dest(), target);
  }

  // optional double max_steering_percentage_when_cruise = 4 [default = 90];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->max_steering_percentage_when_cruise(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioParkAndGoConfig)
  return target;
}

size_t ScenarioParkAndGoConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional double front_obstacle_buffer = 1 [default = 4];
    if (has_front_obstacle_buffer()) {
      total_size += 1 + 8;
    }

    // optional double heading_buffer = 2 [default = 0.5];
    if (has_heading_buffer()) {
      total_size += 1 + 8;
    }

    // optional double min_dist_to_dest = 3 [default = 25];
    if (has_min_dist_to_dest()) {
      total_size += 1 + 8;
    }

    // optional double max_steering_percentage_when_cruise = 4 [default = 90];
    if (has_max_steering_percentage_when_cruise()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioParkAndGoConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioParkAndGoConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioParkAndGoConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioParkAndGoConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioParkAndGoConfig)
    MergeFrom(*source);
  }
}

void ScenarioParkAndGoConfig::MergeFrom(const ScenarioParkAndGoConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      front_obstacle_buffer_ = from.front_obstacle_buffer_;
    }
    if (cached_has_bits & 0x00000002u) {
      heading_buffer_ = from.heading_buffer_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_dist_to_dest_ = from.min_dist_to_dest_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_steering_percentage_when_cruise_ = from.max_steering_percentage_when_cruise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioParkAndGoConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioParkAndGoConfig::CopyFrom(const ScenarioParkAndGoConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioParkAndGoConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioParkAndGoConfig::IsInitialized() const {
  return true;
}

void ScenarioParkAndGoConfig::Swap(ScenarioParkAndGoConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioParkAndGoConfig::InternalSwap(ScenarioParkAndGoConfig* other) {
  std::swap(front_obstacle_buffer_, other->front_obstacle_buffer_);
  std::swap(heading_buffer_, other->heading_buffer_);
  std::swap(min_dist_to_dest_, other->min_dist_to_dest_);
  std::swap(max_steering_percentage_when_cruise_, other->max_steering_percentage_when_cruise_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioParkAndGoConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioParkAndGoConfig

// optional double front_obstacle_buffer = 1 [default = 4];
bool ScenarioParkAndGoConfig::has_front_obstacle_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioParkAndGoConfig::set_has_front_obstacle_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioParkAndGoConfig::clear_has_front_obstacle_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioParkAndGoConfig::clear_front_obstacle_buffer() {
  front_obstacle_buffer_ = 4;
  clear_has_front_obstacle_buffer();
}
double ScenarioParkAndGoConfig::front_obstacle_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.front_obstacle_buffer)
  return front_obstacle_buffer_;
}
void ScenarioParkAndGoConfig::set_front_obstacle_buffer(double value) {
  set_has_front_obstacle_buffer();
  front_obstacle_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.front_obstacle_buffer)
}

// optional double heading_buffer = 2 [default = 0.5];
bool ScenarioParkAndGoConfig::has_heading_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioParkAndGoConfig::set_has_heading_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioParkAndGoConfig::clear_has_heading_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioParkAndGoConfig::clear_heading_buffer() {
  heading_buffer_ = 0.5;
  clear_has_heading_buffer();
}
double ScenarioParkAndGoConfig::heading_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.heading_buffer)
  return heading_buffer_;
}
void ScenarioParkAndGoConfig::set_heading_buffer(double value) {
  set_has_heading_buffer();
  heading_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.heading_buffer)
}

// optional double min_dist_to_dest = 3 [default = 25];
bool ScenarioParkAndGoConfig::has_min_dist_to_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioParkAndGoConfig::set_has_min_dist_to_dest() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioParkAndGoConfig::clear_has_min_dist_to_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioParkAndGoConfig::clear_min_dist_to_dest() {
  min_dist_to_dest_ = 25;
  clear_has_min_dist_to_dest();
}
double ScenarioParkAndGoConfig::min_dist_to_dest() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.min_dist_to_dest)
  return min_dist_to_dest_;
}
void ScenarioParkAndGoConfig::set_min_dist_to_dest(double value) {
  set_has_min_dist_to_dest();
  min_dist_to_dest_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.min_dist_to_dest)
}

// optional double max_steering_percentage_when_cruise = 4 [default = 90];
bool ScenarioParkAndGoConfig::has_max_steering_percentage_when_cruise() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioParkAndGoConfig::set_has_max_steering_percentage_when_cruise() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioParkAndGoConfig::clear_has_max_steering_percentage_when_cruise() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioParkAndGoConfig::clear_max_steering_percentage_when_cruise() {
  max_steering_percentage_when_cruise_ = 90;
  clear_has_max_steering_percentage_when_cruise();
}
double ScenarioParkAndGoConfig::max_steering_percentage_when_cruise() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.max_steering_percentage_when_cruise)
  return max_steering_percentage_when_cruise_;
}
void ScenarioParkAndGoConfig::set_max_steering_percentage_when_cruise(double value) {
  set_has_max_steering_percentage_when_cruise();
  max_steering_percentage_when_cruise_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.max_steering_percentage_when_cruise)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioYieldSignConfig::kStartYieldSignScenarioDistanceFieldNumber;
const int ScenarioYieldSignConfig::kMaxValidStopDistanceFieldNumber;
const int ScenarioYieldSignConfig::kMinPassSDistanceFieldNumber;
const int ScenarioYieldSignConfig::kCreepTimeoutSecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioYieldSignConfig::ScenarioYieldSignConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioYieldSignConfig)
}
ScenarioYieldSignConfig::ScenarioYieldSignConfig(const ScenarioYieldSignConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&creep_timeout_sec_, &from.creep_timeout_sec_,
    reinterpret_cast<char*>(&min_pass_s_distance_) -
    reinterpret_cast<char*>(&creep_timeout_sec_) + sizeof(min_pass_s_distance_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioYieldSignConfig)
}

void ScenarioYieldSignConfig::SharedCtor() {
  _cached_size_ = 0;
  creep_timeout_sec_ = 10;
  start_yield_sign_scenario_distance_ = 10;
  max_valid_stop_distance_ = 4.5;
  min_pass_s_distance_ = 3;
}

ScenarioYieldSignConfig::~ScenarioYieldSignConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioYieldSignConfig)
  SharedDtor();
}

void ScenarioYieldSignConfig::SharedDtor() {
}

void ScenarioYieldSignConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioYieldSignConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioYieldSignConfig& ScenarioYieldSignConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioYieldSignConfig* ScenarioYieldSignConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioYieldSignConfig* n = new ScenarioYieldSignConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioYieldSignConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioYieldSignConfig)
  if (_has_bits_[0 / 32] & 15u) {
    creep_timeout_sec_ = 10;
    start_yield_sign_scenario_distance_ = 10;
    max_valid_stop_distance_ = 4.5;
    min_pass_s_distance_ = 3;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioYieldSignConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioYieldSignConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double start_yield_sign_scenario_distance = 1 [default = 10];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u)) {
          set_has_start_yield_sign_scenario_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &start_yield_sign_scenario_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double max_valid_stop_distance = 2 [default = 4.5];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u)) {
          set_has_max_valid_stop_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_valid_stop_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double min_pass_s_distance = 3 [default = 3];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u)) {
          set_has_min_pass_s_distance();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_pass_s_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float creep_timeout_sec = 4 [default = 10];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {
          set_has_creep_timeout_sec();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &creep_timeout_sec_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioYieldSignConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioYieldSignConfig)
  return false;
#undef DO_
}

void ScenarioYieldSignConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioYieldSignConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_yield_sign_scenario_distance = 1 [default = 10];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->start_yield_sign_scenario_distance(), output);
  }

  // optional double max_valid_stop_distance = 2 [default = 4.5];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->max_valid_stop_distance(), output);
  }

  // optional double min_pass_s_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->min_pass_s_distance(), output);
  }

  // optional float creep_timeout_sec = 4 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->creep_timeout_sec(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioYieldSignConfig)
}

::google::protobuf::uint8* ScenarioYieldSignConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioYieldSignConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double start_yield_sign_scenario_distance = 1 [default = 10];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->start_yield_sign_scenario_distance(), target);
  }

  // optional double max_valid_stop_distance = 2 [default = 4.5];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->max_valid_stop_distance(), target);
  }

  // optional double min_pass_s_distance = 3 [default = 3];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->min_pass_s_distance(), target);
  }

  // optional float creep_timeout_sec = 4 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->creep_timeout_sec(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioYieldSignConfig)
  return target;
}

size_t ScenarioYieldSignConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioYieldSignConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional float creep_timeout_sec = 4 [default = 10];
    if (has_creep_timeout_sec()) {
      total_size += 1 + 4;
    }

    // optional double start_yield_sign_scenario_distance = 1 [default = 10];
    if (has_start_yield_sign_scenario_distance()) {
      total_size += 1 + 8;
    }

    // optional double max_valid_stop_distance = 2 [default = 4.5];
    if (has_max_valid_stop_distance()) {
      total_size += 1 + 8;
    }

    // optional double min_pass_s_distance = 3 [default = 3];
    if (has_min_pass_s_distance()) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioYieldSignConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioYieldSignConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioYieldSignConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioYieldSignConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioYieldSignConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioYieldSignConfig)
    MergeFrom(*source);
  }
}

void ScenarioYieldSignConfig::MergeFrom(const ScenarioYieldSignConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioYieldSignConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      creep_timeout_sec_ = from.creep_timeout_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_yield_sign_scenario_distance_ = from.start_yield_sign_scenario_distance_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_valid_stop_distance_ = from.max_valid_stop_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_pass_s_distance_ = from.min_pass_s_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioYieldSignConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioYieldSignConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioYieldSignConfig::CopyFrom(const ScenarioYieldSignConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioYieldSignConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioYieldSignConfig::IsInitialized() const {
  return true;
}

void ScenarioYieldSignConfig::Swap(ScenarioYieldSignConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioYieldSignConfig::InternalSwap(ScenarioYieldSignConfig* other) {
  std::swap(creep_timeout_sec_, other->creep_timeout_sec_);
  std::swap(start_yield_sign_scenario_distance_, other->start_yield_sign_scenario_distance_);
  std::swap(max_valid_stop_distance_, other->max_valid_stop_distance_);
  std::swap(min_pass_s_distance_, other->min_pass_s_distance_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioYieldSignConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioYieldSignConfig

// optional double start_yield_sign_scenario_distance = 1 [default = 10];
bool ScenarioYieldSignConfig::has_start_yield_sign_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioYieldSignConfig::set_has_start_yield_sign_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioYieldSignConfig::clear_has_start_yield_sign_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioYieldSignConfig::clear_start_yield_sign_scenario_distance() {
  start_yield_sign_scenario_distance_ = 10;
  clear_has_start_yield_sign_scenario_distance();
}
double ScenarioYieldSignConfig::start_yield_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.start_yield_sign_scenario_distance)
  return start_yield_sign_scenario_distance_;
}
void ScenarioYieldSignConfig::set_start_yield_sign_scenario_distance(double value) {
  set_has_start_yield_sign_scenario_distance();
  start_yield_sign_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.start_yield_sign_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 4.5];
bool ScenarioYieldSignConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScenarioYieldSignConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
void ScenarioYieldSignConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScenarioYieldSignConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 4.5;
  clear_has_max_valid_stop_distance();
}
double ScenarioYieldSignConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
void ScenarioYieldSignConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 3 [default = 3];
bool ScenarioYieldSignConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScenarioYieldSignConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000008u;
}
void ScenarioYieldSignConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScenarioYieldSignConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
double ScenarioYieldSignConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
void ScenarioYieldSignConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 4 [default = 10];
bool ScenarioYieldSignConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioYieldSignConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioYieldSignConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioYieldSignConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
float ScenarioYieldSignConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
void ScenarioYieldSignConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.creep_timeout_sec)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioTestLearningModelConfig::kModelFileFieldNumber;
const int ScenarioTestLearningModelConfig::kInputFeatureNumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioTestLearningModelConfig::ScenarioTestLearningModelConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioTestLearningModelConfig)
}
ScenarioTestLearningModelConfig::ScenarioTestLearningModelConfig(const ScenarioTestLearningModelConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  model_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_model_file()) {
    model_file_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_file_);
  }
  input_feature_num_ = from.input_feature_num_;
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioTestLearningModelConfig)
}

void ScenarioTestLearningModelConfig::SharedCtor() {
  _cached_size_ = 0;
  model_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  input_feature_num_ = 0;
}

ScenarioTestLearningModelConfig::~ScenarioTestLearningModelConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioTestLearningModelConfig)
  SharedDtor();
}

void ScenarioTestLearningModelConfig::SharedDtor() {
  model_file_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ScenarioTestLearningModelConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioTestLearningModelConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioTestLearningModelConfig& ScenarioTestLearningModelConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioTestLearningModelConfig* ScenarioTestLearningModelConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioTestLearningModelConfig* n = new ScenarioTestLearningModelConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioTestLearningModelConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  if (has_model_file()) {
    GOOGLE_DCHECK(!model_file_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*model_file_.UnsafeRawStringPointer())->clear();
  }
  input_feature_num_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioTestLearningModelConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string model_file = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_file().data(), this->model_file().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "jmc_auto.planning.ScenarioTestLearningModelConfig.model_file");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 input_feature_num = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_input_feature_num();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &input_feature_num_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioTestLearningModelConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioTestLearningModelConfig)
  return false;
#undef DO_
}

void ScenarioTestLearningModelConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string model_file = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_file().data(), this->model_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.ScenarioTestLearningModelConfig.model_file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_file(), output);
  }

  // optional int32 input_feature_num = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->input_feature_num(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioTestLearningModelConfig)
}

::google::protobuf::uint8* ScenarioTestLearningModelConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string model_file = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_file().data(), this->model_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "jmc_auto.planning.ScenarioTestLearningModelConfig.model_file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_file(), target);
  }

  // optional int32 input_feature_num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->input_feature_num(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioTestLearningModelConfig)
  return target;
}

size_t ScenarioTestLearningModelConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string model_file = 1;
    if (has_model_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model_file());
    }

    // optional int32 input_feature_num = 2;
    if (has_input_feature_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->input_feature_num());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioTestLearningModelConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioTestLearningModelConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioTestLearningModelConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioTestLearningModelConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioTestLearningModelConfig)
    MergeFrom(*source);
  }
}

void ScenarioTestLearningModelConfig::MergeFrom(const ScenarioTestLearningModelConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_model_file();
      model_file_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_file_);
    }
    if (cached_has_bits & 0x00000002u) {
      input_feature_num_ = from.input_feature_num_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioTestLearningModelConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioTestLearningModelConfig::CopyFrom(const ScenarioTestLearningModelConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioTestLearningModelConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioTestLearningModelConfig::IsInitialized() const {
  return true;
}

void ScenarioTestLearningModelConfig::Swap(ScenarioTestLearningModelConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioTestLearningModelConfig::InternalSwap(ScenarioTestLearningModelConfig* other) {
  model_file_.Swap(&other->model_file_);
  std::swap(input_feature_num_, other->input_feature_num_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioTestLearningModelConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioTestLearningModelConfig

// optional string model_file = 1;
bool ScenarioTestLearningModelConfig::has_model_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioTestLearningModelConfig::set_has_model_file() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioTestLearningModelConfig::clear_has_model_file() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioTestLearningModelConfig::clear_model_file() {
  model_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_file();
}
const ::std::string& ScenarioTestLearningModelConfig::model_file() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
  return model_file_.GetNoArena();
}
void ScenarioTestLearningModelConfig::set_model_file(const ::std::string& value) {
  set_has_model_file();
  model_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
#if LANG_CXX11
void ScenarioTestLearningModelConfig::set_model_file(::std::string&& value) {
  set_has_model_file();
  model_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
#endif
void ScenarioTestLearningModelConfig::set_model_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_file();
  model_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
void ScenarioTestLearningModelConfig::set_model_file(const char* value, size_t size) {
  set_has_model_file();
  model_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
::std::string* ScenarioTestLearningModelConfig::mutable_model_file() {
  set_has_model_file();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
  return model_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ScenarioTestLearningModelConfig::release_model_file() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
  clear_has_model_file();
  return model_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ScenarioTestLearningModelConfig::set_allocated_model_file(::std::string* model_file) {
  if (model_file != NULL) {
    set_has_model_file();
  } else {
    clear_has_model_file();
  }
  model_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_file);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}

// optional int32 input_feature_num = 2;
bool ScenarioTestLearningModelConfig::has_input_feature_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioTestLearningModelConfig::set_has_input_feature_num() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioTestLearningModelConfig::clear_has_input_feature_num() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioTestLearningModelConfig::clear_input_feature_num() {
  input_feature_num_ = 0;
  clear_has_input_feature_num();
}
::google::protobuf::int32 ScenarioTestLearningModelConfig::input_feature_num() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTestLearningModelConfig.input_feature_num)
  return input_feature_num_;
}
void ScenarioTestLearningModelConfig::set_input_feature_num(::google::protobuf::int32 value) {
  set_has_input_feature_num();
  input_feature_num_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTestLearningModelConfig.input_feature_num)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioConfig_StageConfig::kStageTypeFieldNumber;
const int ScenarioConfig_StageConfig::kEnabledFieldNumber;
const int ScenarioConfig_StageConfig::kTaskTypeFieldNumber;
const int ScenarioConfig_StageConfig::kTaskConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioConfig_StageConfig::ScenarioConfig_StageConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioConfig.StageConfig)
}
ScenarioConfig_StageConfig::ScenarioConfig_StageConfig(const ScenarioConfig_StageConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      task_type_(from.task_type_),
      task_config_(from.task_config_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&stage_type_, &from.stage_type_,
    reinterpret_cast<char*>(&enabled_) -
    reinterpret_cast<char*>(&stage_type_) + sizeof(enabled_));
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioConfig.StageConfig)
}

void ScenarioConfig_StageConfig::SharedCtor() {
  _cached_size_ = 0;
  stage_type_ = 0;
  enabled_ = true;
}

ScenarioConfig_StageConfig::~ScenarioConfig_StageConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioConfig.StageConfig)
  SharedDtor();
}

void ScenarioConfig_StageConfig::SharedDtor() {
}

void ScenarioConfig_StageConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioConfig_StageConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioConfig_StageConfig& ScenarioConfig_StageConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioConfig_StageConfig* ScenarioConfig_StageConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioConfig_StageConfig* n = new ScenarioConfig_StageConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioConfig_StageConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  task_type_.Clear();
  task_config_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    stage_type_ = 0;
    enabled_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioConfig_StageConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value)) {
            set_stage_type(static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enabled = 2 [default = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_enabled();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::TaskConfig_TaskType_IsValid(value)) {
            add_task_type(static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(26u)) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 3,
                 ::jmc_auto::planning::TaskConfig_TaskType_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_task_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.TaskConfig task_config = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_task_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioConfig.StageConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioConfig.StageConfig)
  return false;
#undef DO_
}

void ScenarioConfig_StageConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->stage_type(), output);
  }

  // optional bool enabled = 2 [default = true];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->enabled(), output);
  }

  // repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
  for (int i = 0, n = this->task_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->task_type(i), output);
  }

  // repeated .jmc_auto.planning.TaskConfig task_config = 4;
  for (unsigned int i = 0, n = this->task_config_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->task_config(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioConfig.StageConfig)
}

::google::protobuf::uint8* ScenarioConfig_StageConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->stage_type(), target);
  }

  // optional bool enabled = 2 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->enabled(), target);
  }

  // repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
  target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
    3, this->task_type_, target);

  // repeated .jmc_auto.planning.TaskConfig task_config = 4;
  for (unsigned int i = 0, n = this->task_config_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->task_config(i), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioConfig.StageConfig)
  return target;
}

size_t ScenarioConfig_StageConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
  {
    size_t data_size = 0;
    unsigned int count = this->task_type_size();for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->task_type(i));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .jmc_auto.planning.TaskConfig task_config = 4;
  {
    unsigned int count = this->task_config_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_config(i));
    }
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
    if (has_stage_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->stage_type());
    }

    // optional bool enabled = 2 [default = true];
    if (has_enabled()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioConfig_StageConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioConfig_StageConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioConfig_StageConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioConfig.StageConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioConfig.StageConfig)
    MergeFrom(*source);
  }
}

void ScenarioConfig_StageConfig::MergeFrom(const ScenarioConfig_StageConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  task_type_.MergeFrom(from.task_type_);
  task_config_.MergeFrom(from.task_config_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      stage_type_ = from.stage_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      enabled_ = from.enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ScenarioConfig_StageConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioConfig_StageConfig::CopyFrom(const ScenarioConfig_StageConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioConfig.StageConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioConfig_StageConfig::IsInitialized() const {
  return true;
}

void ScenarioConfig_StageConfig::Swap(ScenarioConfig_StageConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioConfig_StageConfig::InternalSwap(ScenarioConfig_StageConfig* other) {
  task_type_.InternalSwap(&other->task_type_);
  task_config_.InternalSwap(&other->task_config_);
  std::swap(stage_type_, other->stage_type_);
  std::swap(enabled_, other->enabled_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioConfig_StageConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioConfig_StageConfig

// optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
bool ScenarioConfig_StageConfig::has_stage_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioConfig_StageConfig::set_has_stage_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioConfig_StageConfig::clear_has_stage_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioConfig_StageConfig::clear_stage_type() {
  stage_type_ = 0;
  clear_has_stage_type();
}
::jmc_auto::planning::ScenarioConfig_StageType ScenarioConfig_StageConfig::stage_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.stage_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(stage_type_);
}
void ScenarioConfig_StageConfig::set_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  set_has_stage_type();
  stage_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.StageConfig.stage_type)
}

// optional bool enabled = 2 [default = true];
bool ScenarioConfig_StageConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScenarioConfig_StageConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
void ScenarioConfig_StageConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScenarioConfig_StageConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
bool ScenarioConfig_StageConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.enabled)
  return enabled_;
}
void ScenarioConfig_StageConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.StageConfig.enabled)
}

// repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
int ScenarioConfig_StageConfig::task_type_size() const {
  return task_type_.size();
}
void ScenarioConfig_StageConfig::clear_task_type() {
  task_type_.Clear();
}
::jmc_auto::planning::TaskConfig_TaskType ScenarioConfig_StageConfig::task_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
  return static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(task_type_.Get(index));
}
void ScenarioConfig_StageConfig::set_task_type(int index, ::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
}
void ScenarioConfig_StageConfig::add_task_type(::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
}
const ::google::protobuf::RepeatedField<int>&
ScenarioConfig_StageConfig::task_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
  return task_type_;
}
::google::protobuf::RepeatedField<int>*
ScenarioConfig_StageConfig::mutable_task_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
  return &task_type_;
}

// repeated .jmc_auto.planning.TaskConfig task_config = 4;
int ScenarioConfig_StageConfig::task_config_size() const {
  return task_config_.size();
}
void ScenarioConfig_StageConfig::clear_task_config() {
  task_config_.Clear();
}
const ::jmc_auto::planning::TaskConfig& ScenarioConfig_StageConfig::task_config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Get(index);
}
::jmc_auto::planning::TaskConfig* ScenarioConfig_StageConfig::mutable_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Mutable(index);
}
::jmc_auto::planning::TaskConfig* ScenarioConfig_StageConfig::add_task_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Add();
}
::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >*
ScenarioConfig_StageConfig::mutable_task_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return &task_config_;
}
const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >&
ScenarioConfig_StageConfig::task_config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScenarioConfig::kScenarioTypeFieldNumber;
const int ScenarioConfig::kLaneFollowConfigFieldNumber;
const int ScenarioConfig::kBareIntersectionUnprotectedConfigFieldNumber;
const int ScenarioConfig::kEmergencyPullOverConfigFieldNumber;
const int ScenarioConfig::kEmergencyStopConfigFieldNumber;
const int ScenarioConfig::kNarrowStreetUTurnConfigFieldNumber;
const int ScenarioConfig::kStopSignUnprotectedConfigFieldNumber;
const int ScenarioConfig::kTrafficLightProtectedConfigFieldNumber;
const int ScenarioConfig::kTrafficLightUnprotectedRightTurnConfigFieldNumber;
const int ScenarioConfig::kTrafficLightUnprotectedLeftTurnConfigFieldNumber;
const int ScenarioConfig::kParkAndGoConfigFieldNumber;
const int ScenarioConfig::kPullOverConfigFieldNumber;
const int ScenarioConfig::kValetParkingConfigFieldNumber;
const int ScenarioConfig::kYieldSignConfigFieldNumber;
const int ScenarioConfig::kTestLearningModelConfigFieldNumber;
const int ScenarioConfig::kStageTypeFieldNumber;
const int ScenarioConfig::kStageConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScenarioConfig::ScenarioConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.ScenarioConfig)
}
ScenarioConfig::ScenarioConfig(const ScenarioConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      stage_type_(from.stage_type_),
      stage_config_(from.stage_config_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  scenario_type_ = from.scenario_type_;
  clear_has_scenario_config();
  switch (from.scenario_config_case()) {
    case kLaneFollowConfig: {
      mutable_lane_follow_config()->::jmc_auto::planning::ScenarioLaneFollowConfig::MergeFrom(from.lane_follow_config());
      break;
    }
    case kBareIntersectionUnprotectedConfig: {
      mutable_bare_intersection_unprotected_config()->::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig::MergeFrom(from.bare_intersection_unprotected_config());
      break;
    }
    case kEmergencyPullOverConfig: {
      mutable_emergency_pull_over_config()->::jmc_auto::planning::ScenarioEmergencyPullOverConfig::MergeFrom(from.emergency_pull_over_config());
      break;
    }
    case kEmergencyStopConfig: {
      mutable_emergency_stop_config()->::jmc_auto::planning::ScenarioEmergencyStopConfig::MergeFrom(from.emergency_stop_config());
      break;
    }
    case kNarrowStreetUTurnConfig: {
      mutable_narrow_street_u_turn_config()->::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig::MergeFrom(from.narrow_street_u_turn_config());
      break;
    }
    case kStopSignUnprotectedConfig: {
      mutable_stop_sign_unprotected_config()->::jmc_auto::planning::ScenarioStopSignUnprotectedConfig::MergeFrom(from.stop_sign_unprotected_config());
      break;
    }
    case kTrafficLightProtectedConfig: {
      mutable_traffic_light_protected_config()->::jmc_auto::planning::ScenarioTrafficLightProtectedConfig::MergeFrom(from.traffic_light_protected_config());
      break;
    }
    case kTrafficLightUnprotectedRightTurnConfig: {
      mutable_traffic_light_unprotected_right_turn_config()->::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig::MergeFrom(from.traffic_light_unprotected_right_turn_config());
      break;
    }
    case kTrafficLightUnprotectedLeftTurnConfig: {
      mutable_traffic_light_unprotected_left_turn_config()->::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig::MergeFrom(from.traffic_light_unprotected_left_turn_config());
      break;
    }
    case kParkAndGoConfig: {
      mutable_park_and_go_config()->::jmc_auto::planning::ScenarioParkAndGoConfig::MergeFrom(from.park_and_go_config());
      break;
    }
    case kPullOverConfig: {
      mutable_pull_over_config()->::jmc_auto::planning::ScenarioPullOverConfig::MergeFrom(from.pull_over_config());
      break;
    }
    case kValetParkingConfig: {
      mutable_valet_parking_config()->::jmc_auto::planning::ScenarioValetParkingConfig::MergeFrom(from.valet_parking_config());
      break;
    }
    case kYieldSignConfig: {
      mutable_yield_sign_config()->::jmc_auto::planning::ScenarioYieldSignConfig::MergeFrom(from.yield_sign_config());
      break;
    }
    case kTestLearningModelConfig: {
      mutable_test_learning_model_config()->::jmc_auto::planning::ScenarioTestLearningModelConfig::MergeFrom(from.test_learning_model_config());
      break;
    }
    case SCENARIO_CONFIG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.ScenarioConfig)
}

void ScenarioConfig::SharedCtor() {
  _cached_size_ = 0;
  scenario_type_ = 0;
  clear_has_scenario_config();
}

ScenarioConfig::~ScenarioConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.ScenarioConfig)
  SharedDtor();
}

void ScenarioConfig::SharedDtor() {
  if (has_scenario_config()) {
    clear_scenario_config();
  }
}

void ScenarioConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScenarioConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ScenarioConfig& ScenarioConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

ScenarioConfig* ScenarioConfig::New(::google::protobuf::Arena* arena) const {
  ScenarioConfig* n = new ScenarioConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScenarioConfig::clear_scenario_config() {
// @@protoc_insertion_point(one_of_clear_start:jmc_auto.planning.ScenarioConfig)
  switch (scenario_config_case()) {
    case kLaneFollowConfig: {
      delete scenario_config_.lane_follow_config_;
      break;
    }
    case kBareIntersectionUnprotectedConfig: {
      delete scenario_config_.bare_intersection_unprotected_config_;
      break;
    }
    case kEmergencyPullOverConfig: {
      delete scenario_config_.emergency_pull_over_config_;
      break;
    }
    case kEmergencyStopConfig: {
      delete scenario_config_.emergency_stop_config_;
      break;
    }
    case kNarrowStreetUTurnConfig: {
      delete scenario_config_.narrow_street_u_turn_config_;
      break;
    }
    case kStopSignUnprotectedConfig: {
      delete scenario_config_.stop_sign_unprotected_config_;
      break;
    }
    case kTrafficLightProtectedConfig: {
      delete scenario_config_.traffic_light_protected_config_;
      break;
    }
    case kTrafficLightUnprotectedRightTurnConfig: {
      delete scenario_config_.traffic_light_unprotected_right_turn_config_;
      break;
    }
    case kTrafficLightUnprotectedLeftTurnConfig: {
      delete scenario_config_.traffic_light_unprotected_left_turn_config_;
      break;
    }
    case kParkAndGoConfig: {
      delete scenario_config_.park_and_go_config_;
      break;
    }
    case kPullOverConfig: {
      delete scenario_config_.pull_over_config_;
      break;
    }
    case kValetParkingConfig: {
      delete scenario_config_.valet_parking_config_;
      break;
    }
    case kYieldSignConfig: {
      delete scenario_config_.yield_sign_config_;
      break;
    }
    case kTestLearningModelConfig: {
      delete scenario_config_.test_learning_model_config_;
      break;
    }
    case SCENARIO_CONFIG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SCENARIO_CONFIG_NOT_SET;
}


void ScenarioConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.ScenarioConfig)
  stage_type_.Clear();
  stage_config_.Clear();
  scenario_type_ = 0;
  clear_scenario_config();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ScenarioConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.ScenarioConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::ScenarioConfig_ScenarioType_IsValid(value)) {
            set_scenario_type(static_cast< ::jmc_auto::planning::ScenarioConfig_ScenarioType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lane_follow_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bare_intersection_unprotected_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_emergency_pull_over_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioEmergencyStopConfig emergency_stop_config = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_emergency_stop_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_narrow_street_u_turn_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_sign_unprotected_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traffic_light_protected_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traffic_light_unprotected_right_turn_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traffic_light_unprotected_left_turn_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioParkAndGoConfig park_and_go_config = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_park_and_go_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioPullOverConfig pull_over_config = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pull_over_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioValetParkingConfig valet_parking_config = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_valet_parking_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioYieldSignConfig yield_sign_config = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(122u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_yield_sign_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(128u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value)) {
            add_stage_type(static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(16, value);
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(130u)) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 16,
                 ::jmc_auto::planning::ScenarioConfig_StageType_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_stage_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(138u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stage_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(146u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_test_learning_model_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.ScenarioConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.ScenarioConfig)
  return false;
#undef DO_
}

void ScenarioConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.ScenarioConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->scenario_type(), output);
  }

  switch (scenario_config_case()) {
    case kLaneFollowConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, *scenario_config_.lane_follow_config_, output);
      break;
    case kBareIntersectionUnprotectedConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        4, *scenario_config_.bare_intersection_unprotected_config_, output);
      break;
    case kEmergencyPullOverConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        5, *scenario_config_.emergency_pull_over_config_, output);
      break;
    case kEmergencyStopConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        6, *scenario_config_.emergency_stop_config_, output);
      break;
    case kNarrowStreetUTurnConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        7, *scenario_config_.narrow_street_u_turn_config_, output);
      break;
    case kStopSignUnprotectedConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        8, *scenario_config_.stop_sign_unprotected_config_, output);
      break;
    case kTrafficLightProtectedConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        9, *scenario_config_.traffic_light_protected_config_, output);
      break;
    case kTrafficLightUnprotectedRightTurnConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        10, *scenario_config_.traffic_light_unprotected_right_turn_config_, output);
      break;
    case kTrafficLightUnprotectedLeftTurnConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        11, *scenario_config_.traffic_light_unprotected_left_turn_config_, output);
      break;
    case kParkAndGoConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        12, *scenario_config_.park_and_go_config_, output);
      break;
    case kPullOverConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        13, *scenario_config_.pull_over_config_, output);
      break;
    case kValetParkingConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        14, *scenario_config_.valet_parking_config_, output);
      break;
    case kYieldSignConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        15, *scenario_config_.yield_sign_config_, output);
      break;
    default: ;
  }
  // repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
  for (int i = 0, n = this->stage_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      16, this->stage_type(i), output);
  }

  // repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
  for (unsigned int i = 0, n = this->stage_config_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, this->stage_config(i), output);
  }

  // optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
  if (has_test_learning_model_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *scenario_config_.test_learning_model_config_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.ScenarioConfig)
}

::google::protobuf::uint8* ScenarioConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.ScenarioConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->scenario_type(), target);
  }

  switch (scenario_config_case()) {
    case kLaneFollowConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          2, *scenario_config_.lane_follow_config_, deterministic, target);
      break;
    case kBareIntersectionUnprotectedConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          4, *scenario_config_.bare_intersection_unprotected_config_, deterministic, target);
      break;
    case kEmergencyPullOverConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          5, *scenario_config_.emergency_pull_over_config_, deterministic, target);
      break;
    case kEmergencyStopConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          6, *scenario_config_.emergency_stop_config_, deterministic, target);
      break;
    case kNarrowStreetUTurnConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          7, *scenario_config_.narrow_street_u_turn_config_, deterministic, target);
      break;
    case kStopSignUnprotectedConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          8, *scenario_config_.stop_sign_unprotected_config_, deterministic, target);
      break;
    case kTrafficLightProtectedConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          9, *scenario_config_.traffic_light_protected_config_, deterministic, target);
      break;
    case kTrafficLightUnprotectedRightTurnConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          10, *scenario_config_.traffic_light_unprotected_right_turn_config_, deterministic, target);
      break;
    case kTrafficLightUnprotectedLeftTurnConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          11, *scenario_config_.traffic_light_unprotected_left_turn_config_, deterministic, target);
      break;
    case kParkAndGoConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          12, *scenario_config_.park_and_go_config_, deterministic, target);
      break;
    case kPullOverConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          13, *scenario_config_.pull_over_config_, deterministic, target);
      break;
    case kValetParkingConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          14, *scenario_config_.valet_parking_config_, deterministic, target);
      break;
    case kYieldSignConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          15, *scenario_config_.yield_sign_config_, deterministic, target);
      break;
    default: ;
  }
  // repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
  target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
    16, this->stage_type_, target);

  // repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
  for (unsigned int i = 0, n = this->stage_config_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        17, this->stage_config(i), deterministic, target);
  }

  // optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
  if (has_test_learning_model_config()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        18, *scenario_config_.test_learning_model_config_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.ScenarioConfig)
  return target;
}

size_t ScenarioConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.ScenarioConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
  {
    size_t data_size = 0;
    unsigned int count = this->stage_type_size();for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->stage_type(i));
    }
    total_size += (2UL * count) + data_size;
  }

  // repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
  {
    unsigned int count = this->stage_config_size();
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stage_config(i));
    }
  }

  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  if (has_scenario_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->scenario_type());
  }

  switch (scenario_config_case()) {
    // optional .jmc_auto.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
    case kLaneFollowConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.lane_follow_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
    case kBareIntersectionUnprotectedConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.bare_intersection_unprotected_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 5;
    case kEmergencyPullOverConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.emergency_pull_over_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioEmergencyStopConfig emergency_stop_config = 6;
    case kEmergencyStopConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.emergency_stop_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
    case kNarrowStreetUTurnConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.narrow_street_u_turn_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 8;
    case kStopSignUnprotectedConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.stop_sign_unprotected_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 9;
    case kTrafficLightProtectedConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.traffic_light_protected_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 10;
    case kTrafficLightUnprotectedRightTurnConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.traffic_light_unprotected_right_turn_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 11;
    case kTrafficLightUnprotectedLeftTurnConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.traffic_light_unprotected_left_turn_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioParkAndGoConfig park_and_go_config = 12;
    case kParkAndGoConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.park_and_go_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioPullOverConfig pull_over_config = 13;
    case kPullOverConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.pull_over_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioValetParkingConfig valet_parking_config = 14;
    case kValetParkingConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.valet_parking_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioYieldSignConfig yield_sign_config = 15;
    case kYieldSignConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.yield_sign_config_);
      break;
    }
    // optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
    case kTestLearningModelConfig: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *scenario_config_.test_learning_model_config_);
      break;
    }
    case SCENARIO_CONFIG_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScenarioConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.ScenarioConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const ScenarioConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ScenarioConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.ScenarioConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.ScenarioConfig)
    MergeFrom(*source);
  }
}

void ScenarioConfig::MergeFrom(const ScenarioConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.ScenarioConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  stage_type_.MergeFrom(from.stage_type_);
  stage_config_.MergeFrom(from.stage_config_);
  if (from.has_scenario_type()) {
    set_scenario_type(from.scenario_type());
  }
  switch (from.scenario_config_case()) {
    case kLaneFollowConfig: {
      mutable_lane_follow_config()->::jmc_auto::planning::ScenarioLaneFollowConfig::MergeFrom(from.lane_follow_config());
      break;
    }
    case kBareIntersectionUnprotectedConfig: {
      mutable_bare_intersection_unprotected_config()->::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig::MergeFrom(from.bare_intersection_unprotected_config());
      break;
    }
    case kEmergencyPullOverConfig: {
      mutable_emergency_pull_over_config()->::jmc_auto::planning::ScenarioEmergencyPullOverConfig::MergeFrom(from.emergency_pull_over_config());
      break;
    }
    case kEmergencyStopConfig: {
      mutable_emergency_stop_config()->::jmc_auto::planning::ScenarioEmergencyStopConfig::MergeFrom(from.emergency_stop_config());
      break;
    }
    case kNarrowStreetUTurnConfig: {
      mutable_narrow_street_u_turn_config()->::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig::MergeFrom(from.narrow_street_u_turn_config());
      break;
    }
    case kStopSignUnprotectedConfig: {
      mutable_stop_sign_unprotected_config()->::jmc_auto::planning::ScenarioStopSignUnprotectedConfig::MergeFrom(from.stop_sign_unprotected_config());
      break;
    }
    case kTrafficLightProtectedConfig: {
      mutable_traffic_light_protected_config()->::jmc_auto::planning::ScenarioTrafficLightProtectedConfig::MergeFrom(from.traffic_light_protected_config());
      break;
    }
    case kTrafficLightUnprotectedRightTurnConfig: {
      mutable_traffic_light_unprotected_right_turn_config()->::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig::MergeFrom(from.traffic_light_unprotected_right_turn_config());
      break;
    }
    case kTrafficLightUnprotectedLeftTurnConfig: {
      mutable_traffic_light_unprotected_left_turn_config()->::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig::MergeFrom(from.traffic_light_unprotected_left_turn_config());
      break;
    }
    case kParkAndGoConfig: {
      mutable_park_and_go_config()->::jmc_auto::planning::ScenarioParkAndGoConfig::MergeFrom(from.park_and_go_config());
      break;
    }
    case kPullOverConfig: {
      mutable_pull_over_config()->::jmc_auto::planning::ScenarioPullOverConfig::MergeFrom(from.pull_over_config());
      break;
    }
    case kValetParkingConfig: {
      mutable_valet_parking_config()->::jmc_auto::planning::ScenarioValetParkingConfig::MergeFrom(from.valet_parking_config());
      break;
    }
    case kYieldSignConfig: {
      mutable_yield_sign_config()->::jmc_auto::planning::ScenarioYieldSignConfig::MergeFrom(from.yield_sign_config());
      break;
    }
    case kTestLearningModelConfig: {
      mutable_test_learning_model_config()->::jmc_auto::planning::ScenarioTestLearningModelConfig::MergeFrom(from.test_learning_model_config());
      break;
    }
    case SCENARIO_CONFIG_NOT_SET: {
      break;
    }
  }
}

void ScenarioConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.ScenarioConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScenarioConfig::CopyFrom(const ScenarioConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.ScenarioConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScenarioConfig::IsInitialized() const {
  return true;
}

void ScenarioConfig::Swap(ScenarioConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScenarioConfig::InternalSwap(ScenarioConfig* other) {
  stage_type_.InternalSwap(&other->stage_type_);
  stage_config_.InternalSwap(&other->stage_config_);
  std::swap(scenario_type_, other->scenario_type_);
  std::swap(scenario_config_, other->scenario_config_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScenarioConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScenarioConfig

// optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
bool ScenarioConfig::has_scenario_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScenarioConfig::set_has_scenario_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ScenarioConfig::clear_has_scenario_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScenarioConfig::clear_scenario_type() {
  scenario_type_ = 0;
  clear_has_scenario_type();
}
::jmc_auto::planning::ScenarioConfig_ScenarioType ScenarioConfig::scenario_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.scenario_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
void ScenarioConfig::set_scenario_type(::jmc_auto::planning::ScenarioConfig_ScenarioType value) {
  assert(::jmc_auto::planning::ScenarioConfig_ScenarioType_IsValid(value));
  set_has_scenario_type();
  scenario_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.scenario_type)
}

// optional .jmc_auto.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
bool ScenarioConfig::has_lane_follow_config() const {
  return scenario_config_case() == kLaneFollowConfig;
}
void ScenarioConfig::set_has_lane_follow_config() {
  _oneof_case_[0] = kLaneFollowConfig;
}
void ScenarioConfig::clear_lane_follow_config() {
  if (has_lane_follow_config()) {
    delete scenario_config_.lane_follow_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioLaneFollowConfig& ScenarioConfig::lane_follow_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.lane_follow_config)
  return has_lane_follow_config()
      ? *scenario_config_.lane_follow_config_
      : ::jmc_auto::planning::ScenarioLaneFollowConfig::default_instance();
}
::jmc_auto::planning::ScenarioLaneFollowConfig* ScenarioConfig::mutable_lane_follow_config() {
  if (!has_lane_follow_config()) {
    clear_scenario_config();
    set_has_lane_follow_config();
    scenario_config_.lane_follow_config_ = new ::jmc_auto::planning::ScenarioLaneFollowConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.lane_follow_config)
  return scenario_config_.lane_follow_config_;
}
::jmc_auto::planning::ScenarioLaneFollowConfig* ScenarioConfig::release_lane_follow_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.lane_follow_config)
  if (has_lane_follow_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioLaneFollowConfig* temp = scenario_config_.lane_follow_config_;
    scenario_config_.lane_follow_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_lane_follow_config(::jmc_auto::planning::ScenarioLaneFollowConfig* lane_follow_config) {
  clear_scenario_config();
  if (lane_follow_config) {
    set_has_lane_follow_config();
    scenario_config_.lane_follow_config_ = lane_follow_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.lane_follow_config)
}

// optional .jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
bool ScenarioConfig::has_bare_intersection_unprotected_config() const {
  return scenario_config_case() == kBareIntersectionUnprotectedConfig;
}
void ScenarioConfig::set_has_bare_intersection_unprotected_config() {
  _oneof_case_[0] = kBareIntersectionUnprotectedConfig;
}
void ScenarioConfig::clear_bare_intersection_unprotected_config() {
  if (has_bare_intersection_unprotected_config()) {
    delete scenario_config_.bare_intersection_unprotected_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig& ScenarioConfig::bare_intersection_unprotected_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return has_bare_intersection_unprotected_config()
      ? *scenario_config_.bare_intersection_unprotected_config_
      : ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig::default_instance();
}
::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::mutable_bare_intersection_unprotected_config() {
  if (!has_bare_intersection_unprotected_config()) {
    clear_scenario_config();
    set_has_bare_intersection_unprotected_config();
    scenario_config_.bare_intersection_unprotected_config_ = new ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return scenario_config_.bare_intersection_unprotected_config_;
}
::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::release_bare_intersection_unprotected_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
  if (has_bare_intersection_unprotected_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* temp = scenario_config_.bare_intersection_unprotected_config_;
    scenario_config_.bare_intersection_unprotected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_bare_intersection_unprotected_config(::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config) {
  clear_scenario_config();
  if (bare_intersection_unprotected_config) {
    set_has_bare_intersection_unprotected_config();
    scenario_config_.bare_intersection_unprotected_config_ = bare_intersection_unprotected_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
}

// optional .jmc_auto.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 5;
bool ScenarioConfig::has_emergency_pull_over_config() const {
  return scenario_config_case() == kEmergencyPullOverConfig;
}
void ScenarioConfig::set_has_emergency_pull_over_config() {
  _oneof_case_[0] = kEmergencyPullOverConfig;
}
void ScenarioConfig::clear_emergency_pull_over_config() {
  if (has_emergency_pull_over_config()) {
    delete scenario_config_.emergency_pull_over_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioEmergencyPullOverConfig& ScenarioConfig::emergency_pull_over_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
  return has_emergency_pull_over_config()
      ? *scenario_config_.emergency_pull_over_config_
      : ::jmc_auto::planning::ScenarioEmergencyPullOverConfig::default_instance();
}
::jmc_auto::planning::ScenarioEmergencyPullOverConfig* ScenarioConfig::mutable_emergency_pull_over_config() {
  if (!has_emergency_pull_over_config()) {
    clear_scenario_config();
    set_has_emergency_pull_over_config();
    scenario_config_.emergency_pull_over_config_ = new ::jmc_auto::planning::ScenarioEmergencyPullOverConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
  return scenario_config_.emergency_pull_over_config_;
}
::jmc_auto::planning::ScenarioEmergencyPullOverConfig* ScenarioConfig::release_emergency_pull_over_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
  if (has_emergency_pull_over_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* temp = scenario_config_.emergency_pull_over_config_;
    scenario_config_.emergency_pull_over_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_emergency_pull_over_config(::jmc_auto::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config) {
  clear_scenario_config();
  if (emergency_pull_over_config) {
    set_has_emergency_pull_over_config();
    scenario_config_.emergency_pull_over_config_ = emergency_pull_over_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
}

// optional .jmc_auto.planning.ScenarioEmergencyStopConfig emergency_stop_config = 6;
bool ScenarioConfig::has_emergency_stop_config() const {
  return scenario_config_case() == kEmergencyStopConfig;
}
void ScenarioConfig::set_has_emergency_stop_config() {
  _oneof_case_[0] = kEmergencyStopConfig;
}
void ScenarioConfig::clear_emergency_stop_config() {
  if (has_emergency_stop_config()) {
    delete scenario_config_.emergency_stop_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioEmergencyStopConfig& ScenarioConfig::emergency_stop_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
  return has_emergency_stop_config()
      ? *scenario_config_.emergency_stop_config_
      : ::jmc_auto::planning::ScenarioEmergencyStopConfig::default_instance();
}
::jmc_auto::planning::ScenarioEmergencyStopConfig* ScenarioConfig::mutable_emergency_stop_config() {
  if (!has_emergency_stop_config()) {
    clear_scenario_config();
    set_has_emergency_stop_config();
    scenario_config_.emergency_stop_config_ = new ::jmc_auto::planning::ScenarioEmergencyStopConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
  return scenario_config_.emergency_stop_config_;
}
::jmc_auto::planning::ScenarioEmergencyStopConfig* ScenarioConfig::release_emergency_stop_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
  if (has_emergency_stop_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioEmergencyStopConfig* temp = scenario_config_.emergency_stop_config_;
    scenario_config_.emergency_stop_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_emergency_stop_config(::jmc_auto::planning::ScenarioEmergencyStopConfig* emergency_stop_config) {
  clear_scenario_config();
  if (emergency_stop_config) {
    set_has_emergency_stop_config();
    scenario_config_.emergency_stop_config_ = emergency_stop_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
}

// optional .jmc_auto.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
bool ScenarioConfig::has_narrow_street_u_turn_config() const {
  return scenario_config_case() == kNarrowStreetUTurnConfig;
}
void ScenarioConfig::set_has_narrow_street_u_turn_config() {
  _oneof_case_[0] = kNarrowStreetUTurnConfig;
}
void ScenarioConfig::clear_narrow_street_u_turn_config() {
  if (has_narrow_street_u_turn_config()) {
    delete scenario_config_.narrow_street_u_turn_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig& ScenarioConfig::narrow_street_u_turn_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
  return has_narrow_street_u_turn_config()
      ? *scenario_config_.narrow_street_u_turn_config_
      : ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig::default_instance();
}
::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::mutable_narrow_street_u_turn_config() {
  if (!has_narrow_street_u_turn_config()) {
    clear_scenario_config();
    set_has_narrow_street_u_turn_config();
    scenario_config_.narrow_street_u_turn_config_ = new ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
  return scenario_config_.narrow_street_u_turn_config_;
}
::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::release_narrow_street_u_turn_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
  if (has_narrow_street_u_turn_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* temp = scenario_config_.narrow_street_u_turn_config_;
    scenario_config_.narrow_street_u_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_narrow_street_u_turn_config(::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config) {
  clear_scenario_config();
  if (narrow_street_u_turn_config) {
    set_has_narrow_street_u_turn_config();
    scenario_config_.narrow_street_u_turn_config_ = narrow_street_u_turn_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
}

// optional .jmc_auto.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 8;
bool ScenarioConfig::has_stop_sign_unprotected_config() const {
  return scenario_config_case() == kStopSignUnprotectedConfig;
}
void ScenarioConfig::set_has_stop_sign_unprotected_config() {
  _oneof_case_[0] = kStopSignUnprotectedConfig;
}
void ScenarioConfig::clear_stop_sign_unprotected_config() {
  if (has_stop_sign_unprotected_config()) {
    delete scenario_config_.stop_sign_unprotected_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig& ScenarioConfig::stop_sign_unprotected_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
  return has_stop_sign_unprotected_config()
      ? *scenario_config_.stop_sign_unprotected_config_
      : ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig::default_instance();
}
::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::mutable_stop_sign_unprotected_config() {
  if (!has_stop_sign_unprotected_config()) {
    clear_scenario_config();
    set_has_stop_sign_unprotected_config();
    scenario_config_.stop_sign_unprotected_config_ = new ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
  return scenario_config_.stop_sign_unprotected_config_;
}
::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::release_stop_sign_unprotected_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
  if (has_stop_sign_unprotected_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* temp = scenario_config_.stop_sign_unprotected_config_;
    scenario_config_.stop_sign_unprotected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_stop_sign_unprotected_config(::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config) {
  clear_scenario_config();
  if (stop_sign_unprotected_config) {
    set_has_stop_sign_unprotected_config();
    scenario_config_.stop_sign_unprotected_config_ = stop_sign_unprotected_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
}

// optional .jmc_auto.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 9;
bool ScenarioConfig::has_traffic_light_protected_config() const {
  return scenario_config_case() == kTrafficLightProtectedConfig;
}
void ScenarioConfig::set_has_traffic_light_protected_config() {
  _oneof_case_[0] = kTrafficLightProtectedConfig;
}
void ScenarioConfig::clear_traffic_light_protected_config() {
  if (has_traffic_light_protected_config()) {
    delete scenario_config_.traffic_light_protected_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig& ScenarioConfig::traffic_light_protected_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
  return has_traffic_light_protected_config()
      ? *scenario_config_.traffic_light_protected_config_
      : ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig::default_instance();
}
::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::mutable_traffic_light_protected_config() {
  if (!has_traffic_light_protected_config()) {
    clear_scenario_config();
    set_has_traffic_light_protected_config();
    scenario_config_.traffic_light_protected_config_ = new ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
  return scenario_config_.traffic_light_protected_config_;
}
::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::release_traffic_light_protected_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
  if (has_traffic_light_protected_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* temp = scenario_config_.traffic_light_protected_config_;
    scenario_config_.traffic_light_protected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_traffic_light_protected_config(::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config) {
  clear_scenario_config();
  if (traffic_light_protected_config) {
    set_has_traffic_light_protected_config();
    scenario_config_.traffic_light_protected_config_ = traffic_light_protected_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
}

// optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 10;
bool ScenarioConfig::has_traffic_light_unprotected_right_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedRightTurnConfig;
}
void ScenarioConfig::set_has_traffic_light_unprotected_right_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedRightTurnConfig;
}
void ScenarioConfig::clear_traffic_light_unprotected_right_turn_config() {
  if (has_traffic_light_unprotected_right_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_right_turn_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioConfig::traffic_light_unprotected_right_turn_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return has_traffic_light_unprotected_right_turn_config()
      ? *scenario_config_.traffic_light_unprotected_right_turn_config_
      : ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig::default_instance();
}
::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_right_turn_config() {
  if (!has_traffic_light_unprotected_right_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_right_turn_config();
    scenario_config_.traffic_light_unprotected_right_turn_config_ = new ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return scenario_config_.traffic_light_unprotected_right_turn_config_;
}
::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::release_traffic_light_unprotected_right_turn_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  if (has_traffic_light_unprotected_right_turn_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* temp = scenario_config_.traffic_light_unprotected_right_turn_config_;
    scenario_config_.traffic_light_unprotected_right_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_traffic_light_unprotected_right_turn_config(::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config) {
  clear_scenario_config();
  if (traffic_light_unprotected_right_turn_config) {
    set_has_traffic_light_unprotected_right_turn_config();
    scenario_config_.traffic_light_unprotected_right_turn_config_ = traffic_light_unprotected_right_turn_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
}

// optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 11;
bool ScenarioConfig::has_traffic_light_unprotected_left_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedLeftTurnConfig;
}
void ScenarioConfig::set_has_traffic_light_unprotected_left_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedLeftTurnConfig;
}
void ScenarioConfig::clear_traffic_light_unprotected_left_turn_config() {
  if (has_traffic_light_unprotected_left_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_left_turn_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioConfig::traffic_light_unprotected_left_turn_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return has_traffic_light_unprotected_left_turn_config()
      ? *scenario_config_.traffic_light_unprotected_left_turn_config_
      : ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig::default_instance();
}
::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_left_turn_config() {
  if (!has_traffic_light_unprotected_left_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_left_turn_config();
    scenario_config_.traffic_light_unprotected_left_turn_config_ = new ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return scenario_config_.traffic_light_unprotected_left_turn_config_;
}
::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::release_traffic_light_unprotected_left_turn_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  if (has_traffic_light_unprotected_left_turn_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* temp = scenario_config_.traffic_light_unprotected_left_turn_config_;
    scenario_config_.traffic_light_unprotected_left_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_traffic_light_unprotected_left_turn_config(::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config) {
  clear_scenario_config();
  if (traffic_light_unprotected_left_turn_config) {
    set_has_traffic_light_unprotected_left_turn_config();
    scenario_config_.traffic_light_unprotected_left_turn_config_ = traffic_light_unprotected_left_turn_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
}

// optional .jmc_auto.planning.ScenarioParkAndGoConfig park_and_go_config = 12;
bool ScenarioConfig::has_park_and_go_config() const {
  return scenario_config_case() == kParkAndGoConfig;
}
void ScenarioConfig::set_has_park_and_go_config() {
  _oneof_case_[0] = kParkAndGoConfig;
}
void ScenarioConfig::clear_park_and_go_config() {
  if (has_park_and_go_config()) {
    delete scenario_config_.park_and_go_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioParkAndGoConfig& ScenarioConfig::park_and_go_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.park_and_go_config)
  return has_park_and_go_config()
      ? *scenario_config_.park_and_go_config_
      : ::jmc_auto::planning::ScenarioParkAndGoConfig::default_instance();
}
::jmc_auto::planning::ScenarioParkAndGoConfig* ScenarioConfig::mutable_park_and_go_config() {
  if (!has_park_and_go_config()) {
    clear_scenario_config();
    set_has_park_and_go_config();
    scenario_config_.park_and_go_config_ = new ::jmc_auto::planning::ScenarioParkAndGoConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.park_and_go_config)
  return scenario_config_.park_and_go_config_;
}
::jmc_auto::planning::ScenarioParkAndGoConfig* ScenarioConfig::release_park_and_go_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.park_and_go_config)
  if (has_park_and_go_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioParkAndGoConfig* temp = scenario_config_.park_and_go_config_;
    scenario_config_.park_and_go_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_park_and_go_config(::jmc_auto::planning::ScenarioParkAndGoConfig* park_and_go_config) {
  clear_scenario_config();
  if (park_and_go_config) {
    set_has_park_and_go_config();
    scenario_config_.park_and_go_config_ = park_and_go_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.park_and_go_config)
}

// optional .jmc_auto.planning.ScenarioPullOverConfig pull_over_config = 13;
bool ScenarioConfig::has_pull_over_config() const {
  return scenario_config_case() == kPullOverConfig;
}
void ScenarioConfig::set_has_pull_over_config() {
  _oneof_case_[0] = kPullOverConfig;
}
void ScenarioConfig::clear_pull_over_config() {
  if (has_pull_over_config()) {
    delete scenario_config_.pull_over_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioPullOverConfig& ScenarioConfig::pull_over_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.pull_over_config)
  return has_pull_over_config()
      ? *scenario_config_.pull_over_config_
      : ::jmc_auto::planning::ScenarioPullOverConfig::default_instance();
}
::jmc_auto::planning::ScenarioPullOverConfig* ScenarioConfig::mutable_pull_over_config() {
  if (!has_pull_over_config()) {
    clear_scenario_config();
    set_has_pull_over_config();
    scenario_config_.pull_over_config_ = new ::jmc_auto::planning::ScenarioPullOverConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.pull_over_config)
  return scenario_config_.pull_over_config_;
}
::jmc_auto::planning::ScenarioPullOverConfig* ScenarioConfig::release_pull_over_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.pull_over_config)
  if (has_pull_over_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioPullOverConfig* temp = scenario_config_.pull_over_config_;
    scenario_config_.pull_over_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_pull_over_config(::jmc_auto::planning::ScenarioPullOverConfig* pull_over_config) {
  clear_scenario_config();
  if (pull_over_config) {
    set_has_pull_over_config();
    scenario_config_.pull_over_config_ = pull_over_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.pull_over_config)
}

// optional .jmc_auto.planning.ScenarioValetParkingConfig valet_parking_config = 14;
bool ScenarioConfig::has_valet_parking_config() const {
  return scenario_config_case() == kValetParkingConfig;
}
void ScenarioConfig::set_has_valet_parking_config() {
  _oneof_case_[0] = kValetParkingConfig;
}
void ScenarioConfig::clear_valet_parking_config() {
  if (has_valet_parking_config()) {
    delete scenario_config_.valet_parking_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioValetParkingConfig& ScenarioConfig::valet_parking_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.valet_parking_config)
  return has_valet_parking_config()
      ? *scenario_config_.valet_parking_config_
      : ::jmc_auto::planning::ScenarioValetParkingConfig::default_instance();
}
::jmc_auto::planning::ScenarioValetParkingConfig* ScenarioConfig::mutable_valet_parking_config() {
  if (!has_valet_parking_config()) {
    clear_scenario_config();
    set_has_valet_parking_config();
    scenario_config_.valet_parking_config_ = new ::jmc_auto::planning::ScenarioValetParkingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.valet_parking_config)
  return scenario_config_.valet_parking_config_;
}
::jmc_auto::planning::ScenarioValetParkingConfig* ScenarioConfig::release_valet_parking_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.valet_parking_config)
  if (has_valet_parking_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioValetParkingConfig* temp = scenario_config_.valet_parking_config_;
    scenario_config_.valet_parking_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_valet_parking_config(::jmc_auto::planning::ScenarioValetParkingConfig* valet_parking_config) {
  clear_scenario_config();
  if (valet_parking_config) {
    set_has_valet_parking_config();
    scenario_config_.valet_parking_config_ = valet_parking_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.valet_parking_config)
}

// optional .jmc_auto.planning.ScenarioYieldSignConfig yield_sign_config = 15;
bool ScenarioConfig::has_yield_sign_config() const {
  return scenario_config_case() == kYieldSignConfig;
}
void ScenarioConfig::set_has_yield_sign_config() {
  _oneof_case_[0] = kYieldSignConfig;
}
void ScenarioConfig::clear_yield_sign_config() {
  if (has_yield_sign_config()) {
    delete scenario_config_.yield_sign_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioYieldSignConfig& ScenarioConfig::yield_sign_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.yield_sign_config)
  return has_yield_sign_config()
      ? *scenario_config_.yield_sign_config_
      : ::jmc_auto::planning::ScenarioYieldSignConfig::default_instance();
}
::jmc_auto::planning::ScenarioYieldSignConfig* ScenarioConfig::mutable_yield_sign_config() {
  if (!has_yield_sign_config()) {
    clear_scenario_config();
    set_has_yield_sign_config();
    scenario_config_.yield_sign_config_ = new ::jmc_auto::planning::ScenarioYieldSignConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.yield_sign_config)
  return scenario_config_.yield_sign_config_;
}
::jmc_auto::planning::ScenarioYieldSignConfig* ScenarioConfig::release_yield_sign_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.yield_sign_config)
  if (has_yield_sign_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioYieldSignConfig* temp = scenario_config_.yield_sign_config_;
    scenario_config_.yield_sign_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_yield_sign_config(::jmc_auto::planning::ScenarioYieldSignConfig* yield_sign_config) {
  clear_scenario_config();
  if (yield_sign_config) {
    set_has_yield_sign_config();
    scenario_config_.yield_sign_config_ = yield_sign_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.yield_sign_config)
}

// optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
bool ScenarioConfig::has_test_learning_model_config() const {
  return scenario_config_case() == kTestLearningModelConfig;
}
void ScenarioConfig::set_has_test_learning_model_config() {
  _oneof_case_[0] = kTestLearningModelConfig;
}
void ScenarioConfig::clear_test_learning_model_config() {
  if (has_test_learning_model_config()) {
    delete scenario_config_.test_learning_model_config_;
    clear_has_scenario_config();
  }
}
 const ::jmc_auto::planning::ScenarioTestLearningModelConfig& ScenarioConfig::test_learning_model_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
  return has_test_learning_model_config()
      ? *scenario_config_.test_learning_model_config_
      : ::jmc_auto::planning::ScenarioTestLearningModelConfig::default_instance();
}
::jmc_auto::planning::ScenarioTestLearningModelConfig* ScenarioConfig::mutable_test_learning_model_config() {
  if (!has_test_learning_model_config()) {
    clear_scenario_config();
    set_has_test_learning_model_config();
    scenario_config_.test_learning_model_config_ = new ::jmc_auto::planning::ScenarioTestLearningModelConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
  return scenario_config_.test_learning_model_config_;
}
::jmc_auto::planning::ScenarioTestLearningModelConfig* ScenarioConfig::release_test_learning_model_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
  if (has_test_learning_model_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTestLearningModelConfig* temp = scenario_config_.test_learning_model_config_;
    scenario_config_.test_learning_model_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ScenarioConfig::set_allocated_test_learning_model_config(::jmc_auto::planning::ScenarioTestLearningModelConfig* test_learning_model_config) {
  clear_scenario_config();
  if (test_learning_model_config) {
    set_has_test_learning_model_config();
    scenario_config_.test_learning_model_config_ = test_learning_model_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
}

// repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
int ScenarioConfig::stage_type_size() const {
  return stage_type_.size();
}
void ScenarioConfig::clear_stage_type() {
  stage_type_.Clear();
}
::jmc_auto::planning::ScenarioConfig_StageType ScenarioConfig::stage_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.stage_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(stage_type_.Get(index));
}
void ScenarioConfig::set_stage_type(int index, ::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.stage_type)
}
void ScenarioConfig::add_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.stage_type)
}
const ::google::protobuf::RepeatedField<int>&
ScenarioConfig::stage_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.stage_type)
  return stage_type_;
}
::google::protobuf::RepeatedField<int>*
ScenarioConfig::mutable_stage_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.stage_type)
  return &stage_type_;
}

// repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
int ScenarioConfig::stage_config_size() const {
  return stage_config_.size();
}
void ScenarioConfig::clear_stage_config() {
  stage_config_.Clear();
}
const ::jmc_auto::planning::ScenarioConfig_StageConfig& ScenarioConfig::stage_config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_.Get(index);
}
::jmc_auto::planning::ScenarioConfig_StageConfig* ScenarioConfig::mutable_stage_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_.Mutable(index);
}
::jmc_auto::planning::ScenarioConfig_StageConfig* ScenarioConfig::add_stage_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_.Add();
}
::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig >*
ScenarioConfig::mutable_stage_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.stage_config)
  return &stage_config_;
}
const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig >&
ScenarioConfig::stage_config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_;
}

bool ScenarioConfig::has_scenario_config() const {
  return scenario_config_case() != SCENARIO_CONFIG_NOT_SET;
}
void ScenarioConfig::clear_has_scenario_config() {
  _oneof_case_[0] = SCENARIO_CONFIG_NOT_SET;
}
ScenarioConfig::ScenarioConfigCase ScenarioConfig::scenario_config_case() const {
  return ScenarioConfig::ScenarioConfigCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PlannerPublicRoadConfig::PlannerPublicRoadConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.PlannerPublicRoadConfig)
}
PlannerPublicRoadConfig::PlannerPublicRoadConfig(const PlannerPublicRoadConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.PlannerPublicRoadConfig)
}

void PlannerPublicRoadConfig::SharedCtor() {
  _cached_size_ = 0;
}

PlannerPublicRoadConfig::~PlannerPublicRoadConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.PlannerPublicRoadConfig)
  SharedDtor();
}

void PlannerPublicRoadConfig::SharedDtor() {
}

void PlannerPublicRoadConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlannerPublicRoadConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PlannerPublicRoadConfig& PlannerPublicRoadConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

PlannerPublicRoadConfig* PlannerPublicRoadConfig::New(::google::protobuf::Arena* arena) const {
  PlannerPublicRoadConfig* n = new PlannerPublicRoadConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PlannerPublicRoadConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.PlannerPublicRoadConfig)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PlannerPublicRoadConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.PlannerPublicRoadConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.PlannerPublicRoadConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.PlannerPublicRoadConfig)
  return false;
#undef DO_
}

void PlannerPublicRoadConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.PlannerPublicRoadConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.PlannerPublicRoadConfig)
}

::google::protobuf::uint8* PlannerPublicRoadConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.PlannerPublicRoadConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.PlannerPublicRoadConfig)
  return target;
}

size_t PlannerPublicRoadConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.PlannerPublicRoadConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlannerPublicRoadConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.PlannerPublicRoadConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const PlannerPublicRoadConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PlannerPublicRoadConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.PlannerPublicRoadConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.PlannerPublicRoadConfig)
    MergeFrom(*source);
  }
}

void PlannerPublicRoadConfig::MergeFrom(const PlannerPublicRoadConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.PlannerPublicRoadConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void PlannerPublicRoadConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.PlannerPublicRoadConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlannerPublicRoadConfig::CopyFrom(const PlannerPublicRoadConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.PlannerPublicRoadConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlannerPublicRoadConfig::IsInitialized() const {
  return true;
}

void PlannerPublicRoadConfig::Swap(PlannerPublicRoadConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PlannerPublicRoadConfig::InternalSwap(PlannerPublicRoadConfig* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PlannerPublicRoadConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PlannerPublicRoadConfig

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PlannerNaviConfig::kTaskFieldNumber;
const int PlannerNaviConfig::kNaviPathDeciderConfigFieldNumber;
const int PlannerNaviConfig::kNaviSpeedDeciderConfigFieldNumber;
const int PlannerNaviConfig::kNaviObstacleDeciderConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PlannerNaviConfig::PlannerNaviConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.PlannerNaviConfig)
}
PlannerNaviConfig::PlannerNaviConfig(const PlannerNaviConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      task_(from.task_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_navi_path_decider_config()) {
    navi_path_decider_config_ = new ::jmc_auto::planning::NaviPathDeciderConfig(*from.navi_path_decider_config_);
  } else {
    navi_path_decider_config_ = NULL;
  }
  if (from.has_navi_speed_decider_config()) {
    navi_speed_decider_config_ = new ::jmc_auto::planning::NaviSpeedDeciderConfig(*from.navi_speed_decider_config_);
  } else {
    navi_speed_decider_config_ = NULL;
  }
  if (from.has_navi_obstacle_decider_config()) {
    navi_obstacle_decider_config_ = new ::jmc_auto::planning::NaviObstacleDeciderConfig(*from.navi_obstacle_decider_config_);
  } else {
    navi_obstacle_decider_config_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.PlannerNaviConfig)
}

void PlannerNaviConfig::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&navi_path_decider_config_, 0, reinterpret_cast<char*>(&navi_obstacle_decider_config_) -
    reinterpret_cast<char*>(&navi_path_decider_config_) + sizeof(navi_obstacle_decider_config_));
}

PlannerNaviConfig::~PlannerNaviConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.PlannerNaviConfig)
  SharedDtor();
}

void PlannerNaviConfig::SharedDtor() {
  if (this != internal_default_instance()) {
    delete navi_path_decider_config_;
  }
  if (this != internal_default_instance()) {
    delete navi_speed_decider_config_;
  }
  if (this != internal_default_instance()) {
    delete navi_obstacle_decider_config_;
  }
}

void PlannerNaviConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlannerNaviConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PlannerNaviConfig& PlannerNaviConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

PlannerNaviConfig* PlannerNaviConfig::New(::google::protobuf::Arena* arena) const {
  PlannerNaviConfig* n = new PlannerNaviConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PlannerNaviConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.PlannerNaviConfig)
  task_.Clear();
  if (_has_bits_[0 / 32] & 7u) {
    if (has_navi_path_decider_config()) {
      GOOGLE_DCHECK(navi_path_decider_config_ != NULL);
      navi_path_decider_config_->::jmc_auto::planning::NaviPathDeciderConfig::Clear();
    }
    if (has_navi_speed_decider_config()) {
      GOOGLE_DCHECK(navi_speed_decider_config_ != NULL);
      navi_speed_decider_config_->::jmc_auto::planning::NaviSpeedDeciderConfig::Clear();
    }
    if (has_navi_obstacle_decider_config()) {
      GOOGLE_DCHECK(navi_obstacle_decider_config_ != NULL);
      navi_obstacle_decider_config_->::jmc_auto::planning::NaviObstacleDeciderConfig::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PlannerNaviConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.PlannerNaviConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::TaskConfig_TaskType_IsValid(value)) {
            add_task(static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::jmc_auto::planning::TaskConfig_TaskType_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_task())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_navi_path_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_navi_speed_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_navi_obstacle_decider_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.PlannerNaviConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.PlannerNaviConfig)
  return false;
#undef DO_
}

void PlannerNaviConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.PlannerNaviConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
  for (int i = 0, n = this->task_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->task(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->navi_path_decider_config_, output);
  }

  // optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->navi_speed_decider_config_, output);
  }

  // optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->navi_obstacle_decider_config_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.PlannerNaviConfig)
}

::google::protobuf::uint8* PlannerNaviConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.PlannerNaviConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
  target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
    1, this->task_, target);

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->navi_path_decider_config_, deterministic, target);
  }

  // optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->navi_speed_decider_config_, deterministic, target);
  }

  // optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->navi_obstacle_decider_config_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.PlannerNaviConfig)
  return target;
}

size_t PlannerNaviConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.PlannerNaviConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->task_size();for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->task(i));
    }
    total_size += (1UL * count) + data_size;
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
    if (has_navi_path_decider_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->navi_path_decider_config_);
    }

    // optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
    if (has_navi_speed_decider_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->navi_speed_decider_config_);
    }

    // optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
    if (has_navi_obstacle_decider_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->navi_obstacle_decider_config_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlannerNaviConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.PlannerNaviConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const PlannerNaviConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PlannerNaviConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.PlannerNaviConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.PlannerNaviConfig)
    MergeFrom(*source);
  }
}

void PlannerNaviConfig::MergeFrom(const PlannerNaviConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.PlannerNaviConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  task_.MergeFrom(from.task_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_navi_path_decider_config()->::jmc_auto::planning::NaviPathDeciderConfig::MergeFrom(from.navi_path_decider_config());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_navi_speed_decider_config()->::jmc_auto::planning::NaviSpeedDeciderConfig::MergeFrom(from.navi_speed_decider_config());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_navi_obstacle_decider_config()->::jmc_auto::planning::NaviObstacleDeciderConfig::MergeFrom(from.navi_obstacle_decider_config());
    }
  }
}

void PlannerNaviConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.PlannerNaviConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlannerNaviConfig::CopyFrom(const PlannerNaviConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.PlannerNaviConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlannerNaviConfig::IsInitialized() const {
  return true;
}

void PlannerNaviConfig::Swap(PlannerNaviConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PlannerNaviConfig::InternalSwap(PlannerNaviConfig* other) {
  task_.InternalSwap(&other->task_);
  std::swap(navi_path_decider_config_, other->navi_path_decider_config_);
  std::swap(navi_speed_decider_config_, other->navi_speed_decider_config_);
  std::swap(navi_obstacle_decider_config_, other->navi_obstacle_decider_config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PlannerNaviConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PlannerNaviConfig

// repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
int PlannerNaviConfig::task_size() const {
  return task_.size();
}
void PlannerNaviConfig::clear_task() {
  task_.Clear();
}
::jmc_auto::planning::TaskConfig_TaskType PlannerNaviConfig::task(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.task)
  return static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(task_.Get(index));
}
void PlannerNaviConfig::set_task(int index, ::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PlannerNaviConfig.task)
}
void PlannerNaviConfig::add_task(::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PlannerNaviConfig.task)
}
const ::google::protobuf::RepeatedField<int>&
PlannerNaviConfig::task() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PlannerNaviConfig.task)
  return task_;
}
::google::protobuf::RepeatedField<int>*
PlannerNaviConfig::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PlannerNaviConfig.task)
  return &task_;
}

// optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
bool PlannerNaviConfig::has_navi_path_decider_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PlannerNaviConfig::set_has_navi_path_decider_config() {
  _has_bits_[0] |= 0x00000001u;
}
void PlannerNaviConfig::clear_has_navi_path_decider_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void PlannerNaviConfig::clear_navi_path_decider_config() {
  if (navi_path_decider_config_ != NULL) navi_path_decider_config_->::jmc_auto::planning::NaviPathDeciderConfig::Clear();
  clear_has_navi_path_decider_config();
}
const ::jmc_auto::planning::NaviPathDeciderConfig& PlannerNaviConfig::navi_path_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
  return navi_path_decider_config_ != NULL ? *navi_path_decider_config_
                         : *::jmc_auto::planning::NaviPathDeciderConfig::internal_default_instance();
}
::jmc_auto::planning::NaviPathDeciderConfig* PlannerNaviConfig::mutable_navi_path_decider_config() {
  set_has_navi_path_decider_config();
  if (navi_path_decider_config_ == NULL) {
    navi_path_decider_config_ = new ::jmc_auto::planning::NaviPathDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
  return navi_path_decider_config_;
}
::jmc_auto::planning::NaviPathDeciderConfig* PlannerNaviConfig::release_navi_path_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
  clear_has_navi_path_decider_config();
  ::jmc_auto::planning::NaviPathDeciderConfig* temp = navi_path_decider_config_;
  navi_path_decider_config_ = NULL;
  return temp;
}
void PlannerNaviConfig::set_allocated_navi_path_decider_config(::jmc_auto::planning::NaviPathDeciderConfig* navi_path_decider_config) {
  delete navi_path_decider_config_;
  navi_path_decider_config_ = navi_path_decider_config;
  if (navi_path_decider_config) {
    set_has_navi_path_decider_config();
  } else {
    clear_has_navi_path_decider_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
}

// optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
bool PlannerNaviConfig::has_navi_speed_decider_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PlannerNaviConfig::set_has_navi_speed_decider_config() {
  _has_bits_[0] |= 0x00000002u;
}
void PlannerNaviConfig::clear_has_navi_speed_decider_config() {
  _has_bits_[0] &= ~0x00000002u;
}
void PlannerNaviConfig::clear_navi_speed_decider_config() {
  if (navi_speed_decider_config_ != NULL) navi_speed_decider_config_->::jmc_auto::planning::NaviSpeedDeciderConfig::Clear();
  clear_has_navi_speed_decider_config();
}
const ::jmc_auto::planning::NaviSpeedDeciderConfig& PlannerNaviConfig::navi_speed_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
  return navi_speed_decider_config_ != NULL ? *navi_speed_decider_config_
                         : *::jmc_auto::planning::NaviSpeedDeciderConfig::internal_default_instance();
}
::jmc_auto::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::mutable_navi_speed_decider_config() {
  set_has_navi_speed_decider_config();
  if (navi_speed_decider_config_ == NULL) {
    navi_speed_decider_config_ = new ::jmc_auto::planning::NaviSpeedDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
  return navi_speed_decider_config_;
}
::jmc_auto::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::release_navi_speed_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
  clear_has_navi_speed_decider_config();
  ::jmc_auto::planning::NaviSpeedDeciderConfig* temp = navi_speed_decider_config_;
  navi_speed_decider_config_ = NULL;
  return temp;
}
void PlannerNaviConfig::set_allocated_navi_speed_decider_config(::jmc_auto::planning::NaviSpeedDeciderConfig* navi_speed_decider_config) {
  delete navi_speed_decider_config_;
  navi_speed_decider_config_ = navi_speed_decider_config;
  if (navi_speed_decider_config) {
    set_has_navi_speed_decider_config();
  } else {
    clear_has_navi_speed_decider_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
}

// optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
bool PlannerNaviConfig::has_navi_obstacle_decider_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PlannerNaviConfig::set_has_navi_obstacle_decider_config() {
  _has_bits_[0] |= 0x00000004u;
}
void PlannerNaviConfig::clear_has_navi_obstacle_decider_config() {
  _has_bits_[0] &= ~0x00000004u;
}
void PlannerNaviConfig::clear_navi_obstacle_decider_config() {
  if (navi_obstacle_decider_config_ != NULL) navi_obstacle_decider_config_->::jmc_auto::planning::NaviObstacleDeciderConfig::Clear();
  clear_has_navi_obstacle_decider_config();
}
const ::jmc_auto::planning::NaviObstacleDeciderConfig& PlannerNaviConfig::navi_obstacle_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return navi_obstacle_decider_config_ != NULL ? *navi_obstacle_decider_config_
                         : *::jmc_auto::planning::NaviObstacleDeciderConfig::internal_default_instance();
}
::jmc_auto::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::mutable_navi_obstacle_decider_config() {
  set_has_navi_obstacle_decider_config();
  if (navi_obstacle_decider_config_ == NULL) {
    navi_obstacle_decider_config_ = new ::jmc_auto::planning::NaviObstacleDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return navi_obstacle_decider_config_;
}
::jmc_auto::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::release_navi_obstacle_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  clear_has_navi_obstacle_decider_config();
  ::jmc_auto::planning::NaviObstacleDeciderConfig* temp = navi_obstacle_decider_config_;
  navi_obstacle_decider_config_ = NULL;
  return temp;
}
void PlannerNaviConfig::set_allocated_navi_obstacle_decider_config(::jmc_auto::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config) {
  delete navi_obstacle_decider_config_;
  navi_obstacle_decider_config_ = navi_obstacle_decider_config;
  if (navi_obstacle_decider_config) {
    set_has_navi_obstacle_decider_config();
  } else {
    clear_has_navi_obstacle_decider_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RtkPlanningConfig::kPlannerTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RtkPlanningConfig::RtkPlanningConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.RtkPlanningConfig)
}
RtkPlanningConfig::RtkPlanningConfig(const RtkPlanningConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  planner_type_ = from.planner_type_;
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.RtkPlanningConfig)
}

void RtkPlanningConfig::SharedCtor() {
  _cached_size_ = 0;
  planner_type_ = 0;
}

RtkPlanningConfig::~RtkPlanningConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.RtkPlanningConfig)
  SharedDtor();
}

void RtkPlanningConfig::SharedDtor() {
}

void RtkPlanningConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RtkPlanningConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RtkPlanningConfig& RtkPlanningConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

RtkPlanningConfig* RtkPlanningConfig::New(::google::protobuf::Arena* arena) const {
  RtkPlanningConfig* n = new RtkPlanningConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RtkPlanningConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.RtkPlanningConfig)
  planner_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RtkPlanningConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.RtkPlanningConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.PlannerType planner_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::PlannerType_IsValid(value)) {
            set_planner_type(static_cast< ::jmc_auto::planning::PlannerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.RtkPlanningConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.RtkPlanningConfig)
  return false;
#undef DO_
}

void RtkPlanningConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.RtkPlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PlannerType planner_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->planner_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.RtkPlanningConfig)
}

::google::protobuf::uint8* RtkPlanningConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.RtkPlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PlannerType planner_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->planner_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.RtkPlanningConfig)
  return target;
}

size_t RtkPlanningConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.RtkPlanningConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .jmc_auto.planning.PlannerType planner_type = 1;
  if (has_planner_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->planner_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RtkPlanningConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.RtkPlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const RtkPlanningConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RtkPlanningConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.RtkPlanningConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.RtkPlanningConfig)
    MergeFrom(*source);
  }
}

void RtkPlanningConfig::MergeFrom(const RtkPlanningConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.RtkPlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_planner_type()) {
    set_planner_type(from.planner_type());
  }
}

void RtkPlanningConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.RtkPlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RtkPlanningConfig::CopyFrom(const RtkPlanningConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.RtkPlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RtkPlanningConfig::IsInitialized() const {
  return true;
}

void RtkPlanningConfig::Swap(RtkPlanningConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RtkPlanningConfig::InternalSwap(RtkPlanningConfig* other) {
  std::swap(planner_type_, other->planner_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RtkPlanningConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RtkPlanningConfig

// optional .jmc_auto.planning.PlannerType planner_type = 1;
bool RtkPlanningConfig::has_planner_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RtkPlanningConfig::set_has_planner_type() {
  _has_bits_[0] |= 0x00000001u;
}
void RtkPlanningConfig::clear_has_planner_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void RtkPlanningConfig::clear_planner_type() {
  planner_type_ = 0;
  clear_has_planner_type();
}
::jmc_auto::planning::PlannerType RtkPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.RtkPlanningConfig.planner_type)
  return static_cast< ::jmc_auto::planning::PlannerType >(planner_type_);
}
void RtkPlanningConfig::set_planner_type(::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  set_has_planner_type();
  planner_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.RtkPlanningConfig.planner_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StandardPlanningConfig::kPlannerTypeFieldNumber;
const int StandardPlanningConfig::kPlannerPublicRoadConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StandardPlanningConfig::StandardPlanningConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.StandardPlanningConfig)
}
StandardPlanningConfig::StandardPlanningConfig(const StandardPlanningConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      planner_type_(from.planner_type_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_planner_public_road_config()) {
    planner_public_road_config_ = new ::jmc_auto::planning::PlannerPublicRoadConfig(*from.planner_public_road_config_);
  } else {
    planner_public_road_config_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.StandardPlanningConfig)
}

void StandardPlanningConfig::SharedCtor() {
  _cached_size_ = 0;
  planner_public_road_config_ = NULL;
}

StandardPlanningConfig::~StandardPlanningConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.StandardPlanningConfig)
  SharedDtor();
}

void StandardPlanningConfig::SharedDtor() {
  if (this != internal_default_instance()) {
    delete planner_public_road_config_;
  }
}

void StandardPlanningConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StandardPlanningConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const StandardPlanningConfig& StandardPlanningConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

StandardPlanningConfig* StandardPlanningConfig::New(::google::protobuf::Arena* arena) const {
  StandardPlanningConfig* n = new StandardPlanningConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StandardPlanningConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.StandardPlanningConfig)
  planner_type_.Clear();
  if (has_planner_public_road_config()) {
    GOOGLE_DCHECK(planner_public_road_config_ != NULL);
    planner_public_road_config_->::jmc_auto::planning::PlannerPublicRoadConfig::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StandardPlanningConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.StandardPlanningConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .jmc_auto.planning.PlannerType planner_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::PlannerType_IsValid(value)) {
            add_planner_type(static_cast< ::jmc_auto::planning::PlannerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::jmc_auto::planning::PlannerType_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_planner_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_planner_public_road_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.StandardPlanningConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.StandardPlanningConfig)
  return false;
#undef DO_
}

void StandardPlanningConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.StandardPlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  for (int i = 0, n = this->planner_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->planner_type(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->planner_public_road_config_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.StandardPlanningConfig)
}

::google::protobuf::uint8* StandardPlanningConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.StandardPlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
    1, this->planner_type_, target);

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->planner_public_road_config_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.StandardPlanningConfig)
  return target;
}

size_t StandardPlanningConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.StandardPlanningConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->planner_type_size();for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->planner_type(i));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
  if (has_planner_public_road_config()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->planner_public_road_config_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StandardPlanningConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.StandardPlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const StandardPlanningConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const StandardPlanningConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.StandardPlanningConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.StandardPlanningConfig)
    MergeFrom(*source);
  }
}

void StandardPlanningConfig::MergeFrom(const StandardPlanningConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.StandardPlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  planner_type_.MergeFrom(from.planner_type_);
  if (from.has_planner_public_road_config()) {
    mutable_planner_public_road_config()->::jmc_auto::planning::PlannerPublicRoadConfig::MergeFrom(from.planner_public_road_config());
  }
}

void StandardPlanningConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.StandardPlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StandardPlanningConfig::CopyFrom(const StandardPlanningConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.StandardPlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardPlanningConfig::IsInitialized() const {
  return true;
}

void StandardPlanningConfig::Swap(StandardPlanningConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StandardPlanningConfig::InternalSwap(StandardPlanningConfig* other) {
  planner_type_.InternalSwap(&other->planner_type_);
  std::swap(planner_public_road_config_, other->planner_public_road_config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StandardPlanningConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StandardPlanningConfig

// repeated .jmc_auto.planning.PlannerType planner_type = 1;
int StandardPlanningConfig::planner_type_size() const {
  return planner_type_.size();
}
void StandardPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
::jmc_auto::planning::PlannerType StandardPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StandardPlanningConfig.planner_type)
  return static_cast< ::jmc_auto::planning::PlannerType >(planner_type_.Get(index));
}
void StandardPlanningConfig::set_planner_type(int index, ::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StandardPlanningConfig.planner_type)
}
void StandardPlanningConfig::add_planner_type(::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.StandardPlanningConfig.planner_type)
}
const ::google::protobuf::RepeatedField<int>&
StandardPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.StandardPlanningConfig.planner_type)
  return planner_type_;
}
::google::protobuf::RepeatedField<int>*
StandardPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.StandardPlanningConfig.planner_type)
  return &planner_type_;
}

// optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
bool StandardPlanningConfig::has_planner_public_road_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StandardPlanningConfig::set_has_planner_public_road_config() {
  _has_bits_[0] |= 0x00000001u;
}
void StandardPlanningConfig::clear_has_planner_public_road_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void StandardPlanningConfig::clear_planner_public_road_config() {
  if (planner_public_road_config_ != NULL) planner_public_road_config_->::jmc_auto::planning::PlannerPublicRoadConfig::Clear();
  clear_has_planner_public_road_config();
}
const ::jmc_auto::planning::PlannerPublicRoadConfig& StandardPlanningConfig::planner_public_road_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
  return planner_public_road_config_ != NULL ? *planner_public_road_config_
                         : *::jmc_auto::planning::PlannerPublicRoadConfig::internal_default_instance();
}
::jmc_auto::planning::PlannerPublicRoadConfig* StandardPlanningConfig::mutable_planner_public_road_config() {
  set_has_planner_public_road_config();
  if (planner_public_road_config_ == NULL) {
    planner_public_road_config_ = new ::jmc_auto::planning::PlannerPublicRoadConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
  return planner_public_road_config_;
}
::jmc_auto::planning::PlannerPublicRoadConfig* StandardPlanningConfig::release_planner_public_road_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
  clear_has_planner_public_road_config();
  ::jmc_auto::planning::PlannerPublicRoadConfig* temp = planner_public_road_config_;
  planner_public_road_config_ = NULL;
  return temp;
}
void StandardPlanningConfig::set_allocated_planner_public_road_config(::jmc_auto::planning::PlannerPublicRoadConfig* planner_public_road_config) {
  delete planner_public_road_config_;
  planner_public_road_config_ = planner_public_road_config;
  if (planner_public_road_config) {
    set_has_planner_public_road_config();
  } else {
    clear_has_planner_public_road_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NavigationPlanningConfig::kPlannerTypeFieldNumber;
const int NavigationPlanningConfig::kPlannerNaviConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NavigationPlanningConfig::NavigationPlanningConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.NavigationPlanningConfig)
}
NavigationPlanningConfig::NavigationPlanningConfig(const NavigationPlanningConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      planner_type_(from.planner_type_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_planner_navi_config()) {
    planner_navi_config_ = new ::jmc_auto::planning::PlannerNaviConfig(*from.planner_navi_config_);
  } else {
    planner_navi_config_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.NavigationPlanningConfig)
}

void NavigationPlanningConfig::SharedCtor() {
  _cached_size_ = 0;
  planner_navi_config_ = NULL;
}

NavigationPlanningConfig::~NavigationPlanningConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.NavigationPlanningConfig)
  SharedDtor();
}

void NavigationPlanningConfig::SharedDtor() {
  if (this != internal_default_instance()) {
    delete planner_navi_config_;
  }
}

void NavigationPlanningConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NavigationPlanningConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const NavigationPlanningConfig& NavigationPlanningConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

NavigationPlanningConfig* NavigationPlanningConfig::New(::google::protobuf::Arena* arena) const {
  NavigationPlanningConfig* n = new NavigationPlanningConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NavigationPlanningConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.NavigationPlanningConfig)
  planner_type_.Clear();
  if (has_planner_navi_config()) {
    GOOGLE_DCHECK(planner_navi_config_ != NULL);
    planner_navi_config_->::jmc_auto::planning::PlannerNaviConfig::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NavigationPlanningConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.NavigationPlanningConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .jmc_auto.planning.PlannerType planner_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::jmc_auto::planning::PlannerType_IsValid(value)) {
            add_planner_type(static_cast< ::jmc_auto::planning::PlannerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::jmc_auto::planning::PlannerType_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_planner_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_planner_navi_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.NavigationPlanningConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.NavigationPlanningConfig)
  return false;
#undef DO_
}

void NavigationPlanningConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.NavigationPlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  for (int i = 0, n = this->planner_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->planner_type(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->planner_navi_config_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.NavigationPlanningConfig)
}

::google::protobuf::uint8* NavigationPlanningConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.NavigationPlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
    1, this->planner_type_, target);

  cached_has_bits = _has_bits_[0];
  // optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->planner_navi_config_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.NavigationPlanningConfig)
  return target;
}

size_t NavigationPlanningConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.NavigationPlanningConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->planner_type_size();for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->planner_type(i));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
  if (has_planner_navi_config()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->planner_navi_config_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NavigationPlanningConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.NavigationPlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const NavigationPlanningConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NavigationPlanningConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.NavigationPlanningConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.NavigationPlanningConfig)
    MergeFrom(*source);
  }
}

void NavigationPlanningConfig::MergeFrom(const NavigationPlanningConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.NavigationPlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  planner_type_.MergeFrom(from.planner_type_);
  if (from.has_planner_navi_config()) {
    mutable_planner_navi_config()->::jmc_auto::planning::PlannerNaviConfig::MergeFrom(from.planner_navi_config());
  }
}

void NavigationPlanningConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.NavigationPlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NavigationPlanningConfig::CopyFrom(const NavigationPlanningConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.NavigationPlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavigationPlanningConfig::IsInitialized() const {
  return true;
}

void NavigationPlanningConfig::Swap(NavigationPlanningConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NavigationPlanningConfig::InternalSwap(NavigationPlanningConfig* other) {
  planner_type_.InternalSwap(&other->planner_type_);
  std::swap(planner_navi_config_, other->planner_navi_config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NavigationPlanningConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NavigationPlanningConfig

// repeated .jmc_auto.planning.PlannerType planner_type = 1;
int NavigationPlanningConfig::planner_type_size() const {
  return planner_type_.size();
}
void NavigationPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
::jmc_auto::planning::PlannerType NavigationPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.NavigationPlanningConfig.planner_type)
  return static_cast< ::jmc_auto::planning::PlannerType >(planner_type_.Get(index));
}
void NavigationPlanningConfig::set_planner_type(int index, ::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.NavigationPlanningConfig.planner_type)
}
void NavigationPlanningConfig::add_planner_type(::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.NavigationPlanningConfig.planner_type)
}
const ::google::protobuf::RepeatedField<int>&
NavigationPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.NavigationPlanningConfig.planner_type)
  return planner_type_;
}
::google::protobuf::RepeatedField<int>*
NavigationPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.NavigationPlanningConfig.planner_type)
  return &planner_type_;
}

// optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
bool NavigationPlanningConfig::has_planner_navi_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NavigationPlanningConfig::set_has_planner_navi_config() {
  _has_bits_[0] |= 0x00000001u;
}
void NavigationPlanningConfig::clear_has_planner_navi_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void NavigationPlanningConfig::clear_planner_navi_config() {
  if (planner_navi_config_ != NULL) planner_navi_config_->::jmc_auto::planning::PlannerNaviConfig::Clear();
  clear_has_planner_navi_config();
}
const ::jmc_auto::planning::PlannerNaviConfig& NavigationPlanningConfig::planner_navi_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
  return planner_navi_config_ != NULL ? *planner_navi_config_
                         : *::jmc_auto::planning::PlannerNaviConfig::internal_default_instance();
}
::jmc_auto::planning::PlannerNaviConfig* NavigationPlanningConfig::mutable_planner_navi_config() {
  set_has_planner_navi_config();
  if (planner_navi_config_ == NULL) {
    planner_navi_config_ = new ::jmc_auto::planning::PlannerNaviConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
  return planner_navi_config_;
}
::jmc_auto::planning::PlannerNaviConfig* NavigationPlanningConfig::release_planner_navi_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
  clear_has_planner_navi_config();
  ::jmc_auto::planning::PlannerNaviConfig* temp = planner_navi_config_;
  planner_navi_config_ = NULL;
  return temp;
}
void NavigationPlanningConfig::set_allocated_planner_navi_config(::jmc_auto::planning::PlannerNaviConfig* planner_navi_config) {
  delete planner_navi_config_;
  planner_navi_config_ = planner_navi_config;
  if (planner_navi_config) {
    set_has_planner_navi_config();
  } else {
    clear_has_planner_navi_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PlanningConfig::kRtkPlanningConfigFieldNumber;
const int PlanningConfig::kStandardPlanningConfigFieldNumber;
const int PlanningConfig::kNavigationPlanningConfigFieldNumber;
const int PlanningConfig::kDefaultTaskConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PlanningConfig::PlanningConfig()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:jmc_auto.planning.PlanningConfig)
}
PlanningConfig::PlanningConfig(const PlanningConfig& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      default_task_config_(from.default_task_config_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_planning_config();
  switch (from.planning_config_case()) {
    case kRtkPlanningConfig: {
      mutable_rtk_planning_config()->::jmc_auto::planning::RtkPlanningConfig::MergeFrom(from.rtk_planning_config());
      break;
    }
    case kStandardPlanningConfig: {
      mutable_standard_planning_config()->::jmc_auto::planning::StandardPlanningConfig::MergeFrom(from.standard_planning_config());
      break;
    }
    case kNavigationPlanningConfig: {
      mutable_navigation_planning_config()->::jmc_auto::planning::NavigationPlanningConfig::MergeFrom(from.navigation_planning_config());
      break;
    }
    case PLANNING_CONFIG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:jmc_auto.planning.PlanningConfig)
}

void PlanningConfig::SharedCtor() {
  _cached_size_ = 0;
  clear_has_planning_config();
}

PlanningConfig::~PlanningConfig() {
  // @@protoc_insertion_point(destructor:jmc_auto.planning.PlanningConfig)
  SharedDtor();
}

void PlanningConfig::SharedDtor() {
  if (has_planning_config()) {
    clear_planning_config();
  }
}

void PlanningConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlanningConfig::descriptor() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PlanningConfig& PlanningConfig::default_instance() {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::InitDefaults();
  return *internal_default_instance();
}

PlanningConfig* PlanningConfig::New(::google::protobuf::Arena* arena) const {
  PlanningConfig* n = new PlanningConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PlanningConfig::clear_planning_config() {
// @@protoc_insertion_point(one_of_clear_start:jmc_auto.planning.PlanningConfig)
  switch (planning_config_case()) {
    case kRtkPlanningConfig: {
      delete planning_config_.rtk_planning_config_;
      break;
    }
    case kStandardPlanningConfig: {
      delete planning_config_.standard_planning_config_;
      break;
    }
    case kNavigationPlanningConfig: {
      delete planning_config_.navigation_planning_config_;
      break;
    }
    case PLANNING_CONFIG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PLANNING_CONFIG_NOT_SET;
}


void PlanningConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:jmc_auto.planning.PlanningConfig)
  default_task_config_.Clear();
  clear_planning_config();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PlanningConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:jmc_auto.planning.PlanningConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .jmc_auto.planning.RtkPlanningConfig rtk_planning_config = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rtk_planning_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.StandardPlanningConfig standard_planning_config = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_standard_planning_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .jmc_auto.planning.NavigationPlanningConfig navigation_planning_config = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_navigation_planning_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_default_task_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:jmc_auto.planning.PlanningConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:jmc_auto.planning.PlanningConfig)
  return false;
#undef DO_
}

void PlanningConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:jmc_auto.planning.PlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (planning_config_case()) {
    case kRtkPlanningConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        1, *planning_config_.rtk_planning_config_, output);
      break;
    case kStandardPlanningConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, *planning_config_.standard_planning_config_, output);
      break;
    case kNavigationPlanningConfig:
      ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, *planning_config_.navigation_planning_config_, output);
      break;
    default: ;
  }
  // repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
  for (unsigned int i = 0, n = this->default_task_config_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->default_task_config(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:jmc_auto.planning.PlanningConfig)
}

::google::protobuf::uint8* PlanningConfig::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:jmc_auto.planning.PlanningConfig)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (planning_config_case()) {
    case kRtkPlanningConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          1, *planning_config_.rtk_planning_config_, deterministic, target);
      break;
    case kStandardPlanningConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          2, *planning_config_.standard_planning_config_, deterministic, target);
      break;
    case kNavigationPlanningConfig:
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessageNoVirtualToArray(
          3, *planning_config_.navigation_planning_config_, deterministic, target);
      break;
    default: ;
  }
  // repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
  for (unsigned int i = 0, n = this->default_task_config_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->default_task_config(i), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:jmc_auto.planning.PlanningConfig)
  return target;
}

size_t PlanningConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:jmc_auto.planning.PlanningConfig)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
  {
    unsigned int count = this->default_task_config_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->default_task_config(i));
    }
  }

  switch (planning_config_case()) {
    // optional .jmc_auto.planning.RtkPlanningConfig rtk_planning_config = 1;
    case kRtkPlanningConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *planning_config_.rtk_planning_config_);
      break;
    }
    // optional .jmc_auto.planning.StandardPlanningConfig standard_planning_config = 2;
    case kStandardPlanningConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *planning_config_.standard_planning_config_);
      break;
    }
    // optional .jmc_auto.planning.NavigationPlanningConfig navigation_planning_config = 3;
    case kNavigationPlanningConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *planning_config_.navigation_planning_config_);
      break;
    }
    case PLANNING_CONFIG_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlanningConfig::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:jmc_auto.planning.PlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const PlanningConfig* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PlanningConfig>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:jmc_auto.planning.PlanningConfig)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:jmc_auto.planning.PlanningConfig)
    MergeFrom(*source);
  }
}

void PlanningConfig::MergeFrom(const PlanningConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:jmc_auto.planning.PlanningConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  default_task_config_.MergeFrom(from.default_task_config_);
  switch (from.planning_config_case()) {
    case kRtkPlanningConfig: {
      mutable_rtk_planning_config()->::jmc_auto::planning::RtkPlanningConfig::MergeFrom(from.rtk_planning_config());
      break;
    }
    case kStandardPlanningConfig: {
      mutable_standard_planning_config()->::jmc_auto::planning::StandardPlanningConfig::MergeFrom(from.standard_planning_config());
      break;
    }
    case kNavigationPlanningConfig: {
      mutable_navigation_planning_config()->::jmc_auto::planning::NavigationPlanningConfig::MergeFrom(from.navigation_planning_config());
      break;
    }
    case PLANNING_CONFIG_NOT_SET: {
      break;
    }
  }
}

void PlanningConfig::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:jmc_auto.planning.PlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlanningConfig::CopyFrom(const PlanningConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:jmc_auto.planning.PlanningConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanningConfig::IsInitialized() const {
  return true;
}

void PlanningConfig::Swap(PlanningConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PlanningConfig::InternalSwap(PlanningConfig* other) {
  default_task_config_.InternalSwap(&other->default_task_config_);
  std::swap(planning_config_, other->planning_config_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PlanningConfig::GetMetadata() const {
  protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PlanningConfig

// optional .jmc_auto.planning.RtkPlanningConfig rtk_planning_config = 1;
bool PlanningConfig::has_rtk_planning_config() const {
  return planning_config_case() == kRtkPlanningConfig;
}
void PlanningConfig::set_has_rtk_planning_config() {
  _oneof_case_[0] = kRtkPlanningConfig;
}
void PlanningConfig::clear_rtk_planning_config() {
  if (has_rtk_planning_config()) {
    delete planning_config_.rtk_planning_config_;
    clear_has_planning_config();
  }
}
 const ::jmc_auto::planning::RtkPlanningConfig& PlanningConfig::rtk_planning_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.rtk_planning_config)
  return has_rtk_planning_config()
      ? *planning_config_.rtk_planning_config_
      : ::jmc_auto::planning::RtkPlanningConfig::default_instance();
}
::jmc_auto::planning::RtkPlanningConfig* PlanningConfig::mutable_rtk_planning_config() {
  if (!has_rtk_planning_config()) {
    clear_planning_config();
    set_has_rtk_planning_config();
    planning_config_.rtk_planning_config_ = new ::jmc_auto::planning::RtkPlanningConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.rtk_planning_config)
  return planning_config_.rtk_planning_config_;
}
::jmc_auto::planning::RtkPlanningConfig* PlanningConfig::release_rtk_planning_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningConfig.rtk_planning_config)
  if (has_rtk_planning_config()) {
    clear_has_planning_config();
    ::jmc_auto::planning::RtkPlanningConfig* temp = planning_config_.rtk_planning_config_;
    planning_config_.rtk_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void PlanningConfig::set_allocated_rtk_planning_config(::jmc_auto::planning::RtkPlanningConfig* rtk_planning_config) {
  clear_planning_config();
  if (rtk_planning_config) {
    set_has_rtk_planning_config();
    planning_config_.rtk_planning_config_ = rtk_planning_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningConfig.rtk_planning_config)
}

// optional .jmc_auto.planning.StandardPlanningConfig standard_planning_config = 2;
bool PlanningConfig::has_standard_planning_config() const {
  return planning_config_case() == kStandardPlanningConfig;
}
void PlanningConfig::set_has_standard_planning_config() {
  _oneof_case_[0] = kStandardPlanningConfig;
}
void PlanningConfig::clear_standard_planning_config() {
  if (has_standard_planning_config()) {
    delete planning_config_.standard_planning_config_;
    clear_has_planning_config();
  }
}
 const ::jmc_auto::planning::StandardPlanningConfig& PlanningConfig::standard_planning_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.standard_planning_config)
  return has_standard_planning_config()
      ? *planning_config_.standard_planning_config_
      : ::jmc_auto::planning::StandardPlanningConfig::default_instance();
}
::jmc_auto::planning::StandardPlanningConfig* PlanningConfig::mutable_standard_planning_config() {
  if (!has_standard_planning_config()) {
    clear_planning_config();
    set_has_standard_planning_config();
    planning_config_.standard_planning_config_ = new ::jmc_auto::planning::StandardPlanningConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.standard_planning_config)
  return planning_config_.standard_planning_config_;
}
::jmc_auto::planning::StandardPlanningConfig* PlanningConfig::release_standard_planning_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningConfig.standard_planning_config)
  if (has_standard_planning_config()) {
    clear_has_planning_config();
    ::jmc_auto::planning::StandardPlanningConfig* temp = planning_config_.standard_planning_config_;
    planning_config_.standard_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void PlanningConfig::set_allocated_standard_planning_config(::jmc_auto::planning::StandardPlanningConfig* standard_planning_config) {
  clear_planning_config();
  if (standard_planning_config) {
    set_has_standard_planning_config();
    planning_config_.standard_planning_config_ = standard_planning_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningConfig.standard_planning_config)
}

// optional .jmc_auto.planning.NavigationPlanningConfig navigation_planning_config = 3;
bool PlanningConfig::has_navigation_planning_config() const {
  return planning_config_case() == kNavigationPlanningConfig;
}
void PlanningConfig::set_has_navigation_planning_config() {
  _oneof_case_[0] = kNavigationPlanningConfig;
}
void PlanningConfig::clear_navigation_planning_config() {
  if (has_navigation_planning_config()) {
    delete planning_config_.navigation_planning_config_;
    clear_has_planning_config();
  }
}
 const ::jmc_auto::planning::NavigationPlanningConfig& PlanningConfig::navigation_planning_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.navigation_planning_config)
  return has_navigation_planning_config()
      ? *planning_config_.navigation_planning_config_
      : ::jmc_auto::planning::NavigationPlanningConfig::default_instance();
}
::jmc_auto::planning::NavigationPlanningConfig* PlanningConfig::mutable_navigation_planning_config() {
  if (!has_navigation_planning_config()) {
    clear_planning_config();
    set_has_navigation_planning_config();
    planning_config_.navigation_planning_config_ = new ::jmc_auto::planning::NavigationPlanningConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.navigation_planning_config)
  return planning_config_.navigation_planning_config_;
}
::jmc_auto::planning::NavigationPlanningConfig* PlanningConfig::release_navigation_planning_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningConfig.navigation_planning_config)
  if (has_navigation_planning_config()) {
    clear_has_planning_config();
    ::jmc_auto::planning::NavigationPlanningConfig* temp = planning_config_.navigation_planning_config_;
    planning_config_.navigation_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void PlanningConfig::set_allocated_navigation_planning_config(::jmc_auto::planning::NavigationPlanningConfig* navigation_planning_config) {
  clear_planning_config();
  if (navigation_planning_config) {
    set_has_navigation_planning_config();
    planning_config_.navigation_planning_config_ = navigation_planning_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningConfig.navigation_planning_config)
}

// repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
int PlanningConfig::default_task_config_size() const {
  return default_task_config_.size();
}
void PlanningConfig::clear_default_task_config() {
  default_task_config_.Clear();
}
const ::jmc_auto::planning::TaskConfig& PlanningConfig::default_task_config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_.Get(index);
}
::jmc_auto::planning::TaskConfig* PlanningConfig::mutable_default_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_.Mutable(index);
}
::jmc_auto::planning::TaskConfig* PlanningConfig::add_default_task_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_.Add();
}
::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >*
PlanningConfig::mutable_default_task_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PlanningConfig.default_task_config)
  return &default_task_config_;
}
const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >&
PlanningConfig::default_task_config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_;
}

bool PlanningConfig::has_planning_config() const {
  return planning_config_case() != PLANNING_CONFIG_NOT_SET;
}
void PlanningConfig::clear_has_planning_config() {
  _oneof_case_[0] = PLANNING_CONFIG_NOT_SET;
}
PlanningConfig::PlanningConfigCase PlanningConfig::planning_config_case() const {
  return PlanningConfig::PlanningConfigCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace jmc_auto

// @@protoc_insertion_point(global_scope)
