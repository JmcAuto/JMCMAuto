// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/traffic_rule_config.proto

#ifndef PROTOBUF_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto__INCLUDED
#define PROTOBUF_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace planning {
class BacksideVehicleConfig;
class BacksideVehicleConfigDefaultTypeInternal;
extern BacksideVehicleConfigDefaultTypeInternal _BacksideVehicleConfig_default_instance_;
class CrosswalkConfig;
class CrosswalkConfigDefaultTypeInternal;
extern CrosswalkConfigDefaultTypeInternal _CrosswalkConfig_default_instance_;
class DestinationConfig;
class DestinationConfigDefaultTypeInternal;
extern DestinationConfigDefaultTypeInternal _DestinationConfig_default_instance_;
class KeepClearConfig;
class KeepClearConfigDefaultTypeInternal;
extern KeepClearConfigDefaultTypeInternal _KeepClearConfig_default_instance_;
class ReferenceLineEndConfig;
class ReferenceLineEndConfigDefaultTypeInternal;
extern ReferenceLineEndConfigDefaultTypeInternal _ReferenceLineEndConfig_default_instance_;
class ReroutingConfig;
class ReroutingConfigDefaultTypeInternal;
extern ReroutingConfigDefaultTypeInternal _ReroutingConfig_default_instance_;
class StopSignConfig;
class StopSignConfigDefaultTypeInternal;
extern StopSignConfigDefaultTypeInternal _StopSignConfig_default_instance_;
class TrafficLightConfig;
class TrafficLightConfigDefaultTypeInternal;
extern TrafficLightConfigDefaultTypeInternal _TrafficLightConfig_default_instance_;
class TrafficRuleConfig;
class TrafficRuleConfigDefaultTypeInternal;
extern TrafficRuleConfigDefaultTypeInternal _TrafficRuleConfig_default_instance_;
class TrafficRuleConfigs;
class TrafficRuleConfigsDefaultTypeInternal;
extern TrafficRuleConfigsDefaultTypeInternal _TrafficRuleConfigs_default_instance_;
class YieldSignConfig;
class YieldSignConfigDefaultTypeInternal;
extern YieldSignConfigDefaultTypeInternal _YieldSignConfig_default_instance_;
}  // namespace planning
}  // namespace jmc_auto

namespace jmc_auto {
namespace planning {

namespace protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto

enum TrafficRuleConfig_RuleId {
  TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE = 1,
  TrafficRuleConfig_RuleId_CROSSWALK = 2,
  TrafficRuleConfig_RuleId_DESTINATION = 3,
  TrafficRuleConfig_RuleId_KEEP_CLEAR = 4,
  TrafficRuleConfig_RuleId_REFERENCE_LINE_END = 5,
  TrafficRuleConfig_RuleId_REROUTING = 6,
  TrafficRuleConfig_RuleId_STOP_SIGN = 7,
  TrafficRuleConfig_RuleId_TRAFFIC_LIGHT = 8,
  TrafficRuleConfig_RuleId_YIELD_SIGN = 9
};
bool TrafficRuleConfig_RuleId_IsValid(int value);
const TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MIN = TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
const TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MAX = TrafficRuleConfig_RuleId_YIELD_SIGN;
const int TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE = TrafficRuleConfig_RuleId_RuleId_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficRuleConfig_RuleId_descriptor();
inline const ::std::string& TrafficRuleConfig_RuleId_Name(TrafficRuleConfig_RuleId value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficRuleConfig_RuleId_descriptor(), value);
}
inline bool TrafficRuleConfig_RuleId_Parse(
    const ::std::string& name, TrafficRuleConfig_RuleId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficRuleConfig_RuleId>(
    TrafficRuleConfig_RuleId_descriptor(), name, value);
}
// ===================================================================

class BacksideVehicleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.BacksideVehicleConfig) */ {
 public:
  BacksideVehicleConfig();
  virtual ~BacksideVehicleConfig();

  BacksideVehicleConfig(const BacksideVehicleConfig& from);

  inline BacksideVehicleConfig& operator=(const BacksideVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacksideVehicleConfig& default_instance();

  static inline const BacksideVehicleConfig* internal_default_instance() {
    return reinterpret_cast<const BacksideVehicleConfig*>(
               &_BacksideVehicleConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(BacksideVehicleConfig* other);

  // implements Message ----------------------------------------------

  inline BacksideVehicleConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  BacksideVehicleConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BacksideVehicleConfig& from);
  void MergeFrom(const BacksideVehicleConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BacksideVehicleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double backside_lane_width = 1 [default = 4];
  bool has_backside_lane_width() const;
  void clear_backside_lane_width();
  static const int kBacksideLaneWidthFieldNumber = 1;
  double backside_lane_width() const;
  void set_backside_lane_width(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.BacksideVehicleConfig)
 private:
  void set_has_backside_lane_width();
  void clear_has_backside_lane_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double backside_lane_width_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.CrosswalkConfig) */ {
 public:
  CrosswalkConfig();
  virtual ~CrosswalkConfig();

  CrosswalkConfig(const CrosswalkConfig& from);

  inline CrosswalkConfig& operator=(const CrosswalkConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkConfig& default_instance();

  static inline const CrosswalkConfig* internal_default_instance() {
    return reinterpret_cast<const CrosswalkConfig*>(
               &_CrosswalkConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CrosswalkConfig* other);

  // implements Message ----------------------------------------------

  inline CrosswalkConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CrosswalkConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrosswalkConfig& from);
  void MergeFrom(const CrosswalkConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrosswalkConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double max_stop_deceleration = 2 [default = 4];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 2;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double min_pass_s_distance = 3 [default = 1];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double max_valid_stop_distance = 4 [default = 3];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 4;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double expand_s_distance = 5 [default = 2];
  bool has_expand_s_distance() const;
  void clear_expand_s_distance();
  static const int kExpandSDistanceFieldNumber = 5;
  double expand_s_distance() const;
  void set_expand_s_distance(double value);

  // optional double stop_strict_l_distance = 6 [default = 4];
  bool has_stop_strict_l_distance() const;
  void clear_stop_strict_l_distance();
  static const int kStopStrictLDistanceFieldNumber = 6;
  double stop_strict_l_distance() const;
  void set_stop_strict_l_distance(double value);

  // optional double stop_loose_l_distance = 7 [default = 5];
  bool has_stop_loose_l_distance() const;
  void clear_stop_loose_l_distance();
  static const int kStopLooseLDistanceFieldNumber = 7;
  double stop_loose_l_distance() const;
  void set_stop_loose_l_distance(double value);

  // optional double stop_timeout = 8 [default = 10];
  bool has_stop_timeout() const;
  void clear_stop_timeout();
  static const int kStopTimeoutFieldNumber = 8;
  double stop_timeout() const;
  void set_stop_timeout(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.CrosswalkConfig)
 private:
  void set_has_stop_distance();
  void clear_has_stop_distance();
  void set_has_max_stop_deceleration();
  void clear_has_max_stop_deceleration();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_expand_s_distance();
  void clear_has_expand_s_distance();
  void set_has_stop_strict_l_distance();
  void clear_has_stop_strict_l_distance();
  void set_has_stop_loose_l_distance();
  void clear_has_stop_loose_l_distance();
  void set_has_stop_timeout();
  void clear_has_stop_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double stop_distance_;
  double max_stop_deceleration_;
  double min_pass_s_distance_;
  double max_valid_stop_distance_;
  double expand_s_distance_;
  double stop_strict_l_distance_;
  double stop_loose_l_distance_;
  double stop_timeout_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DestinationConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.DestinationConfig) */ {
 public:
  DestinationConfig();
  virtual ~DestinationConfig();

  DestinationConfig(const DestinationConfig& from);

  inline DestinationConfig& operator=(const DestinationConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationConfig& default_instance();

  static inline const DestinationConfig* internal_default_instance() {
    return reinterpret_cast<const DestinationConfig*>(
               &_DestinationConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DestinationConfig* other);

  // implements Message ----------------------------------------------

  inline DestinationConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  DestinationConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DestinationConfig& from);
  void MergeFrom(const DestinationConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DestinationConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.DestinationConfig)
 private:
  void set_has_stop_distance();
  void clear_has_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double stop_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeepClearConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.KeepClearConfig) */ {
 public:
  KeepClearConfig();
  virtual ~KeepClearConfig();

  KeepClearConfig(const KeepClearConfig& from);

  inline KeepClearConfig& operator=(const KeepClearConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepClearConfig& default_instance();

  static inline const KeepClearConfig* internal_default_instance() {
    return reinterpret_cast<const KeepClearConfig*>(
               &_KeepClearConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(KeepClearConfig* other);

  // implements Message ----------------------------------------------

  inline KeepClearConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  KeepClearConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeepClearConfig& from);
  void MergeFrom(const KeepClearConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeepClearConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_keep_clear_zone = 1 [default = true];
  bool has_enable_keep_clear_zone() const;
  void clear_enable_keep_clear_zone();
  static const int kEnableKeepClearZoneFieldNumber = 1;
  bool enable_keep_clear_zone() const;
  void set_enable_keep_clear_zone(bool value);

  // optional bool enable_junction = 2 [default = true];
  bool has_enable_junction() const;
  void clear_enable_junction();
  static const int kEnableJunctionFieldNumber = 2;
  bool enable_junction() const;
  void set_enable_junction(bool value);

  // optional double min_pass_s_distance = 3 [default = 2];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double align_with_traffic_sign_tolerance = 4 [default = 4.5];
  bool has_align_with_traffic_sign_tolerance() const;
  void clear_align_with_traffic_sign_tolerance();
  static const int kAlignWithTrafficSignToleranceFieldNumber = 4;
  double align_with_traffic_sign_tolerance() const;
  void set_align_with_traffic_sign_tolerance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.KeepClearConfig)
 private:
  void set_has_enable_keep_clear_zone();
  void clear_has_enable_keep_clear_zone();
  void set_has_enable_junction();
  void clear_has_enable_junction();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_align_with_traffic_sign_tolerance();
  void clear_has_align_with_traffic_sign_tolerance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enable_keep_clear_zone_;
  bool enable_junction_;
  double min_pass_s_distance_;
  double align_with_traffic_sign_tolerance_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReferenceLineEndConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ReferenceLineEndConfig) */ {
 public:
  ReferenceLineEndConfig();
  virtual ~ReferenceLineEndConfig();

  ReferenceLineEndConfig(const ReferenceLineEndConfig& from);

  inline ReferenceLineEndConfig& operator=(const ReferenceLineEndConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceLineEndConfig& default_instance();

  static inline const ReferenceLineEndConfig* internal_default_instance() {
    return reinterpret_cast<const ReferenceLineEndConfig*>(
               &_ReferenceLineEndConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ReferenceLineEndConfig* other);

  // implements Message ----------------------------------------------

  inline ReferenceLineEndConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ReferenceLineEndConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReferenceLineEndConfig& from);
  void MergeFrom(const ReferenceLineEndConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReferenceLineEndConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double min_reference_line_remain_length = 2 [default = 50];
  bool has_min_reference_line_remain_length() const;
  void clear_min_reference_line_remain_length();
  static const int kMinReferenceLineRemainLengthFieldNumber = 2;
  double min_reference_line_remain_length() const;
  void set_min_reference_line_remain_length(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ReferenceLineEndConfig)
 private:
  void set_has_stop_distance();
  void clear_has_stop_distance();
  void set_has_min_reference_line_remain_length();
  void clear_has_min_reference_line_remain_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double stop_distance_;
  double min_reference_line_remain_length_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReroutingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ReroutingConfig) */ {
 public:
  ReroutingConfig();
  virtual ~ReroutingConfig();

  ReroutingConfig(const ReroutingConfig& from);

  inline ReroutingConfig& operator=(const ReroutingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReroutingConfig& default_instance();

  static inline const ReroutingConfig* internal_default_instance() {
    return reinterpret_cast<const ReroutingConfig*>(
               &_ReroutingConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ReroutingConfig* other);

  // implements Message ----------------------------------------------

  inline ReroutingConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ReroutingConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReroutingConfig& from);
  void MergeFrom(const ReroutingConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReroutingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double cooldown_time = 1 [default = 3];
  bool has_cooldown_time() const;
  void clear_cooldown_time();
  static const int kCooldownTimeFieldNumber = 1;
  double cooldown_time() const;
  void set_cooldown_time(double value);

  // optional double prepare_rerouting_time = 2 [default = 2];
  bool has_prepare_rerouting_time() const;
  void clear_prepare_rerouting_time();
  static const int kPrepareReroutingTimeFieldNumber = 2;
  double prepare_rerouting_time() const;
  void set_prepare_rerouting_time(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ReroutingConfig)
 private:
  void set_has_cooldown_time();
  void clear_has_cooldown_time();
  void set_has_prepare_rerouting_time();
  void clear_has_prepare_rerouting_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double cooldown_time_;
  double prepare_rerouting_time_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopSignConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.StopSignConfig) */ {
 public:
  StopSignConfig();
  virtual ~StopSignConfig();

  StopSignConfig(const StopSignConfig& from);

  inline StopSignConfig& operator=(const StopSignConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignConfig& default_instance();

  static inline const StopSignConfig* internal_default_instance() {
    return reinterpret_cast<const StopSignConfig*>(
               &_StopSignConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(StopSignConfig* other);

  // implements Message ----------------------------------------------

  inline StopSignConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  StopSignConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopSignConfig& from);
  void MergeFrom(const StopSignConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopSignConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 2;
  double stop_distance() const;
  void set_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.StopSignConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_stop_distance();
  void clear_has_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enabled_;
  double stop_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrafficLightConfig) */ {
 public:
  TrafficLightConfig();
  virtual ~TrafficLightConfig();

  TrafficLightConfig(const TrafficLightConfig& from);

  inline TrafficLightConfig& operator=(const TrafficLightConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightConfig& default_instance();

  static inline const TrafficLightConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficLightConfig*>(
               &_TrafficLightConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TrafficLightConfig* other);

  // implements Message ----------------------------------------------

  inline TrafficLightConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightConfig& from);
  void MergeFrom(const TrafficLightConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 2;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double max_stop_deceleration = 3 [default = 4];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 3;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrafficLightConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_stop_distance();
  void clear_has_stop_distance();
  void set_has_max_stop_deceleration();
  void clear_has_max_stop_deceleration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enabled_;
  double stop_distance_;
  double max_stop_deceleration_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YieldSignConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.YieldSignConfig) */ {
 public:
  YieldSignConfig();
  virtual ~YieldSignConfig();

  YieldSignConfig(const YieldSignConfig& from);

  inline YieldSignConfig& operator=(const YieldSignConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldSignConfig& default_instance();

  static inline const YieldSignConfig* internal_default_instance() {
    return reinterpret_cast<const YieldSignConfig*>(
               &_YieldSignConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(YieldSignConfig* other);

  // implements Message ----------------------------------------------

  inline YieldSignConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  YieldSignConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YieldSignConfig& from);
  void MergeFrom(const YieldSignConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YieldSignConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 2;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double start_watch_distance = 3 [default = 2];
  bool has_start_watch_distance() const;
  void clear_start_watch_distance();
  static const int kStartWatchDistanceFieldNumber = 3;
  double start_watch_distance() const;
  void set_start_watch_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.YieldSignConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_stop_distance();
  void clear_has_stop_distance();
  void set_has_start_watch_distance();
  void clear_has_start_watch_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enabled_;
  double stop_distance_;
  double start_watch_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficRuleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrafficRuleConfig) */ {
 public:
  TrafficRuleConfig();
  virtual ~TrafficRuleConfig();

  TrafficRuleConfig(const TrafficRuleConfig& from);

  inline TrafficRuleConfig& operator=(const TrafficRuleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficRuleConfig& default_instance();

  enum ConfigCase {
    kBacksideVehicle = 3,
    kCrosswalk = 4,
    kDestination = 5,
    kKeepClear = 6,
    kReferenceLineEnd = 7,
    kRerouting = 8,
    kStopSign = 9,
    kTrafficLight = 10,
    kYieldSign = 11,
    CONFIG_NOT_SET = 0,
  };

  static inline const TrafficRuleConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfig*>(
               &_TrafficRuleConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TrafficRuleConfig* other);

  // implements Message ----------------------------------------------

  inline TrafficRuleConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficRuleConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficRuleConfig& from);
  void MergeFrom(const TrafficRuleConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficRuleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficRuleConfig_RuleId RuleId;
  static const RuleId BACKSIDE_VEHICLE =
    TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
  static const RuleId CROSSWALK =
    TrafficRuleConfig_RuleId_CROSSWALK;
  static const RuleId DESTINATION =
    TrafficRuleConfig_RuleId_DESTINATION;
  static const RuleId KEEP_CLEAR =
    TrafficRuleConfig_RuleId_KEEP_CLEAR;
  static const RuleId REFERENCE_LINE_END =
    TrafficRuleConfig_RuleId_REFERENCE_LINE_END;
  static const RuleId REROUTING =
    TrafficRuleConfig_RuleId_REROUTING;
  static const RuleId STOP_SIGN =
    TrafficRuleConfig_RuleId_STOP_SIGN;
  static const RuleId TRAFFIC_LIGHT =
    TrafficRuleConfig_RuleId_TRAFFIC_LIGHT;
  static const RuleId YIELD_SIGN =
    TrafficRuleConfig_RuleId_YIELD_SIGN;
  static inline bool RuleId_IsValid(int value) {
    return TrafficRuleConfig_RuleId_IsValid(value);
  }
  static const RuleId RuleId_MIN =
    TrafficRuleConfig_RuleId_RuleId_MIN;
  static const RuleId RuleId_MAX =
    TrafficRuleConfig_RuleId_RuleId_MAX;
  static const int RuleId_ARRAYSIZE =
    TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RuleId_descriptor() {
    return TrafficRuleConfig_RuleId_descriptor();
  }
  static inline const ::std::string& RuleId_Name(RuleId value) {
    return TrafficRuleConfig_RuleId_Name(value);
  }
  static inline bool RuleId_Parse(const ::std::string& name,
      RuleId* value) {
    return TrafficRuleConfig_RuleId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool enabled = 2;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // optional .jmc_auto.planning.TrafficRuleConfig.RuleId rule_id = 1;
  bool has_rule_id() const;
  void clear_rule_id();
  static const int kRuleIdFieldNumber = 1;
  ::jmc_auto::planning::TrafficRuleConfig_RuleId rule_id() const;
  void set_rule_id(::jmc_auto::planning::TrafficRuleConfig_RuleId value);

  // optional .jmc_auto.planning.BacksideVehicleConfig backside_vehicle = 3;
  bool has_backside_vehicle() const;
  void clear_backside_vehicle();
  static const int kBacksideVehicleFieldNumber = 3;
  const ::jmc_auto::planning::BacksideVehicleConfig& backside_vehicle() const;
  ::jmc_auto::planning::BacksideVehicleConfig* mutable_backside_vehicle();
  ::jmc_auto::planning::BacksideVehicleConfig* release_backside_vehicle();
  void set_allocated_backside_vehicle(::jmc_auto::planning::BacksideVehicleConfig* backside_vehicle);

  // optional .jmc_auto.planning.CrosswalkConfig crosswalk = 4;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 4;
  const ::jmc_auto::planning::CrosswalkConfig& crosswalk() const;
  ::jmc_auto::planning::CrosswalkConfig* mutable_crosswalk();
  ::jmc_auto::planning::CrosswalkConfig* release_crosswalk();
  void set_allocated_crosswalk(::jmc_auto::planning::CrosswalkConfig* crosswalk);

  // optional .jmc_auto.planning.DestinationConfig destination = 5;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 5;
  const ::jmc_auto::planning::DestinationConfig& destination() const;
  ::jmc_auto::planning::DestinationConfig* mutable_destination();
  ::jmc_auto::planning::DestinationConfig* release_destination();
  void set_allocated_destination(::jmc_auto::planning::DestinationConfig* destination);

  // optional .jmc_auto.planning.KeepClearConfig keep_clear = 6;
  bool has_keep_clear() const;
  void clear_keep_clear();
  static const int kKeepClearFieldNumber = 6;
  const ::jmc_auto::planning::KeepClearConfig& keep_clear() const;
  ::jmc_auto::planning::KeepClearConfig* mutable_keep_clear();
  ::jmc_auto::planning::KeepClearConfig* release_keep_clear();
  void set_allocated_keep_clear(::jmc_auto::planning::KeepClearConfig* keep_clear);

  // optional .jmc_auto.planning.ReferenceLineEndConfig reference_line_end = 7;
  bool has_reference_line_end() const;
  void clear_reference_line_end();
  static const int kReferenceLineEndFieldNumber = 7;
  const ::jmc_auto::planning::ReferenceLineEndConfig& reference_line_end() const;
  ::jmc_auto::planning::ReferenceLineEndConfig* mutable_reference_line_end();
  ::jmc_auto::planning::ReferenceLineEndConfig* release_reference_line_end();
  void set_allocated_reference_line_end(::jmc_auto::planning::ReferenceLineEndConfig* reference_line_end);

  // optional .jmc_auto.planning.ReroutingConfig rerouting = 8;
  bool has_rerouting() const;
  void clear_rerouting();
  static const int kReroutingFieldNumber = 8;
  const ::jmc_auto::planning::ReroutingConfig& rerouting() const;
  ::jmc_auto::planning::ReroutingConfig* mutable_rerouting();
  ::jmc_auto::planning::ReroutingConfig* release_rerouting();
  void set_allocated_rerouting(::jmc_auto::planning::ReroutingConfig* rerouting);

  // optional .jmc_auto.planning.StopSignConfig stop_sign = 9;
  bool has_stop_sign() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 9;
  const ::jmc_auto::planning::StopSignConfig& stop_sign() const;
  ::jmc_auto::planning::StopSignConfig* mutable_stop_sign();
  ::jmc_auto::planning::StopSignConfig* release_stop_sign();
  void set_allocated_stop_sign(::jmc_auto::planning::StopSignConfig* stop_sign);

  // optional .jmc_auto.planning.TrafficLightConfig traffic_light = 10;
  bool has_traffic_light() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 10;
  const ::jmc_auto::planning::TrafficLightConfig& traffic_light() const;
  ::jmc_auto::planning::TrafficLightConfig* mutable_traffic_light();
  ::jmc_auto::planning::TrafficLightConfig* release_traffic_light();
  void set_allocated_traffic_light(::jmc_auto::planning::TrafficLightConfig* traffic_light);

  // optional .jmc_auto.planning.YieldSignConfig yield_sign = 11;
  bool has_yield_sign() const;
  void clear_yield_sign();
  static const int kYieldSignFieldNumber = 11;
  const ::jmc_auto::planning::YieldSignConfig& yield_sign() const;
  ::jmc_auto::planning::YieldSignConfig* mutable_yield_sign();
  ::jmc_auto::planning::YieldSignConfig* release_yield_sign();
  void set_allocated_yield_sign(::jmc_auto::planning::YieldSignConfig* yield_sign);

  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrafficRuleConfig)
 private:
  void set_has_rule_id();
  void clear_has_rule_id();
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_backside_vehicle();
  void set_has_crosswalk();
  void set_has_destination();
  void set_has_keep_clear();
  void set_has_reference_line_end();
  void set_has_rerouting();
  void set_has_stop_sign();
  void set_has_traffic_light();
  void set_has_yield_sign();

  inline bool has_config() const;
  void clear_config();
  inline void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enabled_;
  int rule_id_;
  union ConfigUnion {
    ConfigUnion() {}
    ::jmc_auto::planning::BacksideVehicleConfig* backside_vehicle_;
    ::jmc_auto::planning::CrosswalkConfig* crosswalk_;
    ::jmc_auto::planning::DestinationConfig* destination_;
    ::jmc_auto::planning::KeepClearConfig* keep_clear_;
    ::jmc_auto::planning::ReferenceLineEndConfig* reference_line_end_;
    ::jmc_auto::planning::ReroutingConfig* rerouting_;
    ::jmc_auto::planning::StopSignConfig* stop_sign_;
    ::jmc_auto::planning::TrafficLightConfig* traffic_light_;
    ::jmc_auto::planning::YieldSignConfig* yield_sign_;
  } config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficRuleConfigs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrafficRuleConfigs) */ {
 public:
  TrafficRuleConfigs();
  virtual ~TrafficRuleConfigs();

  TrafficRuleConfigs(const TrafficRuleConfigs& from);

  inline TrafficRuleConfigs& operator=(const TrafficRuleConfigs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficRuleConfigs& default_instance();

  static inline const TrafficRuleConfigs* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfigs*>(
               &_TrafficRuleConfigs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(TrafficRuleConfigs* other);

  // implements Message ----------------------------------------------

  inline TrafficRuleConfigs* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficRuleConfigs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficRuleConfigs& from);
  void MergeFrom(const TrafficRuleConfigs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficRuleConfigs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.TrafficRuleConfig config = 1;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::jmc_auto::planning::TrafficRuleConfig& config(int index) const;
  ::jmc_auto::planning::TrafficRuleConfig* mutable_config(int index);
  ::jmc_auto::planning::TrafficRuleConfig* add_config();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficRuleConfig >*
      mutable_config();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficRuleConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrafficRuleConfigs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficRuleConfig > config_;
  friend struct protobuf_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BacksideVehicleConfig

// optional double backside_lane_width = 1 [default = 4];
inline bool BacksideVehicleConfig::has_backside_lane_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacksideVehicleConfig::set_has_backside_lane_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacksideVehicleConfig::clear_has_backside_lane_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacksideVehicleConfig::clear_backside_lane_width() {
  backside_lane_width_ = 4;
  clear_has_backside_lane_width();
}
inline double BacksideVehicleConfig::backside_lane_width() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.BacksideVehicleConfig.backside_lane_width)
  return backside_lane_width_;
}
inline void BacksideVehicleConfig::set_backside_lane_width(double value) {
  set_has_backside_lane_width();
  backside_lane_width_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.BacksideVehicleConfig.backside_lane_width)
}

// -------------------------------------------------------------------

// CrosswalkConfig

// optional double stop_distance = 1 [default = 1];
inline bool CrosswalkConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double CrosswalkConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.stop_distance)
  return stop_distance_;
}
inline void CrosswalkConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 4];
inline bool CrosswalkConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrosswalkConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrosswalkConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CrosswalkConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  clear_has_max_stop_deceleration();
}
inline double CrosswalkConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void CrosswalkConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 1];
inline bool CrosswalkConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrosswalkConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrosswalkConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrosswalkConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 1;
  clear_has_min_pass_s_distance();
}
inline double CrosswalkConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void CrosswalkConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.min_pass_s_distance)
}

// optional double max_valid_stop_distance = 4 [default = 3];
inline bool CrosswalkConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CrosswalkConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CrosswalkConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CrosswalkConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3;
  clear_has_max_valid_stop_distance();
}
inline double CrosswalkConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void CrosswalkConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.max_valid_stop_distance)
}

// optional double expand_s_distance = 5 [default = 2];
inline bool CrosswalkConfig::has_expand_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CrosswalkConfig::set_has_expand_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CrosswalkConfig::clear_has_expand_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CrosswalkConfig::clear_expand_s_distance() {
  expand_s_distance_ = 2;
  clear_has_expand_s_distance();
}
inline double CrosswalkConfig::expand_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.expand_s_distance)
  return expand_s_distance_;
}
inline void CrosswalkConfig::set_expand_s_distance(double value) {
  set_has_expand_s_distance();
  expand_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.expand_s_distance)
}

// optional double stop_strict_l_distance = 6 [default = 4];
inline bool CrosswalkConfig::has_stop_strict_l_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CrosswalkConfig::set_has_stop_strict_l_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CrosswalkConfig::clear_has_stop_strict_l_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CrosswalkConfig::clear_stop_strict_l_distance() {
  stop_strict_l_distance_ = 4;
  clear_has_stop_strict_l_distance();
}
inline double CrosswalkConfig::stop_strict_l_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.stop_strict_l_distance)
  return stop_strict_l_distance_;
}
inline void CrosswalkConfig::set_stop_strict_l_distance(double value) {
  set_has_stop_strict_l_distance();
  stop_strict_l_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.stop_strict_l_distance)
}

// optional double stop_loose_l_distance = 7 [default = 5];
inline bool CrosswalkConfig::has_stop_loose_l_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CrosswalkConfig::set_has_stop_loose_l_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CrosswalkConfig::clear_has_stop_loose_l_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CrosswalkConfig::clear_stop_loose_l_distance() {
  stop_loose_l_distance_ = 5;
  clear_has_stop_loose_l_distance();
}
inline double CrosswalkConfig::stop_loose_l_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.stop_loose_l_distance)
  return stop_loose_l_distance_;
}
inline void CrosswalkConfig::set_stop_loose_l_distance(double value) {
  set_has_stop_loose_l_distance();
  stop_loose_l_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.stop_loose_l_distance)
}

// optional double stop_timeout = 8 [default = 10];
inline bool CrosswalkConfig::has_stop_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CrosswalkConfig::set_has_stop_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CrosswalkConfig::clear_has_stop_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CrosswalkConfig::clear_stop_timeout() {
  stop_timeout_ = 10;
  clear_has_stop_timeout();
}
inline double CrosswalkConfig::stop_timeout() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CrosswalkConfig.stop_timeout)
  return stop_timeout_;
}
inline void CrosswalkConfig::set_stop_timeout(double value) {
  set_has_stop_timeout();
  stop_timeout_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CrosswalkConfig.stop_timeout)
}

// -------------------------------------------------------------------

// DestinationConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool DestinationConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DestinationConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DestinationConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DestinationConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double DestinationConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.DestinationConfig.stop_distance)
  return stop_distance_;
}
inline void DestinationConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.DestinationConfig.stop_distance)
}

// -------------------------------------------------------------------

// KeepClearConfig

// optional bool enable_keep_clear_zone = 1 [default = true];
inline bool KeepClearConfig::has_enable_keep_clear_zone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepClearConfig::set_has_enable_keep_clear_zone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepClearConfig::clear_has_enable_keep_clear_zone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepClearConfig::clear_enable_keep_clear_zone() {
  enable_keep_clear_zone_ = true;
  clear_has_enable_keep_clear_zone();
}
inline bool KeepClearConfig::enable_keep_clear_zone() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.KeepClearConfig.enable_keep_clear_zone)
  return enable_keep_clear_zone_;
}
inline void KeepClearConfig::set_enable_keep_clear_zone(bool value) {
  set_has_enable_keep_clear_zone();
  enable_keep_clear_zone_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.KeepClearConfig.enable_keep_clear_zone)
}

// optional bool enable_junction = 2 [default = true];
inline bool KeepClearConfig::has_enable_junction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepClearConfig::set_has_enable_junction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepClearConfig::clear_has_enable_junction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepClearConfig::clear_enable_junction() {
  enable_junction_ = true;
  clear_has_enable_junction();
}
inline bool KeepClearConfig::enable_junction() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.KeepClearConfig.enable_junction)
  return enable_junction_;
}
inline void KeepClearConfig::set_enable_junction(bool value) {
  set_has_enable_junction();
  enable_junction_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.KeepClearConfig.enable_junction)
}

// optional double min_pass_s_distance = 3 [default = 2];
inline bool KeepClearConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeepClearConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeepClearConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeepClearConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 2;
  clear_has_min_pass_s_distance();
}
inline double KeepClearConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.KeepClearConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void KeepClearConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.KeepClearConfig.min_pass_s_distance)
}

// optional double align_with_traffic_sign_tolerance = 4 [default = 4.5];
inline bool KeepClearConfig::has_align_with_traffic_sign_tolerance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeepClearConfig::set_has_align_with_traffic_sign_tolerance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeepClearConfig::clear_has_align_with_traffic_sign_tolerance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeepClearConfig::clear_align_with_traffic_sign_tolerance() {
  align_with_traffic_sign_tolerance_ = 4.5;
  clear_has_align_with_traffic_sign_tolerance();
}
inline double KeepClearConfig::align_with_traffic_sign_tolerance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.KeepClearConfig.align_with_traffic_sign_tolerance)
  return align_with_traffic_sign_tolerance_;
}
inline void KeepClearConfig::set_align_with_traffic_sign_tolerance(double value) {
  set_has_align_with_traffic_sign_tolerance();
  align_with_traffic_sign_tolerance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.KeepClearConfig.align_with_traffic_sign_tolerance)
}

// -------------------------------------------------------------------

// ReferenceLineEndConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool ReferenceLineEndConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceLineEndConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceLineEndConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceLineEndConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double ReferenceLineEndConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReferenceLineEndConfig.stop_distance)
  return stop_distance_;
}
inline void ReferenceLineEndConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReferenceLineEndConfig.stop_distance)
}

// optional double min_reference_line_remain_length = 2 [default = 50];
inline bool ReferenceLineEndConfig::has_min_reference_line_remain_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceLineEndConfig::set_has_min_reference_line_remain_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceLineEndConfig::clear_has_min_reference_line_remain_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceLineEndConfig::clear_min_reference_line_remain_length() {
  min_reference_line_remain_length_ = 50;
  clear_has_min_reference_line_remain_length();
}
inline double ReferenceLineEndConfig::min_reference_line_remain_length() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
  return min_reference_line_remain_length_;
}
inline void ReferenceLineEndConfig::set_min_reference_line_remain_length(double value) {
  set_has_min_reference_line_remain_length();
  min_reference_line_remain_length_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
}

// -------------------------------------------------------------------

// ReroutingConfig

// optional double cooldown_time = 1 [default = 3];
inline bool ReroutingConfig::has_cooldown_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReroutingConfig::set_has_cooldown_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReroutingConfig::clear_has_cooldown_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReroutingConfig::clear_cooldown_time() {
  cooldown_time_ = 3;
  clear_has_cooldown_time();
}
inline double ReroutingConfig::cooldown_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingConfig.cooldown_time)
  return cooldown_time_;
}
inline void ReroutingConfig::set_cooldown_time(double value) {
  set_has_cooldown_time();
  cooldown_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReroutingConfig.cooldown_time)
}

// optional double prepare_rerouting_time = 2 [default = 2];
inline bool ReroutingConfig::has_prepare_rerouting_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReroutingConfig::set_has_prepare_rerouting_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReroutingConfig::clear_has_prepare_rerouting_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReroutingConfig::clear_prepare_rerouting_time() {
  prepare_rerouting_time_ = 2;
  clear_has_prepare_rerouting_time();
}
inline double ReroutingConfig::prepare_rerouting_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ReroutingConfig.prepare_rerouting_time)
  return prepare_rerouting_time_;
}
inline void ReroutingConfig::set_prepare_rerouting_time(double value) {
  set_has_prepare_rerouting_time();
  prepare_rerouting_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ReroutingConfig.prepare_rerouting_time)
}

// -------------------------------------------------------------------

// StopSignConfig

// optional bool enabled = 1 [default = true];
inline bool StopSignConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSignConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSignConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSignConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool StopSignConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignConfig.enabled)
  return enabled_;
}
inline void StopSignConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool StopSignConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopSignConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopSignConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopSignConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double StopSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StopSignConfig.stop_distance)
  return stop_distance_;
}
inline void StopSignConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StopSignConfig.stop_distance)
}

// -------------------------------------------------------------------

// TrafficLightConfig

// optional bool enabled = 1 [default = true];
inline bool TrafficLightConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool TrafficLightConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightConfig.enabled)
  return enabled_;
}
inline void TrafficLightConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool TrafficLightConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double TrafficLightConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightConfig.stop_distance)
  return stop_distance_;
}
inline void TrafficLightConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightConfig.stop_distance)
}

// optional double max_stop_deceleration = 3 [default = 4];
inline bool TrafficLightConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  clear_has_max_stop_deceleration();
}
inline double TrafficLightConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void TrafficLightConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightConfig.max_stop_deceleration)
}

// -------------------------------------------------------------------

// YieldSignConfig

// optional bool enabled = 1 [default = true];
inline bool YieldSignConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YieldSignConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YieldSignConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YieldSignConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool YieldSignConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignConfig.enabled)
  return enabled_;
}
inline void YieldSignConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool YieldSignConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YieldSignConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YieldSignConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YieldSignConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double YieldSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignConfig.stop_distance)
  return stop_distance_;
}
inline void YieldSignConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignConfig.stop_distance)
}

// optional double start_watch_distance = 3 [default = 2];
inline bool YieldSignConfig::has_start_watch_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YieldSignConfig::set_has_start_watch_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YieldSignConfig::clear_has_start_watch_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YieldSignConfig::clear_start_watch_distance() {
  start_watch_distance_ = 2;
  clear_has_start_watch_distance();
}
inline double YieldSignConfig::start_watch_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.YieldSignConfig.start_watch_distance)
  return start_watch_distance_;
}
inline void YieldSignConfig::set_start_watch_distance(double value) {
  set_has_start_watch_distance();
  start_watch_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.YieldSignConfig.start_watch_distance)
}

// -------------------------------------------------------------------

// TrafficRuleConfig

// optional .jmc_auto.planning.TrafficRuleConfig.RuleId rule_id = 1;
inline bool TrafficRuleConfig::has_rule_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficRuleConfig::set_has_rule_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficRuleConfig::clear_has_rule_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficRuleConfig::clear_rule_id() {
  rule_id_ = 1;
  clear_has_rule_id();
}
inline ::jmc_auto::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::rule_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.rule_id)
  return static_cast< ::jmc_auto::planning::TrafficRuleConfig_RuleId >(rule_id_);
}
inline void TrafficRuleConfig::set_rule_id(::jmc_auto::planning::TrafficRuleConfig_RuleId value) {
  assert(::jmc_auto::planning::TrafficRuleConfig_RuleId_IsValid(value));
  set_has_rule_id();
  rule_id_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficRuleConfig.rule_id)
}

// optional bool enabled = 2;
inline bool TrafficRuleConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficRuleConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficRuleConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficRuleConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool TrafficRuleConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.enabled)
  return enabled_;
}
inline void TrafficRuleConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficRuleConfig.enabled)
}

// optional .jmc_auto.planning.BacksideVehicleConfig backside_vehicle = 3;
inline bool TrafficRuleConfig::has_backside_vehicle() const {
  return config_case() == kBacksideVehicle;
}
inline void TrafficRuleConfig::set_has_backside_vehicle() {
  _oneof_case_[0] = kBacksideVehicle;
}
inline void TrafficRuleConfig::clear_backside_vehicle() {
  if (has_backside_vehicle()) {
    delete config_.backside_vehicle_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::BacksideVehicleConfig& TrafficRuleConfig::backside_vehicle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.backside_vehicle)
  return has_backside_vehicle()
      ? *config_.backside_vehicle_
      : ::jmc_auto::planning::BacksideVehicleConfig::default_instance();
}
inline ::jmc_auto::planning::BacksideVehicleConfig* TrafficRuleConfig::mutable_backside_vehicle() {
  if (!has_backside_vehicle()) {
    clear_config();
    set_has_backside_vehicle();
    config_.backside_vehicle_ = new ::jmc_auto::planning::BacksideVehicleConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.backside_vehicle)
  return config_.backside_vehicle_;
}
inline ::jmc_auto::planning::BacksideVehicleConfig* TrafficRuleConfig::release_backside_vehicle() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.backside_vehicle)
  if (has_backside_vehicle()) {
    clear_has_config();
    ::jmc_auto::planning::BacksideVehicleConfig* temp = config_.backside_vehicle_;
    config_.backside_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_backside_vehicle(::jmc_auto::planning::BacksideVehicleConfig* backside_vehicle) {
  clear_config();
  if (backside_vehicle) {
    set_has_backside_vehicle();
    config_.backside_vehicle_ = backside_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.backside_vehicle)
}

// optional .jmc_auto.planning.CrosswalkConfig crosswalk = 4;
inline bool TrafficRuleConfig::has_crosswalk() const {
  return config_case() == kCrosswalk;
}
inline void TrafficRuleConfig::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
inline void TrafficRuleConfig::clear_crosswalk() {
  if (has_crosswalk()) {
    delete config_.crosswalk_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::CrosswalkConfig& TrafficRuleConfig::crosswalk() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.crosswalk)
  return has_crosswalk()
      ? *config_.crosswalk_
      : ::jmc_auto::planning::CrosswalkConfig::default_instance();
}
inline ::jmc_auto::planning::CrosswalkConfig* TrafficRuleConfig::mutable_crosswalk() {
  if (!has_crosswalk()) {
    clear_config();
    set_has_crosswalk();
    config_.crosswalk_ = new ::jmc_auto::planning::CrosswalkConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.crosswalk)
  return config_.crosswalk_;
}
inline ::jmc_auto::planning::CrosswalkConfig* TrafficRuleConfig::release_crosswalk() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.crosswalk)
  if (has_crosswalk()) {
    clear_has_config();
    ::jmc_auto::planning::CrosswalkConfig* temp = config_.crosswalk_;
    config_.crosswalk_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_crosswalk(::jmc_auto::planning::CrosswalkConfig* crosswalk) {
  clear_config();
  if (crosswalk) {
    set_has_crosswalk();
    config_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.crosswalk)
}

// optional .jmc_auto.planning.DestinationConfig destination = 5;
inline bool TrafficRuleConfig::has_destination() const {
  return config_case() == kDestination;
}
inline void TrafficRuleConfig::set_has_destination() {
  _oneof_case_[0] = kDestination;
}
inline void TrafficRuleConfig::clear_destination() {
  if (has_destination()) {
    delete config_.destination_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::DestinationConfig& TrafficRuleConfig::destination() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.destination)
  return has_destination()
      ? *config_.destination_
      : ::jmc_auto::planning::DestinationConfig::default_instance();
}
inline ::jmc_auto::planning::DestinationConfig* TrafficRuleConfig::mutable_destination() {
  if (!has_destination()) {
    clear_config();
    set_has_destination();
    config_.destination_ = new ::jmc_auto::planning::DestinationConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.destination)
  return config_.destination_;
}
inline ::jmc_auto::planning::DestinationConfig* TrafficRuleConfig::release_destination() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.destination)
  if (has_destination()) {
    clear_has_config();
    ::jmc_auto::planning::DestinationConfig* temp = config_.destination_;
    config_.destination_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_destination(::jmc_auto::planning::DestinationConfig* destination) {
  clear_config();
  if (destination) {
    set_has_destination();
    config_.destination_ = destination;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.destination)
}

// optional .jmc_auto.planning.KeepClearConfig keep_clear = 6;
inline bool TrafficRuleConfig::has_keep_clear() const {
  return config_case() == kKeepClear;
}
inline void TrafficRuleConfig::set_has_keep_clear() {
  _oneof_case_[0] = kKeepClear;
}
inline void TrafficRuleConfig::clear_keep_clear() {
  if (has_keep_clear()) {
    delete config_.keep_clear_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::KeepClearConfig& TrafficRuleConfig::keep_clear() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.keep_clear)
  return has_keep_clear()
      ? *config_.keep_clear_
      : ::jmc_auto::planning::KeepClearConfig::default_instance();
}
inline ::jmc_auto::planning::KeepClearConfig* TrafficRuleConfig::mutable_keep_clear() {
  if (!has_keep_clear()) {
    clear_config();
    set_has_keep_clear();
    config_.keep_clear_ = new ::jmc_auto::planning::KeepClearConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.keep_clear)
  return config_.keep_clear_;
}
inline ::jmc_auto::planning::KeepClearConfig* TrafficRuleConfig::release_keep_clear() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.keep_clear)
  if (has_keep_clear()) {
    clear_has_config();
    ::jmc_auto::planning::KeepClearConfig* temp = config_.keep_clear_;
    config_.keep_clear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_keep_clear(::jmc_auto::planning::KeepClearConfig* keep_clear) {
  clear_config();
  if (keep_clear) {
    set_has_keep_clear();
    config_.keep_clear_ = keep_clear;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.keep_clear)
}

// optional .jmc_auto.planning.ReferenceLineEndConfig reference_line_end = 7;
inline bool TrafficRuleConfig::has_reference_line_end() const {
  return config_case() == kReferenceLineEnd;
}
inline void TrafficRuleConfig::set_has_reference_line_end() {
  _oneof_case_[0] = kReferenceLineEnd;
}
inline void TrafficRuleConfig::clear_reference_line_end() {
  if (has_reference_line_end()) {
    delete config_.reference_line_end_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::ReferenceLineEndConfig& TrafficRuleConfig::reference_line_end() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.reference_line_end)
  return has_reference_line_end()
      ? *config_.reference_line_end_
      : ::jmc_auto::planning::ReferenceLineEndConfig::default_instance();
}
inline ::jmc_auto::planning::ReferenceLineEndConfig* TrafficRuleConfig::mutable_reference_line_end() {
  if (!has_reference_line_end()) {
    clear_config();
    set_has_reference_line_end();
    config_.reference_line_end_ = new ::jmc_auto::planning::ReferenceLineEndConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.reference_line_end)
  return config_.reference_line_end_;
}
inline ::jmc_auto::planning::ReferenceLineEndConfig* TrafficRuleConfig::release_reference_line_end() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.reference_line_end)
  if (has_reference_line_end()) {
    clear_has_config();
    ::jmc_auto::planning::ReferenceLineEndConfig* temp = config_.reference_line_end_;
    config_.reference_line_end_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_reference_line_end(::jmc_auto::planning::ReferenceLineEndConfig* reference_line_end) {
  clear_config();
  if (reference_line_end) {
    set_has_reference_line_end();
    config_.reference_line_end_ = reference_line_end;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.reference_line_end)
}

// optional .jmc_auto.planning.ReroutingConfig rerouting = 8;
inline bool TrafficRuleConfig::has_rerouting() const {
  return config_case() == kRerouting;
}
inline void TrafficRuleConfig::set_has_rerouting() {
  _oneof_case_[0] = kRerouting;
}
inline void TrafficRuleConfig::clear_rerouting() {
  if (has_rerouting()) {
    delete config_.rerouting_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::ReroutingConfig& TrafficRuleConfig::rerouting() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.rerouting)
  return has_rerouting()
      ? *config_.rerouting_
      : ::jmc_auto::planning::ReroutingConfig::default_instance();
}
inline ::jmc_auto::planning::ReroutingConfig* TrafficRuleConfig::mutable_rerouting() {
  if (!has_rerouting()) {
    clear_config();
    set_has_rerouting();
    config_.rerouting_ = new ::jmc_auto::planning::ReroutingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.rerouting)
  return config_.rerouting_;
}
inline ::jmc_auto::planning::ReroutingConfig* TrafficRuleConfig::release_rerouting() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.rerouting)
  if (has_rerouting()) {
    clear_has_config();
    ::jmc_auto::planning::ReroutingConfig* temp = config_.rerouting_;
    config_.rerouting_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_rerouting(::jmc_auto::planning::ReroutingConfig* rerouting) {
  clear_config();
  if (rerouting) {
    set_has_rerouting();
    config_.rerouting_ = rerouting;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.rerouting)
}

// optional .jmc_auto.planning.StopSignConfig stop_sign = 9;
inline bool TrafficRuleConfig::has_stop_sign() const {
  return config_case() == kStopSign;
}
inline void TrafficRuleConfig::set_has_stop_sign() {
  _oneof_case_[0] = kStopSign;
}
inline void TrafficRuleConfig::clear_stop_sign() {
  if (has_stop_sign()) {
    delete config_.stop_sign_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::StopSignConfig& TrafficRuleConfig::stop_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.stop_sign)
  return has_stop_sign()
      ? *config_.stop_sign_
      : ::jmc_auto::planning::StopSignConfig::default_instance();
}
inline ::jmc_auto::planning::StopSignConfig* TrafficRuleConfig::mutable_stop_sign() {
  if (!has_stop_sign()) {
    clear_config();
    set_has_stop_sign();
    config_.stop_sign_ = new ::jmc_auto::planning::StopSignConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.stop_sign)
  return config_.stop_sign_;
}
inline ::jmc_auto::planning::StopSignConfig* TrafficRuleConfig::release_stop_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.stop_sign)
  if (has_stop_sign()) {
    clear_has_config();
    ::jmc_auto::planning::StopSignConfig* temp = config_.stop_sign_;
    config_.stop_sign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_stop_sign(::jmc_auto::planning::StopSignConfig* stop_sign) {
  clear_config();
  if (stop_sign) {
    set_has_stop_sign();
    config_.stop_sign_ = stop_sign;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.stop_sign)
}

// optional .jmc_auto.planning.TrafficLightConfig traffic_light = 10;
inline bool TrafficRuleConfig::has_traffic_light() const {
  return config_case() == kTrafficLight;
}
inline void TrafficRuleConfig::set_has_traffic_light() {
  _oneof_case_[0] = kTrafficLight;
}
inline void TrafficRuleConfig::clear_traffic_light() {
  if (has_traffic_light()) {
    delete config_.traffic_light_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::TrafficLightConfig& TrafficRuleConfig::traffic_light() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.traffic_light)
  return has_traffic_light()
      ? *config_.traffic_light_
      : ::jmc_auto::planning::TrafficLightConfig::default_instance();
}
inline ::jmc_auto::planning::TrafficLightConfig* TrafficRuleConfig::mutable_traffic_light() {
  if (!has_traffic_light()) {
    clear_config();
    set_has_traffic_light();
    config_.traffic_light_ = new ::jmc_auto::planning::TrafficLightConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.traffic_light)
  return config_.traffic_light_;
}
inline ::jmc_auto::planning::TrafficLightConfig* TrafficRuleConfig::release_traffic_light() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.traffic_light)
  if (has_traffic_light()) {
    clear_has_config();
    ::jmc_auto::planning::TrafficLightConfig* temp = config_.traffic_light_;
    config_.traffic_light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_traffic_light(::jmc_auto::planning::TrafficLightConfig* traffic_light) {
  clear_config();
  if (traffic_light) {
    set_has_traffic_light();
    config_.traffic_light_ = traffic_light;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.traffic_light)
}

// optional .jmc_auto.planning.YieldSignConfig yield_sign = 11;
inline bool TrafficRuleConfig::has_yield_sign() const {
  return config_case() == kYieldSign;
}
inline void TrafficRuleConfig::set_has_yield_sign() {
  _oneof_case_[0] = kYieldSign;
}
inline void TrafficRuleConfig::clear_yield_sign() {
  if (has_yield_sign()) {
    delete config_.yield_sign_;
    clear_has_config();
  }
}
inline  const ::jmc_auto::planning::YieldSignConfig& TrafficRuleConfig::yield_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfig.yield_sign)
  return has_yield_sign()
      ? *config_.yield_sign_
      : ::jmc_auto::planning::YieldSignConfig::default_instance();
}
inline ::jmc_auto::planning::YieldSignConfig* TrafficRuleConfig::mutable_yield_sign() {
  if (!has_yield_sign()) {
    clear_config();
    set_has_yield_sign();
    config_.yield_sign_ = new ::jmc_auto::planning::YieldSignConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfig.yield_sign)
  return config_.yield_sign_;
}
inline ::jmc_auto::planning::YieldSignConfig* TrafficRuleConfig::release_yield_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficRuleConfig.yield_sign)
  if (has_yield_sign()) {
    clear_has_config();
    ::jmc_auto::planning::YieldSignConfig* temp = config_.yield_sign_;
    config_.yield_sign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_yield_sign(::jmc_auto::planning::YieldSignConfig* yield_sign) {
  clear_config();
  if (yield_sign) {
    set_has_yield_sign();
    config_.yield_sign_ = yield_sign;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficRuleConfig.yield_sign)
}

inline bool TrafficRuleConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void TrafficRuleConfig::clear_has_config() {
  _oneof_case_[0] = CONFIG_NOT_SET;
}
inline TrafficRuleConfig::ConfigCase TrafficRuleConfig::config_case() const {
  return TrafficRuleConfig::ConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrafficRuleConfigs

// repeated .jmc_auto.planning.TrafficRuleConfig config = 1;
inline int TrafficRuleConfigs::config_size() const {
  return config_.size();
}
inline void TrafficRuleConfigs::clear_config() {
  config_.Clear();
}
inline const ::jmc_auto::planning::TrafficRuleConfig& TrafficRuleConfigs::config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficRuleConfigs.config)
  return config_.Get(index);
}
inline ::jmc_auto::planning::TrafficRuleConfig* TrafficRuleConfigs::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficRuleConfigs.config)
  return config_.Mutable(index);
}
inline ::jmc_auto::planning::TrafficRuleConfig* TrafficRuleConfigs::add_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficRuleConfigs.config)
  return config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficRuleConfig >*
TrafficRuleConfigs::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.TrafficRuleConfigs.config)
  return &config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficRuleConfig >&
TrafficRuleConfigs::config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.TrafficRuleConfigs.config)
  return config_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace planning
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::planning::TrafficRuleConfig_RuleId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::TrafficRuleConfig_RuleId>() {
  return ::jmc_auto::planning::TrafficRuleConfig_RuleId_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto__INCLUDED
