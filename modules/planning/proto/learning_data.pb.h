// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/learning_data.proto

#ifndef PROTOBUF_modules_2fplanning_2fproto_2flearning_5fdata_2eproto__INCLUDED
#define PROTOBUF_modules_2fplanning_2fproto_2flearning_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/common/proto/geometry.pb.h"
#include "modules/common/proto/pnc_point.pb.h"
#include "modules/map/proto/map_lane.pb.h"
#include "modules/perception/proto/perception_obstacle.pb.h"
#include "modules/prediction/proto/feature.pb.h"
#include "modules/prediction/proto/prediction_obstacle.pb.h"
#include "modules/perception/proto/traffic_light_detection.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace canbus {
class Chassis;
class ChassisDefaultTypeInternal;
extern ChassisDefaultTypeInternal _Chassis_default_instance_;
class ChassisGPS;
class ChassisGPSDefaultTypeInternal;
extern ChassisGPSDefaultTypeInternal _ChassisGPS_default_instance_;
class License;
class LicenseDefaultTypeInternal;
extern LicenseDefaultTypeInternal _License_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Sonar;
class SonarDefaultTypeInternal;
extern SonarDefaultTypeInternal _Sonar_default_instance_;
class Surround;
class SurroundDefaultTypeInternal;
extern SurroundDefaultTypeInternal _Surround_default_instance_;
class WheelSpeed;
class WheelSpeedDefaultTypeInternal;
extern WheelSpeedDefaultTypeInternal _WheelSpeed_default_instance_;
}  // namespace canbus
namespace common {
class FrenetFramePoint;
class FrenetFramePointDefaultTypeInternal;
extern FrenetFramePointDefaultTypeInternal _FrenetFramePoint_default_instance_;
class GaussianInfo;
class GaussianInfoDefaultTypeInternal;
extern GaussianInfoDefaultTypeInternal _GaussianInfo_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class PathPoint;
class PathPointDefaultTypeInternal;
extern PathPointDefaultTypeInternal _PathPoint_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class PointLLH;
class PointLLHDefaultTypeInternal;
extern PointLLHDefaultTypeInternal _PointLLH_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class SLPoint;
class SLPointDefaultTypeInternal;
extern SLPointDefaultTypeInternal _SLPoint_default_instance_;
class SpeedPoint;
class SpeedPointDefaultTypeInternal;
extern SpeedPointDefaultTypeInternal _SpeedPoint_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
class VehicleMotion;
class VehicleMotionDefaultTypeInternal;
extern VehicleMotionDefaultTypeInternal _VehicleMotion_default_instance_;
class VehicleMotionPoint;
class VehicleMotionPointDefaultTypeInternal;
extern VehicleMotionPointDefaultTypeInternal _VehicleMotionPoint_default_instance_;
}  // namespace common
namespace hdmap {
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneBoundary;
class LaneBoundaryDefaultTypeInternal;
extern LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
class LaneBoundaryType;
class LaneBoundaryTypeDefaultTypeInternal;
extern LaneBoundaryTypeDefaultTypeInternal _LaneBoundaryType_default_instance_;
class LaneSampleAssociation;
class LaneSampleAssociationDefaultTypeInternal;
extern LaneSampleAssociationDefaultTypeInternal _LaneSampleAssociation_default_instance_;
}  // namespace hdmap
namespace perception {
class CIPVInfo;
class CIPVInfoDefaultTypeInternal;
extern CIPVInfoDefaultTypeInternal _CIPVInfo_default_instance_;
class LaneMarker;
class LaneMarkerDefaultTypeInternal;
extern LaneMarkerDefaultTypeInternal _LaneMarker_default_instance_;
class LaneMarkers;
class LaneMarkersDefaultTypeInternal;
extern LaneMarkersDefaultTypeInternal _LaneMarkers_default_instance_;
class PerceptionObstacle;
class PerceptionObstacleDefaultTypeInternal;
extern PerceptionObstacleDefaultTypeInternal _PerceptionObstacle_default_instance_;
class PerceptionObstacles;
class PerceptionObstaclesDefaultTypeInternal;
extern PerceptionObstaclesDefaultTypeInternal _PerceptionObstacles_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficLightBox;
class TrafficLightBoxDefaultTypeInternal;
extern TrafficLightBoxDefaultTypeInternal _TrafficLightBox_default_instance_;
class TrafficLightDebug;
class TrafficLightDebugDefaultTypeInternal;
extern TrafficLightDebugDefaultTypeInternal _TrafficLightDebug_default_instance_;
class TrafficLightDetection;
class TrafficLightDetectionDefaultTypeInternal;
extern TrafficLightDetectionDefaultTypeInternal _TrafficLightDetection_default_instance_;
}  // namespace perception
namespace planning {
class ADCTrajectoryPoint;
class ADCTrajectoryPointDefaultTypeInternal;
extern ADCTrajectoryPointDefaultTypeInternal _ADCTrajectoryPoint_default_instance_;
class ChassisFeature;
class ChassisFeatureDefaultTypeInternal;
extern ChassisFeatureDefaultTypeInternal _ChassisFeature_default_instance_;
class LearningData;
class LearningDataDefaultTypeInternal;
extern LearningDataDefaultTypeInternal _LearningData_default_instance_;
class LearningDataFrame;
class LearningDataFrameDefaultTypeInternal;
extern LearningDataFrameDefaultTypeInternal _LearningDataFrame_default_instance_;
class LearningOutput;
class LearningOutputDefaultTypeInternal;
extern LearningOutputDefaultTypeInternal _LearningOutput_default_instance_;
class LocalizationFeature;
class LocalizationFeatureDefaultTypeInternal;
extern LocalizationFeatureDefaultTypeInternal _LocalizationFeature_default_instance_;
class ObstacleFeature;
class ObstacleFeatureDefaultTypeInternal;
extern ObstacleFeatureDefaultTypeInternal _ObstacleFeature_default_instance_;
class ObstacleTrajectoryFeature;
class ObstacleTrajectoryFeatureDefaultTypeInternal;
extern ObstacleTrajectoryFeatureDefaultTypeInternal _ObstacleTrajectoryFeature_default_instance_;
class OverlapFeature;
class OverlapFeatureDefaultTypeInternal;
extern OverlapFeatureDefaultTypeInternal _OverlapFeature_default_instance_;
class PathPointFeature;
class PathPointFeatureDefaultTypeInternal;
extern PathPointFeatureDefaultTypeInternal _PathPointFeature_default_instance_;
class PerceptionObstacleFeature;
class PerceptionObstacleFeatureDefaultTypeInternal;
extern PerceptionObstacleFeatureDefaultTypeInternal _PerceptionObstacleFeature_default_instance_;
class PlanningTag;
class PlanningTagDefaultTypeInternal;
extern PlanningTagDefaultTypeInternal _PlanningTag_default_instance_;
class PredictionObstacleFeature;
class PredictionObstacleFeatureDefaultTypeInternal;
extern PredictionObstacleFeatureDefaultTypeInternal _PredictionObstacleFeature_default_instance_;
class PredictionTrajectoryFeature;
class PredictionTrajectoryFeatureDefaultTypeInternal;
extern PredictionTrajectoryFeatureDefaultTypeInternal _PredictionTrajectoryFeature_default_instance_;
class RoutingFeature;
class RoutingFeatureDefaultTypeInternal;
extern RoutingFeatureDefaultTypeInternal _RoutingFeature_default_instance_;
class TrafficLightDetectionFeature;
class TrafficLightDetectionFeatureDefaultTypeInternal;
extern TrafficLightDetectionFeatureDefaultTypeInternal _TrafficLightDetectionFeature_default_instance_;
class TrafficLightFeature;
class TrafficLightFeatureDefaultTypeInternal;
extern TrafficLightFeatureDefaultTypeInternal _TrafficLightFeature_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
class TrajectoryPointFeature;
class TrajectoryPointFeatureDefaultTypeInternal;
extern TrajectoryPointFeatureDefaultTypeInternal _TrajectoryPointFeature_default_instance_;
}  // namespace planning
namespace prediction {
class Feature;
class FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class Intent;
class IntentDefaultTypeInternal;
extern IntentDefaultTypeInternal _Intent_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneFeature;
class LaneFeatureDefaultTypeInternal;
extern LaneFeatureDefaultTypeInternal _LaneFeature_default_instance_;
class ObstacleIntent;
class ObstacleIntentDefaultTypeInternal;
extern ObstacleIntentDefaultTypeInternal _ObstacleIntent_default_instance_;
class ObstaclePriority;
class ObstaclePriorityDefaultTypeInternal;
extern ObstaclePriorityDefaultTypeInternal _ObstaclePriority_default_instance_;
class PredictionObstacle;
class PredictionObstacleDefaultTypeInternal;
extern PredictionObstacleDefaultTypeInternal _PredictionObstacle_default_instance_;
class PredictionObstacles;
class PredictionObstaclesDefaultTypeInternal;
extern PredictionObstaclesDefaultTypeInternal _PredictionObstacles_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
}  // namespace prediction
}  // namespace jmc_auto

namespace jmc_auto {
namespace planning {

namespace protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto

// ===================================================================

class OverlapFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.OverlapFeature) */ {
 public:
  OverlapFeature();
  virtual ~OverlapFeature();

  OverlapFeature(const OverlapFeature& from);

  inline OverlapFeature& operator=(const OverlapFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OverlapFeature& default_instance();

  static inline const OverlapFeature* internal_default_instance() {
    return reinterpret_cast<const OverlapFeature*>(
               &_OverlapFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(OverlapFeature* other);

  // implements Message ----------------------------------------------

  inline OverlapFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  OverlapFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OverlapFeature& from);
  void MergeFrom(const OverlapFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OverlapFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional double distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.OverlapFeature)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_distance();
  void clear_has_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  double distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PlanningTag) */ {
 public:
  PlanningTag();
  virtual ~PlanningTag();

  PlanningTag(const PlanningTag& from);

  inline PlanningTag& operator=(const PlanningTag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningTag& default_instance();

  static inline const PlanningTag* internal_default_instance() {
    return reinterpret_cast<const PlanningTag*>(
               &_PlanningTag_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PlanningTag* other);

  // implements Message ----------------------------------------------

  inline PlanningTag* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningTag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningTag& from);
  void MergeFrom(const PlanningTag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.OverlapFeature clear_area = 2;
  bool has_clear_area() const;
  void clear_clear_area();
  static const int kClearAreaFieldNumber = 2;
  const ::jmc_auto::planning::OverlapFeature& clear_area() const;
  ::jmc_auto::planning::OverlapFeature* mutable_clear_area();
  ::jmc_auto::planning::OverlapFeature* release_clear_area();
  void set_allocated_clear_area(::jmc_auto::planning::OverlapFeature* clear_area);

  // optional .jmc_auto.planning.OverlapFeature crosswalk = 3;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 3;
  const ::jmc_auto::planning::OverlapFeature& crosswalk() const;
  ::jmc_auto::planning::OverlapFeature* mutable_crosswalk();
  ::jmc_auto::planning::OverlapFeature* release_crosswalk();
  void set_allocated_crosswalk(::jmc_auto::planning::OverlapFeature* crosswalk);

  // optional .jmc_auto.planning.OverlapFeature pnc_junction = 4;
  bool has_pnc_junction() const;
  void clear_pnc_junction();
  static const int kPncJunctionFieldNumber = 4;
  const ::jmc_auto::planning::OverlapFeature& pnc_junction() const;
  ::jmc_auto::planning::OverlapFeature* mutable_pnc_junction();
  ::jmc_auto::planning::OverlapFeature* release_pnc_junction();
  void set_allocated_pnc_junction(::jmc_auto::planning::OverlapFeature* pnc_junction);

  // optional .jmc_auto.planning.OverlapFeature signal = 5;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 5;
  const ::jmc_auto::planning::OverlapFeature& signal() const;
  ::jmc_auto::planning::OverlapFeature* mutable_signal();
  ::jmc_auto::planning::OverlapFeature* release_signal();
  void set_allocated_signal(::jmc_auto::planning::OverlapFeature* signal);

  // optional .jmc_auto.planning.OverlapFeature stop_sign = 6;
  bool has_stop_sign() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 6;
  const ::jmc_auto::planning::OverlapFeature& stop_sign() const;
  ::jmc_auto::planning::OverlapFeature* mutable_stop_sign();
  ::jmc_auto::planning::OverlapFeature* release_stop_sign();
  void set_allocated_stop_sign(::jmc_auto::planning::OverlapFeature* stop_sign);

  // optional .jmc_auto.planning.OverlapFeature yield_sign = 7;
  bool has_yield_sign() const;
  void clear_yield_sign();
  static const int kYieldSignFieldNumber = 7;
  const ::jmc_auto::planning::OverlapFeature& yield_sign() const;
  ::jmc_auto::planning::OverlapFeature* mutable_yield_sign();
  ::jmc_auto::planning::OverlapFeature* release_yield_sign();
  void set_allocated_yield_sign(::jmc_auto::planning::OverlapFeature* yield_sign);

  // optional .jmc_auto.hdmap.Lane.LaneTurn lane_turn = 1;
  bool has_lane_turn() const;
  void clear_lane_turn();
  static const int kLaneTurnFieldNumber = 1;
  ::jmc_auto::hdmap::Lane_LaneTurn lane_turn() const;
  void set_lane_turn(::jmc_auto::hdmap::Lane_LaneTurn value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PlanningTag)
 private:
  void set_has_lane_turn();
  void clear_has_lane_turn();
  void set_has_clear_area();
  void clear_has_clear_area();
  void set_has_crosswalk();
  void clear_has_crosswalk();
  void set_has_pnc_junction();
  void clear_has_pnc_junction();
  void set_has_signal();
  void clear_has_signal();
  void set_has_stop_sign();
  void clear_has_stop_sign();
  void set_has_yield_sign();
  void clear_has_yield_sign();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::OverlapFeature* clear_area_;
  ::jmc_auto::planning::OverlapFeature* crosswalk_;
  ::jmc_auto::planning::OverlapFeature* pnc_junction_;
  ::jmc_auto::planning::OverlapFeature* signal_;
  ::jmc_auto::planning::OverlapFeature* stop_sign_;
  ::jmc_auto::planning::OverlapFeature* yield_sign_;
  int lane_turn_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChassisFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ChassisFeature) */ {
 public:
  ChassisFeature();
  virtual ~ChassisFeature();

  ChassisFeature(const ChassisFeature& from);

  inline ChassisFeature& operator=(const ChassisFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChassisFeature& default_instance();

  static inline const ChassisFeature* internal_default_instance() {
    return reinterpret_cast<const ChassisFeature*>(
               &_ChassisFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ChassisFeature* other);

  // implements Message ----------------------------------------------

  inline ChassisFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  ChassisFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChassisFeature& from);
  void MergeFrom(const ChassisFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChassisFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // optional float speed_mps = 2;
  bool has_speed_mps() const;
  void clear_speed_mps();
  static const int kSpeedMpsFieldNumber = 2;
  float speed_mps() const;
  void set_speed_mps(float value);

  // optional float throttle_percentage = 3;
  bool has_throttle_percentage() const;
  void clear_throttle_percentage();
  static const int kThrottlePercentageFieldNumber = 3;
  float throttle_percentage() const;
  void set_throttle_percentage(float value);

  // optional float brake_percentage = 4;
  bool has_brake_percentage() const;
  void clear_brake_percentage();
  static const int kBrakePercentageFieldNumber = 4;
  float brake_percentage() const;
  void set_brake_percentage(float value);

  // optional float steering_percentage = 5;
  bool has_steering_percentage() const;
  void clear_steering_percentage();
  static const int kSteeringPercentageFieldNumber = 5;
  float steering_percentage() const;
  void set_steering_percentage(float value);

  // optional .jmc_auto.canbus.Chassis.GearPosition gear_location = 6;
  bool has_gear_location() const;
  void clear_gear_location();
  static const int kGearLocationFieldNumber = 6;
  ::jmc_auto::canbus::Chassis_GearPosition gear_location() const;
  void set_gear_location(::jmc_auto::canbus::Chassis_GearPosition value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ChassisFeature)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();
  void set_has_speed_mps();
  void clear_has_speed_mps();
  void set_has_throttle_percentage();
  void clear_has_throttle_percentage();
  void set_has_brake_percentage();
  void clear_has_brake_percentage();
  void set_has_steering_percentage();
  void clear_has_steering_percentage();
  void set_has_gear_location();
  void clear_has_gear_location();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double message_timestamp_sec_;
  float speed_mps_;
  float throttle_percentage_;
  float brake_percentage_;
  float steering_percentage_;
  int gear_location_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalizationFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.LocalizationFeature) */ {
 public:
  LocalizationFeature();
  virtual ~LocalizationFeature();

  LocalizationFeature(const LocalizationFeature& from);

  inline LocalizationFeature& operator=(const LocalizationFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalizationFeature& default_instance();

  static inline const LocalizationFeature* internal_default_instance() {
    return reinterpret_cast<const LocalizationFeature*>(
               &_LocalizationFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LocalizationFeature* other);

  // implements Message ----------------------------------------------

  inline LocalizationFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalizationFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocalizationFeature& from);
  void MergeFrom(const LocalizationFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocalizationFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.common.PointENU position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::jmc_auto::common::PointENU& position() const;
  ::jmc_auto::common::PointENU* mutable_position();
  ::jmc_auto::common::PointENU* release_position();
  void set_allocated_position(::jmc_auto::common::PointENU* position);

  // optional .jmc_auto.common.Point3D linear_velocity = 4;
  bool has_linear_velocity() const;
  void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 4;
  const ::jmc_auto::common::Point3D& linear_velocity() const;
  ::jmc_auto::common::Point3D* mutable_linear_velocity();
  ::jmc_auto::common::Point3D* release_linear_velocity();
  void set_allocated_linear_velocity(::jmc_auto::common::Point3D* linear_velocity);

  // optional .jmc_auto.common.Point3D linear_acceleration = 5;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 5;
  const ::jmc_auto::common::Point3D& linear_acceleration() const;
  ::jmc_auto::common::Point3D* mutable_linear_acceleration();
  ::jmc_auto::common::Point3D* release_linear_acceleration();
  void set_allocated_linear_acceleration(::jmc_auto::common::Point3D* linear_acceleration);

  // optional .jmc_auto.common.Point3D angular_velocity = 6;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 6;
  const ::jmc_auto::common::Point3D& angular_velocity() const;
  ::jmc_auto::common::Point3D* mutable_angular_velocity();
  ::jmc_auto::common::Point3D* release_angular_velocity();
  void set_allocated_angular_velocity(::jmc_auto::common::Point3D* angular_velocity);

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // optional double heading = 3;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  double heading() const;
  void set_heading(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.LocalizationFeature)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();
  void set_has_position();
  void clear_has_position();
  void set_has_heading();
  void clear_has_heading();
  void set_has_linear_velocity();
  void clear_has_linear_velocity();
  void set_has_linear_acceleration();
  void clear_has_linear_acceleration();
  void set_has_angular_velocity();
  void clear_has_angular_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::common::PointENU* position_;
  ::jmc_auto::common::Point3D* linear_velocity_;
  ::jmc_auto::common::Point3D* linear_acceleration_;
  ::jmc_auto::common::Point3D* angular_velocity_;
  double message_timestamp_sec_;
  double heading_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathPointFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PathPointFeature) */ {
 public:
  PathPointFeature();
  virtual ~PathPointFeature();

  PathPointFeature(const PathPointFeature& from);

  inline PathPointFeature& operator=(const PathPointFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathPointFeature& default_instance();

  static inline const PathPointFeature* internal_default_instance() {
    return reinterpret_cast<const PathPointFeature*>(
               &_PathPointFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PathPointFeature* other);

  // implements Message ----------------------------------------------

  inline PathPointFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  PathPointFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PathPointFeature& from);
  void MergeFrom(const PathPointFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PathPointFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lane_id = 6;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 6;
  const ::std::string& lane_id() const;
  void set_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void set_lane_id(::std::string&& value);
  #endif
  void set_lane_id(const char* value);
  void set_lane_id(const char* value, size_t size);
  ::std::string* mutable_lane_id();
  ::std::string* release_lane_id();
  void set_allocated_lane_id(::std::string* lane_id);

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double theta = 4;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 4;
  double theta() const;
  void set_theta(double value);

  // optional double s = 5;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 5;
  double s() const;
  void set_s(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PathPointFeature)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_theta();
  void clear_has_theta();
  void set_has_s();
  void clear_has_s();
  void set_has_lane_id();
  void clear_has_lane_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lane_id_;
  double x_;
  double y_;
  double z_;
  double theta_;
  double s_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryPointFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrajectoryPointFeature) */ {
 public:
  TrajectoryPointFeature();
  virtual ~TrajectoryPointFeature();

  TrajectoryPointFeature(const TrajectoryPointFeature& from);

  inline TrajectoryPointFeature& operator=(const TrajectoryPointFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryPointFeature& default_instance();

  static inline const TrajectoryPointFeature* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPointFeature*>(
               &_TrajectoryPointFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TrajectoryPointFeature* other);

  // implements Message ----------------------------------------------

  inline TrajectoryPointFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryPointFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryPointFeature& from);
  void MergeFrom(const TrajectoryPointFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryPointFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.PathPointFeature path_point = 1;
  bool has_path_point() const;
  void clear_path_point();
  static const int kPathPointFieldNumber = 1;
  const ::jmc_auto::planning::PathPointFeature& path_point() const;
  ::jmc_auto::planning::PathPointFeature* mutable_path_point();
  ::jmc_auto::planning::PathPointFeature* release_path_point();
  void set_allocated_path_point(::jmc_auto::planning::PathPointFeature* path_point);

  // optional .jmc_auto.common.GaussianInfo gaussian_info = 5;
  bool has_gaussian_info() const;
  void clear_gaussian_info();
  static const int kGaussianInfoFieldNumber = 5;
  const ::jmc_auto::common::GaussianInfo& gaussian_info() const;
  ::jmc_auto::common::GaussianInfo* mutable_gaussian_info();
  ::jmc_auto::common::GaussianInfo* release_gaussian_info();
  void set_allocated_gaussian_info(::jmc_auto::common::GaussianInfo* gaussian_info);

  // optional double v = 2;
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 2;
  double v() const;
  void set_v(double value);

  // optional double a = 3;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 3;
  double a() const;
  void set_a(double value);

  // optional double relative_time = 4;
  bool has_relative_time() const;
  void clear_relative_time();
  static const int kRelativeTimeFieldNumber = 4;
  double relative_time() const;
  void set_relative_time(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrajectoryPointFeature)
 private:
  void set_has_path_point();
  void clear_has_path_point();
  void set_has_v();
  void clear_has_v();
  void set_has_a();
  void clear_has_a();
  void set_has_relative_time();
  void clear_has_relative_time();
  void set_has_gaussian_info();
  void clear_has_gaussian_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::PathPointFeature* path_point_;
  ::jmc_auto::common::GaussianInfo* gaussian_info_;
  double v_;
  double a_;
  double relative_time_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrajectoryPoint) */ {
 public:
  TrajectoryPoint();
  virtual ~TrajectoryPoint();

  TrajectoryPoint(const TrajectoryPoint& from);

  inline TrajectoryPoint& operator=(const TrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryPoint& default_instance();

  static inline const TrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPoint*>(
               &_TrajectoryPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TrajectoryPoint* other);

  // implements Message ----------------------------------------------

  inline TrajectoryPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryPoint& from);
  void MergeFrom(const TrajectoryPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.TrajectoryPointFeature trajectory_point = 2;
  bool has_trajectory_point() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 2;
  const ::jmc_auto::planning::TrajectoryPointFeature& trajectory_point() const;
  ::jmc_auto::planning::TrajectoryPointFeature* mutable_trajectory_point();
  ::jmc_auto::planning::TrajectoryPointFeature* release_trajectory_point();
  void set_allocated_trajectory_point(::jmc_auto::planning::TrajectoryPointFeature* trajectory_point);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrajectoryPoint)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_trajectory_point();
  void clear_has_trajectory_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::TrajectoryPointFeature* trajectory_point_;
  double timestamp_sec_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceptionObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PerceptionObstacleFeature) */ {
 public:
  PerceptionObstacleFeature();
  virtual ~PerceptionObstacleFeature();

  PerceptionObstacleFeature(const PerceptionObstacleFeature& from);

  inline PerceptionObstacleFeature& operator=(const PerceptionObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionObstacleFeature& default_instance();

  static inline const PerceptionObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const PerceptionObstacleFeature*>(
               &_PerceptionObstacleFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(PerceptionObstacleFeature* other);

  // implements Message ----------------------------------------------

  inline PerceptionObstacleFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  PerceptionObstacleFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PerceptionObstacleFeature& from);
  void MergeFrom(const PerceptionObstacleFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PerceptionObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.common.Point3D polygon_point = 6;
  int polygon_point_size() const;
  void clear_polygon_point();
  static const int kPolygonPointFieldNumber = 6;
  const ::jmc_auto::common::Point3D& polygon_point(int index) const;
  ::jmc_auto::common::Point3D* mutable_polygon_point(int index);
  ::jmc_auto::common::Point3D* add_polygon_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Point3D >*
      mutable_polygon_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Point3D >&
      polygon_point() const;

  // optional .jmc_auto.common.Point3D position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::jmc_auto::common::Point3D& position() const;
  ::jmc_auto::common::Point3D* mutable_position();
  ::jmc_auto::common::Point3D* release_position();
  void set_allocated_position(::jmc_auto::common::Point3D* position);

  // optional .jmc_auto.common.Point3D velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  const ::jmc_auto::common::Point3D& velocity() const;
  ::jmc_auto::common::Point3D* mutable_velocity();
  ::jmc_auto::common::Point3D* release_velocity();
  void set_allocated_velocity(::jmc_auto::common::Point3D* velocity);

  // optional .jmc_auto.common.Point3D acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  const ::jmc_auto::common::Point3D& acceleration() const;
  ::jmc_auto::common::Point3D* mutable_acceleration();
  ::jmc_auto::common::Point3D* release_acceleration();
  void set_allocated_acceleration(::jmc_auto::common::Point3D* acceleration);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional double theta = 3;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 3;
  double theta() const;
  void set_theta(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PerceptionObstacleFeature)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_position();
  void clear_has_position();
  void set_has_theta();
  void clear_has_theta();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_acceleration();
  void clear_has_acceleration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Point3D > polygon_point_;
  ::jmc_auto::common::Point3D* position_;
  ::jmc_auto::common::Point3D* velocity_;
  ::jmc_auto::common::Point3D* acceleration_;
  double timestamp_sec_;
  double theta_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleTrajectoryFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ObstacleTrajectoryFeature) */ {
 public:
  ObstacleTrajectoryFeature();
  virtual ~ObstacleTrajectoryFeature();

  ObstacleTrajectoryFeature(const ObstacleTrajectoryFeature& from);

  inline ObstacleTrajectoryFeature& operator=(const ObstacleTrajectoryFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleTrajectoryFeature& default_instance();

  static inline const ObstacleTrajectoryFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleTrajectoryFeature*>(
               &_ObstacleTrajectoryFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ObstacleTrajectoryFeature* other);

  // implements Message ----------------------------------------------

  inline ObstacleTrajectoryFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleTrajectoryFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleTrajectoryFeature& from);
  void MergeFrom(const ObstacleTrajectoryFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleTrajectoryFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.PerceptionObstacleFeature perception_obstacle_history = 1;
  int perception_obstacle_history_size() const;
  void clear_perception_obstacle_history();
  static const int kPerceptionObstacleHistoryFieldNumber = 1;
  const ::jmc_auto::planning::PerceptionObstacleFeature& perception_obstacle_history(int index) const;
  ::jmc_auto::planning::PerceptionObstacleFeature* mutable_perception_obstacle_history(int index);
  ::jmc_auto::planning::PerceptionObstacleFeature* add_perception_obstacle_history();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PerceptionObstacleFeature >*
      mutable_perception_obstacle_history();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PerceptionObstacleFeature >&
      perception_obstacle_history() const;

  // repeated .jmc_auto.planning.TrajectoryPoint evaluated_trajectory_point = 2;
  int evaluated_trajectory_point_size() const;
  void clear_evaluated_trajectory_point();
  static const int kEvaluatedTrajectoryPointFieldNumber = 2;
  const ::jmc_auto::planning::TrajectoryPoint& evaluated_trajectory_point(int index) const;
  ::jmc_auto::planning::TrajectoryPoint* mutable_evaluated_trajectory_point(int index);
  ::jmc_auto::planning::TrajectoryPoint* add_evaluated_trajectory_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >*
      mutable_evaluated_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >&
      evaluated_trajectory_point() const;

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ObstacleTrajectoryFeature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PerceptionObstacleFeature > perception_obstacle_history_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint > evaluated_trajectory_point_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictionTrajectoryFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PredictionTrajectoryFeature) */ {
 public:
  PredictionTrajectoryFeature();
  virtual ~PredictionTrajectoryFeature();

  PredictionTrajectoryFeature(const PredictionTrajectoryFeature& from);

  inline PredictionTrajectoryFeature& operator=(const PredictionTrajectoryFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionTrajectoryFeature& default_instance();

  static inline const PredictionTrajectoryFeature* internal_default_instance() {
    return reinterpret_cast<const PredictionTrajectoryFeature*>(
               &_PredictionTrajectoryFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PredictionTrajectoryFeature* other);

  // implements Message ----------------------------------------------

  inline PredictionTrajectoryFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  PredictionTrajectoryFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PredictionTrajectoryFeature& from);
  void MergeFrom(const PredictionTrajectoryFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PredictionTrajectoryFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.TrajectoryPoint trajectory_point = 2;
  int trajectory_point_size() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 2;
  const ::jmc_auto::planning::TrajectoryPoint& trajectory_point(int index) const;
  ::jmc_auto::planning::TrajectoryPoint* mutable_trajectory_point(int index);
  ::jmc_auto::planning::TrajectoryPoint* add_trajectory_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >*
      mutable_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >&
      trajectory_point() const;

  // optional double probability = 1;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 1;
  double probability() const;
  void set_probability(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PredictionTrajectoryFeature)
 private:
  void set_has_probability();
  void clear_has_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint > trajectory_point_;
  double probability_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictionObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PredictionObstacleFeature) */ {
 public:
  PredictionObstacleFeature();
  virtual ~PredictionObstacleFeature();

  PredictionObstacleFeature(const PredictionObstacleFeature& from);

  inline PredictionObstacleFeature& operator=(const PredictionObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionObstacleFeature& default_instance();

  static inline const PredictionObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const PredictionObstacleFeature*>(
               &_PredictionObstacleFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PredictionObstacleFeature* other);

  // implements Message ----------------------------------------------

  inline PredictionObstacleFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  PredictionObstacleFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PredictionObstacleFeature& from);
  void MergeFrom(const PredictionObstacleFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PredictionObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.PredictionTrajectoryFeature trajectory = 6;
  int trajectory_size() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 6;
  const ::jmc_auto::planning::PredictionTrajectoryFeature& trajectory(int index) const;
  ::jmc_auto::planning::PredictionTrajectoryFeature* mutable_trajectory(int index);
  ::jmc_auto::planning::PredictionTrajectoryFeature* add_trajectory();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PredictionTrajectoryFeature >*
      mutable_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PredictionTrajectoryFeature >&
      trajectory() const;

  // optional .jmc_auto.prediction.ObstacleIntent intent = 3;
  bool has_intent() const;
  void clear_intent();
  static const int kIntentFieldNumber = 3;
  const ::jmc_auto::prediction::ObstacleIntent& intent() const;
  ::jmc_auto::prediction::ObstacleIntent* mutable_intent();
  ::jmc_auto::prediction::ObstacleIntent* release_intent();
  void set_allocated_intent(::jmc_auto::prediction::ObstacleIntent* intent);

  // optional .jmc_auto.prediction.ObstaclePriority priority = 4;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 4;
  const ::jmc_auto::prediction::ObstaclePriority& priority() const;
  ::jmc_auto::prediction::ObstaclePriority* mutable_priority();
  ::jmc_auto::prediction::ObstaclePriority* release_priority();
  void set_allocated_priority(::jmc_auto::prediction::ObstaclePriority* priority);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional double predicted_period = 2;
  bool has_predicted_period() const;
  void clear_predicted_period();
  static const int kPredictedPeriodFieldNumber = 2;
  double predicted_period() const;
  void set_predicted_period(double value);

  // optional bool is_static = 5 [default = false];
  bool has_is_static() const;
  void clear_is_static();
  static const int kIsStaticFieldNumber = 5;
  bool is_static() const;
  void set_is_static(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PredictionObstacleFeature)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_predicted_period();
  void clear_has_predicted_period();
  void set_has_intent();
  void clear_has_intent();
  void set_has_priority();
  void clear_has_priority();
  void set_has_is_static();
  void clear_has_is_static();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PredictionTrajectoryFeature > trajectory_;
  ::jmc_auto::prediction::ObstacleIntent* intent_;
  ::jmc_auto::prediction::ObstaclePriority* priority_;
  double timestamp_sec_;
  double predicted_period_;
  bool is_static_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ObstacleFeature) */ {
 public:
  ObstacleFeature();
  virtual ~ObstacleFeature();

  ObstacleFeature(const ObstacleFeature& from);

  inline ObstacleFeature& operator=(const ObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleFeature& default_instance();

  static inline const ObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleFeature*>(
               &_ObstacleFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ObstacleFeature* other);

  // implements Message ----------------------------------------------

  inline ObstacleFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleFeature& from);
  void MergeFrom(const ObstacleFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.ObstacleTrajectoryFeature obstacle_trajectory = 6;
  bool has_obstacle_trajectory() const;
  void clear_obstacle_trajectory();
  static const int kObstacleTrajectoryFieldNumber = 6;
  const ::jmc_auto::planning::ObstacleTrajectoryFeature& obstacle_trajectory() const;
  ::jmc_auto::planning::ObstacleTrajectoryFeature* mutable_obstacle_trajectory();
  ::jmc_auto::planning::ObstacleTrajectoryFeature* release_obstacle_trajectory();
  void set_allocated_obstacle_trajectory(::jmc_auto::planning::ObstacleTrajectoryFeature* obstacle_trajectory);

  // optional .jmc_auto.planning.PredictionObstacleFeature obstacle_prediction = 7;
  bool has_obstacle_prediction() const;
  void clear_obstacle_prediction();
  static const int kObstaclePredictionFieldNumber = 7;
  const ::jmc_auto::planning::PredictionObstacleFeature& obstacle_prediction() const;
  ::jmc_auto::planning::PredictionObstacleFeature* mutable_obstacle_prediction();
  ::jmc_auto::planning::PredictionObstacleFeature* release_obstacle_prediction();
  void set_allocated_obstacle_prediction(::jmc_auto::planning::PredictionObstacleFeature* obstacle_prediction);

  // optional double length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  double length() const;
  void set_length(double value);

  // optional double width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  double width() const;
  void set_width(double value);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .jmc_auto.perception.PerceptionObstacle.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::jmc_auto::perception::PerceptionObstacle_Type type() const;
  void set_type(::jmc_auto::perception::PerceptionObstacle_Type value);

  // optional double height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  double height() const;
  void set_height(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ObstacleFeature)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_type();
  void clear_has_type();
  void set_has_obstacle_trajectory();
  void clear_has_obstacle_trajectory();
  void set_has_obstacle_prediction();
  void clear_has_obstacle_prediction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::ObstacleTrajectoryFeature* obstacle_trajectory_;
  ::jmc_auto::planning::PredictionObstacleFeature* obstacle_prediction_;
  double length_;
  double width_;
  ::google::protobuf::int32 id_;
  int type_;
  double height_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoutingFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.RoutingFeature) */ {
 public:
  RoutingFeature();
  virtual ~RoutingFeature();

  RoutingFeature(const RoutingFeature& from);

  inline RoutingFeature& operator=(const RoutingFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingFeature& default_instance();

  static inline const RoutingFeature* internal_default_instance() {
    return reinterpret_cast<const RoutingFeature*>(
               &_RoutingFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RoutingFeature* other);

  // implements Message ----------------------------------------------

  inline RoutingFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  RoutingFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoutingFeature& from);
  void MergeFrom(const RoutingFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoutingFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string routing_lane_id = 1;
  int routing_lane_id_size() const;
  void clear_routing_lane_id();
  static const int kRoutingLaneIdFieldNumber = 1;
  const ::std::string& routing_lane_id(int index) const;
  ::std::string* mutable_routing_lane_id(int index);
  void set_routing_lane_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_routing_lane_id(int index, ::std::string&& value);
  #endif
  void set_routing_lane_id(int index, const char* value);
  void set_routing_lane_id(int index, const char* value, size_t size);
  ::std::string* add_routing_lane_id();
  void add_routing_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void add_routing_lane_id(::std::string&& value);
  #endif
  void add_routing_lane_id(const char* value);
  void add_routing_lane_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& routing_lane_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_routing_lane_id();

  // repeated string local_routing_lane_id = 2;
  int local_routing_lane_id_size() const;
  void clear_local_routing_lane_id();
  static const int kLocalRoutingLaneIdFieldNumber = 2;
  const ::std::string& local_routing_lane_id(int index) const;
  ::std::string* mutable_local_routing_lane_id(int index);
  void set_local_routing_lane_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_local_routing_lane_id(int index, ::std::string&& value);
  #endif
  void set_local_routing_lane_id(int index, const char* value);
  void set_local_routing_lane_id(int index, const char* value, size_t size);
  ::std::string* add_local_routing_lane_id();
  void add_local_routing_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void add_local_routing_lane_id(::std::string&& value);
  #endif
  void add_local_routing_lane_id(const char* value);
  void add_local_routing_lane_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& local_routing_lane_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_local_routing_lane_id();

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.RoutingFeature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> routing_lane_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> local_routing_lane_id_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrafficLightFeature) */ {
 public:
  TrafficLightFeature();
  virtual ~TrafficLightFeature();

  TrafficLightFeature(const TrafficLightFeature& from);

  inline TrafficLightFeature& operator=(const TrafficLightFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightFeature& default_instance();

  static inline const TrafficLightFeature* internal_default_instance() {
    return reinterpret_cast<const TrafficLightFeature*>(
               &_TrafficLightFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TrafficLightFeature* other);

  // implements Message ----------------------------------------------

  inline TrafficLightFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightFeature& from);
  void MergeFrom(const TrafficLightFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .jmc_auto.perception.TrafficLight.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::jmc_auto::perception::TrafficLight_Color color() const;
  void set_color(::jmc_auto::perception::TrafficLight_Color value);

  // optional bool blink = 5;
  bool has_blink() const;
  void clear_blink();
  static const int kBlinkFieldNumber = 5;
  bool blink() const;
  void set_blink(bool value);

  // optional double tracking_time = 4;
  bool has_tracking_time() const;
  void clear_tracking_time();
  static const int kTrackingTimeFieldNumber = 4;
  double tracking_time() const;
  void set_tracking_time(double value);

  // optional double remaining_time = 6;
  bool has_remaining_time() const;
  void clear_remaining_time();
  static const int kRemainingTimeFieldNumber = 6;
  double remaining_time() const;
  void set_remaining_time(double value);

  // optional double confidence = 3 [default = 1];
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  double confidence() const;
  void set_confidence(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrafficLightFeature)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_id();
  void clear_has_id();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_tracking_time();
  void clear_has_tracking_time();
  void set_has_blink();
  void clear_has_blink();
  void set_has_remaining_time();
  void clear_has_remaining_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int color_;
  bool blink_;
  double tracking_time_;
  double remaining_time_;
  double confidence_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightDetectionFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TrafficLightDetectionFeature) */ {
 public:
  TrafficLightDetectionFeature();
  virtual ~TrafficLightDetectionFeature();

  TrafficLightDetectionFeature(const TrafficLightDetectionFeature& from);

  inline TrafficLightDetectionFeature& operator=(const TrafficLightDetectionFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightDetectionFeature& default_instance();

  static inline const TrafficLightDetectionFeature* internal_default_instance() {
    return reinterpret_cast<const TrafficLightDetectionFeature*>(
               &_TrafficLightDetectionFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TrafficLightDetectionFeature* other);

  // implements Message ----------------------------------------------

  inline TrafficLightDetectionFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightDetectionFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightDetectionFeature& from);
  void MergeFrom(const TrafficLightDetectionFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightDetectionFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.TrafficLightFeature traffic_light = 2;
  int traffic_light_size() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 2;
  const ::jmc_auto::planning::TrafficLightFeature& traffic_light(int index) const;
  ::jmc_auto::planning::TrafficLightFeature* mutable_traffic_light(int index);
  ::jmc_auto::planning::TrafficLightFeature* add_traffic_light();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficLightFeature >*
      mutable_traffic_light();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficLightFeature >&
      traffic_light() const;

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TrafficLightDetectionFeature)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficLightFeature > traffic_light_;
  double message_timestamp_sec_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ADCTrajectoryPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ADCTrajectoryPoint) */ {
 public:
  ADCTrajectoryPoint();
  virtual ~ADCTrajectoryPoint();

  ADCTrajectoryPoint(const ADCTrajectoryPoint& from);

  inline ADCTrajectoryPoint& operator=(const ADCTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ADCTrajectoryPoint& default_instance();

  static inline const ADCTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const ADCTrajectoryPoint*>(
               &_ADCTrajectoryPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ADCTrajectoryPoint* other);

  // implements Message ----------------------------------------------

  inline ADCTrajectoryPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ADCTrajectoryPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ADCTrajectoryPoint& from);
  void MergeFrom(const ADCTrajectoryPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ADCTrajectoryPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.PlanningTag planning_tag = 2;
  bool has_planning_tag() const;
  void clear_planning_tag();
  static const int kPlanningTagFieldNumber = 2;
  const ::jmc_auto::planning::PlanningTag& planning_tag() const;
  ::jmc_auto::planning::PlanningTag* mutable_planning_tag();
  ::jmc_auto::planning::PlanningTag* release_planning_tag();
  void set_allocated_planning_tag(::jmc_auto::planning::PlanningTag* planning_tag);

  // optional .jmc_auto.planning.TrajectoryPointFeature trajectory_point = 3;
  bool has_trajectory_point() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 3;
  const ::jmc_auto::planning::TrajectoryPointFeature& trajectory_point() const;
  ::jmc_auto::planning::TrajectoryPointFeature* mutable_trajectory_point();
  ::jmc_auto::planning::TrajectoryPointFeature* release_trajectory_point();
  void set_allocated_trajectory_point(::jmc_auto::planning::TrajectoryPointFeature* trajectory_point);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ADCTrajectoryPoint)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_planning_tag();
  void clear_has_planning_tag();
  void set_has_trajectory_point();
  void clear_has_trajectory_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::PlanningTag* planning_tag_;
  ::jmc_auto::planning::TrajectoryPointFeature* trajectory_point_;
  double timestamp_sec_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.LearningOutput) */ {
 public:
  LearningOutput();
  virtual ~LearningOutput();

  LearningOutput(const LearningOutput& from);

  inline LearningOutput& operator=(const LearningOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningOutput& default_instance();

  static inline const LearningOutput* internal_default_instance() {
    return reinterpret_cast<const LearningOutput*>(
               &_LearningOutput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(LearningOutput* other);

  // implements Message ----------------------------------------------

  inline LearningOutput* New() const PROTOBUF_FINAL { return New(NULL); }

  LearningOutput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LearningOutput& from);
  void MergeFrom(const LearningOutput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LearningOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.ADCTrajectoryPoint adc_future_trajectory_point = 1;
  int adc_future_trajectory_point_size() const;
  void clear_adc_future_trajectory_point();
  static const int kAdcFutureTrajectoryPointFieldNumber = 1;
  const ::jmc_auto::planning::ADCTrajectoryPoint& adc_future_trajectory_point(int index) const;
  ::jmc_auto::planning::ADCTrajectoryPoint* mutable_adc_future_trajectory_point(int index);
  ::jmc_auto::planning::ADCTrajectoryPoint* add_adc_future_trajectory_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >*
      mutable_adc_future_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >&
      adc_future_trajectory_point() const;

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.LearningOutput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint > adc_future_trajectory_point_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningDataFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.LearningDataFrame) */ {
 public:
  LearningDataFrame();
  virtual ~LearningDataFrame();

  LearningDataFrame(const LearningDataFrame& from);

  inline LearningDataFrame& operator=(const LearningDataFrame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningDataFrame& default_instance();

  static inline const LearningDataFrame* internal_default_instance() {
    return reinterpret_cast<const LearningDataFrame*>(
               &_LearningDataFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(LearningDataFrame* other);

  // implements Message ----------------------------------------------

  inline LearningDataFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  LearningDataFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LearningDataFrame& from);
  void MergeFrom(const LearningDataFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LearningDataFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.ObstacleFeature obstacle = 7;
  int obstacle_size() const;
  void clear_obstacle();
  static const int kObstacleFieldNumber = 7;
  const ::jmc_auto::planning::ObstacleFeature& obstacle(int index) const;
  ::jmc_auto::planning::ObstacleFeature* mutable_obstacle(int index);
  ::jmc_auto::planning::ObstacleFeature* add_obstacle();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ObstacleFeature >*
      mutable_obstacle();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ObstacleFeature >&
      obstacle() const;

  // repeated .jmc_auto.planning.ADCTrajectoryPoint adc_trajectory_point = 10;
  int adc_trajectory_point_size() const;
  void clear_adc_trajectory_point();
  static const int kAdcTrajectoryPointFieldNumber = 10;
  const ::jmc_auto::planning::ADCTrajectoryPoint& adc_trajectory_point(int index) const;
  ::jmc_auto::planning::ADCTrajectoryPoint* mutable_adc_trajectory_point(int index);
  ::jmc_auto::planning::ADCTrajectoryPoint* add_adc_trajectory_point();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >*
      mutable_adc_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >&
      adc_trajectory_point() const;

  // optional string map_name = 3;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 3;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional .jmc_auto.planning.PlanningTag planning_tag = 4;
  bool has_planning_tag() const;
  void clear_planning_tag();
  static const int kPlanningTagFieldNumber = 4;
  const ::jmc_auto::planning::PlanningTag& planning_tag() const;
  ::jmc_auto::planning::PlanningTag* mutable_planning_tag();
  ::jmc_auto::planning::PlanningTag* release_planning_tag();
  void set_allocated_planning_tag(::jmc_auto::planning::PlanningTag* planning_tag);

  // optional .jmc_auto.planning.ChassisFeature chassis = 5;
  bool has_chassis() const;
  void clear_chassis();
  static const int kChassisFieldNumber = 5;
  const ::jmc_auto::planning::ChassisFeature& chassis() const;
  ::jmc_auto::planning::ChassisFeature* mutable_chassis();
  ::jmc_auto::planning::ChassisFeature* release_chassis();
  void set_allocated_chassis(::jmc_auto::planning::ChassisFeature* chassis);

  // optional .jmc_auto.planning.LocalizationFeature localization = 6;
  bool has_localization() const;
  void clear_localization();
  static const int kLocalizationFieldNumber = 6;
  const ::jmc_auto::planning::LocalizationFeature& localization() const;
  ::jmc_auto::planning::LocalizationFeature* mutable_localization();
  ::jmc_auto::planning::LocalizationFeature* release_localization();
  void set_allocated_localization(::jmc_auto::planning::LocalizationFeature* localization);

  // optional .jmc_auto.planning.RoutingFeature routing = 8;
  bool has_routing() const;
  void clear_routing();
  static const int kRoutingFieldNumber = 8;
  const ::jmc_auto::planning::RoutingFeature& routing() const;
  ::jmc_auto::planning::RoutingFeature* mutable_routing();
  ::jmc_auto::planning::RoutingFeature* release_routing();
  void set_allocated_routing(::jmc_auto::planning::RoutingFeature* routing);

  // optional .jmc_auto.planning.TrafficLightDetectionFeature traffic_light_detection = 9;
  bool has_traffic_light_detection() const;
  void clear_traffic_light_detection();
  static const int kTrafficLightDetectionFieldNumber = 9;
  const ::jmc_auto::planning::TrafficLightDetectionFeature& traffic_light_detection() const;
  ::jmc_auto::planning::TrafficLightDetectionFeature* mutable_traffic_light_detection();
  ::jmc_auto::planning::TrafficLightDetectionFeature* release_traffic_light_detection();
  void set_allocated_traffic_light_detection(::jmc_auto::planning::TrafficLightDetectionFeature* traffic_light_detection);

  // optional .jmc_auto.planning.LearningOutput output = 11;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 11;
  const ::jmc_auto::planning::LearningOutput& output() const;
  ::jmc_auto::planning::LearningOutput* mutable_output();
  ::jmc_auto::planning::LearningOutput* release_output();
  void set_allocated_output(::jmc_auto::planning::LearningOutput* output);

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // optional uint32 frame_num = 2;
  bool has_frame_num() const;
  void clear_frame_num();
  static const int kFrameNumFieldNumber = 2;
  ::google::protobuf::uint32 frame_num() const;
  void set_frame_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.LearningDataFrame)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();
  void set_has_frame_num();
  void clear_has_frame_num();
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_planning_tag();
  void clear_has_planning_tag();
  void set_has_chassis();
  void clear_has_chassis();
  void set_has_localization();
  void clear_has_localization();
  void set_has_routing();
  void clear_has_routing();
  void set_has_traffic_light_detection();
  void clear_has_traffic_light_detection();
  void set_has_output();
  void clear_has_output();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ObstacleFeature > obstacle_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint > adc_trajectory_point_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::jmc_auto::planning::PlanningTag* planning_tag_;
  ::jmc_auto::planning::ChassisFeature* chassis_;
  ::jmc_auto::planning::LocalizationFeature* localization_;
  ::jmc_auto::planning::RoutingFeature* routing_;
  ::jmc_auto::planning::TrafficLightDetectionFeature* traffic_light_detection_;
  ::jmc_auto::planning::LearningOutput* output_;
  double message_timestamp_sec_;
  ::google::protobuf::uint32 frame_num_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.LearningData) */ {
 public:
  LearningData();
  virtual ~LearningData();

  LearningData(const LearningData& from);

  inline LearningData& operator=(const LearningData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningData& default_instance();

  static inline const LearningData* internal_default_instance() {
    return reinterpret_cast<const LearningData*>(
               &_LearningData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(LearningData* other);

  // implements Message ----------------------------------------------

  inline LearningData* New() const PROTOBUF_FINAL { return New(NULL); }

  LearningData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LearningData& from);
  void MergeFrom(const LearningData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LearningData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.LearningDataFrame learning_data = 1;
  int learning_data_size() const;
  void clear_learning_data();
  static const int kLearningDataFieldNumber = 1;
  const ::jmc_auto::planning::LearningDataFrame& learning_data(int index) const;
  ::jmc_auto::planning::LearningDataFrame* mutable_learning_data(int index);
  ::jmc_auto::planning::LearningDataFrame* add_learning_data();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::LearningDataFrame >*
      mutable_learning_data();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::LearningDataFrame >&
      learning_data() const;

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.LearningData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::LearningDataFrame > learning_data_;
  friend struct protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// OverlapFeature

// optional string id = 1;
inline bool OverlapFeature::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OverlapFeature::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OverlapFeature::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OverlapFeature::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& OverlapFeature::id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OverlapFeature.id)
  return id_.GetNoArena();
}
inline void OverlapFeature::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OverlapFeature.id)
}
#if LANG_CXX11
inline void OverlapFeature::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.OverlapFeature.id)
}
#endif
inline void OverlapFeature::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.OverlapFeature.id)
}
inline void OverlapFeature::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.OverlapFeature.id)
}
inline ::std::string* OverlapFeature::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.OverlapFeature.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OverlapFeature::release_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.OverlapFeature.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OverlapFeature::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.OverlapFeature.id)
}

// optional double distance = 2;
inline bool OverlapFeature::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OverlapFeature::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OverlapFeature::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OverlapFeature::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double OverlapFeature::distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OverlapFeature.distance)
  return distance_;
}
inline void OverlapFeature::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OverlapFeature.distance)
}

// -------------------------------------------------------------------

// PlanningTag

// optional .jmc_auto.hdmap.Lane.LaneTurn lane_turn = 1;
inline bool PlanningTag::has_lane_turn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlanningTag::set_has_lane_turn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlanningTag::clear_has_lane_turn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlanningTag::clear_lane_turn() {
  lane_turn_ = 1;
  clear_has_lane_turn();
}
inline ::jmc_auto::hdmap::Lane_LaneTurn PlanningTag::lane_turn() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.lane_turn)
  return static_cast< ::jmc_auto::hdmap::Lane_LaneTurn >(lane_turn_);
}
inline void PlanningTag::set_lane_turn(::jmc_auto::hdmap::Lane_LaneTurn value) {
  assert(::jmc_auto::hdmap::Lane_LaneTurn_IsValid(value));
  set_has_lane_turn();
  lane_turn_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PlanningTag.lane_turn)
}

// optional .jmc_auto.planning.OverlapFeature clear_area = 2;
inline bool PlanningTag::has_clear_area() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningTag::set_has_clear_area() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningTag::clear_has_clear_area() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningTag::clear_clear_area() {
  if (clear_area_ != NULL) clear_area_->::jmc_auto::planning::OverlapFeature::Clear();
  clear_has_clear_area();
}
inline const ::jmc_auto::planning::OverlapFeature& PlanningTag::clear_area() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.clear_area)
  return clear_area_ != NULL ? *clear_area_
                         : *::jmc_auto::planning::OverlapFeature::internal_default_instance();
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::mutable_clear_area() {
  set_has_clear_area();
  if (clear_area_ == NULL) {
    clear_area_ = new ::jmc_auto::planning::OverlapFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningTag.clear_area)
  return clear_area_;
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::release_clear_area() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningTag.clear_area)
  clear_has_clear_area();
  ::jmc_auto::planning::OverlapFeature* temp = clear_area_;
  clear_area_ = NULL;
  return temp;
}
inline void PlanningTag::set_allocated_clear_area(::jmc_auto::planning::OverlapFeature* clear_area) {
  delete clear_area_;
  clear_area_ = clear_area;
  if (clear_area) {
    set_has_clear_area();
  } else {
    clear_has_clear_area();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningTag.clear_area)
}

// optional .jmc_auto.planning.OverlapFeature crosswalk = 3;
inline bool PlanningTag::has_crosswalk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningTag::set_has_crosswalk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningTag::clear_has_crosswalk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningTag::clear_crosswalk() {
  if (crosswalk_ != NULL) crosswalk_->::jmc_auto::planning::OverlapFeature::Clear();
  clear_has_crosswalk();
}
inline const ::jmc_auto::planning::OverlapFeature& PlanningTag::crosswalk() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.crosswalk)
  return crosswalk_ != NULL ? *crosswalk_
                         : *::jmc_auto::planning::OverlapFeature::internal_default_instance();
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::mutable_crosswalk() {
  set_has_crosswalk();
  if (crosswalk_ == NULL) {
    crosswalk_ = new ::jmc_auto::planning::OverlapFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningTag.crosswalk)
  return crosswalk_;
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::release_crosswalk() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningTag.crosswalk)
  clear_has_crosswalk();
  ::jmc_auto::planning::OverlapFeature* temp = crosswalk_;
  crosswalk_ = NULL;
  return temp;
}
inline void PlanningTag::set_allocated_crosswalk(::jmc_auto::planning::OverlapFeature* crosswalk) {
  delete crosswalk_;
  crosswalk_ = crosswalk;
  if (crosswalk) {
    set_has_crosswalk();
  } else {
    clear_has_crosswalk();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningTag.crosswalk)
}

// optional .jmc_auto.planning.OverlapFeature pnc_junction = 4;
inline bool PlanningTag::has_pnc_junction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanningTag::set_has_pnc_junction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanningTag::clear_has_pnc_junction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanningTag::clear_pnc_junction() {
  if (pnc_junction_ != NULL) pnc_junction_->::jmc_auto::planning::OverlapFeature::Clear();
  clear_has_pnc_junction();
}
inline const ::jmc_auto::planning::OverlapFeature& PlanningTag::pnc_junction() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.pnc_junction)
  return pnc_junction_ != NULL ? *pnc_junction_
                         : *::jmc_auto::planning::OverlapFeature::internal_default_instance();
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::mutable_pnc_junction() {
  set_has_pnc_junction();
  if (pnc_junction_ == NULL) {
    pnc_junction_ = new ::jmc_auto::planning::OverlapFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningTag.pnc_junction)
  return pnc_junction_;
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::release_pnc_junction() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningTag.pnc_junction)
  clear_has_pnc_junction();
  ::jmc_auto::planning::OverlapFeature* temp = pnc_junction_;
  pnc_junction_ = NULL;
  return temp;
}
inline void PlanningTag::set_allocated_pnc_junction(::jmc_auto::planning::OverlapFeature* pnc_junction) {
  delete pnc_junction_;
  pnc_junction_ = pnc_junction;
  if (pnc_junction) {
    set_has_pnc_junction();
  } else {
    clear_has_pnc_junction();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningTag.pnc_junction)
}

// optional .jmc_auto.planning.OverlapFeature signal = 5;
inline bool PlanningTag::has_signal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanningTag::set_has_signal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanningTag::clear_has_signal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanningTag::clear_signal() {
  if (signal_ != NULL) signal_->::jmc_auto::planning::OverlapFeature::Clear();
  clear_has_signal();
}
inline const ::jmc_auto::planning::OverlapFeature& PlanningTag::signal() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.signal)
  return signal_ != NULL ? *signal_
                         : *::jmc_auto::planning::OverlapFeature::internal_default_instance();
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) {
    signal_ = new ::jmc_auto::planning::OverlapFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningTag.signal)
  return signal_;
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::release_signal() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningTag.signal)
  clear_has_signal();
  ::jmc_auto::planning::OverlapFeature* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void PlanningTag::set_allocated_signal(::jmc_auto::planning::OverlapFeature* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningTag.signal)
}

// optional .jmc_auto.planning.OverlapFeature stop_sign = 6;
inline bool PlanningTag::has_stop_sign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlanningTag::set_has_stop_sign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlanningTag::clear_has_stop_sign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlanningTag::clear_stop_sign() {
  if (stop_sign_ != NULL) stop_sign_->::jmc_auto::planning::OverlapFeature::Clear();
  clear_has_stop_sign();
}
inline const ::jmc_auto::planning::OverlapFeature& PlanningTag::stop_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.stop_sign)
  return stop_sign_ != NULL ? *stop_sign_
                         : *::jmc_auto::planning::OverlapFeature::internal_default_instance();
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::mutable_stop_sign() {
  set_has_stop_sign();
  if (stop_sign_ == NULL) {
    stop_sign_ = new ::jmc_auto::planning::OverlapFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningTag.stop_sign)
  return stop_sign_;
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::release_stop_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningTag.stop_sign)
  clear_has_stop_sign();
  ::jmc_auto::planning::OverlapFeature* temp = stop_sign_;
  stop_sign_ = NULL;
  return temp;
}
inline void PlanningTag::set_allocated_stop_sign(::jmc_auto::planning::OverlapFeature* stop_sign) {
  delete stop_sign_;
  stop_sign_ = stop_sign;
  if (stop_sign) {
    set_has_stop_sign();
  } else {
    clear_has_stop_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningTag.stop_sign)
}

// optional .jmc_auto.planning.OverlapFeature yield_sign = 7;
inline bool PlanningTag::has_yield_sign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlanningTag::set_has_yield_sign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlanningTag::clear_has_yield_sign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlanningTag::clear_yield_sign() {
  if (yield_sign_ != NULL) yield_sign_->::jmc_auto::planning::OverlapFeature::Clear();
  clear_has_yield_sign();
}
inline const ::jmc_auto::planning::OverlapFeature& PlanningTag::yield_sign() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningTag.yield_sign)
  return yield_sign_ != NULL ? *yield_sign_
                         : *::jmc_auto::planning::OverlapFeature::internal_default_instance();
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::mutable_yield_sign() {
  set_has_yield_sign();
  if (yield_sign_ == NULL) {
    yield_sign_ = new ::jmc_auto::planning::OverlapFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningTag.yield_sign)
  return yield_sign_;
}
inline ::jmc_auto::planning::OverlapFeature* PlanningTag::release_yield_sign() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningTag.yield_sign)
  clear_has_yield_sign();
  ::jmc_auto::planning::OverlapFeature* temp = yield_sign_;
  yield_sign_ = NULL;
  return temp;
}
inline void PlanningTag::set_allocated_yield_sign(::jmc_auto::planning::OverlapFeature* yield_sign) {
  delete yield_sign_;
  yield_sign_ = yield_sign;
  if (yield_sign) {
    set_has_yield_sign();
  } else {
    clear_has_yield_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningTag.yield_sign)
}

// -------------------------------------------------------------------

// ChassisFeature

// optional double message_timestamp_sec = 1;
inline bool ChassisFeature::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChassisFeature::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChassisFeature::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChassisFeature::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double ChassisFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChassisFeature.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void ChassisFeature::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChassisFeature.message_timestamp_sec)
}

// optional float speed_mps = 2;
inline bool ChassisFeature::has_speed_mps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChassisFeature::set_has_speed_mps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChassisFeature::clear_has_speed_mps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChassisFeature::clear_speed_mps() {
  speed_mps_ = 0;
  clear_has_speed_mps();
}
inline float ChassisFeature::speed_mps() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChassisFeature.speed_mps)
  return speed_mps_;
}
inline void ChassisFeature::set_speed_mps(float value) {
  set_has_speed_mps();
  speed_mps_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChassisFeature.speed_mps)
}

// optional float throttle_percentage = 3;
inline bool ChassisFeature::has_throttle_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChassisFeature::set_has_throttle_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChassisFeature::clear_has_throttle_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChassisFeature::clear_throttle_percentage() {
  throttle_percentage_ = 0;
  clear_has_throttle_percentage();
}
inline float ChassisFeature::throttle_percentage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChassisFeature.throttle_percentage)
  return throttle_percentage_;
}
inline void ChassisFeature::set_throttle_percentage(float value) {
  set_has_throttle_percentage();
  throttle_percentage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChassisFeature.throttle_percentage)
}

// optional float brake_percentage = 4;
inline bool ChassisFeature::has_brake_percentage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChassisFeature::set_has_brake_percentage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChassisFeature::clear_has_brake_percentage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChassisFeature::clear_brake_percentage() {
  brake_percentage_ = 0;
  clear_has_brake_percentage();
}
inline float ChassisFeature::brake_percentage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChassisFeature.brake_percentage)
  return brake_percentage_;
}
inline void ChassisFeature::set_brake_percentage(float value) {
  set_has_brake_percentage();
  brake_percentage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChassisFeature.brake_percentage)
}

// optional float steering_percentage = 5;
inline bool ChassisFeature::has_steering_percentage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChassisFeature::set_has_steering_percentage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChassisFeature::clear_has_steering_percentage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChassisFeature::clear_steering_percentage() {
  steering_percentage_ = 0;
  clear_has_steering_percentage();
}
inline float ChassisFeature::steering_percentage() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChassisFeature.steering_percentage)
  return steering_percentage_;
}
inline void ChassisFeature::set_steering_percentage(float value) {
  set_has_steering_percentage();
  steering_percentage_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChassisFeature.steering_percentage)
}

// optional .jmc_auto.canbus.Chassis.GearPosition gear_location = 6;
inline bool ChassisFeature::has_gear_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChassisFeature::set_has_gear_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChassisFeature::clear_has_gear_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChassisFeature::clear_gear_location() {
  gear_location_ = 0;
  clear_has_gear_location();
}
inline ::jmc_auto::canbus::Chassis_GearPosition ChassisFeature::gear_location() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ChassisFeature.gear_location)
  return static_cast< ::jmc_auto::canbus::Chassis_GearPosition >(gear_location_);
}
inline void ChassisFeature::set_gear_location(::jmc_auto::canbus::Chassis_GearPosition value) {
  assert(::jmc_auto::canbus::Chassis_GearPosition_IsValid(value));
  set_has_gear_location();
  gear_location_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ChassisFeature.gear_location)
}

// -------------------------------------------------------------------

// LocalizationFeature

// optional double message_timestamp_sec = 1;
inline bool LocalizationFeature::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalizationFeature::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalizationFeature::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalizationFeature::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double LocalizationFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LocalizationFeature.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void LocalizationFeature::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.LocalizationFeature.message_timestamp_sec)
}

// optional .jmc_auto.common.PointENU position = 2;
inline bool LocalizationFeature::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationFeature::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationFeature::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalizationFeature::clear_position() {
  if (position_ != NULL) position_->::jmc_auto::common::PointENU::Clear();
  clear_has_position();
}
inline const ::jmc_auto::common::PointENU& LocalizationFeature::position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LocalizationFeature.position)
  return position_ != NULL ? *position_
                         : *::jmc_auto::common::PointENU::internal_default_instance();
}
inline ::jmc_auto::common::PointENU* LocalizationFeature::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::jmc_auto::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LocalizationFeature.position)
  return position_;
}
inline ::jmc_auto::common::PointENU* LocalizationFeature::release_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LocalizationFeature.position)
  clear_has_position();
  ::jmc_auto::common::PointENU* temp = position_;
  position_ = NULL;
  return temp;
}
inline void LocalizationFeature::set_allocated_position(::jmc_auto::common::PointENU* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LocalizationFeature.position)
}

// optional double heading = 3;
inline bool LocalizationFeature::has_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalizationFeature::set_has_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalizationFeature::clear_has_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalizationFeature::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double LocalizationFeature::heading() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LocalizationFeature.heading)
  return heading_;
}
inline void LocalizationFeature::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.LocalizationFeature.heading)
}

// optional .jmc_auto.common.Point3D linear_velocity = 4;
inline bool LocalizationFeature::has_linear_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalizationFeature::set_has_linear_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalizationFeature::clear_has_linear_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalizationFeature::clear_linear_velocity() {
  if (linear_velocity_ != NULL) linear_velocity_->::jmc_auto::common::Point3D::Clear();
  clear_has_linear_velocity();
}
inline const ::jmc_auto::common::Point3D& LocalizationFeature::linear_velocity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LocalizationFeature.linear_velocity)
  return linear_velocity_ != NULL ? *linear_velocity_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* LocalizationFeature::mutable_linear_velocity() {
  set_has_linear_velocity();
  if (linear_velocity_ == NULL) {
    linear_velocity_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LocalizationFeature.linear_velocity)
  return linear_velocity_;
}
inline ::jmc_auto::common::Point3D* LocalizationFeature::release_linear_velocity() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LocalizationFeature.linear_velocity)
  clear_has_linear_velocity();
  ::jmc_auto::common::Point3D* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline void LocalizationFeature::set_allocated_linear_velocity(::jmc_auto::common::Point3D* linear_velocity) {
  delete linear_velocity_;
  linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    set_has_linear_velocity();
  } else {
    clear_has_linear_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LocalizationFeature.linear_velocity)
}

// optional .jmc_auto.common.Point3D linear_acceleration = 5;
inline bool LocalizationFeature::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationFeature::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationFeature::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalizationFeature::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->::jmc_auto::common::Point3D::Clear();
  clear_has_linear_acceleration();
}
inline const ::jmc_auto::common::Point3D& LocalizationFeature::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LocalizationFeature.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* LocalizationFeature::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LocalizationFeature.linear_acceleration)
  return linear_acceleration_;
}
inline ::jmc_auto::common::Point3D* LocalizationFeature::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LocalizationFeature.linear_acceleration)
  clear_has_linear_acceleration();
  ::jmc_auto::common::Point3D* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void LocalizationFeature::set_allocated_linear_acceleration(::jmc_auto::common::Point3D* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LocalizationFeature.linear_acceleration)
}

// optional .jmc_auto.common.Point3D angular_velocity = 6;
inline bool LocalizationFeature::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationFeature::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationFeature::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalizationFeature::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::jmc_auto::common::Point3D::Clear();
  clear_has_angular_velocity();
}
inline const ::jmc_auto::common::Point3D& LocalizationFeature::angular_velocity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LocalizationFeature.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* LocalizationFeature::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LocalizationFeature.angular_velocity)
  return angular_velocity_;
}
inline ::jmc_auto::common::Point3D* LocalizationFeature::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LocalizationFeature.angular_velocity)
  clear_has_angular_velocity();
  ::jmc_auto::common::Point3D* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void LocalizationFeature::set_allocated_angular_velocity(::jmc_auto::common::Point3D* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LocalizationFeature.angular_velocity)
}

// -------------------------------------------------------------------

// PathPointFeature

// optional double x = 1;
inline bool PathPointFeature::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathPointFeature::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathPointFeature::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathPointFeature::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double PathPointFeature::x() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathPointFeature.x)
  return x_;
}
inline void PathPointFeature::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathPointFeature.x)
}

// optional double y = 2;
inline bool PathPointFeature::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathPointFeature::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathPointFeature::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathPointFeature::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double PathPointFeature::y() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathPointFeature.y)
  return y_;
}
inline void PathPointFeature::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathPointFeature.y)
}

// optional double z = 3;
inline bool PathPointFeature::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PathPointFeature::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PathPointFeature::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PathPointFeature::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double PathPointFeature::z() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathPointFeature.z)
  return z_;
}
inline void PathPointFeature::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathPointFeature.z)
}

// optional double theta = 4;
inline bool PathPointFeature::has_theta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PathPointFeature::set_has_theta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PathPointFeature::clear_has_theta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PathPointFeature::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double PathPointFeature::theta() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathPointFeature.theta)
  return theta_;
}
inline void PathPointFeature::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathPointFeature.theta)
}

// optional double s = 5;
inline bool PathPointFeature::has_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PathPointFeature::set_has_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PathPointFeature::clear_has_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PathPointFeature::clear_s() {
  s_ = 0;
  clear_has_s();
}
inline double PathPointFeature::s() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathPointFeature.s)
  return s_;
}
inline void PathPointFeature::set_s(double value) {
  set_has_s();
  s_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathPointFeature.s)
}

// optional string lane_id = 6;
inline bool PathPointFeature::has_lane_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathPointFeature::set_has_lane_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathPointFeature::clear_has_lane_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathPointFeature::clear_lane_id() {
  lane_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lane_id();
}
inline const ::std::string& PathPointFeature::lane_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PathPointFeature.lane_id)
  return lane_id_.GetNoArena();
}
inline void PathPointFeature::set_lane_id(const ::std::string& value) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PathPointFeature.lane_id)
}
#if LANG_CXX11
inline void PathPointFeature::set_lane_id(::std::string&& value) {
  set_has_lane_id();
  lane_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.PathPointFeature.lane_id)
}
#endif
inline void PathPointFeature::set_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.PathPointFeature.lane_id)
}
inline void PathPointFeature::set_lane_id(const char* value, size_t size) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.PathPointFeature.lane_id)
}
inline ::std::string* PathPointFeature::mutable_lane_id() {
  set_has_lane_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PathPointFeature.lane_id)
  return lane_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PathPointFeature::release_lane_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PathPointFeature.lane_id)
  clear_has_lane_id();
  return lane_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PathPointFeature::set_allocated_lane_id(::std::string* lane_id) {
  if (lane_id != NULL) {
    set_has_lane_id();
  } else {
    clear_has_lane_id();
  }
  lane_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lane_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PathPointFeature.lane_id)
}

// -------------------------------------------------------------------

// TrajectoryPointFeature

// optional .jmc_auto.planning.PathPointFeature path_point = 1;
inline bool TrajectoryPointFeature::has_path_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrajectoryPointFeature::set_has_path_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrajectoryPointFeature::clear_has_path_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrajectoryPointFeature::clear_path_point() {
  if (path_point_ != NULL) path_point_->::jmc_auto::planning::PathPointFeature::Clear();
  clear_has_path_point();
}
inline const ::jmc_auto::planning::PathPointFeature& TrajectoryPointFeature::path_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPointFeature.path_point)
  return path_point_ != NULL ? *path_point_
                         : *::jmc_auto::planning::PathPointFeature::internal_default_instance();
}
inline ::jmc_auto::planning::PathPointFeature* TrajectoryPointFeature::mutable_path_point() {
  set_has_path_point();
  if (path_point_ == NULL) {
    path_point_ = new ::jmc_auto::planning::PathPointFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrajectoryPointFeature.path_point)
  return path_point_;
}
inline ::jmc_auto::planning::PathPointFeature* TrajectoryPointFeature::release_path_point() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrajectoryPointFeature.path_point)
  clear_has_path_point();
  ::jmc_auto::planning::PathPointFeature* temp = path_point_;
  path_point_ = NULL;
  return temp;
}
inline void TrajectoryPointFeature::set_allocated_path_point(::jmc_auto::planning::PathPointFeature* path_point) {
  delete path_point_;
  path_point_ = path_point;
  if (path_point) {
    set_has_path_point();
  } else {
    clear_has_path_point();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrajectoryPointFeature.path_point)
}

// optional double v = 2;
inline bool TrajectoryPointFeature::has_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrajectoryPointFeature::set_has_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrajectoryPointFeature::clear_has_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrajectoryPointFeature::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double TrajectoryPointFeature::v() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPointFeature.v)
  return v_;
}
inline void TrajectoryPointFeature::set_v(double value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrajectoryPointFeature.v)
}

// optional double a = 3;
inline bool TrajectoryPointFeature::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrajectoryPointFeature::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrajectoryPointFeature::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrajectoryPointFeature::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double TrajectoryPointFeature::a() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPointFeature.a)
  return a_;
}
inline void TrajectoryPointFeature::set_a(double value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrajectoryPointFeature.a)
}

// optional double relative_time = 4;
inline bool TrajectoryPointFeature::has_relative_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrajectoryPointFeature::set_has_relative_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrajectoryPointFeature::clear_has_relative_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrajectoryPointFeature::clear_relative_time() {
  relative_time_ = 0;
  clear_has_relative_time();
}
inline double TrajectoryPointFeature::relative_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPointFeature.relative_time)
  return relative_time_;
}
inline void TrajectoryPointFeature::set_relative_time(double value) {
  set_has_relative_time();
  relative_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrajectoryPointFeature.relative_time)
}

// optional .jmc_auto.common.GaussianInfo gaussian_info = 5;
inline bool TrajectoryPointFeature::has_gaussian_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrajectoryPointFeature::set_has_gaussian_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrajectoryPointFeature::clear_has_gaussian_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrajectoryPointFeature::clear_gaussian_info() {
  if (gaussian_info_ != NULL) gaussian_info_->::jmc_auto::common::GaussianInfo::Clear();
  clear_has_gaussian_info();
}
inline const ::jmc_auto::common::GaussianInfo& TrajectoryPointFeature::gaussian_info() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPointFeature.gaussian_info)
  return gaussian_info_ != NULL ? *gaussian_info_
                         : *::jmc_auto::common::GaussianInfo::internal_default_instance();
}
inline ::jmc_auto::common::GaussianInfo* TrajectoryPointFeature::mutable_gaussian_info() {
  set_has_gaussian_info();
  if (gaussian_info_ == NULL) {
    gaussian_info_ = new ::jmc_auto::common::GaussianInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrajectoryPointFeature.gaussian_info)
  return gaussian_info_;
}
inline ::jmc_auto::common::GaussianInfo* TrajectoryPointFeature::release_gaussian_info() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrajectoryPointFeature.gaussian_info)
  clear_has_gaussian_info();
  ::jmc_auto::common::GaussianInfo* temp = gaussian_info_;
  gaussian_info_ = NULL;
  return temp;
}
inline void TrajectoryPointFeature::set_allocated_gaussian_info(::jmc_auto::common::GaussianInfo* gaussian_info) {
  delete gaussian_info_;
  gaussian_info_ = gaussian_info;
  if (gaussian_info) {
    set_has_gaussian_info();
  } else {
    clear_has_gaussian_info();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrajectoryPointFeature.gaussian_info)
}

// -------------------------------------------------------------------

// TrajectoryPoint

// optional double timestamp_sec = 1;
inline bool TrajectoryPoint::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrajectoryPoint::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrajectoryPoint::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrajectoryPoint::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double TrajectoryPoint::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPoint.timestamp_sec)
  return timestamp_sec_;
}
inline void TrajectoryPoint::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrajectoryPoint.timestamp_sec)
}

// optional .jmc_auto.planning.TrajectoryPointFeature trajectory_point = 2;
inline bool TrajectoryPoint::has_trajectory_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrajectoryPoint::set_has_trajectory_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrajectoryPoint::clear_has_trajectory_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrajectoryPoint::clear_trajectory_point() {
  if (trajectory_point_ != NULL) trajectory_point_->::jmc_auto::planning::TrajectoryPointFeature::Clear();
  clear_has_trajectory_point();
}
inline const ::jmc_auto::planning::TrajectoryPointFeature& TrajectoryPoint::trajectory_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrajectoryPoint.trajectory_point)
  return trajectory_point_ != NULL ? *trajectory_point_
                         : *::jmc_auto::planning::TrajectoryPointFeature::internal_default_instance();
}
inline ::jmc_auto::planning::TrajectoryPointFeature* TrajectoryPoint::mutable_trajectory_point() {
  set_has_trajectory_point();
  if (trajectory_point_ == NULL) {
    trajectory_point_ = new ::jmc_auto::planning::TrajectoryPointFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrajectoryPoint.trajectory_point)
  return trajectory_point_;
}
inline ::jmc_auto::planning::TrajectoryPointFeature* TrajectoryPoint::release_trajectory_point() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrajectoryPoint.trajectory_point)
  clear_has_trajectory_point();
  ::jmc_auto::planning::TrajectoryPointFeature* temp = trajectory_point_;
  trajectory_point_ = NULL;
  return temp;
}
inline void TrajectoryPoint::set_allocated_trajectory_point(::jmc_auto::planning::TrajectoryPointFeature* trajectory_point) {
  delete trajectory_point_;
  trajectory_point_ = trajectory_point;
  if (trajectory_point) {
    set_has_trajectory_point();
  } else {
    clear_has_trajectory_point();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrajectoryPoint.trajectory_point)
}

// -------------------------------------------------------------------

// PerceptionObstacleFeature

// optional double timestamp_sec = 1;
inline bool PerceptionObstacleFeature::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerceptionObstacleFeature::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerceptionObstacleFeature::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerceptionObstacleFeature::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double PerceptionObstacleFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PerceptionObstacleFeature.timestamp_sec)
  return timestamp_sec_;
}
inline void PerceptionObstacleFeature::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PerceptionObstacleFeature.timestamp_sec)
}

// optional .jmc_auto.common.Point3D position = 2;
inline bool PerceptionObstacleFeature::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceptionObstacleFeature::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerceptionObstacleFeature::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerceptionObstacleFeature::clear_position() {
  if (position_ != NULL) position_->::jmc_auto::common::Point3D::Clear();
  clear_has_position();
}
inline const ::jmc_auto::common::Point3D& PerceptionObstacleFeature::position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PerceptionObstacleFeature.position)
  return position_ != NULL ? *position_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PerceptionObstacleFeature.position)
  return position_;
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::release_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PerceptionObstacleFeature.position)
  clear_has_position();
  ::jmc_auto::common::Point3D* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PerceptionObstacleFeature::set_allocated_position(::jmc_auto::common::Point3D* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PerceptionObstacleFeature.position)
}

// optional double theta = 3;
inline bool PerceptionObstacleFeature::has_theta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerceptionObstacleFeature::set_has_theta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerceptionObstacleFeature::clear_has_theta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerceptionObstacleFeature::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double PerceptionObstacleFeature::theta() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PerceptionObstacleFeature.theta)
  return theta_;
}
inline void PerceptionObstacleFeature::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PerceptionObstacleFeature.theta)
}

// optional .jmc_auto.common.Point3D velocity = 4;
inline bool PerceptionObstacleFeature::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerceptionObstacleFeature::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerceptionObstacleFeature::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerceptionObstacleFeature::clear_velocity() {
  if (velocity_ != NULL) velocity_->::jmc_auto::common::Point3D::Clear();
  clear_has_velocity();
}
inline const ::jmc_auto::common::Point3D& PerceptionObstacleFeature::velocity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PerceptionObstacleFeature.velocity)
  return velocity_ != NULL ? *velocity_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PerceptionObstacleFeature.velocity)
  return velocity_;
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::release_velocity() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PerceptionObstacleFeature.velocity)
  clear_has_velocity();
  ::jmc_auto::common::Point3D* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void PerceptionObstacleFeature::set_allocated_velocity(::jmc_auto::common::Point3D* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PerceptionObstacleFeature.velocity)
}

// optional .jmc_auto.common.Point3D acceleration = 5;
inline bool PerceptionObstacleFeature::has_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerceptionObstacleFeature::set_has_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerceptionObstacleFeature::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerceptionObstacleFeature::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::jmc_auto::common::Point3D::Clear();
  clear_has_acceleration();
}
inline const ::jmc_auto::common::Point3D& PerceptionObstacleFeature::acceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PerceptionObstacleFeature.acceleration)
  return acceleration_ != NULL ? *acceleration_
                         : *::jmc_auto::common::Point3D::internal_default_instance();
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    acceleration_ = new ::jmc_auto::common::Point3D;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PerceptionObstacleFeature.acceleration)
  return acceleration_;
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::release_acceleration() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PerceptionObstacleFeature.acceleration)
  clear_has_acceleration();
  ::jmc_auto::common::Point3D* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void PerceptionObstacleFeature::set_allocated_acceleration(::jmc_auto::common::Point3D* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PerceptionObstacleFeature.acceleration)
}

// repeated .jmc_auto.common.Point3D polygon_point = 6;
inline int PerceptionObstacleFeature::polygon_point_size() const {
  return polygon_point_.size();
}
inline void PerceptionObstacleFeature::clear_polygon_point() {
  polygon_point_.Clear();
}
inline const ::jmc_auto::common::Point3D& PerceptionObstacleFeature::polygon_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_.Get(index);
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::mutable_polygon_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_.Mutable(index);
}
inline ::jmc_auto::common::Point3D* PerceptionObstacleFeature::add_polygon_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Point3D >*
PerceptionObstacleFeature::mutable_polygon_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PerceptionObstacleFeature.polygon_point)
  return &polygon_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::common::Point3D >&
PerceptionObstacleFeature::polygon_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_;
}

// -------------------------------------------------------------------

// ObstacleTrajectoryFeature

// repeated .jmc_auto.planning.PerceptionObstacleFeature perception_obstacle_history = 1;
inline int ObstacleTrajectoryFeature::perception_obstacle_history_size() const {
  return perception_obstacle_history_.size();
}
inline void ObstacleTrajectoryFeature::clear_perception_obstacle_history() {
  perception_obstacle_history_.Clear();
}
inline const ::jmc_auto::planning::PerceptionObstacleFeature& ObstacleTrajectoryFeature::perception_obstacle_history(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_.Get(index);
}
inline ::jmc_auto::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::mutable_perception_obstacle_history(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_.Mutable(index);
}
inline ::jmc_auto::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::add_perception_obstacle_history() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PerceptionObstacleFeature >*
ObstacleTrajectoryFeature::mutable_perception_obstacle_history() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return &perception_obstacle_history_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PerceptionObstacleFeature >&
ObstacleTrajectoryFeature::perception_obstacle_history() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_;
}

// repeated .jmc_auto.planning.TrajectoryPoint evaluated_trajectory_point = 2;
inline int ObstacleTrajectoryFeature::evaluated_trajectory_point_size() const {
  return evaluated_trajectory_point_.size();
}
inline void ObstacleTrajectoryFeature::clear_evaluated_trajectory_point() {
  evaluated_trajectory_point_.Clear();
}
inline const ::jmc_auto::planning::TrajectoryPoint& ObstacleTrajectoryFeature::evaluated_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_.Get(index);
}
inline ::jmc_auto::planning::TrajectoryPoint* ObstacleTrajectoryFeature::mutable_evaluated_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_.Mutable(index);
}
inline ::jmc_auto::planning::TrajectoryPoint* ObstacleTrajectoryFeature::add_evaluated_trajectory_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >*
ObstacleTrajectoryFeature::mutable_evaluated_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return &evaluated_trajectory_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >&
ObstacleTrajectoryFeature::evaluated_trajectory_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_;
}

// -------------------------------------------------------------------

// PredictionTrajectoryFeature

// optional double probability = 1;
inline bool PredictionTrajectoryFeature::has_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredictionTrajectoryFeature::set_has_probability() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredictionTrajectoryFeature::clear_has_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredictionTrajectoryFeature::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline double PredictionTrajectoryFeature::probability() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionTrajectoryFeature.probability)
  return probability_;
}
inline void PredictionTrajectoryFeature::set_probability(double value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PredictionTrajectoryFeature.probability)
}

// repeated .jmc_auto.planning.TrajectoryPoint trajectory_point = 2;
inline int PredictionTrajectoryFeature::trajectory_point_size() const {
  return trajectory_point_.size();
}
inline void PredictionTrajectoryFeature::clear_trajectory_point() {
  trajectory_point_.Clear();
}
inline const ::jmc_auto::planning::TrajectoryPoint& PredictionTrajectoryFeature::trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_.Get(index);
}
inline ::jmc_auto::planning::TrajectoryPoint* PredictionTrajectoryFeature::mutable_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_.Mutable(index);
}
inline ::jmc_auto::planning::TrajectoryPoint* PredictionTrajectoryFeature::add_trajectory_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >*
PredictionTrajectoryFeature::mutable_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PredictionTrajectoryFeature.trajectory_point)
  return &trajectory_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrajectoryPoint >&
PredictionTrajectoryFeature::trajectory_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_;
}

// -------------------------------------------------------------------

// PredictionObstacleFeature

// optional double timestamp_sec = 1;
inline bool PredictionObstacleFeature::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredictionObstacleFeature::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredictionObstacleFeature::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredictionObstacleFeature::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double PredictionObstacleFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionObstacleFeature.timestamp_sec)
  return timestamp_sec_;
}
inline void PredictionObstacleFeature::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PredictionObstacleFeature.timestamp_sec)
}

// optional double predicted_period = 2;
inline bool PredictionObstacleFeature::has_predicted_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredictionObstacleFeature::set_has_predicted_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredictionObstacleFeature::clear_has_predicted_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredictionObstacleFeature::clear_predicted_period() {
  predicted_period_ = 0;
  clear_has_predicted_period();
}
inline double PredictionObstacleFeature::predicted_period() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionObstacleFeature.predicted_period)
  return predicted_period_;
}
inline void PredictionObstacleFeature::set_predicted_period(double value) {
  set_has_predicted_period();
  predicted_period_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PredictionObstacleFeature.predicted_period)
}

// optional .jmc_auto.prediction.ObstacleIntent intent = 3;
inline bool PredictionObstacleFeature::has_intent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredictionObstacleFeature::set_has_intent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredictionObstacleFeature::clear_has_intent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredictionObstacleFeature::clear_intent() {
  if (intent_ != NULL) intent_->::jmc_auto::prediction::ObstacleIntent::Clear();
  clear_has_intent();
}
inline const ::jmc_auto::prediction::ObstacleIntent& PredictionObstacleFeature::intent() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionObstacleFeature.intent)
  return intent_ != NULL ? *intent_
                         : *::jmc_auto::prediction::ObstacleIntent::internal_default_instance();
}
inline ::jmc_auto::prediction::ObstacleIntent* PredictionObstacleFeature::mutable_intent() {
  set_has_intent();
  if (intent_ == NULL) {
    intent_ = new ::jmc_auto::prediction::ObstacleIntent;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PredictionObstacleFeature.intent)
  return intent_;
}
inline ::jmc_auto::prediction::ObstacleIntent* PredictionObstacleFeature::release_intent() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PredictionObstacleFeature.intent)
  clear_has_intent();
  ::jmc_auto::prediction::ObstacleIntent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline void PredictionObstacleFeature::set_allocated_intent(::jmc_auto::prediction::ObstacleIntent* intent) {
  delete intent_;
  intent_ = intent;
  if (intent) {
    set_has_intent();
  } else {
    clear_has_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PredictionObstacleFeature.intent)
}

// optional .jmc_auto.prediction.ObstaclePriority priority = 4;
inline bool PredictionObstacleFeature::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredictionObstacleFeature::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredictionObstacleFeature::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PredictionObstacleFeature::clear_priority() {
  if (priority_ != NULL) priority_->::jmc_auto::prediction::ObstaclePriority::Clear();
  clear_has_priority();
}
inline const ::jmc_auto::prediction::ObstaclePriority& PredictionObstacleFeature::priority() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionObstacleFeature.priority)
  return priority_ != NULL ? *priority_
                         : *::jmc_auto::prediction::ObstaclePriority::internal_default_instance();
}
inline ::jmc_auto::prediction::ObstaclePriority* PredictionObstacleFeature::mutable_priority() {
  set_has_priority();
  if (priority_ == NULL) {
    priority_ = new ::jmc_auto::prediction::ObstaclePriority;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PredictionObstacleFeature.priority)
  return priority_;
}
inline ::jmc_auto::prediction::ObstaclePriority* PredictionObstacleFeature::release_priority() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PredictionObstacleFeature.priority)
  clear_has_priority();
  ::jmc_auto::prediction::ObstaclePriority* temp = priority_;
  priority_ = NULL;
  return temp;
}
inline void PredictionObstacleFeature::set_allocated_priority(::jmc_auto::prediction::ObstaclePriority* priority) {
  delete priority_;
  priority_ = priority;
  if (priority) {
    set_has_priority();
  } else {
    clear_has_priority();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PredictionObstacleFeature.priority)
}

// optional bool is_static = 5 [default = false];
inline bool PredictionObstacleFeature::has_is_static() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PredictionObstacleFeature::set_has_is_static() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PredictionObstacleFeature::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PredictionObstacleFeature::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
inline bool PredictionObstacleFeature::is_static() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionObstacleFeature.is_static)
  return is_static_;
}
inline void PredictionObstacleFeature::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PredictionObstacleFeature.is_static)
}

// repeated .jmc_auto.planning.PredictionTrajectoryFeature trajectory = 6;
inline int PredictionObstacleFeature::trajectory_size() const {
  return trajectory_.size();
}
inline void PredictionObstacleFeature::clear_trajectory() {
  trajectory_.Clear();
}
inline const ::jmc_auto::planning::PredictionTrajectoryFeature& PredictionObstacleFeature::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PredictionObstacleFeature.trajectory)
  return trajectory_.Get(index);
}
inline ::jmc_auto::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PredictionObstacleFeature.trajectory)
  return trajectory_.Mutable(index);
}
inline ::jmc_auto::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::add_trajectory() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PredictionObstacleFeature.trajectory)
  return trajectory_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PredictionTrajectoryFeature >*
PredictionObstacleFeature::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PredictionObstacleFeature.trajectory)
  return &trajectory_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::PredictionTrajectoryFeature >&
PredictionObstacleFeature::trajectory() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PredictionObstacleFeature.trajectory)
  return trajectory_;
}

// -------------------------------------------------------------------

// ObstacleFeature

// optional int32 id = 1;
inline bool ObstacleFeature::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObstacleFeature::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObstacleFeature::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObstacleFeature::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ObstacleFeature::id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.id)
  return id_;
}
inline void ObstacleFeature::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ObstacleFeature.id)
}

// optional double length = 2;
inline bool ObstacleFeature::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleFeature::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleFeature::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleFeature::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double ObstacleFeature::length() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.length)
  return length_;
}
inline void ObstacleFeature::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ObstacleFeature.length)
}

// optional double width = 3;
inline bool ObstacleFeature::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObstacleFeature::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObstacleFeature::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObstacleFeature::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double ObstacleFeature::width() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.width)
  return width_;
}
inline void ObstacleFeature::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ObstacleFeature.width)
}

// optional double height = 4;
inline bool ObstacleFeature::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObstacleFeature::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObstacleFeature::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObstacleFeature::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double ObstacleFeature::height() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.height)
  return height_;
}
inline void ObstacleFeature::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ObstacleFeature.height)
}

// optional .jmc_auto.perception.PerceptionObstacle.Type type = 5;
inline bool ObstacleFeature::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObstacleFeature::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObstacleFeature::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObstacleFeature::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::jmc_auto::perception::PerceptionObstacle_Type ObstacleFeature::type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.type)
  return static_cast< ::jmc_auto::perception::PerceptionObstacle_Type >(type_);
}
inline void ObstacleFeature::set_type(::jmc_auto::perception::PerceptionObstacle_Type value) {
  assert(::jmc_auto::perception::PerceptionObstacle_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ObstacleFeature.type)
}

// optional .jmc_auto.planning.ObstacleTrajectoryFeature obstacle_trajectory = 6;
inline bool ObstacleFeature::has_obstacle_trajectory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleFeature::set_has_obstacle_trajectory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleFeature::clear_has_obstacle_trajectory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleFeature::clear_obstacle_trajectory() {
  if (obstacle_trajectory_ != NULL) obstacle_trajectory_->::jmc_auto::planning::ObstacleTrajectoryFeature::Clear();
  clear_has_obstacle_trajectory();
}
inline const ::jmc_auto::planning::ObstacleTrajectoryFeature& ObstacleFeature::obstacle_trajectory() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.obstacle_trajectory)
  return obstacle_trajectory_ != NULL ? *obstacle_trajectory_
                         : *::jmc_auto::planning::ObstacleTrajectoryFeature::internal_default_instance();
}
inline ::jmc_auto::planning::ObstacleTrajectoryFeature* ObstacleFeature::mutable_obstacle_trajectory() {
  set_has_obstacle_trajectory();
  if (obstacle_trajectory_ == NULL) {
    obstacle_trajectory_ = new ::jmc_auto::planning::ObstacleTrajectoryFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ObstacleFeature.obstacle_trajectory)
  return obstacle_trajectory_;
}
inline ::jmc_auto::planning::ObstacleTrajectoryFeature* ObstacleFeature::release_obstacle_trajectory() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ObstacleFeature.obstacle_trajectory)
  clear_has_obstacle_trajectory();
  ::jmc_auto::planning::ObstacleTrajectoryFeature* temp = obstacle_trajectory_;
  obstacle_trajectory_ = NULL;
  return temp;
}
inline void ObstacleFeature::set_allocated_obstacle_trajectory(::jmc_auto::planning::ObstacleTrajectoryFeature* obstacle_trajectory) {
  delete obstacle_trajectory_;
  obstacle_trajectory_ = obstacle_trajectory;
  if (obstacle_trajectory) {
    set_has_obstacle_trajectory();
  } else {
    clear_has_obstacle_trajectory();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ObstacleFeature.obstacle_trajectory)
}

// optional .jmc_auto.planning.PredictionObstacleFeature obstacle_prediction = 7;
inline bool ObstacleFeature::has_obstacle_prediction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObstacleFeature::set_has_obstacle_prediction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObstacleFeature::clear_has_obstacle_prediction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObstacleFeature::clear_obstacle_prediction() {
  if (obstacle_prediction_ != NULL) obstacle_prediction_->::jmc_auto::planning::PredictionObstacleFeature::Clear();
  clear_has_obstacle_prediction();
}
inline const ::jmc_auto::planning::PredictionObstacleFeature& ObstacleFeature::obstacle_prediction() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ObstacleFeature.obstacle_prediction)
  return obstacle_prediction_ != NULL ? *obstacle_prediction_
                         : *::jmc_auto::planning::PredictionObstacleFeature::internal_default_instance();
}
inline ::jmc_auto::planning::PredictionObstacleFeature* ObstacleFeature::mutable_obstacle_prediction() {
  set_has_obstacle_prediction();
  if (obstacle_prediction_ == NULL) {
    obstacle_prediction_ = new ::jmc_auto::planning::PredictionObstacleFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ObstacleFeature.obstacle_prediction)
  return obstacle_prediction_;
}
inline ::jmc_auto::planning::PredictionObstacleFeature* ObstacleFeature::release_obstacle_prediction() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ObstacleFeature.obstacle_prediction)
  clear_has_obstacle_prediction();
  ::jmc_auto::planning::PredictionObstacleFeature* temp = obstacle_prediction_;
  obstacle_prediction_ = NULL;
  return temp;
}
inline void ObstacleFeature::set_allocated_obstacle_prediction(::jmc_auto::planning::PredictionObstacleFeature* obstacle_prediction) {
  delete obstacle_prediction_;
  obstacle_prediction_ = obstacle_prediction;
  if (obstacle_prediction) {
    set_has_obstacle_prediction();
  } else {
    clear_has_obstacle_prediction();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ObstacleFeature.obstacle_prediction)
}

// -------------------------------------------------------------------

// RoutingFeature

// repeated string routing_lane_id = 1;
inline int RoutingFeature::routing_lane_id_size() const {
  return routing_lane_id_.size();
}
inline void RoutingFeature::clear_routing_lane_id() {
  routing_lane_id_.Clear();
}
inline const ::std::string& RoutingFeature::routing_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.RoutingFeature.routing_lane_id)
  return routing_lane_id_.Get(index);
}
inline ::std::string* RoutingFeature::mutable_routing_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.RoutingFeature.routing_lane_id)
  return routing_lane_id_.Mutable(index);
}
inline void RoutingFeature::set_routing_lane_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.RoutingFeature.routing_lane_id)
  routing_lane_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoutingFeature::set_routing_lane_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.RoutingFeature.routing_lane_id)
  routing_lane_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoutingFeature::set_routing_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  routing_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.RoutingFeature.routing_lane_id)
}
inline void RoutingFeature::set_routing_lane_id(int index, const char* value, size_t size) {
  routing_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.RoutingFeature.routing_lane_id)
}
inline ::std::string* RoutingFeature::add_routing_lane_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.RoutingFeature.routing_lane_id)
  return routing_lane_id_.Add();
}
inline void RoutingFeature::add_routing_lane_id(const ::std::string& value) {
  routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.RoutingFeature.routing_lane_id)
}
#if LANG_CXX11
inline void RoutingFeature::add_routing_lane_id(::std::string&& value) {
  routing_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.RoutingFeature.routing_lane_id)
}
#endif
inline void RoutingFeature::add_routing_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.RoutingFeature.routing_lane_id)
}
inline void RoutingFeature::add_routing_lane_id(const char* value, size_t size) {
  routing_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.RoutingFeature.routing_lane_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoutingFeature::routing_lane_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.RoutingFeature.routing_lane_id)
  return routing_lane_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoutingFeature::mutable_routing_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.RoutingFeature.routing_lane_id)
  return &routing_lane_id_;
}

// repeated string local_routing_lane_id = 2;
inline int RoutingFeature::local_routing_lane_id_size() const {
  return local_routing_lane_id_.size();
}
inline void RoutingFeature::clear_local_routing_lane_id() {
  local_routing_lane_id_.Clear();
}
inline const ::std::string& RoutingFeature::local_routing_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_.Get(index);
}
inline ::std::string* RoutingFeature::mutable_local_routing_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_.Mutable(index);
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  local_routing_lane_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoutingFeature::set_local_routing_lane_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  local_routing_lane_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoutingFeature::set_local_routing_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_routing_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const char* value, size_t size) {
  local_routing_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
}
inline ::std::string* RoutingFeature::add_local_routing_lane_id() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_.Add();
}
inline void RoutingFeature::add_local_routing_lane_id(const ::std::string& value) {
  local_routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
}
#if LANG_CXX11
inline void RoutingFeature::add_local_routing_lane_id(::std::string&& value) {
  local_routing_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
}
#endif
inline void RoutingFeature::add_local_routing_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::add_local_routing_lane_id(const char* value, size_t size) {
  local_routing_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoutingFeature::local_routing_lane_id() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoutingFeature::mutable_local_routing_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.RoutingFeature.local_routing_lane_id)
  return &local_routing_lane_id_;
}

// -------------------------------------------------------------------

// TrafficLightFeature

// optional .jmc_auto.perception.TrafficLight.Color color = 1;
inline bool TrafficLightFeature::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightFeature::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightFeature::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightFeature::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::jmc_auto::perception::TrafficLight_Color TrafficLightFeature::color() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightFeature.color)
  return static_cast< ::jmc_auto::perception::TrafficLight_Color >(color_);
}
inline void TrafficLightFeature::set_color(::jmc_auto::perception::TrafficLight_Color value) {
  assert(::jmc_auto::perception::TrafficLight_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightFeature.color)
}

// optional string id = 2;
inline bool TrafficLightFeature::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightFeature::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightFeature::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightFeature::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLightFeature::id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightFeature.id)
  return id_.GetNoArena();
}
inline void TrafficLightFeature::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightFeature.id)
}
#if LANG_CXX11
inline void TrafficLightFeature::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.TrafficLightFeature.id)
}
#endif
inline void TrafficLightFeature::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.TrafficLightFeature.id)
}
inline void TrafficLightFeature::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.TrafficLightFeature.id)
}
inline ::std::string* TrafficLightFeature::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficLightFeature.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightFeature::release_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TrafficLightFeature.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightFeature::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TrafficLightFeature.id)
}

// optional double confidence = 3 [default = 1];
inline bool TrafficLightFeature::has_confidence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficLightFeature::set_has_confidence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficLightFeature::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficLightFeature::clear_confidence() {
  confidence_ = 1;
  clear_has_confidence();
}
inline double TrafficLightFeature::confidence() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightFeature.confidence)
  return confidence_;
}
inline void TrafficLightFeature::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightFeature.confidence)
}

// optional double tracking_time = 4;
inline bool TrafficLightFeature::has_tracking_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightFeature::set_has_tracking_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightFeature::clear_has_tracking_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightFeature::clear_tracking_time() {
  tracking_time_ = 0;
  clear_has_tracking_time();
}
inline double TrafficLightFeature::tracking_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightFeature.tracking_time)
  return tracking_time_;
}
inline void TrafficLightFeature::set_tracking_time(double value) {
  set_has_tracking_time();
  tracking_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightFeature.tracking_time)
}

// optional bool blink = 5;
inline bool TrafficLightFeature::has_blink() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightFeature::set_has_blink() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightFeature::clear_has_blink() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightFeature::clear_blink() {
  blink_ = false;
  clear_has_blink();
}
inline bool TrafficLightFeature::blink() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightFeature.blink)
  return blink_;
}
inline void TrafficLightFeature::set_blink(bool value) {
  set_has_blink();
  blink_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightFeature.blink)
}

// optional double remaining_time = 6;
inline bool TrafficLightFeature::has_remaining_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightFeature::set_has_remaining_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightFeature::clear_has_remaining_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightFeature::clear_remaining_time() {
  remaining_time_ = 0;
  clear_has_remaining_time();
}
inline double TrafficLightFeature::remaining_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightFeature.remaining_time)
  return remaining_time_;
}
inline void TrafficLightFeature::set_remaining_time(double value) {
  set_has_remaining_time();
  remaining_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightFeature.remaining_time)
}

// -------------------------------------------------------------------

// TrafficLightDetectionFeature

// optional double message_timestamp_sec = 1;
inline bool TrafficLightDetectionFeature::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightDetectionFeature::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightDetectionFeature::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightDetectionFeature::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double TrafficLightDetectionFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightDetectionFeature.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void TrafficLightDetectionFeature::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TrafficLightDetectionFeature.message_timestamp_sec)
}

// repeated .jmc_auto.planning.TrafficLightFeature traffic_light = 2;
inline int TrafficLightDetectionFeature::traffic_light_size() const {
  return traffic_light_.size();
}
inline void TrafficLightDetectionFeature::clear_traffic_light() {
  traffic_light_.Clear();
}
inline const ::jmc_auto::planning::TrafficLightFeature& TrafficLightDetectionFeature::traffic_light(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_.Get(index);
}
inline ::jmc_auto::planning::TrafficLightFeature* TrafficLightDetectionFeature::mutable_traffic_light(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_.Mutable(index);
}
inline ::jmc_auto::planning::TrafficLightFeature* TrafficLightDetectionFeature::add_traffic_light() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficLightFeature >*
TrafficLightDetectionFeature::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.TrafficLightDetectionFeature.traffic_light)
  return &traffic_light_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TrafficLightFeature >&
TrafficLightDetectionFeature::traffic_light() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_;
}

// -------------------------------------------------------------------

// ADCTrajectoryPoint

// optional double timestamp_sec = 1;
inline bool ADCTrajectoryPoint::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ADCTrajectoryPoint::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ADCTrajectoryPoint::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ADCTrajectoryPoint::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double ADCTrajectoryPoint::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ADCTrajectoryPoint.timestamp_sec)
  return timestamp_sec_;
}
inline void ADCTrajectoryPoint::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ADCTrajectoryPoint.timestamp_sec)
}

// optional .jmc_auto.planning.PlanningTag planning_tag = 2;
inline bool ADCTrajectoryPoint::has_planning_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADCTrajectoryPoint::set_has_planning_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ADCTrajectoryPoint::clear_has_planning_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ADCTrajectoryPoint::clear_planning_tag() {
  if (planning_tag_ != NULL) planning_tag_->::jmc_auto::planning::PlanningTag::Clear();
  clear_has_planning_tag();
}
inline const ::jmc_auto::planning::PlanningTag& ADCTrajectoryPoint::planning_tag() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ADCTrajectoryPoint.planning_tag)
  return planning_tag_ != NULL ? *planning_tag_
                         : *::jmc_auto::planning::PlanningTag::internal_default_instance();
}
inline ::jmc_auto::planning::PlanningTag* ADCTrajectoryPoint::mutable_planning_tag() {
  set_has_planning_tag();
  if (planning_tag_ == NULL) {
    planning_tag_ = new ::jmc_auto::planning::PlanningTag;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ADCTrajectoryPoint.planning_tag)
  return planning_tag_;
}
inline ::jmc_auto::planning::PlanningTag* ADCTrajectoryPoint::release_planning_tag() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ADCTrajectoryPoint.planning_tag)
  clear_has_planning_tag();
  ::jmc_auto::planning::PlanningTag* temp = planning_tag_;
  planning_tag_ = NULL;
  return temp;
}
inline void ADCTrajectoryPoint::set_allocated_planning_tag(::jmc_auto::planning::PlanningTag* planning_tag) {
  delete planning_tag_;
  planning_tag_ = planning_tag;
  if (planning_tag) {
    set_has_planning_tag();
  } else {
    clear_has_planning_tag();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ADCTrajectoryPoint.planning_tag)
}

// optional .jmc_auto.planning.TrajectoryPointFeature trajectory_point = 3;
inline bool ADCTrajectoryPoint::has_trajectory_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ADCTrajectoryPoint::set_has_trajectory_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ADCTrajectoryPoint::clear_has_trajectory_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ADCTrajectoryPoint::clear_trajectory_point() {
  if (trajectory_point_ != NULL) trajectory_point_->::jmc_auto::planning::TrajectoryPointFeature::Clear();
  clear_has_trajectory_point();
}
inline const ::jmc_auto::planning::TrajectoryPointFeature& ADCTrajectoryPoint::trajectory_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ADCTrajectoryPoint.trajectory_point)
  return trajectory_point_ != NULL ? *trajectory_point_
                         : *::jmc_auto::planning::TrajectoryPointFeature::internal_default_instance();
}
inline ::jmc_auto::planning::TrajectoryPointFeature* ADCTrajectoryPoint::mutable_trajectory_point() {
  set_has_trajectory_point();
  if (trajectory_point_ == NULL) {
    trajectory_point_ = new ::jmc_auto::planning::TrajectoryPointFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ADCTrajectoryPoint.trajectory_point)
  return trajectory_point_;
}
inline ::jmc_auto::planning::TrajectoryPointFeature* ADCTrajectoryPoint::release_trajectory_point() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ADCTrajectoryPoint.trajectory_point)
  clear_has_trajectory_point();
  ::jmc_auto::planning::TrajectoryPointFeature* temp = trajectory_point_;
  trajectory_point_ = NULL;
  return temp;
}
inline void ADCTrajectoryPoint::set_allocated_trajectory_point(::jmc_auto::planning::TrajectoryPointFeature* trajectory_point) {
  delete trajectory_point_;
  trajectory_point_ = trajectory_point;
  if (trajectory_point) {
    set_has_trajectory_point();
  } else {
    clear_has_trajectory_point();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ADCTrajectoryPoint.trajectory_point)
}

// -------------------------------------------------------------------

// LearningOutput

// repeated .jmc_auto.planning.ADCTrajectoryPoint adc_future_trajectory_point = 1;
inline int LearningOutput::adc_future_trajectory_point_size() const {
  return adc_future_trajectory_point_.size();
}
inline void LearningOutput::clear_adc_future_trajectory_point() {
  adc_future_trajectory_point_.Clear();
}
inline const ::jmc_auto::planning::ADCTrajectoryPoint& LearningOutput::adc_future_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_.Get(index);
}
inline ::jmc_auto::planning::ADCTrajectoryPoint* LearningOutput::mutable_adc_future_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_.Mutable(index);
}
inline ::jmc_auto::planning::ADCTrajectoryPoint* LearningOutput::add_adc_future_trajectory_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >*
LearningOutput::mutable_adc_future_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.LearningOutput.adc_future_trajectory_point)
  return &adc_future_trajectory_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >&
LearningOutput::adc_future_trajectory_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_;
}

// -------------------------------------------------------------------

// LearningDataFrame

// optional double message_timestamp_sec = 1;
inline bool LearningDataFrame::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LearningDataFrame::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LearningDataFrame::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LearningDataFrame::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double LearningDataFrame::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void LearningDataFrame::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.LearningDataFrame.message_timestamp_sec)
}

// optional uint32 frame_num = 2;
inline bool LearningDataFrame::has_frame_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LearningDataFrame::set_has_frame_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LearningDataFrame::clear_has_frame_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LearningDataFrame::clear_frame_num() {
  frame_num_ = 0u;
  clear_has_frame_num();
}
inline ::google::protobuf::uint32 LearningDataFrame::frame_num() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.frame_num)
  return frame_num_;
}
inline void LearningDataFrame::set_frame_num(::google::protobuf::uint32 value) {
  set_has_frame_num();
  frame_num_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.LearningDataFrame.frame_num)
}

// optional string map_name = 3;
inline bool LearningDataFrame::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LearningDataFrame::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LearningDataFrame::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LearningDataFrame::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& LearningDataFrame::map_name() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.map_name)
  return map_name_.GetNoArena();
}
inline void LearningDataFrame::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.LearningDataFrame.map_name)
}
#if LANG_CXX11
inline void LearningDataFrame::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.LearningDataFrame.map_name)
}
#endif
inline void LearningDataFrame::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.LearningDataFrame.map_name)
}
inline void LearningDataFrame::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.LearningDataFrame.map_name)
}
inline ::std::string* LearningDataFrame::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LearningDataFrame::release_map_name() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.map_name)
  clear_has_map_name();
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LearningDataFrame::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.map_name)
}

// optional .jmc_auto.planning.PlanningTag planning_tag = 4;
inline bool LearningDataFrame::has_planning_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LearningDataFrame::set_has_planning_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LearningDataFrame::clear_has_planning_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LearningDataFrame::clear_planning_tag() {
  if (planning_tag_ != NULL) planning_tag_->::jmc_auto::planning::PlanningTag::Clear();
  clear_has_planning_tag();
}
inline const ::jmc_auto::planning::PlanningTag& LearningDataFrame::planning_tag() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.planning_tag)
  return planning_tag_ != NULL ? *planning_tag_
                         : *::jmc_auto::planning::PlanningTag::internal_default_instance();
}
inline ::jmc_auto::planning::PlanningTag* LearningDataFrame::mutable_planning_tag() {
  set_has_planning_tag();
  if (planning_tag_ == NULL) {
    planning_tag_ = new ::jmc_auto::planning::PlanningTag;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.planning_tag)
  return planning_tag_;
}
inline ::jmc_auto::planning::PlanningTag* LearningDataFrame::release_planning_tag() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.planning_tag)
  clear_has_planning_tag();
  ::jmc_auto::planning::PlanningTag* temp = planning_tag_;
  planning_tag_ = NULL;
  return temp;
}
inline void LearningDataFrame::set_allocated_planning_tag(::jmc_auto::planning::PlanningTag* planning_tag) {
  delete planning_tag_;
  planning_tag_ = planning_tag;
  if (planning_tag) {
    set_has_planning_tag();
  } else {
    clear_has_planning_tag();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.planning_tag)
}

// optional .jmc_auto.planning.ChassisFeature chassis = 5;
inline bool LearningDataFrame::has_chassis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LearningDataFrame::set_has_chassis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LearningDataFrame::clear_has_chassis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LearningDataFrame::clear_chassis() {
  if (chassis_ != NULL) chassis_->::jmc_auto::planning::ChassisFeature::Clear();
  clear_has_chassis();
}
inline const ::jmc_auto::planning::ChassisFeature& LearningDataFrame::chassis() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.chassis)
  return chassis_ != NULL ? *chassis_
                         : *::jmc_auto::planning::ChassisFeature::internal_default_instance();
}
inline ::jmc_auto::planning::ChassisFeature* LearningDataFrame::mutable_chassis() {
  set_has_chassis();
  if (chassis_ == NULL) {
    chassis_ = new ::jmc_auto::planning::ChassisFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.chassis)
  return chassis_;
}
inline ::jmc_auto::planning::ChassisFeature* LearningDataFrame::release_chassis() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.chassis)
  clear_has_chassis();
  ::jmc_auto::planning::ChassisFeature* temp = chassis_;
  chassis_ = NULL;
  return temp;
}
inline void LearningDataFrame::set_allocated_chassis(::jmc_auto::planning::ChassisFeature* chassis) {
  delete chassis_;
  chassis_ = chassis;
  if (chassis) {
    set_has_chassis();
  } else {
    clear_has_chassis();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.chassis)
}

// optional .jmc_auto.planning.LocalizationFeature localization = 6;
inline bool LearningDataFrame::has_localization() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LearningDataFrame::set_has_localization() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LearningDataFrame::clear_has_localization() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LearningDataFrame::clear_localization() {
  if (localization_ != NULL) localization_->::jmc_auto::planning::LocalizationFeature::Clear();
  clear_has_localization();
}
inline const ::jmc_auto::planning::LocalizationFeature& LearningDataFrame::localization() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.localization)
  return localization_ != NULL ? *localization_
                         : *::jmc_auto::planning::LocalizationFeature::internal_default_instance();
}
inline ::jmc_auto::planning::LocalizationFeature* LearningDataFrame::mutable_localization() {
  set_has_localization();
  if (localization_ == NULL) {
    localization_ = new ::jmc_auto::planning::LocalizationFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.localization)
  return localization_;
}
inline ::jmc_auto::planning::LocalizationFeature* LearningDataFrame::release_localization() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.localization)
  clear_has_localization();
  ::jmc_auto::planning::LocalizationFeature* temp = localization_;
  localization_ = NULL;
  return temp;
}
inline void LearningDataFrame::set_allocated_localization(::jmc_auto::planning::LocalizationFeature* localization) {
  delete localization_;
  localization_ = localization;
  if (localization) {
    set_has_localization();
  } else {
    clear_has_localization();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.localization)
}

// repeated .jmc_auto.planning.ObstacleFeature obstacle = 7;
inline int LearningDataFrame::obstacle_size() const {
  return obstacle_.size();
}
inline void LearningDataFrame::clear_obstacle() {
  obstacle_.Clear();
}
inline const ::jmc_auto::planning::ObstacleFeature& LearningDataFrame::obstacle(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.obstacle)
  return obstacle_.Get(index);
}
inline ::jmc_auto::planning::ObstacleFeature* LearningDataFrame::mutable_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.obstacle)
  return obstacle_.Mutable(index);
}
inline ::jmc_auto::planning::ObstacleFeature* LearningDataFrame::add_obstacle() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.LearningDataFrame.obstacle)
  return obstacle_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ObstacleFeature >*
LearningDataFrame::mutable_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.LearningDataFrame.obstacle)
  return &obstacle_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ObstacleFeature >&
LearningDataFrame::obstacle() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.LearningDataFrame.obstacle)
  return obstacle_;
}

// optional .jmc_auto.planning.RoutingFeature routing = 8;
inline bool LearningDataFrame::has_routing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LearningDataFrame::set_has_routing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LearningDataFrame::clear_has_routing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LearningDataFrame::clear_routing() {
  if (routing_ != NULL) routing_->::jmc_auto::planning::RoutingFeature::Clear();
  clear_has_routing();
}
inline const ::jmc_auto::planning::RoutingFeature& LearningDataFrame::routing() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.routing)
  return routing_ != NULL ? *routing_
                         : *::jmc_auto::planning::RoutingFeature::internal_default_instance();
}
inline ::jmc_auto::planning::RoutingFeature* LearningDataFrame::mutable_routing() {
  set_has_routing();
  if (routing_ == NULL) {
    routing_ = new ::jmc_auto::planning::RoutingFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.routing)
  return routing_;
}
inline ::jmc_auto::planning::RoutingFeature* LearningDataFrame::release_routing() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.routing)
  clear_has_routing();
  ::jmc_auto::planning::RoutingFeature* temp = routing_;
  routing_ = NULL;
  return temp;
}
inline void LearningDataFrame::set_allocated_routing(::jmc_auto::planning::RoutingFeature* routing) {
  delete routing_;
  routing_ = routing;
  if (routing) {
    set_has_routing();
  } else {
    clear_has_routing();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.routing)
}

// optional .jmc_auto.planning.TrafficLightDetectionFeature traffic_light_detection = 9;
inline bool LearningDataFrame::has_traffic_light_detection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LearningDataFrame::set_has_traffic_light_detection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LearningDataFrame::clear_has_traffic_light_detection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LearningDataFrame::clear_traffic_light_detection() {
  if (traffic_light_detection_ != NULL) traffic_light_detection_->::jmc_auto::planning::TrafficLightDetectionFeature::Clear();
  clear_has_traffic_light_detection();
}
inline const ::jmc_auto::planning::TrafficLightDetectionFeature& LearningDataFrame::traffic_light_detection() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.traffic_light_detection)
  return traffic_light_detection_ != NULL ? *traffic_light_detection_
                         : *::jmc_auto::planning::TrafficLightDetectionFeature::internal_default_instance();
}
inline ::jmc_auto::planning::TrafficLightDetectionFeature* LearningDataFrame::mutable_traffic_light_detection() {
  set_has_traffic_light_detection();
  if (traffic_light_detection_ == NULL) {
    traffic_light_detection_ = new ::jmc_auto::planning::TrafficLightDetectionFeature;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.traffic_light_detection)
  return traffic_light_detection_;
}
inline ::jmc_auto::planning::TrafficLightDetectionFeature* LearningDataFrame::release_traffic_light_detection() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.traffic_light_detection)
  clear_has_traffic_light_detection();
  ::jmc_auto::planning::TrafficLightDetectionFeature* temp = traffic_light_detection_;
  traffic_light_detection_ = NULL;
  return temp;
}
inline void LearningDataFrame::set_allocated_traffic_light_detection(::jmc_auto::planning::TrafficLightDetectionFeature* traffic_light_detection) {
  delete traffic_light_detection_;
  traffic_light_detection_ = traffic_light_detection;
  if (traffic_light_detection) {
    set_has_traffic_light_detection();
  } else {
    clear_has_traffic_light_detection();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.traffic_light_detection)
}

// repeated .jmc_auto.planning.ADCTrajectoryPoint adc_trajectory_point = 10;
inline int LearningDataFrame::adc_trajectory_point_size() const {
  return adc_trajectory_point_.size();
}
inline void LearningDataFrame::clear_adc_trajectory_point() {
  adc_trajectory_point_.Clear();
}
inline const ::jmc_auto::planning::ADCTrajectoryPoint& LearningDataFrame::adc_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_.Get(index);
}
inline ::jmc_auto::planning::ADCTrajectoryPoint* LearningDataFrame::mutable_adc_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_.Mutable(index);
}
inline ::jmc_auto::planning::ADCTrajectoryPoint* LearningDataFrame::add_adc_trajectory_point() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >*
LearningDataFrame::mutable_adc_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.LearningDataFrame.adc_trajectory_point)
  return &adc_trajectory_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ADCTrajectoryPoint >&
LearningDataFrame::adc_trajectory_point() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_;
}

// optional .jmc_auto.planning.LearningOutput output = 11;
inline bool LearningDataFrame::has_output() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LearningDataFrame::set_has_output() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LearningDataFrame::clear_has_output() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LearningDataFrame::clear_output() {
  if (output_ != NULL) output_->::jmc_auto::planning::LearningOutput::Clear();
  clear_has_output();
}
inline const ::jmc_auto::planning::LearningOutput& LearningDataFrame::output() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningDataFrame.output)
  return output_ != NULL ? *output_
                         : *::jmc_auto::planning::LearningOutput::internal_default_instance();
}
inline ::jmc_auto::planning::LearningOutput* LearningDataFrame::mutable_output() {
  set_has_output();
  if (output_ == NULL) {
    output_ = new ::jmc_auto::planning::LearningOutput;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningDataFrame.output)
  return output_;
}
inline ::jmc_auto::planning::LearningOutput* LearningDataFrame::release_output() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.LearningDataFrame.output)
  clear_has_output();
  ::jmc_auto::planning::LearningOutput* temp = output_;
  output_ = NULL;
  return temp;
}
inline void LearningDataFrame::set_allocated_output(::jmc_auto::planning::LearningOutput* output) {
  delete output_;
  output_ = output;
  if (output) {
    set_has_output();
  } else {
    clear_has_output();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.LearningDataFrame.output)
}

// -------------------------------------------------------------------

// LearningData

// repeated .jmc_auto.planning.LearningDataFrame learning_data = 1;
inline int LearningData::learning_data_size() const {
  return learning_data_.size();
}
inline void LearningData::clear_learning_data() {
  learning_data_.Clear();
}
inline const ::jmc_auto::planning::LearningDataFrame& LearningData::learning_data(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.LearningData.learning_data)
  return learning_data_.Get(index);
}
inline ::jmc_auto::planning::LearningDataFrame* LearningData::mutable_learning_data(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.LearningData.learning_data)
  return learning_data_.Mutable(index);
}
inline ::jmc_auto::planning::LearningDataFrame* LearningData::add_learning_data() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.LearningData.learning_data)
  return learning_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::LearningDataFrame >*
LearningData::mutable_learning_data() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.LearningData.learning_data)
  return &learning_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::LearningDataFrame >&
LearningData::learning_data() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.LearningData.learning_data)
  return learning_data_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace planning
}  // namespace jmc_auto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fplanning_2fproto_2flearning_5fdata_2eproto__INCLUDED
