// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_mode_config.proto

#ifndef PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto__INCLUDED
#define PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace planning {
class CallDrivingConfig;
class CallDrivingConfigDefaultTypeInternal;
extern CallDrivingConfigDefaultTypeInternal _CallDrivingConfig_default_instance_;
class FlowParkingConfig;
class FlowParkingConfigDefaultTypeInternal;
extern FlowParkingConfigDefaultTypeInternal _FlowParkingConfig_default_instance_;
class OwnParkingConfig;
class OwnParkingConfigDefaultTypeInternal;
extern OwnParkingConfigDefaultTypeInternal _OwnParkingConfig_default_instance_;
class ParkingConfig;
class ParkingConfigDefaultTypeInternal;
extern ParkingConfigDefaultTypeInternal _ParkingConfig_default_instance_;
class PlanningModeConfig;
class PlanningModeConfigDefaultTypeInternal;
extern PlanningModeConfigDefaultTypeInternal _PlanningModeConfig_default_instance_;
}  // namespace planning
namespace routing {
class LaneSegment;
class LaneSegmentDefaultTypeInternal;
extern LaneSegmentDefaultTypeInternal _LaneSegment_default_instance_;
class LaneWaypoint;
class LaneWaypointDefaultTypeInternal;
extern LaneWaypointDefaultTypeInternal _LaneWaypoint_default_instance_;
class Measurement;
class MeasurementDefaultTypeInternal;
extern MeasurementDefaultTypeInternal _Measurement_default_instance_;
class ParkingInfo;
class ParkingInfoDefaultTypeInternal;
extern ParkingInfoDefaultTypeInternal _ParkingInfo_default_instance_;
class Passage;
class PassageDefaultTypeInternal;
extern PassageDefaultTypeInternal _Passage_default_instance_;
class RoadSegment;
class RoadSegmentDefaultTypeInternal;
extern RoadSegmentDefaultTypeInternal _RoadSegment_default_instance_;
class RoutingRequest;
class RoutingRequestDefaultTypeInternal;
extern RoutingRequestDefaultTypeInternal _RoutingRequest_default_instance_;
class RoutingResponse;
class RoutingResponseDefaultTypeInternal;
extern RoutingResponseDefaultTypeInternal _RoutingResponse_default_instance_;
}  // namespace routing
}  // namespace jmc_auto

namespace jmc_auto {
namespace planning {

namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto

// ===================================================================

class OwnParkingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.OwnParkingConfig) */ {
 public:
  OwnParkingConfig();
  virtual ~OwnParkingConfig();

  OwnParkingConfig(const OwnParkingConfig& from);

  inline OwnParkingConfig& operator=(const OwnParkingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnParkingConfig& default_instance();

  static inline const OwnParkingConfig* internal_default_instance() {
    return reinterpret_cast<const OwnParkingConfig*>(
               &_OwnParkingConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(OwnParkingConfig* other);

  // implements Message ----------------------------------------------

  inline OwnParkingConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  OwnParkingConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OwnParkingConfig& from);
  void MergeFrom(const OwnParkingConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OwnParkingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.routing.RoutingRequest routingrequest = 2;
  bool has_routingrequest() const;
  void clear_routingrequest();
  static const int kRoutingrequestFieldNumber = 2;
  const ::jmc_auto::routing::RoutingRequest& routingrequest() const;
  ::jmc_auto::routing::RoutingRequest* mutable_routingrequest();
  ::jmc_auto::routing::RoutingRequest* release_routingrequest();
  void set_allocated_routingrequest(::jmc_auto::routing::RoutingRequest* routingrequest);

  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.OwnParkingConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_routingrequest();
  void clear_has_routingrequest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::routing::RoutingRequest* routingrequest_;
  bool enabled_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowParkingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.FlowParkingConfig) */ {
 public:
  FlowParkingConfig();
  virtual ~FlowParkingConfig();

  FlowParkingConfig(const FlowParkingConfig& from);

  inline FlowParkingConfig& operator=(const FlowParkingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowParkingConfig& default_instance();

  static inline const FlowParkingConfig* internal_default_instance() {
    return reinterpret_cast<const FlowParkingConfig*>(
               &_FlowParkingConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FlowParkingConfig* other);

  // implements Message ----------------------------------------------

  inline FlowParkingConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  FlowParkingConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FlowParkingConfig& from);
  void MergeFrom(const FlowParkingConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FlowParkingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.routing.RoutingRequest routingrequest = 2;
  bool has_routingrequest() const;
  void clear_routingrequest();
  static const int kRoutingrequestFieldNumber = 2;
  const ::jmc_auto::routing::RoutingRequest& routingrequest() const;
  ::jmc_auto::routing::RoutingRequest* mutable_routingrequest();
  ::jmc_auto::routing::RoutingRequest* release_routingrequest();
  void set_allocated_routingrequest(::jmc_auto::routing::RoutingRequest* routingrequest);

  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.FlowParkingConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_routingrequest();
  void clear_has_routingrequest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::routing::RoutingRequest* routingrequest_;
  bool enabled_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CallDrivingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.CallDrivingConfig) */ {
 public:
  CallDrivingConfig();
  virtual ~CallDrivingConfig();

  CallDrivingConfig(const CallDrivingConfig& from);

  inline CallDrivingConfig& operator=(const CallDrivingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallDrivingConfig& default_instance();

  static inline const CallDrivingConfig* internal_default_instance() {
    return reinterpret_cast<const CallDrivingConfig*>(
               &_CallDrivingConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CallDrivingConfig* other);

  // implements Message ----------------------------------------------

  inline CallDrivingConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  CallDrivingConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CallDrivingConfig& from);
  void MergeFrom(const CallDrivingConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CallDrivingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.routing.RoutingRequest routingrequest = 2;
  bool has_routingrequest() const;
  void clear_routingrequest();
  static const int kRoutingrequestFieldNumber = 2;
  const ::jmc_auto::routing::RoutingRequest& routingrequest() const;
  ::jmc_auto::routing::RoutingRequest* mutable_routingrequest();
  ::jmc_auto::routing::RoutingRequest* release_routingrequest();
  void set_allocated_routingrequest(::jmc_auto::routing::RoutingRequest* routingrequest);

  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.CallDrivingConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_routingrequest();
  void clear_has_routingrequest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::routing::RoutingRequest* routingrequest_;
  bool enabled_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParkingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ParkingConfig) */ {
 public:
  ParkingConfig();
  virtual ~ParkingConfig();

  ParkingConfig(const ParkingConfig& from);

  inline ParkingConfig& operator=(const ParkingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingConfig& default_instance();

  static inline const ParkingConfig* internal_default_instance() {
    return reinterpret_cast<const ParkingConfig*>(
               &_ParkingConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ParkingConfig* other);

  // implements Message ----------------------------------------------

  inline ParkingConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingConfig& from);
  void MergeFrom(const ParkingConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.OwnParkingConfig ownparking = 2;
  bool has_ownparking() const;
  void clear_ownparking();
  static const int kOwnparkingFieldNumber = 2;
  const ::jmc_auto::planning::OwnParkingConfig& ownparking() const;
  ::jmc_auto::planning::OwnParkingConfig* mutable_ownparking();
  ::jmc_auto::planning::OwnParkingConfig* release_ownparking();
  void set_allocated_ownparking(::jmc_auto::planning::OwnParkingConfig* ownparking);

  // optional .jmc_auto.planning.FlowParkingConfig flowparking = 3;
  bool has_flowparking() const;
  void clear_flowparking();
  static const int kFlowparkingFieldNumber = 3;
  const ::jmc_auto::planning::FlowParkingConfig& flowparking() const;
  ::jmc_auto::planning::FlowParkingConfig* mutable_flowparking();
  ::jmc_auto::planning::FlowParkingConfig* release_flowparking();
  void set_allocated_flowparking(::jmc_auto::planning::FlowParkingConfig* flowparking);

  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ParkingConfig)
 private:
  void set_has_enabled();
  void clear_has_enabled();
  void set_has_ownparking();
  void clear_has_ownparking();
  void set_has_flowparking();
  void clear_has_flowparking();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::OwnParkingConfig* ownparking_;
  ::jmc_auto::planning::FlowParkingConfig* flowparking_;
  bool enabled_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningModeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PlanningModeConfig) */ {
 public:
  PlanningModeConfig();
  virtual ~PlanningModeConfig();

  PlanningModeConfig(const PlanningModeConfig& from);

  inline PlanningModeConfig& operator=(const PlanningModeConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningModeConfig& default_instance();

  static inline const PlanningModeConfig* internal_default_instance() {
    return reinterpret_cast<const PlanningModeConfig*>(
               &_PlanningModeConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PlanningModeConfig* other);

  // implements Message ----------------------------------------------

  inline PlanningModeConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningModeConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningModeConfig& from);
  void MergeFrom(const PlanningModeConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningModeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.CallDrivingConfig calldriving = 1;
  bool has_calldriving() const;
  void clear_calldriving();
  static const int kCalldrivingFieldNumber = 1;
  const ::jmc_auto::planning::CallDrivingConfig& calldriving() const;
  ::jmc_auto::planning::CallDrivingConfig* mutable_calldriving();
  ::jmc_auto::planning::CallDrivingConfig* release_calldriving();
  void set_allocated_calldriving(::jmc_auto::planning::CallDrivingConfig* calldriving);

  // optional .jmc_auto.planning.ParkingConfig parking = 2;
  bool has_parking() const;
  void clear_parking();
  static const int kParkingFieldNumber = 2;
  const ::jmc_auto::planning::ParkingConfig& parking() const;
  ::jmc_auto::planning::ParkingConfig* mutable_parking();
  ::jmc_auto::planning::ParkingConfig* release_parking();
  void set_allocated_parking(::jmc_auto::planning::ParkingConfig* parking);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PlanningModeConfig)
 private:
  void set_has_calldriving();
  void clear_has_calldriving();
  void set_has_parking();
  void clear_has_parking();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::planning::CallDrivingConfig* calldriving_;
  ::jmc_auto::planning::ParkingConfig* parking_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// OwnParkingConfig

// optional bool enabled = 1;
inline bool OwnParkingConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OwnParkingConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OwnParkingConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OwnParkingConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool OwnParkingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OwnParkingConfig.enabled)
  return enabled_;
}
inline void OwnParkingConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.OwnParkingConfig.enabled)
}

// optional .jmc_auto.routing.RoutingRequest routingrequest = 2;
inline bool OwnParkingConfig::has_routingrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OwnParkingConfig::set_has_routingrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OwnParkingConfig::clear_has_routingrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OwnParkingConfig::clear_routingrequest() {
  if (routingrequest_ != NULL) routingrequest_->::jmc_auto::routing::RoutingRequest::Clear();
  clear_has_routingrequest();
}
inline const ::jmc_auto::routing::RoutingRequest& OwnParkingConfig::routingrequest() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.OwnParkingConfig.routingrequest)
  return routingrequest_ != NULL ? *routingrequest_
                         : *::jmc_auto::routing::RoutingRequest::internal_default_instance();
}
inline ::jmc_auto::routing::RoutingRequest* OwnParkingConfig::mutable_routingrequest() {
  set_has_routingrequest();
  if (routingrequest_ == NULL) {
    routingrequest_ = new ::jmc_auto::routing::RoutingRequest;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.OwnParkingConfig.routingrequest)
  return routingrequest_;
}
inline ::jmc_auto::routing::RoutingRequest* OwnParkingConfig::release_routingrequest() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.OwnParkingConfig.routingrequest)
  clear_has_routingrequest();
  ::jmc_auto::routing::RoutingRequest* temp = routingrequest_;
  routingrequest_ = NULL;
  return temp;
}
inline void OwnParkingConfig::set_allocated_routingrequest(::jmc_auto::routing::RoutingRequest* routingrequest) {
  delete routingrequest_;
  routingrequest_ = routingrequest;
  if (routingrequest) {
    set_has_routingrequest();
  } else {
    clear_has_routingrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.OwnParkingConfig.routingrequest)
}

// -------------------------------------------------------------------

// FlowParkingConfig

// optional bool enabled = 1;
inline bool FlowParkingConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowParkingConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowParkingConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowParkingConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool FlowParkingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.FlowParkingConfig.enabled)
  return enabled_;
}
inline void FlowParkingConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.FlowParkingConfig.enabled)
}

// optional .jmc_auto.routing.RoutingRequest routingrequest = 2;
inline bool FlowParkingConfig::has_routingrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowParkingConfig::set_has_routingrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowParkingConfig::clear_has_routingrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowParkingConfig::clear_routingrequest() {
  if (routingrequest_ != NULL) routingrequest_->::jmc_auto::routing::RoutingRequest::Clear();
  clear_has_routingrequest();
}
inline const ::jmc_auto::routing::RoutingRequest& FlowParkingConfig::routingrequest() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.FlowParkingConfig.routingrequest)
  return routingrequest_ != NULL ? *routingrequest_
                         : *::jmc_auto::routing::RoutingRequest::internal_default_instance();
}
inline ::jmc_auto::routing::RoutingRequest* FlowParkingConfig::mutable_routingrequest() {
  set_has_routingrequest();
  if (routingrequest_ == NULL) {
    routingrequest_ = new ::jmc_auto::routing::RoutingRequest;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.FlowParkingConfig.routingrequest)
  return routingrequest_;
}
inline ::jmc_auto::routing::RoutingRequest* FlowParkingConfig::release_routingrequest() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.FlowParkingConfig.routingrequest)
  clear_has_routingrequest();
  ::jmc_auto::routing::RoutingRequest* temp = routingrequest_;
  routingrequest_ = NULL;
  return temp;
}
inline void FlowParkingConfig::set_allocated_routingrequest(::jmc_auto::routing::RoutingRequest* routingrequest) {
  delete routingrequest_;
  routingrequest_ = routingrequest;
  if (routingrequest) {
    set_has_routingrequest();
  } else {
    clear_has_routingrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.FlowParkingConfig.routingrequest)
}

// -------------------------------------------------------------------

// CallDrivingConfig

// optional bool enabled = 1;
inline bool CallDrivingConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallDrivingConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallDrivingConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallDrivingConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool CallDrivingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CallDrivingConfig.enabled)
  return enabled_;
}
inline void CallDrivingConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.CallDrivingConfig.enabled)
}

// optional .jmc_auto.routing.RoutingRequest routingrequest = 2;
inline bool CallDrivingConfig::has_routingrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallDrivingConfig::set_has_routingrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallDrivingConfig::clear_has_routingrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallDrivingConfig::clear_routingrequest() {
  if (routingrequest_ != NULL) routingrequest_->::jmc_auto::routing::RoutingRequest::Clear();
  clear_has_routingrequest();
}
inline const ::jmc_auto::routing::RoutingRequest& CallDrivingConfig::routingrequest() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.CallDrivingConfig.routingrequest)
  return routingrequest_ != NULL ? *routingrequest_
                         : *::jmc_auto::routing::RoutingRequest::internal_default_instance();
}
inline ::jmc_auto::routing::RoutingRequest* CallDrivingConfig::mutable_routingrequest() {
  set_has_routingrequest();
  if (routingrequest_ == NULL) {
    routingrequest_ = new ::jmc_auto::routing::RoutingRequest;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.CallDrivingConfig.routingrequest)
  return routingrequest_;
}
inline ::jmc_auto::routing::RoutingRequest* CallDrivingConfig::release_routingrequest() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.CallDrivingConfig.routingrequest)
  clear_has_routingrequest();
  ::jmc_auto::routing::RoutingRequest* temp = routingrequest_;
  routingrequest_ = NULL;
  return temp;
}
inline void CallDrivingConfig::set_allocated_routingrequest(::jmc_auto::routing::RoutingRequest* routingrequest) {
  delete routingrequest_;
  routingrequest_ = routingrequest;
  if (routingrequest) {
    set_has_routingrequest();
  } else {
    clear_has_routingrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.CallDrivingConfig.routingrequest)
}

// -------------------------------------------------------------------

// ParkingConfig

// optional bool enabled = 1;
inline bool ParkingConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParkingConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParkingConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParkingConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool ParkingConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkingConfig.enabled)
  return enabled_;
}
inline void ParkingConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ParkingConfig.enabled)
}

// optional .jmc_auto.planning.OwnParkingConfig ownparking = 2;
inline bool ParkingConfig::has_ownparking() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingConfig::set_has_ownparking() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingConfig::clear_has_ownparking() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingConfig::clear_ownparking() {
  if (ownparking_ != NULL) ownparking_->::jmc_auto::planning::OwnParkingConfig::Clear();
  clear_has_ownparking();
}
inline const ::jmc_auto::planning::OwnParkingConfig& ParkingConfig::ownparking() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkingConfig.ownparking)
  return ownparking_ != NULL ? *ownparking_
                         : *::jmc_auto::planning::OwnParkingConfig::internal_default_instance();
}
inline ::jmc_auto::planning::OwnParkingConfig* ParkingConfig::mutable_ownparking() {
  set_has_ownparking();
  if (ownparking_ == NULL) {
    ownparking_ = new ::jmc_auto::planning::OwnParkingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ParkingConfig.ownparking)
  return ownparking_;
}
inline ::jmc_auto::planning::OwnParkingConfig* ParkingConfig::release_ownparking() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ParkingConfig.ownparking)
  clear_has_ownparking();
  ::jmc_auto::planning::OwnParkingConfig* temp = ownparking_;
  ownparking_ = NULL;
  return temp;
}
inline void ParkingConfig::set_allocated_ownparking(::jmc_auto::planning::OwnParkingConfig* ownparking) {
  delete ownparking_;
  ownparking_ = ownparking;
  if (ownparking) {
    set_has_ownparking();
  } else {
    clear_has_ownparking();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ParkingConfig.ownparking)
}

// optional .jmc_auto.planning.FlowParkingConfig flowparking = 3;
inline bool ParkingConfig::has_flowparking() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkingConfig::set_has_flowparking() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkingConfig::clear_has_flowparking() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkingConfig::clear_flowparking() {
  if (flowparking_ != NULL) flowparking_->::jmc_auto::planning::FlowParkingConfig::Clear();
  clear_has_flowparking();
}
inline const ::jmc_auto::planning::FlowParkingConfig& ParkingConfig::flowparking() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ParkingConfig.flowparking)
  return flowparking_ != NULL ? *flowparking_
                         : *::jmc_auto::planning::FlowParkingConfig::internal_default_instance();
}
inline ::jmc_auto::planning::FlowParkingConfig* ParkingConfig::mutable_flowparking() {
  set_has_flowparking();
  if (flowparking_ == NULL) {
    flowparking_ = new ::jmc_auto::planning::FlowParkingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ParkingConfig.flowparking)
  return flowparking_;
}
inline ::jmc_auto::planning::FlowParkingConfig* ParkingConfig::release_flowparking() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ParkingConfig.flowparking)
  clear_has_flowparking();
  ::jmc_auto::planning::FlowParkingConfig* temp = flowparking_;
  flowparking_ = NULL;
  return temp;
}
inline void ParkingConfig::set_allocated_flowparking(::jmc_auto::planning::FlowParkingConfig* flowparking) {
  delete flowparking_;
  flowparking_ = flowparking;
  if (flowparking) {
    set_has_flowparking();
  } else {
    clear_has_flowparking();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ParkingConfig.flowparking)
}

// -------------------------------------------------------------------

// PlanningModeConfig

// optional .jmc_auto.planning.CallDrivingConfig calldriving = 1;
inline bool PlanningModeConfig::has_calldriving() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningModeConfig::set_has_calldriving() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningModeConfig::clear_has_calldriving() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningModeConfig::clear_calldriving() {
  if (calldriving_ != NULL) calldriving_->::jmc_auto::planning::CallDrivingConfig::Clear();
  clear_has_calldriving();
}
inline const ::jmc_auto::planning::CallDrivingConfig& PlanningModeConfig::calldriving() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningModeConfig.calldriving)
  return calldriving_ != NULL ? *calldriving_
                         : *::jmc_auto::planning::CallDrivingConfig::internal_default_instance();
}
inline ::jmc_auto::planning::CallDrivingConfig* PlanningModeConfig::mutable_calldriving() {
  set_has_calldriving();
  if (calldriving_ == NULL) {
    calldriving_ = new ::jmc_auto::planning::CallDrivingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningModeConfig.calldriving)
  return calldriving_;
}
inline ::jmc_auto::planning::CallDrivingConfig* PlanningModeConfig::release_calldriving() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningModeConfig.calldriving)
  clear_has_calldriving();
  ::jmc_auto::planning::CallDrivingConfig* temp = calldriving_;
  calldriving_ = NULL;
  return temp;
}
inline void PlanningModeConfig::set_allocated_calldriving(::jmc_auto::planning::CallDrivingConfig* calldriving) {
  delete calldriving_;
  calldriving_ = calldriving;
  if (calldriving) {
    set_has_calldriving();
  } else {
    clear_has_calldriving();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningModeConfig.calldriving)
}

// optional .jmc_auto.planning.ParkingConfig parking = 2;
inline bool PlanningModeConfig::has_parking() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningModeConfig::set_has_parking() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningModeConfig::clear_has_parking() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningModeConfig::clear_parking() {
  if (parking_ != NULL) parking_->::jmc_auto::planning::ParkingConfig::Clear();
  clear_has_parking();
}
inline const ::jmc_auto::planning::ParkingConfig& PlanningModeConfig::parking() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningModeConfig.parking)
  return parking_ != NULL ? *parking_
                         : *::jmc_auto::planning::ParkingConfig::internal_default_instance();
}
inline ::jmc_auto::planning::ParkingConfig* PlanningModeConfig::mutable_parking() {
  set_has_parking();
  if (parking_ == NULL) {
    parking_ = new ::jmc_auto::planning::ParkingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningModeConfig.parking)
  return parking_;
}
inline ::jmc_auto::planning::ParkingConfig* PlanningModeConfig::release_parking() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningModeConfig.parking)
  clear_has_parking();
  ::jmc_auto::planning::ParkingConfig* temp = parking_;
  parking_ = NULL;
  return temp;
}
inline void PlanningModeConfig::set_allocated_parking(::jmc_auto::planning::ParkingConfig* parking) {
  delete parking_;
  parking_ = parking;
  if (parking) {
    set_has_parking();
  } else {
    clear_has_parking();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningModeConfig.parking)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace planning
}  // namespace jmc_auto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fmode_5fconfig_2eproto__INCLUDED
