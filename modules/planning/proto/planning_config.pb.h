// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_config.proto

#ifndef PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto__INCLUDED
#define PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/planning/proto/creep_decider_config.pb.h"
#include "modules/planning/proto/dp_st_speed_config.pb.h"
#include "modules/planning/proto/lane_change_decider_config.pb.h"
#include "modules/planning/proto/open_space_fallback_decider_config.pb.h"
#include "modules/planning/proto/open_space_pre_stop_decider_config.pb.h"
#include "modules/planning/proto/open_space_roi_decider_config.pb.h"
#include "modules/planning/proto/open_space_trajectory_provider_config.pb.h"
#include "modules/planning/proto/open_space_trajectory_partition_config.pb.h"
#include "modules/planning/proto/path_assessment_decider_config.pb.h"
#include "modules/planning/proto/path_bounds_decider_config.pb.h"
#include "modules/planning/proto/path_decider_config.pb.h"
#include "modules/planning/proto/path_lane_borrow_decider_config.pb.h"
#include "modules/planning/proto/piecewise_jerk_path_config.pb.h"
#include "modules/planning/proto/piecewise_jerk_speed_config.pb.h"
#include "modules/planning/proto/piecewise_jerk_nonlinear_speed_config.pb.h"
#include "modules/planning/proto/rule_based_stop_decider_config.pb.h"
#include "modules/planning/proto/speed_bounds_decider_config.pb.h"
#include "modules/planning/proto/navi_path_decider_config.pb.h"
#include "modules/planning/proto/navi_speed_decider_config.pb.h"
#include "modules/planning/proto/navi_obstacle_decider_config.pb.h"
#include "modules/planning/proto/path_reuse_decider_config.pb.h"
#include "modules/planning/proto/st_bounds_decider_config.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace planning {
class CreepDeciderConfig;
class CreepDeciderConfigDefaultTypeInternal;
extern CreepDeciderConfigDefaultTypeInternal _CreepDeciderConfig_default_instance_;
class DistanceApproachTrajectorySmootherConfig;
class DistanceApproachTrajectorySmootherConfigDefaultTypeInternal;
extern DistanceApproachTrajectorySmootherConfigDefaultTypeInternal _DistanceApproachTrajectorySmootherConfig_default_instance_;
class DpStSpeedConfig;
class DpStSpeedConfigDefaultTypeInternal;
extern DpStSpeedConfigDefaultTypeInternal _DpStSpeedConfig_default_instance_;
class DualVariableConfig;
class DualVariableConfigDefaultTypeInternal;
extern DualVariableConfigDefaultTypeInternal _DualVariableConfig_default_instance_;
class HybridAStarConfig;
class HybridAStarConfigDefaultTypeInternal;
extern HybridAStarConfigDefaultTypeInternal _HybridAStarConfig_default_instance_;
class IpoptSolverConfig;
class IpoptSolverConfigDefaultTypeInternal;
extern IpoptSolverConfigDefaultTypeInternal _IpoptSolverConfig_default_instance_;
class LaneChangeDeciderConfig;
class LaneChangeDeciderConfigDefaultTypeInternal;
extern LaneChangeDeciderConfigDefaultTypeInternal _LaneChangeDeciderConfig_default_instance_;
class MoveDestLaneConfigTable;
class MoveDestLaneConfigTableDefaultTypeInternal;
extern MoveDestLaneConfigTableDefaultTypeInternal _MoveDestLaneConfigTable_default_instance_;
class NaviObstacleDeciderConfig;
class NaviObstacleDeciderConfigDefaultTypeInternal;
extern NaviObstacleDeciderConfigDefaultTypeInternal _NaviObstacleDeciderConfig_default_instance_;
class NaviPathDeciderConfig;
class NaviPathDeciderConfigDefaultTypeInternal;
extern NaviPathDeciderConfigDefaultTypeInternal _NaviPathDeciderConfig_default_instance_;
class NaviSpeedDeciderConfig;
class NaviSpeedDeciderConfigDefaultTypeInternal;
extern NaviSpeedDeciderConfigDefaultTypeInternal _NaviSpeedDeciderConfig_default_instance_;
class NavigationPlanningConfig;
class NavigationPlanningConfigDefaultTypeInternal;
extern NavigationPlanningConfigDefaultTypeInternal _NavigationPlanningConfig_default_instance_;
class OpenSpaceFallBackDeciderConfig;
class OpenSpaceFallBackDeciderConfigDefaultTypeInternal;
extern OpenSpaceFallBackDeciderConfigDefaultTypeInternal _OpenSpaceFallBackDeciderConfig_default_instance_;
class OpenSpacePreStopDeciderConfig;
class OpenSpacePreStopDeciderConfigDefaultTypeInternal;
extern OpenSpacePreStopDeciderConfigDefaultTypeInternal _OpenSpacePreStopDeciderConfig_default_instance_;
class OpenSpaceRoiDeciderConfig;
class OpenSpaceRoiDeciderConfigDefaultTypeInternal;
extern OpenSpaceRoiDeciderConfigDefaultTypeInternal _OpenSpaceRoiDeciderConfig_default_instance_;
class OpenSpaceTrajectoryOptimizerConfig;
class OpenSpaceTrajectoryOptimizerConfigDefaultTypeInternal;
extern OpenSpaceTrajectoryOptimizerConfigDefaultTypeInternal _OpenSpaceTrajectoryOptimizerConfig_default_instance_;
class OpenSpaceTrajectoryPartitionConfig;
class OpenSpaceTrajectoryPartitionConfigDefaultTypeInternal;
extern OpenSpaceTrajectoryPartitionConfigDefaultTypeInternal _OpenSpaceTrajectoryPartitionConfig_default_instance_;
class OpenSpaceTrajectoryProviderConfig;
class OpenSpaceTrajectoryProviderConfigDefaultTypeInternal;
extern OpenSpaceTrajectoryProviderConfigDefaultTypeInternal _OpenSpaceTrajectoryProviderConfig_default_instance_;
class PathAssessmentDeciderConfig;
class PathAssessmentDeciderConfigDefaultTypeInternal;
extern PathAssessmentDeciderConfigDefaultTypeInternal _PathAssessmentDeciderConfig_default_instance_;
class PathBoundsDeciderConfig;
class PathBoundsDeciderConfigDefaultTypeInternal;
extern PathBoundsDeciderConfigDefaultTypeInternal _PathBoundsDeciderConfig_default_instance_;
class PathDeciderConfig;
class PathDeciderConfigDefaultTypeInternal;
extern PathDeciderConfigDefaultTypeInternal _PathDeciderConfig_default_instance_;
class PathLaneBorrowDeciderConfig;
class PathLaneBorrowDeciderConfigDefaultTypeInternal;
extern PathLaneBorrowDeciderConfigDefaultTypeInternal _PathLaneBorrowDeciderConfig_default_instance_;
class PathReuseDeciderConfig;
class PathReuseDeciderConfigDefaultTypeInternal;
extern PathReuseDeciderConfigDefaultTypeInternal _PathReuseDeciderConfig_default_instance_;
class PiecewiseJerkNonlinearSpeedConfig;
class PiecewiseJerkNonlinearSpeedConfigDefaultTypeInternal;
extern PiecewiseJerkNonlinearSpeedConfigDefaultTypeInternal _PiecewiseJerkNonlinearSpeedConfig_default_instance_;
class PiecewiseJerkPathConfig;
class PiecewiseJerkPathConfigDefaultTypeInternal;
extern PiecewiseJerkPathConfigDefaultTypeInternal _PiecewiseJerkPathConfig_default_instance_;
class PiecewiseJerkPathWeights;
class PiecewiseJerkPathWeightsDefaultTypeInternal;
extern PiecewiseJerkPathWeightsDefaultTypeInternal _PiecewiseJerkPathWeights_default_instance_;
class PiecewiseJerkSpeedConfig;
class PiecewiseJerkSpeedConfigDefaultTypeInternal;
extern PiecewiseJerkSpeedConfigDefaultTypeInternal _PiecewiseJerkSpeedConfig_default_instance_;
class PlannerNaviConfig;
class PlannerNaviConfigDefaultTypeInternal;
extern PlannerNaviConfigDefaultTypeInternal _PlannerNaviConfig_default_instance_;
class PlannerPublicRoadConfig;
class PlannerPublicRoadConfigDefaultTypeInternal;
extern PlannerPublicRoadConfigDefaultTypeInternal _PlannerPublicRoadConfig_default_instance_;
class PlanningConfig;
class PlanningConfigDefaultTypeInternal;
extern PlanningConfigDefaultTypeInternal _PlanningConfig_default_instance_;
class RtkPlanningConfig;
class RtkPlanningConfigDefaultTypeInternal;
extern RtkPlanningConfigDefaultTypeInternal _RtkPlanningConfig_default_instance_;
class RuleBasedStopDeciderConfig;
class RuleBasedStopDeciderConfigDefaultTypeInternal;
extern RuleBasedStopDeciderConfigDefaultTypeInternal _RuleBasedStopDeciderConfig_default_instance_;
class STBoundsDeciderConfig;
class STBoundsDeciderConfigDefaultTypeInternal;
extern STBoundsDeciderConfigDefaultTypeInternal _STBoundsDeciderConfig_default_instance_;
class ScenarioBareIntersectionUnprotectedConfig;
class ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal;
extern ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal _ScenarioBareIntersectionUnprotectedConfig_default_instance_;
class ScenarioConfig;
class ScenarioConfigDefaultTypeInternal;
extern ScenarioConfigDefaultTypeInternal _ScenarioConfig_default_instance_;
class ScenarioConfig_StageConfig;
class ScenarioConfig_StageConfigDefaultTypeInternal;
extern ScenarioConfig_StageConfigDefaultTypeInternal _ScenarioConfig_StageConfig_default_instance_;
class ScenarioEmergencyPullOverConfig;
class ScenarioEmergencyPullOverConfigDefaultTypeInternal;
extern ScenarioEmergencyPullOverConfigDefaultTypeInternal _ScenarioEmergencyPullOverConfig_default_instance_;
class ScenarioEmergencyStopConfig;
class ScenarioEmergencyStopConfigDefaultTypeInternal;
extern ScenarioEmergencyStopConfigDefaultTypeInternal _ScenarioEmergencyStopConfig_default_instance_;
class ScenarioLaneFollowConfig;
class ScenarioLaneFollowConfigDefaultTypeInternal;
extern ScenarioLaneFollowConfigDefaultTypeInternal _ScenarioLaneFollowConfig_default_instance_;
class ScenarioNarrowStreetUTurnConfig;
class ScenarioNarrowStreetUTurnConfigDefaultTypeInternal;
extern ScenarioNarrowStreetUTurnConfigDefaultTypeInternal _ScenarioNarrowStreetUTurnConfig_default_instance_;
class ScenarioParkAndGoConfig;
class ScenarioParkAndGoConfigDefaultTypeInternal;
extern ScenarioParkAndGoConfigDefaultTypeInternal _ScenarioParkAndGoConfig_default_instance_;
class ScenarioPullOverConfig;
class ScenarioPullOverConfigDefaultTypeInternal;
extern ScenarioPullOverConfigDefaultTypeInternal _ScenarioPullOverConfig_default_instance_;
class ScenarioStopSignUnprotectedConfig;
class ScenarioStopSignUnprotectedConfigDefaultTypeInternal;
extern ScenarioStopSignUnprotectedConfigDefaultTypeInternal _ScenarioStopSignUnprotectedConfig_default_instance_;
class ScenarioTestLearningModelConfig;
class ScenarioTestLearningModelConfigDefaultTypeInternal;
extern ScenarioTestLearningModelConfigDefaultTypeInternal _ScenarioTestLearningModelConfig_default_instance_;
class ScenarioTrafficLightProtectedConfig;
class ScenarioTrafficLightProtectedConfigDefaultTypeInternal;
extern ScenarioTrafficLightProtectedConfigDefaultTypeInternal _ScenarioTrafficLightProtectedConfig_default_instance_;
class ScenarioTrafficLightUnprotectedLeftTurnConfig;
class ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_;
class ScenarioTrafficLightUnprotectedRightTurnConfig;
class ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_;
class ScenarioValetParkingConfig;
class ScenarioValetParkingConfigDefaultTypeInternal;
extern ScenarioValetParkingConfigDefaultTypeInternal _ScenarioValetParkingConfig_default_instance_;
class ScenarioYieldSignConfig;
class ScenarioYieldSignConfigDefaultTypeInternal;
extern ScenarioYieldSignConfigDefaultTypeInternal _ScenarioYieldSignConfig_default_instance_;
class ShiftConfig;
class ShiftConfigDefaultTypeInternal;
extern ShiftConfigDefaultTypeInternal _ShiftConfig_default_instance_;
class SpeedBoundsDeciderConfig;
class SpeedBoundsDeciderConfigDefaultTypeInternal;
extern SpeedBoundsDeciderConfigDefaultTypeInternal _SpeedBoundsDeciderConfig_default_instance_;
class SpeedHeuristicConfig;
class SpeedHeuristicConfigDefaultTypeInternal;
extern SpeedHeuristicConfigDefaultTypeInternal _SpeedHeuristicConfig_default_instance_;
class StandardPlanningConfig;
class StandardPlanningConfigDefaultTypeInternal;
extern StandardPlanningConfigDefaultTypeInternal _StandardPlanningConfig_default_instance_;
class TaskConfig;
class TaskConfigDefaultTypeInternal;
extern TaskConfigDefaultTypeInternal _TaskConfig_default_instance_;
}  // namespace planning
}  // namespace jmc_auto

namespace jmc_auto {
namespace planning {

namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto

enum TaskConfig_TaskType {
  TaskConfig_TaskType_DP_ST_SPEED_OPTIMIZER = 1,
  TaskConfig_TaskType_PATH_DECIDER = 4,
  TaskConfig_TaskType_SPEED_DECIDER = 5,
  TaskConfig_TaskType_NAVI_PATH_DECIDER = 7,
  TaskConfig_TaskType_NAVI_SPEED_DECIDER = 8,
  TaskConfig_TaskType_NAVI_OBSTACLE_DECIDER = 9,
  TaskConfig_TaskType_CREEP_DECIDER = 11,
  TaskConfig_TaskType_OPEN_SPACE_PRE_STOP_DECIDER = 12,
  TaskConfig_TaskType_DECIDER_RSS = 16,
  TaskConfig_TaskType_SPEED_BOUNDS_PRIORI_DECIDER = 17,
  TaskConfig_TaskType_SPEED_BOUNDS_FINAL_DECIDER = 18,
  TaskConfig_TaskType_PIECEWISE_JERK_PATH_OPTIMIZER = 19,
  TaskConfig_TaskType_PATH_BOUNDS_DECIDER = 20,
  TaskConfig_TaskType_OPEN_SPACE_ROI_DECIDER = 21,
  TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PROVIDER = 22,
  TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PARTITION = 23,
  TaskConfig_TaskType_OPEN_SPACE_FALLBACK_DECIDER = 24,
  TaskConfig_TaskType_PATH_ASSESSMENT_DECIDER = 25,
  TaskConfig_TaskType_PATH_LANE_BORROW_DECIDER = 26,
  TaskConfig_TaskType_PIECEWISE_JERK_SPEED_OPTIMIZER = 27,
  TaskConfig_TaskType_LANE_CHANGE_DECIDER = 28,
  TaskConfig_TaskType_RULE_BASED_STOP_DECIDER = 29,
  TaskConfig_TaskType_PATH_REUSE_DECIDER = 30,
  TaskConfig_TaskType_ST_BOUNDS_DECIDER = 31,
  TaskConfig_TaskType_PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER = 32
};
bool TaskConfig_TaskType_IsValid(int value);
const TaskConfig_TaskType TaskConfig_TaskType_TaskType_MIN = TaskConfig_TaskType_DP_ST_SPEED_OPTIMIZER;
const TaskConfig_TaskType TaskConfig_TaskType_TaskType_MAX = TaskConfig_TaskType_PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER;
const int TaskConfig_TaskType_TaskType_ARRAYSIZE = TaskConfig_TaskType_TaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskConfig_TaskType_descriptor();
inline const ::std::string& TaskConfig_TaskType_Name(TaskConfig_TaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskConfig_TaskType_descriptor(), value);
}
inline bool TaskConfig_TaskType_Parse(
    const ::std::string& name, TaskConfig_TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskConfig_TaskType>(
    TaskConfig_TaskType_descriptor(), name, value);
}
enum ScenarioConfig_ScenarioType {
  ScenarioConfig_ScenarioType_LANE_FOLLOW = 0,
  ScenarioConfig_ScenarioType_BARE_INTERSECTION_UNPROTECTED = 2,
  ScenarioConfig_ScenarioType_STOP_SIGN_PROTECTED = 3,
  ScenarioConfig_ScenarioType_STOP_SIGN_UNPROTECTED = 4,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_PROTECTED = 5,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN = 6,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN = 7,
  ScenarioConfig_ScenarioType_YIELD_SIGN = 8,
  ScenarioConfig_ScenarioType_PULL_OVER = 9,
  ScenarioConfig_ScenarioType_VALET_PARKING = 10,
  ScenarioConfig_ScenarioType_EMERGENCY_PULL_OVER = 11,
  ScenarioConfig_ScenarioType_EMERGENCY_STOP = 12,
  ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN = 13,
  ScenarioConfig_ScenarioType_PARK_AND_GO = 14,
  ScenarioConfig_ScenarioType_TEST_LEARNING_MODEL = 15
};
bool ScenarioConfig_ScenarioType_IsValid(int value);
const ScenarioConfig_ScenarioType ScenarioConfig_ScenarioType_ScenarioType_MIN = ScenarioConfig_ScenarioType_LANE_FOLLOW;
const ScenarioConfig_ScenarioType ScenarioConfig_ScenarioType_ScenarioType_MAX = ScenarioConfig_ScenarioType_TEST_LEARNING_MODEL;
const int ScenarioConfig_ScenarioType_ScenarioType_ARRAYSIZE = ScenarioConfig_ScenarioType_ScenarioType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScenarioConfig_ScenarioType_descriptor();
inline const ::std::string& ScenarioConfig_ScenarioType_Name(ScenarioConfig_ScenarioType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScenarioConfig_ScenarioType_descriptor(), value);
}
inline bool ScenarioConfig_ScenarioType_Parse(
    const ::std::string& name, ScenarioConfig_ScenarioType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScenarioConfig_ScenarioType>(
    ScenarioConfig_ScenarioType_descriptor(), name, value);
}
enum ScenarioConfig_StageType {
  ScenarioConfig_StageType_NO_STAGE = 0,
  ScenarioConfig_StageType_LANE_FOLLOW_DEFAULT_STAGE = 1,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_APPROACH = 200,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE = 201,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_PRE_STOP = 300,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_STOP = 301,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_CREEP = 302,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE = 303,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_APPROACH = 400,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE = 401,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH = 410,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP = 411,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE = 412,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP = 420,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP = 421,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE = 422,
  ScenarioConfig_StageType_PULL_OVER_APPROACH = 500,
  ScenarioConfig_StageType_PULL_OVER_RETRY_APPROACH_PARKING = 501,
  ScenarioConfig_StageType_PULL_OVER_RETRY_PARKING = 502,
  ScenarioConfig_StageType_EMERGENCY_PULL_OVER_SLOW_DOWN = 600,
  ScenarioConfig_StageType_EMERGENCY_PULL_OVER_APPROACH = 601,
  ScenarioConfig_StageType_EMERGENCY_PULL_OVER_STANDBY = 602,
  ScenarioConfig_StageType_EMERGENCY_STOP_APPROACH = 610,
  ScenarioConfig_StageType_EMERGENCY_STOP_STANDBY = 611,
  ScenarioConfig_StageType_VALET_PARKING_APPROACHING_PARKING_SPOT = 700,
  ScenarioConfig_StageType_VALET_PARKING_PARKING = 701,
  ScenarioConfig_StageType_PARK_AND_GO_CHECK = 800,
  ScenarioConfig_StageType_PARK_AND_GO_CRUISE = 801,
  ScenarioConfig_StageType_PARK_AND_GO_ADJUST = 802,
  ScenarioConfig_StageType_PARK_AND_GO_PRE_CRUISE = 803,
  ScenarioConfig_StageType_YIELD_SIGN_APPROACH = 900,
  ScenarioConfig_StageType_YIELD_SIGN_CREEP = 901
};
bool ScenarioConfig_StageType_IsValid(int value);
const ScenarioConfig_StageType ScenarioConfig_StageType_StageType_MIN = ScenarioConfig_StageType_NO_STAGE;
const ScenarioConfig_StageType ScenarioConfig_StageType_StageType_MAX = ScenarioConfig_StageType_YIELD_SIGN_CREEP;
const int ScenarioConfig_StageType_StageType_ARRAYSIZE = ScenarioConfig_StageType_StageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScenarioConfig_StageType_descriptor();
inline const ::std::string& ScenarioConfig_StageType_Name(ScenarioConfig_StageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScenarioConfig_StageType_descriptor(), value);
}
inline bool ScenarioConfig_StageType_Parse(
    const ::std::string& name, ScenarioConfig_StageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScenarioConfig_StageType>(
    ScenarioConfig_StageType_descriptor(), name, value);
}
enum PlannerType {
  RTK = 0,
  PUBLIC_ROAD = 1,
  NAVI = 2,
  LATTICE = 3
};
bool PlannerType_IsValid(int value);
const PlannerType PlannerType_MIN = RTK;
const PlannerType PlannerType_MAX = LATTICE;
const int PlannerType_ARRAYSIZE = PlannerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlannerType_descriptor();
inline const ::std::string& PlannerType_Name(PlannerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlannerType_descriptor(), value);
}
inline bool PlannerType_Parse(
    const ::std::string& name, PlannerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlannerType>(
    PlannerType_descriptor(), name, value);
}
// ===================================================================

class TaskConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.TaskConfig) */ {
 public:
  TaskConfig();
  virtual ~TaskConfig();

  TaskConfig(const TaskConfig& from);

  inline TaskConfig& operator=(const TaskConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskConfig& default_instance();

  enum TaskConfigCase {
    kSpeedHeuristicConfig = 3,
    kPathDeciderConfig = 7,
    kCreepDeciderConfig = 10,
    kOpenSpacePreStopDeciderConfig = 11,
    kSpeedBoundsDeciderConfig = 15,
    kPiecewiseJerkPathConfig = 16,
    kPathBoundsDeciderConfig = 17,
    kOpenSpaceFallbackDeciderConfig = 18,
    kOpenSpaceRoiDeciderConfig = 19,
    kOpenSpaceTrajectoryProviderConfig = 20,
    kOpenSpaceTrajectoryPartitionConfig = 21,
    kPathAssessmentDeciderConfig = 22,
    kPiecewiseJerkSpeedConfig = 23,
    kPathLaneBorrowDeciderConfig = 24,
    kLaneChangeDeciderConfig = 25,
    kRuleBasedStopDeciderConfig = 26,
    kPathReuseDeciderConfig = 27,
    kStBoundsDeciderConfig = 28,
    kPiecewiseJerkNonlinearSpeedConfig = 29,
    TASK_CONFIG_NOT_SET = 0,
  };

  static inline const TaskConfig* internal_default_instance() {
    return reinterpret_cast<const TaskConfig*>(
               &_TaskConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TaskConfig* other);

  // implements Message ----------------------------------------------

  inline TaskConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskConfig& from);
  void MergeFrom(const TaskConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskConfig_TaskType TaskType;
  static const TaskType DP_ST_SPEED_OPTIMIZER =
    TaskConfig_TaskType_DP_ST_SPEED_OPTIMIZER;
  static const TaskType PATH_DECIDER =
    TaskConfig_TaskType_PATH_DECIDER;
  static const TaskType SPEED_DECIDER =
    TaskConfig_TaskType_SPEED_DECIDER;
  static const TaskType NAVI_PATH_DECIDER =
    TaskConfig_TaskType_NAVI_PATH_DECIDER;
  static const TaskType NAVI_SPEED_DECIDER =
    TaskConfig_TaskType_NAVI_SPEED_DECIDER;
  static const TaskType NAVI_OBSTACLE_DECIDER =
    TaskConfig_TaskType_NAVI_OBSTACLE_DECIDER;
  static const TaskType CREEP_DECIDER =
    TaskConfig_TaskType_CREEP_DECIDER;
  static const TaskType OPEN_SPACE_PRE_STOP_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_PRE_STOP_DECIDER;
  static const TaskType DECIDER_RSS =
    TaskConfig_TaskType_DECIDER_RSS;
  static const TaskType SPEED_BOUNDS_PRIORI_DECIDER =
    TaskConfig_TaskType_SPEED_BOUNDS_PRIORI_DECIDER;
  static const TaskType SPEED_BOUNDS_FINAL_DECIDER =
    TaskConfig_TaskType_SPEED_BOUNDS_FINAL_DECIDER;
  static const TaskType PIECEWISE_JERK_PATH_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_PATH_OPTIMIZER;
  static const TaskType PATH_BOUNDS_DECIDER =
    TaskConfig_TaskType_PATH_BOUNDS_DECIDER;
  static const TaskType OPEN_SPACE_ROI_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_ROI_DECIDER;
  static const TaskType OPEN_SPACE_TRAJECTORY_PROVIDER =
    TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PROVIDER;
  static const TaskType OPEN_SPACE_TRAJECTORY_PARTITION =
    TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PARTITION;
  static const TaskType OPEN_SPACE_FALLBACK_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_FALLBACK_DECIDER;
  static const TaskType PATH_ASSESSMENT_DECIDER =
    TaskConfig_TaskType_PATH_ASSESSMENT_DECIDER;
  static const TaskType PATH_LANE_BORROW_DECIDER =
    TaskConfig_TaskType_PATH_LANE_BORROW_DECIDER;
  static const TaskType PIECEWISE_JERK_SPEED_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_SPEED_OPTIMIZER;
  static const TaskType LANE_CHANGE_DECIDER =
    TaskConfig_TaskType_LANE_CHANGE_DECIDER;
  static const TaskType RULE_BASED_STOP_DECIDER =
    TaskConfig_TaskType_RULE_BASED_STOP_DECIDER;
  static const TaskType PATH_REUSE_DECIDER =
    TaskConfig_TaskType_PATH_REUSE_DECIDER;
  static const TaskType ST_BOUNDS_DECIDER =
    TaskConfig_TaskType_ST_BOUNDS_DECIDER;
  static const TaskType PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER;
  static inline bool TaskType_IsValid(int value) {
    return TaskConfig_TaskType_IsValid(value);
  }
  static const TaskType TaskType_MIN =
    TaskConfig_TaskType_TaskType_MIN;
  static const TaskType TaskType_MAX =
    TaskConfig_TaskType_TaskType_MAX;
  static const int TaskType_ARRAYSIZE =
    TaskConfig_TaskType_TaskType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TaskType_descriptor() {
    return TaskConfig_TaskType_descriptor();
  }
  static inline const ::std::string& TaskType_Name(TaskType value) {
    return TaskConfig_TaskType_Name(value);
  }
  static inline bool TaskType_Parse(const ::std::string& name,
      TaskType* value) {
    return TaskConfig_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
  bool has_task_type() const;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 1;
  ::jmc_auto::planning::TaskConfig_TaskType task_type() const;
  void set_task_type(::jmc_auto::planning::TaskConfig_TaskType value);

  // optional .jmc_auto.planning.SpeedHeuristicConfig speed_heuristic_config = 3;
  bool has_speed_heuristic_config() const;
  void clear_speed_heuristic_config();
  static const int kSpeedHeuristicConfigFieldNumber = 3;
  const ::jmc_auto::planning::SpeedHeuristicConfig& speed_heuristic_config() const;
  ::jmc_auto::planning::SpeedHeuristicConfig* mutable_speed_heuristic_config();
  ::jmc_auto::planning::SpeedHeuristicConfig* release_speed_heuristic_config();
  void set_allocated_speed_heuristic_config(::jmc_auto::planning::SpeedHeuristicConfig* speed_heuristic_config);

  // optional .jmc_auto.planning.PathDeciderConfig path_decider_config = 7;
  bool has_path_decider_config() const;
  void clear_path_decider_config();
  static const int kPathDeciderConfigFieldNumber = 7;
  const ::jmc_auto::planning::PathDeciderConfig& path_decider_config() const;
  ::jmc_auto::planning::PathDeciderConfig* mutable_path_decider_config();
  ::jmc_auto::planning::PathDeciderConfig* release_path_decider_config();
  void set_allocated_path_decider_config(::jmc_auto::planning::PathDeciderConfig* path_decider_config);

  // optional .jmc_auto.planning.CreepDeciderConfig creep_decider_config = 10;
  bool has_creep_decider_config() const;
  void clear_creep_decider_config();
  static const int kCreepDeciderConfigFieldNumber = 10;
  const ::jmc_auto::planning::CreepDeciderConfig& creep_decider_config() const;
  ::jmc_auto::planning::CreepDeciderConfig* mutable_creep_decider_config();
  ::jmc_auto::planning::CreepDeciderConfig* release_creep_decider_config();
  void set_allocated_creep_decider_config(::jmc_auto::planning::CreepDeciderConfig* creep_decider_config);

  // optional .jmc_auto.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
  bool has_open_space_pre_stop_decider_config() const;
  void clear_open_space_pre_stop_decider_config();
  static const int kOpenSpacePreStopDeciderConfigFieldNumber = 11;
  const ::jmc_auto::planning::OpenSpacePreStopDeciderConfig& open_space_pre_stop_decider_config() const;
  ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* mutable_open_space_pre_stop_decider_config();
  ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* release_open_space_pre_stop_decider_config();
  void set_allocated_open_space_pre_stop_decider_config(::jmc_auto::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config);

  // optional .jmc_auto.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
  bool has_speed_bounds_decider_config() const;
  void clear_speed_bounds_decider_config();
  static const int kSpeedBoundsDeciderConfigFieldNumber = 15;
  const ::jmc_auto::planning::SpeedBoundsDeciderConfig& speed_bounds_decider_config() const;
  ::jmc_auto::planning::SpeedBoundsDeciderConfig* mutable_speed_bounds_decider_config();
  ::jmc_auto::planning::SpeedBoundsDeciderConfig* release_speed_bounds_decider_config();
  void set_allocated_speed_bounds_decider_config(::jmc_auto::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config);

  // optional .jmc_auto.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
  bool has_piecewise_jerk_path_config() const;
  void clear_piecewise_jerk_path_config();
  static const int kPiecewiseJerkPathConfigFieldNumber = 16;
  const ::jmc_auto::planning::PiecewiseJerkPathConfig& piecewise_jerk_path_config() const;
  ::jmc_auto::planning::PiecewiseJerkPathConfig* mutable_piecewise_jerk_path_config();
  ::jmc_auto::planning::PiecewiseJerkPathConfig* release_piecewise_jerk_path_config();
  void set_allocated_piecewise_jerk_path_config(::jmc_auto::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config);

  // optional .jmc_auto.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
  bool has_path_bounds_decider_config() const;
  void clear_path_bounds_decider_config();
  static const int kPathBoundsDeciderConfigFieldNumber = 17;
  const ::jmc_auto::planning::PathBoundsDeciderConfig& path_bounds_decider_config() const;
  ::jmc_auto::planning::PathBoundsDeciderConfig* mutable_path_bounds_decider_config();
  ::jmc_auto::planning::PathBoundsDeciderConfig* release_path_bounds_decider_config();
  void set_allocated_path_bounds_decider_config(::jmc_auto::planning::PathBoundsDeciderConfig* path_bounds_decider_config);

  // optional .jmc_auto.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
  bool has_open_space_fallback_decider_config() const;
  void clear_open_space_fallback_decider_config();
  static const int kOpenSpaceFallbackDeciderConfigFieldNumber = 18;
  const ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig& open_space_fallback_decider_config() const;
  ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* mutable_open_space_fallback_decider_config();
  ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* release_open_space_fallback_decider_config();
  void set_allocated_open_space_fallback_decider_config(::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config);

  // optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
  bool has_open_space_roi_decider_config() const;
  void clear_open_space_roi_decider_config();
  static const int kOpenSpaceRoiDeciderConfigFieldNumber = 19;
  const ::jmc_auto::planning::OpenSpaceRoiDeciderConfig& open_space_roi_decider_config() const;
  ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* mutable_open_space_roi_decider_config();
  ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* release_open_space_roi_decider_config();
  void set_allocated_open_space_roi_decider_config(::jmc_auto::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config);

  // optional .jmc_auto.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
  bool has_open_space_trajectory_provider_config() const;
  void clear_open_space_trajectory_provider_config();
  static const int kOpenSpaceTrajectoryProviderConfigFieldNumber = 20;
  const ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig& open_space_trajectory_provider_config() const;
  ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* mutable_open_space_trajectory_provider_config();
  ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* release_open_space_trajectory_provider_config();
  void set_allocated_open_space_trajectory_provider_config(::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config);

  // optional .jmc_auto.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
  bool has_open_space_trajectory_partition_config() const;
  void clear_open_space_trajectory_partition_config();
  static const int kOpenSpaceTrajectoryPartitionConfigFieldNumber = 21;
  const ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig& open_space_trajectory_partition_config() const;
  ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* mutable_open_space_trajectory_partition_config();
  ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* release_open_space_trajectory_partition_config();
  void set_allocated_open_space_trajectory_partition_config(::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config);

  // optional .jmc_auto.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
  bool has_path_assessment_decider_config() const;
  void clear_path_assessment_decider_config();
  static const int kPathAssessmentDeciderConfigFieldNumber = 22;
  const ::jmc_auto::planning::PathAssessmentDeciderConfig& path_assessment_decider_config() const;
  ::jmc_auto::planning::PathAssessmentDeciderConfig* mutable_path_assessment_decider_config();
  ::jmc_auto::planning::PathAssessmentDeciderConfig* release_path_assessment_decider_config();
  void set_allocated_path_assessment_decider_config(::jmc_auto::planning::PathAssessmentDeciderConfig* path_assessment_decider_config);

  // optional .jmc_auto.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
  bool has_piecewise_jerk_speed_config() const;
  void clear_piecewise_jerk_speed_config();
  static const int kPiecewiseJerkSpeedConfigFieldNumber = 23;
  const ::jmc_auto::planning::PiecewiseJerkSpeedConfig& piecewise_jerk_speed_config() const;
  ::jmc_auto::planning::PiecewiseJerkSpeedConfig* mutable_piecewise_jerk_speed_config();
  ::jmc_auto::planning::PiecewiseJerkSpeedConfig* release_piecewise_jerk_speed_config();
  void set_allocated_piecewise_jerk_speed_config(::jmc_auto::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config);

  // optional .jmc_auto.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
  bool has_path_lane_borrow_decider_config() const;
  void clear_path_lane_borrow_decider_config();
  static const int kPathLaneBorrowDeciderConfigFieldNumber = 24;
  const ::jmc_auto::planning::PathLaneBorrowDeciderConfig& path_lane_borrow_decider_config() const;
  ::jmc_auto::planning::PathLaneBorrowDeciderConfig* mutable_path_lane_borrow_decider_config();
  ::jmc_auto::planning::PathLaneBorrowDeciderConfig* release_path_lane_borrow_decider_config();
  void set_allocated_path_lane_borrow_decider_config(::jmc_auto::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config);

  // optional .jmc_auto.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
  bool has_lane_change_decider_config() const;
  void clear_lane_change_decider_config();
  static const int kLaneChangeDeciderConfigFieldNumber = 25;
  const ::jmc_auto::planning::LaneChangeDeciderConfig& lane_change_decider_config() const;
  ::jmc_auto::planning::LaneChangeDeciderConfig* mutable_lane_change_decider_config();
  ::jmc_auto::planning::LaneChangeDeciderConfig* release_lane_change_decider_config();
  void set_allocated_lane_change_decider_config(::jmc_auto::planning::LaneChangeDeciderConfig* lane_change_decider_config);

  // optional .jmc_auto.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
  bool has_rule_based_stop_decider_config() const;
  void clear_rule_based_stop_decider_config();
  static const int kRuleBasedStopDeciderConfigFieldNumber = 26;
  const ::jmc_auto::planning::RuleBasedStopDeciderConfig& rule_based_stop_decider_config() const;
  ::jmc_auto::planning::RuleBasedStopDeciderConfig* mutable_rule_based_stop_decider_config();
  ::jmc_auto::planning::RuleBasedStopDeciderConfig* release_rule_based_stop_decider_config();
  void set_allocated_rule_based_stop_decider_config(::jmc_auto::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config);

  // optional .jmc_auto.planning.PathReuseDeciderConfig path_reuse_decider_config = 27;
  bool has_path_reuse_decider_config() const;
  void clear_path_reuse_decider_config();
  static const int kPathReuseDeciderConfigFieldNumber = 27;
  const ::jmc_auto::planning::PathReuseDeciderConfig& path_reuse_decider_config() const;
  ::jmc_auto::planning::PathReuseDeciderConfig* mutable_path_reuse_decider_config();
  ::jmc_auto::planning::PathReuseDeciderConfig* release_path_reuse_decider_config();
  void set_allocated_path_reuse_decider_config(::jmc_auto::planning::PathReuseDeciderConfig* path_reuse_decider_config);

  // optional .jmc_auto.planning.STBoundsDeciderConfig st_bounds_decider_config = 28;
  bool has_st_bounds_decider_config() const;
  void clear_st_bounds_decider_config();
  static const int kStBoundsDeciderConfigFieldNumber = 28;
  const ::jmc_auto::planning::STBoundsDeciderConfig& st_bounds_decider_config() const;
  ::jmc_auto::planning::STBoundsDeciderConfig* mutable_st_bounds_decider_config();
  ::jmc_auto::planning::STBoundsDeciderConfig* release_st_bounds_decider_config();
  void set_allocated_st_bounds_decider_config(::jmc_auto::planning::STBoundsDeciderConfig* st_bounds_decider_config);

  // optional .jmc_auto.planning.PiecewiseJerkNonlinearSpeedConfig piecewise_jerk_nonlinear_speed_config = 29;
  bool has_piecewise_jerk_nonlinear_speed_config() const;
  void clear_piecewise_jerk_nonlinear_speed_config();
  static const int kPiecewiseJerkNonlinearSpeedConfigFieldNumber = 29;
  const ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig& piecewise_jerk_nonlinear_speed_config() const;
  ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* mutable_piecewise_jerk_nonlinear_speed_config();
  ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* release_piecewise_jerk_nonlinear_speed_config();
  void set_allocated_piecewise_jerk_nonlinear_speed_config(::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* piecewise_jerk_nonlinear_speed_config);

  TaskConfigCase task_config_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.planning.TaskConfig)
 private:
  void set_has_task_type();
  void clear_has_task_type();
  void set_has_speed_heuristic_config();
  void set_has_path_decider_config();
  void set_has_creep_decider_config();
  void set_has_open_space_pre_stop_decider_config();
  void set_has_speed_bounds_decider_config();
  void set_has_piecewise_jerk_path_config();
  void set_has_path_bounds_decider_config();
  void set_has_open_space_fallback_decider_config();
  void set_has_open_space_roi_decider_config();
  void set_has_open_space_trajectory_provider_config();
  void set_has_open_space_trajectory_partition_config();
  void set_has_path_assessment_decider_config();
  void set_has_piecewise_jerk_speed_config();
  void set_has_path_lane_borrow_decider_config();
  void set_has_lane_change_decider_config();
  void set_has_rule_based_stop_decider_config();
  void set_has_path_reuse_decider_config();
  void set_has_st_bounds_decider_config();
  void set_has_piecewise_jerk_nonlinear_speed_config();

  inline bool has_task_config() const;
  void clear_task_config();
  inline void clear_has_task_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int task_type_;
  union TaskConfigUnion {
    TaskConfigUnion() {}
    ::jmc_auto::planning::SpeedHeuristicConfig* speed_heuristic_config_;
    ::jmc_auto::planning::PathDeciderConfig* path_decider_config_;
    ::jmc_auto::planning::CreepDeciderConfig* creep_decider_config_;
    ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config_;
    ::jmc_auto::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config_;
    ::jmc_auto::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config_;
    ::jmc_auto::planning::PathBoundsDeciderConfig* path_bounds_decider_config_;
    ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config_;
    ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config_;
    ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config_;
    ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config_;
    ::jmc_auto::planning::PathAssessmentDeciderConfig* path_assessment_decider_config_;
    ::jmc_auto::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config_;
    ::jmc_auto::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config_;
    ::jmc_auto::planning::LaneChangeDeciderConfig* lane_change_decider_config_;
    ::jmc_auto::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config_;
    ::jmc_auto::planning::PathReuseDeciderConfig* path_reuse_decider_config_;
    ::jmc_auto::planning::STBoundsDeciderConfig* st_bounds_decider_config_;
    ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* piecewise_jerk_nonlinear_speed_config_;
  } task_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioLaneFollowConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioLaneFollowConfig) */ {
 public:
  ScenarioLaneFollowConfig();
  virtual ~ScenarioLaneFollowConfig();

  ScenarioLaneFollowConfig(const ScenarioLaneFollowConfig& from);

  inline ScenarioLaneFollowConfig& operator=(const ScenarioLaneFollowConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioLaneFollowConfig& default_instance();

  static inline const ScenarioLaneFollowConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioLaneFollowConfig*>(
               &_ScenarioLaneFollowConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ScenarioLaneFollowConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioLaneFollowConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioLaneFollowConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioLaneFollowConfig& from);
  void MergeFrom(const ScenarioLaneFollowConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioLaneFollowConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioLaneFollowConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioBareIntersectionUnprotectedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig) */ {
 public:
  ScenarioBareIntersectionUnprotectedConfig();
  virtual ~ScenarioBareIntersectionUnprotectedConfig();

  ScenarioBareIntersectionUnprotectedConfig(const ScenarioBareIntersectionUnprotectedConfig& from);

  inline ScenarioBareIntersectionUnprotectedConfig& operator=(const ScenarioBareIntersectionUnprotectedConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioBareIntersectionUnprotectedConfig& default_instance();

  static inline const ScenarioBareIntersectionUnprotectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioBareIntersectionUnprotectedConfig*>(
               &_ScenarioBareIntersectionUnprotectedConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ScenarioBareIntersectionUnprotectedConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioBareIntersectionUnprotectedConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioBareIntersectionUnprotectedConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioBareIntersectionUnprotectedConfig& from);
  void MergeFrom(const ScenarioBareIntersectionUnprotectedConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioBareIntersectionUnprotectedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_explicit_stop = 2 [default = false];
  bool has_enable_explicit_stop() const;
  void clear_enable_explicit_stop();
  static const int kEnableExplicitStopFieldNumber = 2;
  bool enable_explicit_stop() const;
  void set_enable_explicit_stop(bool value);

  // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
  bool has_start_bare_intersection_scenario_distance() const;
  void clear_start_bare_intersection_scenario_distance();
  static const int kStartBareIntersectionScenarioDistanceFieldNumber = 1;
  double start_bare_intersection_scenario_distance() const;
  void set_start_bare_intersection_scenario_distance(double value);

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double approach_cruise_speed = 4 [default = 6.7056];
  bool has_approach_cruise_speed() const;
  void clear_approach_cruise_speed();
  static const int kApproachCruiseSpeedFieldNumber = 4;
  double approach_cruise_speed() const;
  void set_approach_cruise_speed(double value);

  // optional double stop_distance = 5 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 5;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional float stop_timeout_sec = 6 [default = 8];
  bool has_stop_timeout_sec() const;
  void clear_stop_timeout_sec();
  static const int kStopTimeoutSecFieldNumber = 6;
  float stop_timeout_sec() const;
  void set_stop_timeout_sec(float value);

  // optional float creep_timeout_sec = 7 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 7;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig)
 private:
  void set_has_start_bare_intersection_scenario_distance();
  void clear_has_start_bare_intersection_scenario_distance();
  void set_has_enable_explicit_stop();
  void clear_has_enable_explicit_stop();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_approach_cruise_speed();
  void clear_has_approach_cruise_speed();
  void set_has_stop_distance();
  void clear_has_stop_distance();
  void set_has_stop_timeout_sec();
  void clear_has_stop_timeout_sec();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enable_explicit_stop_;
  double start_bare_intersection_scenario_distance_;
  double min_pass_s_distance_;
  double approach_cruise_speed_;
  double stop_distance_;
  float stop_timeout_sec_;
  float creep_timeout_sec_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioStopSignUnprotectedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioStopSignUnprotectedConfig) */ {
 public:
  ScenarioStopSignUnprotectedConfig();
  virtual ~ScenarioStopSignUnprotectedConfig();

  ScenarioStopSignUnprotectedConfig(const ScenarioStopSignUnprotectedConfig& from);

  inline ScenarioStopSignUnprotectedConfig& operator=(const ScenarioStopSignUnprotectedConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioStopSignUnprotectedConfig& default_instance();

  static inline const ScenarioStopSignUnprotectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioStopSignUnprotectedConfig*>(
               &_ScenarioStopSignUnprotectedConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ScenarioStopSignUnprotectedConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioStopSignUnprotectedConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioStopSignUnprotectedConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioStopSignUnprotectedConfig& from);
  void MergeFrom(const ScenarioStopSignUnprotectedConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioStopSignUnprotectedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float creep_timeout_sec = 7 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 7;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double start_stop_sign_scenario_distance = 1 [default = 5];
  bool has_start_stop_sign_scenario_distance() const;
  void clear_start_stop_sign_scenario_distance();
  static const int kStartStopSignScenarioDistanceFieldNumber = 1;
  double start_stop_sign_scenario_distance() const;
  void set_start_stop_sign_scenario_distance(double value);

  // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
  bool has_watch_vehicle_max_valid_stop_distance() const;
  void clear_watch_vehicle_max_valid_stop_distance();
  static const int kWatchVehicleMaxValidStopDistanceFieldNumber = 2;
  double watch_vehicle_max_valid_stop_distance() const;
  void set_watch_vehicle_max_valid_stop_distance(double value);

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 5 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 5;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional float stop_duration_sec = 4 [default = 1];
  bool has_stop_duration_sec() const;
  void clear_stop_duration_sec();
  static const int kStopDurationSecFieldNumber = 4;
  float stop_duration_sec() const;
  void set_stop_duration_sec(float value);

  // optional float stop_timeout_sec = 6 [default = 8];
  bool has_stop_timeout_sec() const;
  void clear_stop_timeout_sec();
  static const int kStopTimeoutSecFieldNumber = 6;
  float stop_timeout_sec() const;
  void set_stop_timeout_sec(float value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioStopSignUnprotectedConfig)
 private:
  void set_has_start_stop_sign_scenario_distance();
  void clear_has_start_stop_sign_scenario_distance();
  void set_has_watch_vehicle_max_valid_stop_distance();
  void clear_has_watch_vehicle_max_valid_stop_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_stop_duration_sec();
  void clear_has_stop_duration_sec();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_stop_timeout_sec();
  void clear_has_stop_timeout_sec();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float creep_timeout_sec_;
  double start_stop_sign_scenario_distance_;
  double watch_vehicle_max_valid_stop_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  float stop_duration_sec_;
  float stop_timeout_sec_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightProtectedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioTrafficLightProtectedConfig) */ {
 public:
  ScenarioTrafficLightProtectedConfig();
  virtual ~ScenarioTrafficLightProtectedConfig();

  ScenarioTrafficLightProtectedConfig(const ScenarioTrafficLightProtectedConfig& from);

  inline ScenarioTrafficLightProtectedConfig& operator=(const ScenarioTrafficLightProtectedConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTrafficLightProtectedConfig& default_instance();

  static inline const ScenarioTrafficLightProtectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightProtectedConfig*>(
               &_ScenarioTrafficLightProtectedConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ScenarioTrafficLightProtectedConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightProtectedConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioTrafficLightProtectedConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioTrafficLightProtectedConfig& from);
  void MergeFrom(const ScenarioTrafficLightProtectedConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioTrafficLightProtectedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  void clear_start_traffic_light_scenario_distance();
  static const int kStartTrafficLightScenarioDistanceFieldNumber = 1;
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);

  // optional double max_valid_stop_distance = 2 [default = 2];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioTrafficLightProtectedConfig)
 private:
  void set_has_start_traffic_light_scenario_distance();
  void clear_has_start_traffic_light_scenario_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightUnprotectedLeftTurnConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig) */ {
 public:
  ScenarioTrafficLightUnprotectedLeftTurnConfig();
  virtual ~ScenarioTrafficLightUnprotectedLeftTurnConfig();

  ScenarioTrafficLightUnprotectedLeftTurnConfig(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig& operator=(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTrafficLightUnprotectedLeftTurnConfig& default_instance();

  static inline const ScenarioTrafficLightUnprotectedLeftTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightUnprotectedLeftTurnConfig*>(
               &_ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioTrafficLightUnprotectedLeftTurnConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  void MergeFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float creep_timeout_sec = 5 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 5;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  void clear_start_traffic_light_scenario_distance();
  static const int kStartTrafficLightScenarioDistanceFieldNumber = 1;
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);

  // optional double approach_cruise_speed = 2 [default = 2.78];
  bool has_approach_cruise_speed() const;
  void clear_approach_cruise_speed();
  static const int kApproachCruiseSpeedFieldNumber = 2;
  double approach_cruise_speed() const;
  void set_approach_cruise_speed(double value);

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 4 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 4;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double max_adc_speed_before_creep = 6 [default = 5.56];
  bool has_max_adc_speed_before_creep() const;
  void clear_max_adc_speed_before_creep();
  static const int kMaxAdcSpeedBeforeCreepFieldNumber = 6;
  double max_adc_speed_before_creep() const;
  void set_max_adc_speed_before_creep(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
 private:
  void set_has_start_traffic_light_scenario_distance();
  void clear_has_start_traffic_light_scenario_distance();
  void set_has_approach_cruise_speed();
  void clear_has_approach_cruise_speed();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();
  void set_has_max_adc_speed_before_creep();
  void clear_has_max_adc_speed_before_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float creep_timeout_sec_;
  double start_traffic_light_scenario_distance_;
  double approach_cruise_speed_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  double max_adc_speed_before_creep_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightUnprotectedRightTurnConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig) */ {
 public:
  ScenarioTrafficLightUnprotectedRightTurnConfig();
  virtual ~ScenarioTrafficLightUnprotectedRightTurnConfig();

  ScenarioTrafficLightUnprotectedRightTurnConfig(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);

  inline ScenarioTrafficLightUnprotectedRightTurnConfig& operator=(const ScenarioTrafficLightUnprotectedRightTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTrafficLightUnprotectedRightTurnConfig& default_instance();

  static inline const ScenarioTrafficLightUnprotectedRightTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightUnprotectedRightTurnConfig*>(
               &_ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ScenarioTrafficLightUnprotectedRightTurnConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightUnprotectedRightTurnConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioTrafficLightUnprotectedRightTurnConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  void MergeFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioTrafficLightUnprotectedRightTurnConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_right_turn_on_red = 2 [default = false];
  bool has_enable_right_turn_on_red() const;
  void clear_enable_right_turn_on_red();
  static const int kEnableRightTurnOnRedFieldNumber = 2;
  bool enable_right_turn_on_red() const;
  void set_enable_right_turn_on_red(bool value);

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  void clear_start_traffic_light_scenario_distance();
  static const int kStartTrafficLightScenarioDistanceFieldNumber = 1;
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 4 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 4;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
  bool has_red_light_right_turn_stop_duration_sec() const;
  void clear_red_light_right_turn_stop_duration_sec();
  static const int kRedLightRightTurnStopDurationSecFieldNumber = 5;
  float red_light_right_turn_stop_duration_sec() const;
  void set_red_light_right_turn_stop_duration_sec(float value);

  // optional float creep_timeout_sec = 6 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 6;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double max_adc_speed_before_creep = 7 [default = 3];
  bool has_max_adc_speed_before_creep() const;
  void clear_max_adc_speed_before_creep();
  static const int kMaxAdcSpeedBeforeCreepFieldNumber = 7;
  double max_adc_speed_before_creep() const;
  void set_max_adc_speed_before_creep(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
 private:
  void set_has_start_traffic_light_scenario_distance();
  void clear_has_start_traffic_light_scenario_distance();
  void set_has_enable_right_turn_on_red();
  void clear_has_enable_right_turn_on_red();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_red_light_right_turn_stop_duration_sec();
  void clear_has_red_light_right_turn_stop_duration_sec();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();
  void set_has_max_adc_speed_before_creep();
  void clear_has_max_adc_speed_before_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool enable_right_turn_on_red_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  float red_light_right_turn_stop_duration_sec_;
  float creep_timeout_sec_;
  double max_adc_speed_before_creep_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioPullOverConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioPullOverConfig) */ {
 public:
  ScenarioPullOverConfig();
  virtual ~ScenarioPullOverConfig();

  ScenarioPullOverConfig(const ScenarioPullOverConfig& from);

  inline ScenarioPullOverConfig& operator=(const ScenarioPullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioPullOverConfig& default_instance();

  static inline const ScenarioPullOverConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioPullOverConfig*>(
               &_ScenarioPullOverConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ScenarioPullOverConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioPullOverConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioPullOverConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioPullOverConfig& from);
  void MergeFrom(const ScenarioPullOverConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioPullOverConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_pull_over_scenario_distance = 1 [default = 50];
  bool has_start_pull_over_scenario_distance() const;
  void clear_start_pull_over_scenario_distance();
  static const int kStartPullOverScenarioDistanceFieldNumber = 1;
  double start_pull_over_scenario_distance() const;
  void set_start_pull_over_scenario_distance(double value);

  // optional double pull_over_min_distance_buffer = 2 [default = 10];
  bool has_pull_over_min_distance_buffer() const;
  void clear_pull_over_min_distance_buffer();
  static const int kPullOverMinDistanceBufferFieldNumber = 2;
  double pull_over_min_distance_buffer() const;
  void set_pull_over_min_distance_buffer(double value);

  // optional double max_distance_stop_search = 3 [default = 25];
  bool has_max_distance_stop_search() const;
  void clear_max_distance_stop_search();
  static const int kMaxDistanceStopSearchFieldNumber = 3;
  double max_distance_stop_search() const;
  void set_max_distance_stop_search(double value);

  // optional double max_s_error_to_end_point = 4 [default = 0.2];
  bool has_max_s_error_to_end_point() const;
  void clear_max_s_error_to_end_point();
  static const int kMaxSErrorToEndPointFieldNumber = 4;
  double max_s_error_to_end_point() const;
  void set_max_s_error_to_end_point(double value);

  // optional double max_l_error_to_end_point = 5 [default = 0.5];
  bool has_max_l_error_to_end_point() const;
  void clear_max_l_error_to_end_point();
  static const int kMaxLErrorToEndPointFieldNumber = 5;
  double max_l_error_to_end_point() const;
  void set_max_l_error_to_end_point(double value);

  // optional double max_theta_error_to_end_point = 6 [default = 0.2];
  bool has_max_theta_error_to_end_point() const;
  void clear_max_theta_error_to_end_point();
  static const int kMaxThetaErrorToEndPointFieldNumber = 6;
  double max_theta_error_to_end_point() const;
  void set_max_theta_error_to_end_point(double value);

  // optional double max_distance_error_to_end_point = 7 [default = 0.2];
  bool has_max_distance_error_to_end_point() const;
  void clear_max_distance_error_to_end_point();
  static const int kMaxDistanceErrorToEndPointFieldNumber = 7;
  double max_distance_error_to_end_point() const;
  void set_max_distance_error_to_end_point(double value);

  // optional double pass_destination_threshold = 8 [default = 10];
  bool has_pass_destination_threshold() const;
  void clear_pass_destination_threshold();
  static const int kPassDestinationThresholdFieldNumber = 8;
  double pass_destination_threshold() const;
  void set_pass_destination_threshold(double value);

  // optional double max_valid_stop_distance = 9 [default = 1];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 9;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
  bool has_s_distance_to_stop_for_open_space_parking() const;
  void clear_s_distance_to_stop_for_open_space_parking();
  static const int kSDistanceToStopForOpenSpaceParkingFieldNumber = 10;
  double s_distance_to_stop_for_open_space_parking() const;
  void set_s_distance_to_stop_for_open_space_parking(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioPullOverConfig)
 private:
  void set_has_start_pull_over_scenario_distance();
  void clear_has_start_pull_over_scenario_distance();
  void set_has_pull_over_min_distance_buffer();
  void clear_has_pull_over_min_distance_buffer();
  void set_has_max_distance_stop_search();
  void clear_has_max_distance_stop_search();
  void set_has_max_s_error_to_end_point();
  void clear_has_max_s_error_to_end_point();
  void set_has_max_l_error_to_end_point();
  void clear_has_max_l_error_to_end_point();
  void set_has_max_theta_error_to_end_point();
  void clear_has_max_theta_error_to_end_point();
  void set_has_max_distance_error_to_end_point();
  void clear_has_max_distance_error_to_end_point();
  void set_has_pass_destination_threshold();
  void clear_has_pass_destination_threshold();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_s_distance_to_stop_for_open_space_parking();
  void clear_has_s_distance_to_stop_for_open_space_parking();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double start_pull_over_scenario_distance_;
  double pull_over_min_distance_buffer_;
  double max_distance_stop_search_;
  double max_s_error_to_end_point_;
  double max_l_error_to_end_point_;
  double max_theta_error_to_end_point_;
  double max_distance_error_to_end_point_;
  double pass_destination_threshold_;
  double max_valid_stop_distance_;
  double s_distance_to_stop_for_open_space_parking_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioEmergencyPullOverConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioEmergencyPullOverConfig) */ {
 public:
  ScenarioEmergencyPullOverConfig();
  virtual ~ScenarioEmergencyPullOverConfig();

  ScenarioEmergencyPullOverConfig(const ScenarioEmergencyPullOverConfig& from);

  inline ScenarioEmergencyPullOverConfig& operator=(const ScenarioEmergencyPullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioEmergencyPullOverConfig& default_instance();

  static inline const ScenarioEmergencyPullOverConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioEmergencyPullOverConfig*>(
               &_ScenarioEmergencyPullOverConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ScenarioEmergencyPullOverConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioEmergencyPullOverConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioEmergencyPullOverConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioEmergencyPullOverConfig& from);
  void MergeFrom(const ScenarioEmergencyPullOverConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioEmergencyPullOverConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_stop_deceleration = 1 [default = 3];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 1;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double slow_down_deceleration_time = 2 [default = 3];
  bool has_slow_down_deceleration_time() const;
  void clear_slow_down_deceleration_time();
  static const int kSlowDownDecelerationTimeFieldNumber = 2;
  double slow_down_deceleration_time() const;
  void set_slow_down_deceleration_time(double value);

  // optional double target_slow_down_speed = 3 [default = 2.5];
  bool has_target_slow_down_speed() const;
  void clear_target_slow_down_speed();
  static const int kTargetSlowDownSpeedFieldNumber = 3;
  double target_slow_down_speed() const;
  void set_target_slow_down_speed(double value);

  // optional double stop_distance = 4 [default = 1.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 4;
  double stop_distance() const;
  void set_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioEmergencyPullOverConfig)
 private:
  void set_has_max_stop_deceleration();
  void clear_has_max_stop_deceleration();
  void set_has_slow_down_deceleration_time();
  void clear_has_slow_down_deceleration_time();
  void set_has_target_slow_down_speed();
  void clear_has_target_slow_down_speed();
  void set_has_stop_distance();
  void clear_has_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_stop_deceleration_;
  double slow_down_deceleration_time_;
  double target_slow_down_speed_;
  double stop_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioEmergencyStopConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioEmergencyStopConfig) */ {
 public:
  ScenarioEmergencyStopConfig();
  virtual ~ScenarioEmergencyStopConfig();

  ScenarioEmergencyStopConfig(const ScenarioEmergencyStopConfig& from);

  inline ScenarioEmergencyStopConfig& operator=(const ScenarioEmergencyStopConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioEmergencyStopConfig& default_instance();

  static inline const ScenarioEmergencyStopConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioEmergencyStopConfig*>(
               &_ScenarioEmergencyStopConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ScenarioEmergencyStopConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioEmergencyStopConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioEmergencyStopConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioEmergencyStopConfig& from);
  void MergeFrom(const ScenarioEmergencyStopConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioEmergencyStopConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_stop_deceleration = 1 [default = 6];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 1;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 2;
  double stop_distance() const;
  void set_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioEmergencyStopConfig)
 private:
  void set_has_max_stop_deceleration();
  void clear_has_max_stop_deceleration();
  void set_has_stop_distance();
  void clear_has_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_stop_deceleration_;
  double stop_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioValetParkingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioValetParkingConfig) */ {
 public:
  ScenarioValetParkingConfig();
  virtual ~ScenarioValetParkingConfig();

  ScenarioValetParkingConfig(const ScenarioValetParkingConfig& from);

  inline ScenarioValetParkingConfig& operator=(const ScenarioValetParkingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioValetParkingConfig& default_instance();

  static inline const ScenarioValetParkingConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioValetParkingConfig*>(
               &_ScenarioValetParkingConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ScenarioValetParkingConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioValetParkingConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioValetParkingConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioValetParkingConfig& from);
  void MergeFrom(const ScenarioValetParkingConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioValetParkingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double parking_spot_range_to_start = 1 [default = 20];
  bool has_parking_spot_range_to_start() const;
  void clear_parking_spot_range_to_start();
  static const int kParkingSpotRangeToStartFieldNumber = 1;
  double parking_spot_range_to_start() const;
  void set_parking_spot_range_to_start(double value);

  // optional double max_valid_stop_distance = 2 [default = 1];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioValetParkingConfig)
 private:
  void set_has_parking_spot_range_to_start();
  void clear_has_parking_spot_range_to_start();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double parking_spot_range_to_start_;
  double max_valid_stop_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioNarrowStreetUTurnConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig) */ {
 public:
  ScenarioNarrowStreetUTurnConfig();
  virtual ~ScenarioNarrowStreetUTurnConfig();

  ScenarioNarrowStreetUTurnConfig(const ScenarioNarrowStreetUTurnConfig& from);

  inline ScenarioNarrowStreetUTurnConfig& operator=(const ScenarioNarrowStreetUTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioNarrowStreetUTurnConfig& default_instance();

  static inline const ScenarioNarrowStreetUTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioNarrowStreetUTurnConfig*>(
               &_ScenarioNarrowStreetUTurnConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ScenarioNarrowStreetUTurnConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioNarrowStreetUTurnConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioNarrowStreetUTurnConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioNarrowStreetUTurnConfig& from);
  void MergeFrom(const ScenarioNarrowStreetUTurnConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioNarrowStreetUTurnConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioNarrowStreetUTurnConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioParkAndGoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioParkAndGoConfig) */ {
 public:
  ScenarioParkAndGoConfig();
  virtual ~ScenarioParkAndGoConfig();

  ScenarioParkAndGoConfig(const ScenarioParkAndGoConfig& from);

  inline ScenarioParkAndGoConfig& operator=(const ScenarioParkAndGoConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioParkAndGoConfig& default_instance();

  static inline const ScenarioParkAndGoConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioParkAndGoConfig*>(
               &_ScenarioParkAndGoConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ScenarioParkAndGoConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioParkAndGoConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioParkAndGoConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioParkAndGoConfig& from);
  void MergeFrom(const ScenarioParkAndGoConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioParkAndGoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double front_obstacle_buffer = 1 [default = 4];
  bool has_front_obstacle_buffer() const;
  void clear_front_obstacle_buffer();
  static const int kFrontObstacleBufferFieldNumber = 1;
  double front_obstacle_buffer() const;
  void set_front_obstacle_buffer(double value);

  // optional double heading_buffer = 2 [default = 0.5];
  bool has_heading_buffer() const;
  void clear_heading_buffer();
  static const int kHeadingBufferFieldNumber = 2;
  double heading_buffer() const;
  void set_heading_buffer(double value);

  // optional double min_dist_to_dest = 3 [default = 25];
  bool has_min_dist_to_dest() const;
  void clear_min_dist_to_dest();
  static const int kMinDistToDestFieldNumber = 3;
  double min_dist_to_dest() const;
  void set_min_dist_to_dest(double value);

  // optional double max_steering_percentage_when_cruise = 4 [default = 90];
  bool has_max_steering_percentage_when_cruise() const;
  void clear_max_steering_percentage_when_cruise();
  static const int kMaxSteeringPercentageWhenCruiseFieldNumber = 4;
  double max_steering_percentage_when_cruise() const;
  void set_max_steering_percentage_when_cruise(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioParkAndGoConfig)
 private:
  void set_has_front_obstacle_buffer();
  void clear_has_front_obstacle_buffer();
  void set_has_heading_buffer();
  void clear_has_heading_buffer();
  void set_has_min_dist_to_dest();
  void clear_has_min_dist_to_dest();
  void set_has_max_steering_percentage_when_cruise();
  void clear_has_max_steering_percentage_when_cruise();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double front_obstacle_buffer_;
  double heading_buffer_;
  double min_dist_to_dest_;
  double max_steering_percentage_when_cruise_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioYieldSignConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioYieldSignConfig) */ {
 public:
  ScenarioYieldSignConfig();
  virtual ~ScenarioYieldSignConfig();

  ScenarioYieldSignConfig(const ScenarioYieldSignConfig& from);

  inline ScenarioYieldSignConfig& operator=(const ScenarioYieldSignConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioYieldSignConfig& default_instance();

  static inline const ScenarioYieldSignConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioYieldSignConfig*>(
               &_ScenarioYieldSignConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ScenarioYieldSignConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioYieldSignConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioYieldSignConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioYieldSignConfig& from);
  void MergeFrom(const ScenarioYieldSignConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioYieldSignConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float creep_timeout_sec = 4 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 4;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double start_yield_sign_scenario_distance = 1 [default = 10];
  bool has_start_yield_sign_scenario_distance() const;
  void clear_start_yield_sign_scenario_distance();
  static const int kStartYieldSignScenarioDistanceFieldNumber = 1;
  double start_yield_sign_scenario_distance() const;
  void set_start_yield_sign_scenario_distance(double value);

  // optional double max_valid_stop_distance = 2 [default = 4.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioYieldSignConfig)
 private:
  void set_has_start_yield_sign_scenario_distance();
  void clear_has_start_yield_sign_scenario_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float creep_timeout_sec_;
  double start_yield_sign_scenario_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTestLearningModelConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioTestLearningModelConfig) */ {
 public:
  ScenarioTestLearningModelConfig();
  virtual ~ScenarioTestLearningModelConfig();

  ScenarioTestLearningModelConfig(const ScenarioTestLearningModelConfig& from);

  inline ScenarioTestLearningModelConfig& operator=(const ScenarioTestLearningModelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTestLearningModelConfig& default_instance();

  static inline const ScenarioTestLearningModelConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTestLearningModelConfig*>(
               &_ScenarioTestLearningModelConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ScenarioTestLearningModelConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioTestLearningModelConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioTestLearningModelConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioTestLearningModelConfig& from);
  void MergeFrom(const ScenarioTestLearningModelConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioTestLearningModelConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string model_file = 1;
  bool has_model_file() const;
  void clear_model_file();
  static const int kModelFileFieldNumber = 1;
  const ::std::string& model_file() const;
  void set_model_file(const ::std::string& value);
  #if LANG_CXX11
  void set_model_file(::std::string&& value);
  #endif
  void set_model_file(const char* value);
  void set_model_file(const char* value, size_t size);
  ::std::string* mutable_model_file();
  ::std::string* release_model_file();
  void set_allocated_model_file(::std::string* model_file);

  // optional int32 input_feature_num = 2;
  bool has_input_feature_num() const;
  void clear_input_feature_num();
  static const int kInputFeatureNumFieldNumber = 2;
  ::google::protobuf::int32 input_feature_num() const;
  void set_input_feature_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioTestLearningModelConfig)
 private:
  void set_has_model_file();
  void clear_has_model_file();
  void set_has_input_feature_num();
  void clear_has_input_feature_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_file_;
  ::google::protobuf::int32 input_feature_num_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioConfig_StageConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioConfig.StageConfig) */ {
 public:
  ScenarioConfig_StageConfig();
  virtual ~ScenarioConfig_StageConfig();

  ScenarioConfig_StageConfig(const ScenarioConfig_StageConfig& from);

  inline ScenarioConfig_StageConfig& operator=(const ScenarioConfig_StageConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioConfig_StageConfig& default_instance();

  static inline const ScenarioConfig_StageConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig_StageConfig*>(
               &_ScenarioConfig_StageConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ScenarioConfig_StageConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioConfig_StageConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioConfig_StageConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioConfig_StageConfig& from);
  void MergeFrom(const ScenarioConfig_StageConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioConfig_StageConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
  int task_type_size() const;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 3;
  ::jmc_auto::planning::TaskConfig_TaskType task_type(int index) const;
  void set_task_type(int index, ::jmc_auto::planning::TaskConfig_TaskType value);
  void add_task_type(::jmc_auto::planning::TaskConfig_TaskType value);
  const ::google::protobuf::RepeatedField<int>& task_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_task_type();

  // repeated .jmc_auto.planning.TaskConfig task_config = 4;
  int task_config_size() const;
  void clear_task_config();
  static const int kTaskConfigFieldNumber = 4;
  const ::jmc_auto::planning::TaskConfig& task_config(int index) const;
  ::jmc_auto::planning::TaskConfig* mutable_task_config(int index);
  ::jmc_auto::planning::TaskConfig* add_task_config();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >*
      mutable_task_config();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >&
      task_config() const;

  // optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
  bool has_stage_type() const;
  void clear_stage_type();
  static const int kStageTypeFieldNumber = 1;
  ::jmc_auto::planning::ScenarioConfig_StageType stage_type() const;
  void set_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value);

  // optional bool enabled = 2 [default = true];
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioConfig.StageConfig)
 private:
  void set_has_stage_type();
  void clear_has_stage_type();
  void set_has_enabled();
  void clear_has_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> task_type_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig > task_config_;
  int stage_type_;
  bool enabled_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.ScenarioConfig) */ {
 public:
  ScenarioConfig();
  virtual ~ScenarioConfig();

  ScenarioConfig(const ScenarioConfig& from);

  inline ScenarioConfig& operator=(const ScenarioConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioConfig& default_instance();

  enum ScenarioConfigCase {
    kLaneFollowConfig = 2,
    kBareIntersectionUnprotectedConfig = 4,
    kEmergencyPullOverConfig = 5,
    kEmergencyStopConfig = 6,
    kNarrowStreetUTurnConfig = 7,
    kStopSignUnprotectedConfig = 8,
    kTrafficLightProtectedConfig = 9,
    kTrafficLightUnprotectedRightTurnConfig = 10,
    kTrafficLightUnprotectedLeftTurnConfig = 11,
    kParkAndGoConfig = 12,
    kPullOverConfig = 13,
    kValetParkingConfig = 14,
    kYieldSignConfig = 15,
    kTestLearningModelConfig = 18,
    SCENARIO_CONFIG_NOT_SET = 0,
  };

  static inline const ScenarioConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig*>(
               &_ScenarioConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ScenarioConfig* other);

  // implements Message ----------------------------------------------

  inline ScenarioConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ScenarioConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScenarioConfig& from);
  void MergeFrom(const ScenarioConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScenarioConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ScenarioConfig_StageConfig StageConfig;

  typedef ScenarioConfig_ScenarioType ScenarioType;
  static const ScenarioType LANE_FOLLOW =
    ScenarioConfig_ScenarioType_LANE_FOLLOW;
  static const ScenarioType BARE_INTERSECTION_UNPROTECTED =
    ScenarioConfig_ScenarioType_BARE_INTERSECTION_UNPROTECTED;
  static const ScenarioType STOP_SIGN_PROTECTED =
    ScenarioConfig_ScenarioType_STOP_SIGN_PROTECTED;
  static const ScenarioType STOP_SIGN_UNPROTECTED =
    ScenarioConfig_ScenarioType_STOP_SIGN_UNPROTECTED;
  static const ScenarioType TRAFFIC_LIGHT_PROTECTED =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_PROTECTED;
  static const ScenarioType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN;
  static const ScenarioType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN;
  static const ScenarioType YIELD_SIGN =
    ScenarioConfig_ScenarioType_YIELD_SIGN;
  static const ScenarioType PULL_OVER =
    ScenarioConfig_ScenarioType_PULL_OVER;
  static const ScenarioType VALET_PARKING =
    ScenarioConfig_ScenarioType_VALET_PARKING;
  static const ScenarioType EMERGENCY_PULL_OVER =
    ScenarioConfig_ScenarioType_EMERGENCY_PULL_OVER;
  static const ScenarioType EMERGENCY_STOP =
    ScenarioConfig_ScenarioType_EMERGENCY_STOP;
  static const ScenarioType NARROW_STREET_U_TURN =
    ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN;
  static const ScenarioType PARK_AND_GO =
    ScenarioConfig_ScenarioType_PARK_AND_GO;
  static const ScenarioType TEST_LEARNING_MODEL =
    ScenarioConfig_ScenarioType_TEST_LEARNING_MODEL;
  static inline bool ScenarioType_IsValid(int value) {
    return ScenarioConfig_ScenarioType_IsValid(value);
  }
  static const ScenarioType ScenarioType_MIN =
    ScenarioConfig_ScenarioType_ScenarioType_MIN;
  static const ScenarioType ScenarioType_MAX =
    ScenarioConfig_ScenarioType_ScenarioType_MAX;
  static const int ScenarioType_ARRAYSIZE =
    ScenarioConfig_ScenarioType_ScenarioType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScenarioType_descriptor() {
    return ScenarioConfig_ScenarioType_descriptor();
  }
  static inline const ::std::string& ScenarioType_Name(ScenarioType value) {
    return ScenarioConfig_ScenarioType_Name(value);
  }
  static inline bool ScenarioType_Parse(const ::std::string& name,
      ScenarioType* value) {
    return ScenarioConfig_ScenarioType_Parse(name, value);
  }

  typedef ScenarioConfig_StageType StageType;
  static const StageType NO_STAGE =
    ScenarioConfig_StageType_NO_STAGE;
  static const StageType LANE_FOLLOW_DEFAULT_STAGE =
    ScenarioConfig_StageType_LANE_FOLLOW_DEFAULT_STAGE;
  static const StageType BARE_INTERSECTION_UNPROTECTED_APPROACH =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_APPROACH;
  static const StageType BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE;
  static const StageType STOP_SIGN_UNPROTECTED_PRE_STOP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_PRE_STOP;
  static const StageType STOP_SIGN_UNPROTECTED_STOP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_STOP;
  static const StageType STOP_SIGN_UNPROTECTED_CREEP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_CREEP;
  static const StageType STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE;
  static const StageType TRAFFIC_LIGHT_PROTECTED_APPROACH =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_APPROACH;
  static const StageType TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE;
  static const StageType PULL_OVER_APPROACH =
    ScenarioConfig_StageType_PULL_OVER_APPROACH;
  static const StageType PULL_OVER_RETRY_APPROACH_PARKING =
    ScenarioConfig_StageType_PULL_OVER_RETRY_APPROACH_PARKING;
  static const StageType PULL_OVER_RETRY_PARKING =
    ScenarioConfig_StageType_PULL_OVER_RETRY_PARKING;
  static const StageType EMERGENCY_PULL_OVER_SLOW_DOWN =
    ScenarioConfig_StageType_EMERGENCY_PULL_OVER_SLOW_DOWN;
  static const StageType EMERGENCY_PULL_OVER_APPROACH =
    ScenarioConfig_StageType_EMERGENCY_PULL_OVER_APPROACH;
  static const StageType EMERGENCY_PULL_OVER_STANDBY =
    ScenarioConfig_StageType_EMERGENCY_PULL_OVER_STANDBY;
  static const StageType EMERGENCY_STOP_APPROACH =
    ScenarioConfig_StageType_EMERGENCY_STOP_APPROACH;
  static const StageType EMERGENCY_STOP_STANDBY =
    ScenarioConfig_StageType_EMERGENCY_STOP_STANDBY;
  static const StageType VALET_PARKING_APPROACHING_PARKING_SPOT =
    ScenarioConfig_StageType_VALET_PARKING_APPROACHING_PARKING_SPOT;
  static const StageType VALET_PARKING_PARKING =
    ScenarioConfig_StageType_VALET_PARKING_PARKING;
  static const StageType PARK_AND_GO_CHECK =
    ScenarioConfig_StageType_PARK_AND_GO_CHECK;
  static const StageType PARK_AND_GO_CRUISE =
    ScenarioConfig_StageType_PARK_AND_GO_CRUISE;
  static const StageType PARK_AND_GO_ADJUST =
    ScenarioConfig_StageType_PARK_AND_GO_ADJUST;
  static const StageType PARK_AND_GO_PRE_CRUISE =
    ScenarioConfig_StageType_PARK_AND_GO_PRE_CRUISE;
  static const StageType YIELD_SIGN_APPROACH =
    ScenarioConfig_StageType_YIELD_SIGN_APPROACH;
  static const StageType YIELD_SIGN_CREEP =
    ScenarioConfig_StageType_YIELD_SIGN_CREEP;
  static inline bool StageType_IsValid(int value) {
    return ScenarioConfig_StageType_IsValid(value);
  }
  static const StageType StageType_MIN =
    ScenarioConfig_StageType_StageType_MIN;
  static const StageType StageType_MAX =
    ScenarioConfig_StageType_StageType_MAX;
  static const int StageType_ARRAYSIZE =
    ScenarioConfig_StageType_StageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StageType_descriptor() {
    return ScenarioConfig_StageType_descriptor();
  }
  static inline const ::std::string& StageType_Name(StageType value) {
    return ScenarioConfig_StageType_Name(value);
  }
  static inline bool StageType_Parse(const ::std::string& name,
      StageType* value) {
    return ScenarioConfig_StageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
  int stage_type_size() const;
  void clear_stage_type();
  static const int kStageTypeFieldNumber = 16;
  ::jmc_auto::planning::ScenarioConfig_StageType stage_type(int index) const;
  void set_stage_type(int index, ::jmc_auto::planning::ScenarioConfig_StageType value);
  void add_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value);
  const ::google::protobuf::RepeatedField<int>& stage_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_stage_type();

  // repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
  int stage_config_size() const;
  void clear_stage_config();
  static const int kStageConfigFieldNumber = 17;
  const ::jmc_auto::planning::ScenarioConfig_StageConfig& stage_config(int index) const;
  ::jmc_auto::planning::ScenarioConfig_StageConfig* mutable_stage_config(int index);
  ::jmc_auto::planning::ScenarioConfig_StageConfig* add_stage_config();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig >*
      mutable_stage_config();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig >&
      stage_config() const;

  // optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  bool has_scenario_type() const;
  void clear_scenario_type();
  static const int kScenarioTypeFieldNumber = 1;
  ::jmc_auto::planning::ScenarioConfig_ScenarioType scenario_type() const;
  void set_scenario_type(::jmc_auto::planning::ScenarioConfig_ScenarioType value);

  // optional .jmc_auto.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
  bool has_lane_follow_config() const;
  void clear_lane_follow_config();
  static const int kLaneFollowConfigFieldNumber = 2;
  const ::jmc_auto::planning::ScenarioLaneFollowConfig& lane_follow_config() const;
  ::jmc_auto::planning::ScenarioLaneFollowConfig* mutable_lane_follow_config();
  ::jmc_auto::planning::ScenarioLaneFollowConfig* release_lane_follow_config();
  void set_allocated_lane_follow_config(::jmc_auto::planning::ScenarioLaneFollowConfig* lane_follow_config);

  // optional .jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
  bool has_bare_intersection_unprotected_config() const;
  void clear_bare_intersection_unprotected_config();
  static const int kBareIntersectionUnprotectedConfigFieldNumber = 4;
  const ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig& bare_intersection_unprotected_config() const;
  ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* mutable_bare_intersection_unprotected_config();
  ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* release_bare_intersection_unprotected_config();
  void set_allocated_bare_intersection_unprotected_config(::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config);

  // optional .jmc_auto.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 5;
  bool has_emergency_pull_over_config() const;
  void clear_emergency_pull_over_config();
  static const int kEmergencyPullOverConfigFieldNumber = 5;
  const ::jmc_auto::planning::ScenarioEmergencyPullOverConfig& emergency_pull_over_config() const;
  ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* mutable_emergency_pull_over_config();
  ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* release_emergency_pull_over_config();
  void set_allocated_emergency_pull_over_config(::jmc_auto::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config);

  // optional .jmc_auto.planning.ScenarioEmergencyStopConfig emergency_stop_config = 6;
  bool has_emergency_stop_config() const;
  void clear_emergency_stop_config();
  static const int kEmergencyStopConfigFieldNumber = 6;
  const ::jmc_auto::planning::ScenarioEmergencyStopConfig& emergency_stop_config() const;
  ::jmc_auto::planning::ScenarioEmergencyStopConfig* mutable_emergency_stop_config();
  ::jmc_auto::planning::ScenarioEmergencyStopConfig* release_emergency_stop_config();
  void set_allocated_emergency_stop_config(::jmc_auto::planning::ScenarioEmergencyStopConfig* emergency_stop_config);

  // optional .jmc_auto.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
  bool has_narrow_street_u_turn_config() const;
  void clear_narrow_street_u_turn_config();
  static const int kNarrowStreetUTurnConfigFieldNumber = 7;
  const ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig& narrow_street_u_turn_config() const;
  ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* mutable_narrow_street_u_turn_config();
  ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* release_narrow_street_u_turn_config();
  void set_allocated_narrow_street_u_turn_config(::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config);

  // optional .jmc_auto.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 8;
  bool has_stop_sign_unprotected_config() const;
  void clear_stop_sign_unprotected_config();
  static const int kStopSignUnprotectedConfigFieldNumber = 8;
  const ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig& stop_sign_unprotected_config() const;
  ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* mutable_stop_sign_unprotected_config();
  ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* release_stop_sign_unprotected_config();
  void set_allocated_stop_sign_unprotected_config(::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config);

  // optional .jmc_auto.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 9;
  bool has_traffic_light_protected_config() const;
  void clear_traffic_light_protected_config();
  static const int kTrafficLightProtectedConfigFieldNumber = 9;
  const ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig& traffic_light_protected_config() const;
  ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* mutable_traffic_light_protected_config();
  ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* release_traffic_light_protected_config();
  void set_allocated_traffic_light_protected_config(::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config);

  // optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 10;
  bool has_traffic_light_unprotected_right_turn_config() const;
  void clear_traffic_light_unprotected_right_turn_config();
  static const int kTrafficLightUnprotectedRightTurnConfigFieldNumber = 10;
  const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& traffic_light_unprotected_right_turn_config() const;
  ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* mutable_traffic_light_unprotected_right_turn_config();
  ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* release_traffic_light_unprotected_right_turn_config();
  void set_allocated_traffic_light_unprotected_right_turn_config(::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config);

  // optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 11;
  bool has_traffic_light_unprotected_left_turn_config() const;
  void clear_traffic_light_unprotected_left_turn_config();
  static const int kTrafficLightUnprotectedLeftTurnConfigFieldNumber = 11;
  const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& traffic_light_unprotected_left_turn_config() const;
  ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* mutable_traffic_light_unprotected_left_turn_config();
  ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* release_traffic_light_unprotected_left_turn_config();
  void set_allocated_traffic_light_unprotected_left_turn_config(::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config);

  // optional .jmc_auto.planning.ScenarioParkAndGoConfig park_and_go_config = 12;
  bool has_park_and_go_config() const;
  void clear_park_and_go_config();
  static const int kParkAndGoConfigFieldNumber = 12;
  const ::jmc_auto::planning::ScenarioParkAndGoConfig& park_and_go_config() const;
  ::jmc_auto::planning::ScenarioParkAndGoConfig* mutable_park_and_go_config();
  ::jmc_auto::planning::ScenarioParkAndGoConfig* release_park_and_go_config();
  void set_allocated_park_and_go_config(::jmc_auto::planning::ScenarioParkAndGoConfig* park_and_go_config);

  // optional .jmc_auto.planning.ScenarioPullOverConfig pull_over_config = 13;
  bool has_pull_over_config() const;
  void clear_pull_over_config();
  static const int kPullOverConfigFieldNumber = 13;
  const ::jmc_auto::planning::ScenarioPullOverConfig& pull_over_config() const;
  ::jmc_auto::planning::ScenarioPullOverConfig* mutable_pull_over_config();
  ::jmc_auto::planning::ScenarioPullOverConfig* release_pull_over_config();
  void set_allocated_pull_over_config(::jmc_auto::planning::ScenarioPullOverConfig* pull_over_config);

  // optional .jmc_auto.planning.ScenarioValetParkingConfig valet_parking_config = 14;
  bool has_valet_parking_config() const;
  void clear_valet_parking_config();
  static const int kValetParkingConfigFieldNumber = 14;
  const ::jmc_auto::planning::ScenarioValetParkingConfig& valet_parking_config() const;
  ::jmc_auto::planning::ScenarioValetParkingConfig* mutable_valet_parking_config();
  ::jmc_auto::planning::ScenarioValetParkingConfig* release_valet_parking_config();
  void set_allocated_valet_parking_config(::jmc_auto::planning::ScenarioValetParkingConfig* valet_parking_config);

  // optional .jmc_auto.planning.ScenarioYieldSignConfig yield_sign_config = 15;
  bool has_yield_sign_config() const;
  void clear_yield_sign_config();
  static const int kYieldSignConfigFieldNumber = 15;
  const ::jmc_auto::planning::ScenarioYieldSignConfig& yield_sign_config() const;
  ::jmc_auto::planning::ScenarioYieldSignConfig* mutable_yield_sign_config();
  ::jmc_auto::planning::ScenarioYieldSignConfig* release_yield_sign_config();
  void set_allocated_yield_sign_config(::jmc_auto::planning::ScenarioYieldSignConfig* yield_sign_config);

  // optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
  bool has_test_learning_model_config() const;
  void clear_test_learning_model_config();
  static const int kTestLearningModelConfigFieldNumber = 18;
  const ::jmc_auto::planning::ScenarioTestLearningModelConfig& test_learning_model_config() const;
  ::jmc_auto::planning::ScenarioTestLearningModelConfig* mutable_test_learning_model_config();
  ::jmc_auto::planning::ScenarioTestLearningModelConfig* release_test_learning_model_config();
  void set_allocated_test_learning_model_config(::jmc_auto::planning::ScenarioTestLearningModelConfig* test_learning_model_config);

  ScenarioConfigCase scenario_config_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.planning.ScenarioConfig)
 private:
  void set_has_scenario_type();
  void clear_has_scenario_type();
  void set_has_lane_follow_config();
  void set_has_bare_intersection_unprotected_config();
  void set_has_emergency_pull_over_config();
  void set_has_emergency_stop_config();
  void set_has_narrow_street_u_turn_config();
  void set_has_stop_sign_unprotected_config();
  void set_has_traffic_light_protected_config();
  void set_has_traffic_light_unprotected_right_turn_config();
  void set_has_traffic_light_unprotected_left_turn_config();
  void set_has_park_and_go_config();
  void set_has_pull_over_config();
  void set_has_valet_parking_config();
  void set_has_yield_sign_config();
  void set_has_test_learning_model_config();

  inline bool has_scenario_config() const;
  void clear_scenario_config();
  inline void clear_has_scenario_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> stage_type_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig > stage_config_;
  int scenario_type_;
  union ScenarioConfigUnion {
    ScenarioConfigUnion() {}
    ::jmc_auto::planning::ScenarioLaneFollowConfig* lane_follow_config_;
    ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config_;
    ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config_;
    ::jmc_auto::planning::ScenarioEmergencyStopConfig* emergency_stop_config_;
    ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config_;
    ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config_;
    ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config_;
    ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config_;
    ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config_;
    ::jmc_auto::planning::ScenarioParkAndGoConfig* park_and_go_config_;
    ::jmc_auto::planning::ScenarioPullOverConfig* pull_over_config_;
    ::jmc_auto::planning::ScenarioValetParkingConfig* valet_parking_config_;
    ::jmc_auto::planning::ScenarioYieldSignConfig* yield_sign_config_;
    ::jmc_auto::planning::ScenarioTestLearningModelConfig* test_learning_model_config_;
  } scenario_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlannerPublicRoadConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PlannerPublicRoadConfig) */ {
 public:
  PlannerPublicRoadConfig();
  virtual ~PlannerPublicRoadConfig();

  PlannerPublicRoadConfig(const PlannerPublicRoadConfig& from);

  inline PlannerPublicRoadConfig& operator=(const PlannerPublicRoadConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerPublicRoadConfig& default_instance();

  static inline const PlannerPublicRoadConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerPublicRoadConfig*>(
               &_PlannerPublicRoadConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(PlannerPublicRoadConfig* other);

  // implements Message ----------------------------------------------

  inline PlannerPublicRoadConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlannerPublicRoadConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlannerPublicRoadConfig& from);
  void MergeFrom(const PlannerPublicRoadConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlannerPublicRoadConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PlannerPublicRoadConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlannerNaviConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PlannerNaviConfig) */ {
 public:
  PlannerNaviConfig();
  virtual ~PlannerNaviConfig();

  PlannerNaviConfig(const PlannerNaviConfig& from);

  inline PlannerNaviConfig& operator=(const PlannerNaviConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerNaviConfig& default_instance();

  static inline const PlannerNaviConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerNaviConfig*>(
               &_PlannerNaviConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(PlannerNaviConfig* other);

  // implements Message ----------------------------------------------

  inline PlannerNaviConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlannerNaviConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlannerNaviConfig& from);
  void MergeFrom(const PlannerNaviConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlannerNaviConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
  int task_size() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  ::jmc_auto::planning::TaskConfig_TaskType task(int index) const;
  void set_task(int index, ::jmc_auto::planning::TaskConfig_TaskType value);
  void add_task(::jmc_auto::planning::TaskConfig_TaskType value);
  const ::google::protobuf::RepeatedField<int>& task() const;
  ::google::protobuf::RepeatedField<int>* mutable_task();

  // optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
  bool has_navi_path_decider_config() const;
  void clear_navi_path_decider_config();
  static const int kNaviPathDeciderConfigFieldNumber = 2;
  const ::jmc_auto::planning::NaviPathDeciderConfig& navi_path_decider_config() const;
  ::jmc_auto::planning::NaviPathDeciderConfig* mutable_navi_path_decider_config();
  ::jmc_auto::planning::NaviPathDeciderConfig* release_navi_path_decider_config();
  void set_allocated_navi_path_decider_config(::jmc_auto::planning::NaviPathDeciderConfig* navi_path_decider_config);

  // optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
  bool has_navi_speed_decider_config() const;
  void clear_navi_speed_decider_config();
  static const int kNaviSpeedDeciderConfigFieldNumber = 3;
  const ::jmc_auto::planning::NaviSpeedDeciderConfig& navi_speed_decider_config() const;
  ::jmc_auto::planning::NaviSpeedDeciderConfig* mutable_navi_speed_decider_config();
  ::jmc_auto::planning::NaviSpeedDeciderConfig* release_navi_speed_decider_config();
  void set_allocated_navi_speed_decider_config(::jmc_auto::planning::NaviSpeedDeciderConfig* navi_speed_decider_config);

  // optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
  bool has_navi_obstacle_decider_config() const;
  void clear_navi_obstacle_decider_config();
  static const int kNaviObstacleDeciderConfigFieldNumber = 4;
  const ::jmc_auto::planning::NaviObstacleDeciderConfig& navi_obstacle_decider_config() const;
  ::jmc_auto::planning::NaviObstacleDeciderConfig* mutable_navi_obstacle_decider_config();
  ::jmc_auto::planning::NaviObstacleDeciderConfig* release_navi_obstacle_decider_config();
  void set_allocated_navi_obstacle_decider_config(::jmc_auto::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PlannerNaviConfig)
 private:
  void set_has_navi_path_decider_config();
  void clear_has_navi_path_decider_config();
  void set_has_navi_speed_decider_config();
  void clear_has_navi_speed_decider_config();
  void set_has_navi_obstacle_decider_config();
  void clear_has_navi_obstacle_decider_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> task_;
  ::jmc_auto::planning::NaviPathDeciderConfig* navi_path_decider_config_;
  ::jmc_auto::planning::NaviSpeedDeciderConfig* navi_speed_decider_config_;
  ::jmc_auto::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RtkPlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.RtkPlanningConfig) */ {
 public:
  RtkPlanningConfig();
  virtual ~RtkPlanningConfig();

  RtkPlanningConfig(const RtkPlanningConfig& from);

  inline RtkPlanningConfig& operator=(const RtkPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtkPlanningConfig& default_instance();

  static inline const RtkPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const RtkPlanningConfig*>(
               &_RtkPlanningConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RtkPlanningConfig* other);

  // implements Message ----------------------------------------------

  inline RtkPlanningConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  RtkPlanningConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RtkPlanningConfig& from);
  void MergeFrom(const RtkPlanningConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RtkPlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.planning.PlannerType planner_type = 1;
  bool has_planner_type() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::jmc_auto::planning::PlannerType planner_type() const;
  void set_planner_type(::jmc_auto::planning::PlannerType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.RtkPlanningConfig)
 private:
  void set_has_planner_type();
  void clear_has_planner_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int planner_type_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StandardPlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.StandardPlanningConfig) */ {
 public:
  StandardPlanningConfig();
  virtual ~StandardPlanningConfig();

  StandardPlanningConfig(const StandardPlanningConfig& from);

  inline StandardPlanningConfig& operator=(const StandardPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StandardPlanningConfig& default_instance();

  static inline const StandardPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const StandardPlanningConfig*>(
               &_StandardPlanningConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(StandardPlanningConfig* other);

  // implements Message ----------------------------------------------

  inline StandardPlanningConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  StandardPlanningConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StandardPlanningConfig& from);
  void MergeFrom(const StandardPlanningConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StandardPlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  int planner_type_size() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::jmc_auto::planning::PlannerType planner_type(int index) const;
  void set_planner_type(int index, ::jmc_auto::planning::PlannerType value);
  void add_planner_type(::jmc_auto::planning::PlannerType value);
  const ::google::protobuf::RepeatedField<int>& planner_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_planner_type();

  // optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
  bool has_planner_public_road_config() const;
  void clear_planner_public_road_config();
  static const int kPlannerPublicRoadConfigFieldNumber = 2;
  const ::jmc_auto::planning::PlannerPublicRoadConfig& planner_public_road_config() const;
  ::jmc_auto::planning::PlannerPublicRoadConfig* mutable_planner_public_road_config();
  ::jmc_auto::planning::PlannerPublicRoadConfig* release_planner_public_road_config();
  void set_allocated_planner_public_road_config(::jmc_auto::planning::PlannerPublicRoadConfig* planner_public_road_config);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.StandardPlanningConfig)
 private:
  void set_has_planner_public_road_config();
  void clear_has_planner_public_road_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> planner_type_;
  ::jmc_auto::planning::PlannerPublicRoadConfig* planner_public_road_config_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavigationPlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.NavigationPlanningConfig) */ {
 public:
  NavigationPlanningConfig();
  virtual ~NavigationPlanningConfig();

  NavigationPlanningConfig(const NavigationPlanningConfig& from);

  inline NavigationPlanningConfig& operator=(const NavigationPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationPlanningConfig& default_instance();

  static inline const NavigationPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const NavigationPlanningConfig*>(
               &_NavigationPlanningConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(NavigationPlanningConfig* other);

  // implements Message ----------------------------------------------

  inline NavigationPlanningConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  NavigationPlanningConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavigationPlanningConfig& from);
  void MergeFrom(const NavigationPlanningConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavigationPlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.PlannerType planner_type = 1;
  int planner_type_size() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::jmc_auto::planning::PlannerType planner_type(int index) const;
  void set_planner_type(int index, ::jmc_auto::planning::PlannerType value);
  void add_planner_type(::jmc_auto::planning::PlannerType value);
  const ::google::protobuf::RepeatedField<int>& planner_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_planner_type();

  // optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
  bool has_planner_navi_config() const;
  void clear_planner_navi_config();
  static const int kPlannerNaviConfigFieldNumber = 4;
  const ::jmc_auto::planning::PlannerNaviConfig& planner_navi_config() const;
  ::jmc_auto::planning::PlannerNaviConfig* mutable_planner_navi_config();
  ::jmc_auto::planning::PlannerNaviConfig* release_planner_navi_config();
  void set_allocated_planner_navi_config(::jmc_auto::planning::PlannerNaviConfig* planner_navi_config);

  // @@protoc_insertion_point(class_scope:jmc_auto.planning.NavigationPlanningConfig)
 private:
  void set_has_planner_navi_config();
  void clear_has_planner_navi_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> planner_type_;
  ::jmc_auto::planning::PlannerNaviConfig* planner_navi_config_;
  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.planning.PlanningConfig) */ {
 public:
  PlanningConfig();
  virtual ~PlanningConfig();

  PlanningConfig(const PlanningConfig& from);

  inline PlanningConfig& operator=(const PlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningConfig& default_instance();

  enum PlanningConfigCase {
    kRtkPlanningConfig = 1,
    kStandardPlanningConfig = 2,
    kNavigationPlanningConfig = 3,
    PLANNING_CONFIG_NOT_SET = 0,
  };

  static inline const PlanningConfig* internal_default_instance() {
    return reinterpret_cast<const PlanningConfig*>(
               &_PlanningConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(PlanningConfig* other);

  // implements Message ----------------------------------------------

  inline PlanningConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningConfig& from);
  void MergeFrom(const PlanningConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
  int default_task_config_size() const;
  void clear_default_task_config();
  static const int kDefaultTaskConfigFieldNumber = 5;
  const ::jmc_auto::planning::TaskConfig& default_task_config(int index) const;
  ::jmc_auto::planning::TaskConfig* mutable_default_task_config(int index);
  ::jmc_auto::planning::TaskConfig* add_default_task_config();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >*
      mutable_default_task_config();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >&
      default_task_config() const;

  // optional .jmc_auto.planning.RtkPlanningConfig rtk_planning_config = 1;
  bool has_rtk_planning_config() const;
  void clear_rtk_planning_config();
  static const int kRtkPlanningConfigFieldNumber = 1;
  const ::jmc_auto::planning::RtkPlanningConfig& rtk_planning_config() const;
  ::jmc_auto::planning::RtkPlanningConfig* mutable_rtk_planning_config();
  ::jmc_auto::planning::RtkPlanningConfig* release_rtk_planning_config();
  void set_allocated_rtk_planning_config(::jmc_auto::planning::RtkPlanningConfig* rtk_planning_config);

  // optional .jmc_auto.planning.StandardPlanningConfig standard_planning_config = 2;
  bool has_standard_planning_config() const;
  void clear_standard_planning_config();
  static const int kStandardPlanningConfigFieldNumber = 2;
  const ::jmc_auto::planning::StandardPlanningConfig& standard_planning_config() const;
  ::jmc_auto::planning::StandardPlanningConfig* mutable_standard_planning_config();
  ::jmc_auto::planning::StandardPlanningConfig* release_standard_planning_config();
  void set_allocated_standard_planning_config(::jmc_auto::planning::StandardPlanningConfig* standard_planning_config);

  // optional .jmc_auto.planning.NavigationPlanningConfig navigation_planning_config = 3;
  bool has_navigation_planning_config() const;
  void clear_navigation_planning_config();
  static const int kNavigationPlanningConfigFieldNumber = 3;
  const ::jmc_auto::planning::NavigationPlanningConfig& navigation_planning_config() const;
  ::jmc_auto::planning::NavigationPlanningConfig* mutable_navigation_planning_config();
  ::jmc_auto::planning::NavigationPlanningConfig* release_navigation_planning_config();
  void set_allocated_navigation_planning_config(::jmc_auto::planning::NavigationPlanningConfig* navigation_planning_config);

  PlanningConfigCase planning_config_case() const;
  // @@protoc_insertion_point(class_scope:jmc_auto.planning.PlanningConfig)
 private:
  void set_has_rtk_planning_config();
  void set_has_standard_planning_config();
  void set_has_navigation_planning_config();

  inline bool has_planning_config() const;
  void clear_planning_config();
  inline void clear_has_planning_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig > default_task_config_;
  union PlanningConfigUnion {
    PlanningConfigUnion() {}
    ::jmc_auto::planning::RtkPlanningConfig* rtk_planning_config_;
    ::jmc_auto::planning::StandardPlanningConfig* standard_planning_config_;
    ::jmc_auto::planning::NavigationPlanningConfig* navigation_planning_config_;
  } planning_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TaskConfig

// optional .jmc_auto.planning.TaskConfig.TaskType task_type = 1;
inline bool TaskConfig::has_task_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskConfig::set_has_task_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskConfig::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskConfig::clear_task_type() {
  task_type_ = 1;
  clear_has_task_type();
}
inline ::jmc_auto::planning::TaskConfig_TaskType TaskConfig::task_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.task_type)
  return static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(task_type_);
}
inline void TaskConfig::set_task_type(::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  set_has_task_type();
  task_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.TaskConfig.task_type)
}

// optional .jmc_auto.planning.SpeedHeuristicConfig speed_heuristic_config = 3;
inline bool TaskConfig::has_speed_heuristic_config() const {
  return task_config_case() == kSpeedHeuristicConfig;
}
inline void TaskConfig::set_has_speed_heuristic_config() {
  _oneof_case_[0] = kSpeedHeuristicConfig;
}
inline void TaskConfig::clear_speed_heuristic_config() {
  if (has_speed_heuristic_config()) {
    delete task_config_.speed_heuristic_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::SpeedHeuristicConfig& TaskConfig::speed_heuristic_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.speed_heuristic_config)
  return has_speed_heuristic_config()
      ? *task_config_.speed_heuristic_config_
      : ::jmc_auto::planning::SpeedHeuristicConfig::default_instance();
}
inline ::jmc_auto::planning::SpeedHeuristicConfig* TaskConfig::mutable_speed_heuristic_config() {
  if (!has_speed_heuristic_config()) {
    clear_task_config();
    set_has_speed_heuristic_config();
    task_config_.speed_heuristic_config_ = new ::jmc_auto::planning::SpeedHeuristicConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.speed_heuristic_config)
  return task_config_.speed_heuristic_config_;
}
inline ::jmc_auto::planning::SpeedHeuristicConfig* TaskConfig::release_speed_heuristic_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.speed_heuristic_config)
  if (has_speed_heuristic_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::SpeedHeuristicConfig* temp = task_config_.speed_heuristic_config_;
    task_config_.speed_heuristic_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_speed_heuristic_config(::jmc_auto::planning::SpeedHeuristicConfig* speed_heuristic_config) {
  clear_task_config();
  if (speed_heuristic_config) {
    set_has_speed_heuristic_config();
    task_config_.speed_heuristic_config_ = speed_heuristic_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.speed_heuristic_config)
}

// optional .jmc_auto.planning.PathDeciderConfig path_decider_config = 7;
inline bool TaskConfig::has_path_decider_config() const {
  return task_config_case() == kPathDeciderConfig;
}
inline void TaskConfig::set_has_path_decider_config() {
  _oneof_case_[0] = kPathDeciderConfig;
}
inline void TaskConfig::clear_path_decider_config() {
  if (has_path_decider_config()) {
    delete task_config_.path_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PathDeciderConfig& TaskConfig::path_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_decider_config)
  return has_path_decider_config()
      ? *task_config_.path_decider_config_
      : ::jmc_auto::planning::PathDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::PathDeciderConfig* TaskConfig::mutable_path_decider_config() {
  if (!has_path_decider_config()) {
    clear_task_config();
    set_has_path_decider_config();
    task_config_.path_decider_config_ = new ::jmc_auto::planning::PathDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_decider_config)
  return task_config_.path_decider_config_;
}
inline ::jmc_auto::planning::PathDeciderConfig* TaskConfig::release_path_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_decider_config)
  if (has_path_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathDeciderConfig* temp = task_config_.path_decider_config_;
    task_config_.path_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_path_decider_config(::jmc_auto::planning::PathDeciderConfig* path_decider_config) {
  clear_task_config();
  if (path_decider_config) {
    set_has_path_decider_config();
    task_config_.path_decider_config_ = path_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_decider_config)
}

// optional .jmc_auto.planning.CreepDeciderConfig creep_decider_config = 10;
inline bool TaskConfig::has_creep_decider_config() const {
  return task_config_case() == kCreepDeciderConfig;
}
inline void TaskConfig::set_has_creep_decider_config() {
  _oneof_case_[0] = kCreepDeciderConfig;
}
inline void TaskConfig::clear_creep_decider_config() {
  if (has_creep_decider_config()) {
    delete task_config_.creep_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::CreepDeciderConfig& TaskConfig::creep_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.creep_decider_config)
  return has_creep_decider_config()
      ? *task_config_.creep_decider_config_
      : ::jmc_auto::planning::CreepDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::CreepDeciderConfig* TaskConfig::mutable_creep_decider_config() {
  if (!has_creep_decider_config()) {
    clear_task_config();
    set_has_creep_decider_config();
    task_config_.creep_decider_config_ = new ::jmc_auto::planning::CreepDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.creep_decider_config)
  return task_config_.creep_decider_config_;
}
inline ::jmc_auto::planning::CreepDeciderConfig* TaskConfig::release_creep_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.creep_decider_config)
  if (has_creep_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::CreepDeciderConfig* temp = task_config_.creep_decider_config_;
    task_config_.creep_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_creep_decider_config(::jmc_auto::planning::CreepDeciderConfig* creep_decider_config) {
  clear_task_config();
  if (creep_decider_config) {
    set_has_creep_decider_config();
    task_config_.creep_decider_config_ = creep_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.creep_decider_config)
}

// optional .jmc_auto.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 11;
inline bool TaskConfig::has_open_space_pre_stop_decider_config() const {
  return task_config_case() == kOpenSpacePreStopDeciderConfig;
}
inline void TaskConfig::set_has_open_space_pre_stop_decider_config() {
  _oneof_case_[0] = kOpenSpacePreStopDeciderConfig;
}
inline void TaskConfig::clear_open_space_pre_stop_decider_config() {
  if (has_open_space_pre_stop_decider_config()) {
    delete task_config_.open_space_pre_stop_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::OpenSpacePreStopDeciderConfig& TaskConfig::open_space_pre_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
  return has_open_space_pre_stop_decider_config()
      ? *task_config_.open_space_pre_stop_decider_config_
      : ::jmc_auto::planning::OpenSpacePreStopDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* TaskConfig::mutable_open_space_pre_stop_decider_config() {
  if (!has_open_space_pre_stop_decider_config()) {
    clear_task_config();
    set_has_open_space_pre_stop_decider_config();
    task_config_.open_space_pre_stop_decider_config_ = new ::jmc_auto::planning::OpenSpacePreStopDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
  return task_config_.open_space_pre_stop_decider_config_;
}
inline ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* TaskConfig::release_open_space_pre_stop_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
  if (has_open_space_pre_stop_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpacePreStopDeciderConfig* temp = task_config_.open_space_pre_stop_decider_config_;
    task_config_.open_space_pre_stop_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_open_space_pre_stop_decider_config(::jmc_auto::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config) {
  clear_task_config();
  if (open_space_pre_stop_decider_config) {
    set_has_open_space_pre_stop_decider_config();
    task_config_.open_space_pre_stop_decider_config_ = open_space_pre_stop_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_pre_stop_decider_config)
}

// optional .jmc_auto.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 15;
inline bool TaskConfig::has_speed_bounds_decider_config() const {
  return task_config_case() == kSpeedBoundsDeciderConfig;
}
inline void TaskConfig::set_has_speed_bounds_decider_config() {
  _oneof_case_[0] = kSpeedBoundsDeciderConfig;
}
inline void TaskConfig::clear_speed_bounds_decider_config() {
  if (has_speed_bounds_decider_config()) {
    delete task_config_.speed_bounds_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::SpeedBoundsDeciderConfig& TaskConfig::speed_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
  return has_speed_bounds_decider_config()
      ? *task_config_.speed_bounds_decider_config_
      : ::jmc_auto::planning::SpeedBoundsDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::SpeedBoundsDeciderConfig* TaskConfig::mutable_speed_bounds_decider_config() {
  if (!has_speed_bounds_decider_config()) {
    clear_task_config();
    set_has_speed_bounds_decider_config();
    task_config_.speed_bounds_decider_config_ = new ::jmc_auto::planning::SpeedBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
  return task_config_.speed_bounds_decider_config_;
}
inline ::jmc_auto::planning::SpeedBoundsDeciderConfig* TaskConfig::release_speed_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
  if (has_speed_bounds_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::SpeedBoundsDeciderConfig* temp = task_config_.speed_bounds_decider_config_;
    task_config_.speed_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_speed_bounds_decider_config(::jmc_auto::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config) {
  clear_task_config();
  if (speed_bounds_decider_config) {
    set_has_speed_bounds_decider_config();
    task_config_.speed_bounds_decider_config_ = speed_bounds_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.speed_bounds_decider_config)
}

// optional .jmc_auto.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 16;
inline bool TaskConfig::has_piecewise_jerk_path_config() const {
  return task_config_case() == kPiecewiseJerkPathConfig;
}
inline void TaskConfig::set_has_piecewise_jerk_path_config() {
  _oneof_case_[0] = kPiecewiseJerkPathConfig;
}
inline void TaskConfig::clear_piecewise_jerk_path_config() {
  if (has_piecewise_jerk_path_config()) {
    delete task_config_.piecewise_jerk_path_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PiecewiseJerkPathConfig& TaskConfig::piecewise_jerk_path_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
  return has_piecewise_jerk_path_config()
      ? *task_config_.piecewise_jerk_path_config_
      : ::jmc_auto::planning::PiecewiseJerkPathConfig::default_instance();
}
inline ::jmc_auto::planning::PiecewiseJerkPathConfig* TaskConfig::mutable_piecewise_jerk_path_config() {
  if (!has_piecewise_jerk_path_config()) {
    clear_task_config();
    set_has_piecewise_jerk_path_config();
    task_config_.piecewise_jerk_path_config_ = new ::jmc_auto::planning::PiecewiseJerkPathConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
  return task_config_.piecewise_jerk_path_config_;
}
inline ::jmc_auto::planning::PiecewiseJerkPathConfig* TaskConfig::release_piecewise_jerk_path_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
  if (has_piecewise_jerk_path_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PiecewiseJerkPathConfig* temp = task_config_.piecewise_jerk_path_config_;
    task_config_.piecewise_jerk_path_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_piecewise_jerk_path_config(::jmc_auto::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config) {
  clear_task_config();
  if (piecewise_jerk_path_config) {
    set_has_piecewise_jerk_path_config();
    task_config_.piecewise_jerk_path_config_ = piecewise_jerk_path_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.piecewise_jerk_path_config)
}

// optional .jmc_auto.planning.PathBoundsDeciderConfig path_bounds_decider_config = 17;
inline bool TaskConfig::has_path_bounds_decider_config() const {
  return task_config_case() == kPathBoundsDeciderConfig;
}
inline void TaskConfig::set_has_path_bounds_decider_config() {
  _oneof_case_[0] = kPathBoundsDeciderConfig;
}
inline void TaskConfig::clear_path_bounds_decider_config() {
  if (has_path_bounds_decider_config()) {
    delete task_config_.path_bounds_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PathBoundsDeciderConfig& TaskConfig::path_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
  return has_path_bounds_decider_config()
      ? *task_config_.path_bounds_decider_config_
      : ::jmc_auto::planning::PathBoundsDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::PathBoundsDeciderConfig* TaskConfig::mutable_path_bounds_decider_config() {
  if (!has_path_bounds_decider_config()) {
    clear_task_config();
    set_has_path_bounds_decider_config();
    task_config_.path_bounds_decider_config_ = new ::jmc_auto::planning::PathBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
  return task_config_.path_bounds_decider_config_;
}
inline ::jmc_auto::planning::PathBoundsDeciderConfig* TaskConfig::release_path_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
  if (has_path_bounds_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathBoundsDeciderConfig* temp = task_config_.path_bounds_decider_config_;
    task_config_.path_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_path_bounds_decider_config(::jmc_auto::planning::PathBoundsDeciderConfig* path_bounds_decider_config) {
  clear_task_config();
  if (path_bounds_decider_config) {
    set_has_path_bounds_decider_config();
    task_config_.path_bounds_decider_config_ = path_bounds_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_bounds_decider_config)
}

// optional .jmc_auto.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 18;
inline bool TaskConfig::has_open_space_fallback_decider_config() const {
  return task_config_case() == kOpenSpaceFallbackDeciderConfig;
}
inline void TaskConfig::set_has_open_space_fallback_decider_config() {
  _oneof_case_[0] = kOpenSpaceFallbackDeciderConfig;
}
inline void TaskConfig::clear_open_space_fallback_decider_config() {
  if (has_open_space_fallback_decider_config()) {
    delete task_config_.open_space_fallback_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig& TaskConfig::open_space_fallback_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
  return has_open_space_fallback_decider_config()
      ? *task_config_.open_space_fallback_decider_config_
      : ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::mutable_open_space_fallback_decider_config() {
  if (!has_open_space_fallback_decider_config()) {
    clear_task_config();
    set_has_open_space_fallback_decider_config();
    task_config_.open_space_fallback_decider_config_ = new ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
  return task_config_.open_space_fallback_decider_config_;
}
inline ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::release_open_space_fallback_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
  if (has_open_space_fallback_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* temp = task_config_.open_space_fallback_decider_config_;
    task_config_.open_space_fallback_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_open_space_fallback_decider_config(::jmc_auto::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config) {
  clear_task_config();
  if (open_space_fallback_decider_config) {
    set_has_open_space_fallback_decider_config();
    task_config_.open_space_fallback_decider_config_ = open_space_fallback_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_fallback_decider_config)
}

// optional .jmc_auto.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 19;
inline bool TaskConfig::has_open_space_roi_decider_config() const {
  return task_config_case() == kOpenSpaceRoiDeciderConfig;
}
inline void TaskConfig::set_has_open_space_roi_decider_config() {
  _oneof_case_[0] = kOpenSpaceRoiDeciderConfig;
}
inline void TaskConfig::clear_open_space_roi_decider_config() {
  if (has_open_space_roi_decider_config()) {
    delete task_config_.open_space_roi_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::OpenSpaceRoiDeciderConfig& TaskConfig::open_space_roi_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
  return has_open_space_roi_decider_config()
      ? *task_config_.open_space_roi_decider_config_
      : ::jmc_auto::planning::OpenSpaceRoiDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* TaskConfig::mutable_open_space_roi_decider_config() {
  if (!has_open_space_roi_decider_config()) {
    clear_task_config();
    set_has_open_space_roi_decider_config();
    task_config_.open_space_roi_decider_config_ = new ::jmc_auto::planning::OpenSpaceRoiDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
  return task_config_.open_space_roi_decider_config_;
}
inline ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* TaskConfig::release_open_space_roi_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
  if (has_open_space_roi_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceRoiDeciderConfig* temp = task_config_.open_space_roi_decider_config_;
    task_config_.open_space_roi_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_open_space_roi_decider_config(::jmc_auto::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config) {
  clear_task_config();
  if (open_space_roi_decider_config) {
    set_has_open_space_roi_decider_config();
    task_config_.open_space_roi_decider_config_ = open_space_roi_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_roi_decider_config)
}

// optional .jmc_auto.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 20;
inline bool TaskConfig::has_open_space_trajectory_provider_config() const {
  return task_config_case() == kOpenSpaceTrajectoryProviderConfig;
}
inline void TaskConfig::set_has_open_space_trajectory_provider_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryProviderConfig;
}
inline void TaskConfig::clear_open_space_trajectory_provider_config() {
  if (has_open_space_trajectory_provider_config()) {
    delete task_config_.open_space_trajectory_provider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig& TaskConfig::open_space_trajectory_provider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
  return has_open_space_trajectory_provider_config()
      ? *task_config_.open_space_trajectory_provider_config_
      : ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig::default_instance();
}
inline ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::mutable_open_space_trajectory_provider_config() {
  if (!has_open_space_trajectory_provider_config()) {
    clear_task_config();
    set_has_open_space_trajectory_provider_config();
    task_config_.open_space_trajectory_provider_config_ = new ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
  return task_config_.open_space_trajectory_provider_config_;
}
inline ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::release_open_space_trajectory_provider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
  if (has_open_space_trajectory_provider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* temp = task_config_.open_space_trajectory_provider_config_;
    task_config_.open_space_trajectory_provider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_open_space_trajectory_provider_config(::jmc_auto::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config) {
  clear_task_config();
  if (open_space_trajectory_provider_config) {
    set_has_open_space_trajectory_provider_config();
    task_config_.open_space_trajectory_provider_config_ = open_space_trajectory_provider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_trajectory_provider_config)
}

// optional .jmc_auto.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 21;
inline bool TaskConfig::has_open_space_trajectory_partition_config() const {
  return task_config_case() == kOpenSpaceTrajectoryPartitionConfig;
}
inline void TaskConfig::set_has_open_space_trajectory_partition_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryPartitionConfig;
}
inline void TaskConfig::clear_open_space_trajectory_partition_config() {
  if (has_open_space_trajectory_partition_config()) {
    delete task_config_.open_space_trajectory_partition_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig& TaskConfig::open_space_trajectory_partition_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
  return has_open_space_trajectory_partition_config()
      ? *task_config_.open_space_trajectory_partition_config_
      : ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig::default_instance();
}
inline ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::mutable_open_space_trajectory_partition_config() {
  if (!has_open_space_trajectory_partition_config()) {
    clear_task_config();
    set_has_open_space_trajectory_partition_config();
    task_config_.open_space_trajectory_partition_config_ = new ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
  return task_config_.open_space_trajectory_partition_config_;
}
inline ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::release_open_space_trajectory_partition_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
  if (has_open_space_trajectory_partition_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* temp = task_config_.open_space_trajectory_partition_config_;
    task_config_.open_space_trajectory_partition_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_open_space_trajectory_partition_config(::jmc_auto::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config) {
  clear_task_config();
  if (open_space_trajectory_partition_config) {
    set_has_open_space_trajectory_partition_config();
    task_config_.open_space_trajectory_partition_config_ = open_space_trajectory_partition_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.open_space_trajectory_partition_config)
}

// optional .jmc_auto.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 22;
inline bool TaskConfig::has_path_assessment_decider_config() const {
  return task_config_case() == kPathAssessmentDeciderConfig;
}
inline void TaskConfig::set_has_path_assessment_decider_config() {
  _oneof_case_[0] = kPathAssessmentDeciderConfig;
}
inline void TaskConfig::clear_path_assessment_decider_config() {
  if (has_path_assessment_decider_config()) {
    delete task_config_.path_assessment_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PathAssessmentDeciderConfig& TaskConfig::path_assessment_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
  return has_path_assessment_decider_config()
      ? *task_config_.path_assessment_decider_config_
      : ::jmc_auto::planning::PathAssessmentDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::PathAssessmentDeciderConfig* TaskConfig::mutable_path_assessment_decider_config() {
  if (!has_path_assessment_decider_config()) {
    clear_task_config();
    set_has_path_assessment_decider_config();
    task_config_.path_assessment_decider_config_ = new ::jmc_auto::planning::PathAssessmentDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
  return task_config_.path_assessment_decider_config_;
}
inline ::jmc_auto::planning::PathAssessmentDeciderConfig* TaskConfig::release_path_assessment_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
  if (has_path_assessment_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathAssessmentDeciderConfig* temp = task_config_.path_assessment_decider_config_;
    task_config_.path_assessment_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_path_assessment_decider_config(::jmc_auto::planning::PathAssessmentDeciderConfig* path_assessment_decider_config) {
  clear_task_config();
  if (path_assessment_decider_config) {
    set_has_path_assessment_decider_config();
    task_config_.path_assessment_decider_config_ = path_assessment_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_assessment_decider_config)
}

// optional .jmc_auto.planning.PiecewiseJerkSpeedConfig piecewise_jerk_speed_config = 23;
inline bool TaskConfig::has_piecewise_jerk_speed_config() const {
  return task_config_case() == kPiecewiseJerkSpeedConfig;
}
inline void TaskConfig::set_has_piecewise_jerk_speed_config() {
  _oneof_case_[0] = kPiecewiseJerkSpeedConfig;
}
inline void TaskConfig::clear_piecewise_jerk_speed_config() {
  if (has_piecewise_jerk_speed_config()) {
    delete task_config_.piecewise_jerk_speed_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PiecewiseJerkSpeedConfig& TaskConfig::piecewise_jerk_speed_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
  return has_piecewise_jerk_speed_config()
      ? *task_config_.piecewise_jerk_speed_config_
      : ::jmc_auto::planning::PiecewiseJerkSpeedConfig::default_instance();
}
inline ::jmc_auto::planning::PiecewiseJerkSpeedConfig* TaskConfig::mutable_piecewise_jerk_speed_config() {
  if (!has_piecewise_jerk_speed_config()) {
    clear_task_config();
    set_has_piecewise_jerk_speed_config();
    task_config_.piecewise_jerk_speed_config_ = new ::jmc_auto::planning::PiecewiseJerkSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
  return task_config_.piecewise_jerk_speed_config_;
}
inline ::jmc_auto::planning::PiecewiseJerkSpeedConfig* TaskConfig::release_piecewise_jerk_speed_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
  if (has_piecewise_jerk_speed_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PiecewiseJerkSpeedConfig* temp = task_config_.piecewise_jerk_speed_config_;
    task_config_.piecewise_jerk_speed_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_piecewise_jerk_speed_config(::jmc_auto::planning::PiecewiseJerkSpeedConfig* piecewise_jerk_speed_config) {
  clear_task_config();
  if (piecewise_jerk_speed_config) {
    set_has_piecewise_jerk_speed_config();
    task_config_.piecewise_jerk_speed_config_ = piecewise_jerk_speed_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.piecewise_jerk_speed_config)
}

// optional .jmc_auto.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 24;
inline bool TaskConfig::has_path_lane_borrow_decider_config() const {
  return task_config_case() == kPathLaneBorrowDeciderConfig;
}
inline void TaskConfig::set_has_path_lane_borrow_decider_config() {
  _oneof_case_[0] = kPathLaneBorrowDeciderConfig;
}
inline void TaskConfig::clear_path_lane_borrow_decider_config() {
  if (has_path_lane_borrow_decider_config()) {
    delete task_config_.path_lane_borrow_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PathLaneBorrowDeciderConfig& TaskConfig::path_lane_borrow_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
  return has_path_lane_borrow_decider_config()
      ? *task_config_.path_lane_borrow_decider_config_
      : ::jmc_auto::planning::PathLaneBorrowDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::PathLaneBorrowDeciderConfig* TaskConfig::mutable_path_lane_borrow_decider_config() {
  if (!has_path_lane_borrow_decider_config()) {
    clear_task_config();
    set_has_path_lane_borrow_decider_config();
    task_config_.path_lane_borrow_decider_config_ = new ::jmc_auto::planning::PathLaneBorrowDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
  return task_config_.path_lane_borrow_decider_config_;
}
inline ::jmc_auto::planning::PathLaneBorrowDeciderConfig* TaskConfig::release_path_lane_borrow_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
  if (has_path_lane_borrow_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathLaneBorrowDeciderConfig* temp = task_config_.path_lane_borrow_decider_config_;
    task_config_.path_lane_borrow_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_path_lane_borrow_decider_config(::jmc_auto::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config) {
  clear_task_config();
  if (path_lane_borrow_decider_config) {
    set_has_path_lane_borrow_decider_config();
    task_config_.path_lane_borrow_decider_config_ = path_lane_borrow_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_lane_borrow_decider_config)
}

// optional .jmc_auto.planning.LaneChangeDeciderConfig lane_change_decider_config = 25;
inline bool TaskConfig::has_lane_change_decider_config() const {
  return task_config_case() == kLaneChangeDeciderConfig;
}
inline void TaskConfig::set_has_lane_change_decider_config() {
  _oneof_case_[0] = kLaneChangeDeciderConfig;
}
inline void TaskConfig::clear_lane_change_decider_config() {
  if (has_lane_change_decider_config()) {
    delete task_config_.lane_change_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::LaneChangeDeciderConfig& TaskConfig::lane_change_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.lane_change_decider_config)
  return has_lane_change_decider_config()
      ? *task_config_.lane_change_decider_config_
      : ::jmc_auto::planning::LaneChangeDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::LaneChangeDeciderConfig* TaskConfig::mutable_lane_change_decider_config() {
  if (!has_lane_change_decider_config()) {
    clear_task_config();
    set_has_lane_change_decider_config();
    task_config_.lane_change_decider_config_ = new ::jmc_auto::planning::LaneChangeDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.lane_change_decider_config)
  return task_config_.lane_change_decider_config_;
}
inline ::jmc_auto::planning::LaneChangeDeciderConfig* TaskConfig::release_lane_change_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.lane_change_decider_config)
  if (has_lane_change_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::LaneChangeDeciderConfig* temp = task_config_.lane_change_decider_config_;
    task_config_.lane_change_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_lane_change_decider_config(::jmc_auto::planning::LaneChangeDeciderConfig* lane_change_decider_config) {
  clear_task_config();
  if (lane_change_decider_config) {
    set_has_lane_change_decider_config();
    task_config_.lane_change_decider_config_ = lane_change_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.lane_change_decider_config)
}

// optional .jmc_auto.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 26;
inline bool TaskConfig::has_rule_based_stop_decider_config() const {
  return task_config_case() == kRuleBasedStopDeciderConfig;
}
inline void TaskConfig::set_has_rule_based_stop_decider_config() {
  _oneof_case_[0] = kRuleBasedStopDeciderConfig;
}
inline void TaskConfig::clear_rule_based_stop_decider_config() {
  if (has_rule_based_stop_decider_config()) {
    delete task_config_.rule_based_stop_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::RuleBasedStopDeciderConfig& TaskConfig::rule_based_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
  return has_rule_based_stop_decider_config()
      ? *task_config_.rule_based_stop_decider_config_
      : ::jmc_auto::planning::RuleBasedStopDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::RuleBasedStopDeciderConfig* TaskConfig::mutable_rule_based_stop_decider_config() {
  if (!has_rule_based_stop_decider_config()) {
    clear_task_config();
    set_has_rule_based_stop_decider_config();
    task_config_.rule_based_stop_decider_config_ = new ::jmc_auto::planning::RuleBasedStopDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
  return task_config_.rule_based_stop_decider_config_;
}
inline ::jmc_auto::planning::RuleBasedStopDeciderConfig* TaskConfig::release_rule_based_stop_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
  if (has_rule_based_stop_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::RuleBasedStopDeciderConfig* temp = task_config_.rule_based_stop_decider_config_;
    task_config_.rule_based_stop_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_rule_based_stop_decider_config(::jmc_auto::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config) {
  clear_task_config();
  if (rule_based_stop_decider_config) {
    set_has_rule_based_stop_decider_config();
    task_config_.rule_based_stop_decider_config_ = rule_based_stop_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.rule_based_stop_decider_config)
}

// optional .jmc_auto.planning.PathReuseDeciderConfig path_reuse_decider_config = 27;
inline bool TaskConfig::has_path_reuse_decider_config() const {
  return task_config_case() == kPathReuseDeciderConfig;
}
inline void TaskConfig::set_has_path_reuse_decider_config() {
  _oneof_case_[0] = kPathReuseDeciderConfig;
}
inline void TaskConfig::clear_path_reuse_decider_config() {
  if (has_path_reuse_decider_config()) {
    delete task_config_.path_reuse_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PathReuseDeciderConfig& TaskConfig::path_reuse_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
  return has_path_reuse_decider_config()
      ? *task_config_.path_reuse_decider_config_
      : ::jmc_auto::planning::PathReuseDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::PathReuseDeciderConfig* TaskConfig::mutable_path_reuse_decider_config() {
  if (!has_path_reuse_decider_config()) {
    clear_task_config();
    set_has_path_reuse_decider_config();
    task_config_.path_reuse_decider_config_ = new ::jmc_auto::planning::PathReuseDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
  return task_config_.path_reuse_decider_config_;
}
inline ::jmc_auto::planning::PathReuseDeciderConfig* TaskConfig::release_path_reuse_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
  if (has_path_reuse_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PathReuseDeciderConfig* temp = task_config_.path_reuse_decider_config_;
    task_config_.path_reuse_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_path_reuse_decider_config(::jmc_auto::planning::PathReuseDeciderConfig* path_reuse_decider_config) {
  clear_task_config();
  if (path_reuse_decider_config) {
    set_has_path_reuse_decider_config();
    task_config_.path_reuse_decider_config_ = path_reuse_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.path_reuse_decider_config)
}

// optional .jmc_auto.planning.STBoundsDeciderConfig st_bounds_decider_config = 28;
inline bool TaskConfig::has_st_bounds_decider_config() const {
  return task_config_case() == kStBoundsDeciderConfig;
}
inline void TaskConfig::set_has_st_bounds_decider_config() {
  _oneof_case_[0] = kStBoundsDeciderConfig;
}
inline void TaskConfig::clear_st_bounds_decider_config() {
  if (has_st_bounds_decider_config()) {
    delete task_config_.st_bounds_decider_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::STBoundsDeciderConfig& TaskConfig::st_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
  return has_st_bounds_decider_config()
      ? *task_config_.st_bounds_decider_config_
      : ::jmc_auto::planning::STBoundsDeciderConfig::default_instance();
}
inline ::jmc_auto::planning::STBoundsDeciderConfig* TaskConfig::mutable_st_bounds_decider_config() {
  if (!has_st_bounds_decider_config()) {
    clear_task_config();
    set_has_st_bounds_decider_config();
    task_config_.st_bounds_decider_config_ = new ::jmc_auto::planning::STBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
  return task_config_.st_bounds_decider_config_;
}
inline ::jmc_auto::planning::STBoundsDeciderConfig* TaskConfig::release_st_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
  if (has_st_bounds_decider_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::STBoundsDeciderConfig* temp = task_config_.st_bounds_decider_config_;
    task_config_.st_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_st_bounds_decider_config(::jmc_auto::planning::STBoundsDeciderConfig* st_bounds_decider_config) {
  clear_task_config();
  if (st_bounds_decider_config) {
    set_has_st_bounds_decider_config();
    task_config_.st_bounds_decider_config_ = st_bounds_decider_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.st_bounds_decider_config)
}

// optional .jmc_auto.planning.PiecewiseJerkNonlinearSpeedConfig piecewise_jerk_nonlinear_speed_config = 29;
inline bool TaskConfig::has_piecewise_jerk_nonlinear_speed_config() const {
  return task_config_case() == kPiecewiseJerkNonlinearSpeedConfig;
}
inline void TaskConfig::set_has_piecewise_jerk_nonlinear_speed_config() {
  _oneof_case_[0] = kPiecewiseJerkNonlinearSpeedConfig;
}
inline void TaskConfig::clear_piecewise_jerk_nonlinear_speed_config() {
  if (has_piecewise_jerk_nonlinear_speed_config()) {
    delete task_config_.piecewise_jerk_nonlinear_speed_config_;
    clear_has_task_config();
  }
}
inline  const ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig& TaskConfig::piecewise_jerk_nonlinear_speed_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
  return has_piecewise_jerk_nonlinear_speed_config()
      ? *task_config_.piecewise_jerk_nonlinear_speed_config_
      : ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig::default_instance();
}
inline ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* TaskConfig::mutable_piecewise_jerk_nonlinear_speed_config() {
  if (!has_piecewise_jerk_nonlinear_speed_config()) {
    clear_task_config();
    set_has_piecewise_jerk_nonlinear_speed_config();
    task_config_.piecewise_jerk_nonlinear_speed_config_ = new ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
  return task_config_.piecewise_jerk_nonlinear_speed_config_;
}
inline ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* TaskConfig::release_piecewise_jerk_nonlinear_speed_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
  if (has_piecewise_jerk_nonlinear_speed_config()) {
    clear_has_task_config();
    ::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* temp = task_config_.piecewise_jerk_nonlinear_speed_config_;
    task_config_.piecewise_jerk_nonlinear_speed_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TaskConfig::set_allocated_piecewise_jerk_nonlinear_speed_config(::jmc_auto::planning::PiecewiseJerkNonlinearSpeedConfig* piecewise_jerk_nonlinear_speed_config) {
  clear_task_config();
  if (piecewise_jerk_nonlinear_speed_config) {
    set_has_piecewise_jerk_nonlinear_speed_config();
    task_config_.piecewise_jerk_nonlinear_speed_config_ = piecewise_jerk_nonlinear_speed_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.TaskConfig.piecewise_jerk_nonlinear_speed_config)
}

inline bool TaskConfig::has_task_config() const {
  return task_config_case() != TASK_CONFIG_NOT_SET;
}
inline void TaskConfig::clear_has_task_config() {
  _oneof_case_[0] = TASK_CONFIG_NOT_SET;
}
inline TaskConfig::TaskConfigCase TaskConfig::task_config_case() const {
  return TaskConfig::TaskConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ScenarioLaneFollowConfig

// -------------------------------------------------------------------

// ScenarioBareIntersectionUnprotectedConfig

// optional double start_bare_intersection_scenario_distance = 1 [default = 25];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_start_bare_intersection_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_start_bare_intersection_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_start_bare_intersection_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_start_bare_intersection_scenario_distance() {
  start_bare_intersection_scenario_distance_ = 25;
  clear_has_start_bare_intersection_scenario_distance();
}
inline double ScenarioBareIntersectionUnprotectedConfig::start_bare_intersection_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
  return start_bare_intersection_scenario_distance_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_start_bare_intersection_scenario_distance(double value) {
  set_has_start_bare_intersection_scenario_distance();
  start_bare_intersection_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
}

// optional bool enable_explicit_stop = 2 [default = false];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_enable_explicit_stop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_enable_explicit_stop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_enable_explicit_stop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_enable_explicit_stop() {
  enable_explicit_stop_ = false;
  clear_has_enable_explicit_stop();
}
inline bool ScenarioBareIntersectionUnprotectedConfig::enable_explicit_stop() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
  return enable_explicit_stop_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_enable_explicit_stop(bool value) {
  set_has_enable_explicit_stop();
  enable_explicit_stop_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioBareIntersectionUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
}

// optional double approach_cruise_speed = 4 [default = 6.7056];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_approach_cruise_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_approach_cruise_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_approach_cruise_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_approach_cruise_speed() {
  approach_cruise_speed_ = 6.7056;
  clear_has_approach_cruise_speed();
}
inline double ScenarioBareIntersectionUnprotectedConfig::approach_cruise_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.approach_cruise_speed)
  return approach_cruise_speed_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_approach_cruise_speed(double value) {
  set_has_approach_cruise_speed();
  approach_cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.approach_cruise_speed)
}

// optional double stop_distance = 5 [default = 0.5];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double ScenarioBareIntersectionUnprotectedConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
  return stop_distance_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_stop_timeout_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_stop_timeout_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_stop_timeout_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  clear_has_stop_timeout_sec();
}
inline float ScenarioBareIntersectionUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
  return stop_timeout_sec_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_stop_timeout_sec(float value) {
  set_has_stop_timeout_sec();
  stop_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioBareIntersectionUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioStopSignUnprotectedConfig

// optional double start_stop_sign_scenario_distance = 1 [default = 5];
inline bool ScenarioStopSignUnprotectedConfig::has_start_stop_sign_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_start_stop_sign_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_start_stop_sign_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_start_stop_sign_scenario_distance() {
  start_stop_sign_scenario_distance_ = 5;
  clear_has_start_stop_sign_scenario_distance();
}
inline double ScenarioStopSignUnprotectedConfig::start_stop_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
  return start_stop_sign_scenario_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_start_stop_sign_scenario_distance(double value) {
  set_has_start_stop_sign_scenario_distance();
  start_stop_sign_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
}

// optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
inline bool ScenarioStopSignUnprotectedConfig::has_watch_vehicle_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_watch_vehicle_max_valid_stop_distance() {
  watch_vehicle_max_valid_stop_distance_ = 5;
  clear_has_watch_vehicle_max_valid_stop_distance();
}
inline double ScenarioStopSignUnprotectedConfig::watch_vehicle_max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
  return watch_vehicle_max_valid_stop_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_watch_vehicle_max_valid_stop_distance(double value) {
  set_has_watch_vehicle_max_valid_stop_distance();
  watch_vehicle_max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioStopSignUnprotectedConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioStopSignUnprotectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
}

// optional float stop_duration_sec = 4 [default = 1];
inline bool ScenarioStopSignUnprotectedConfig::has_stop_duration_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_stop_duration_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_stop_duration_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_stop_duration_sec() {
  stop_duration_sec_ = 1;
  clear_has_stop_duration_sec();
}
inline float ScenarioStopSignUnprotectedConfig::stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
  return stop_duration_sec_;
}
inline void ScenarioStopSignUnprotectedConfig::set_stop_duration_sec(float value) {
  set_has_stop_duration_sec();
  stop_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
}

// optional double min_pass_s_distance = 5 [default = 3];
inline bool ScenarioStopSignUnprotectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioStopSignUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
inline bool ScenarioStopSignUnprotectedConfig::has_stop_timeout_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_stop_timeout_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_stop_timeout_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  clear_has_stop_timeout_sec();
}
inline float ScenarioStopSignUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
  return stop_timeout_sec_;
}
inline void ScenarioStopSignUnprotectedConfig::set_stop_timeout_sec(float value) {
  set_has_stop_timeout_sec();
  stop_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
inline bool ScenarioStopSignUnprotectedConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioStopSignUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioStopSignUnprotectedConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightProtectedConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightProtectedConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTrafficLightProtectedConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
inline double ScenarioTrafficLightProtectedConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
inline void ScenarioTrafficLightProtectedConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 2];
inline bool ScenarioTrafficLightProtectedConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTrafficLightProtectedConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 2;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioTrafficLightProtectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioTrafficLightProtectedConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioTrafficLightProtectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioTrafficLightProtectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioTrafficLightProtectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioTrafficLightProtectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightUnprotectedLeftTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
}

// optional double approach_cruise_speed = 2 [default = 2.78];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_approach_cruise_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_approach_cruise_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_approach_cruise_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_approach_cruise_speed() {
  approach_cruise_speed_ = 2.78;
  clear_has_approach_cruise_speed();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::approach_cruise_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.approach_cruise_speed)
  return approach_cruise_speed_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_approach_cruise_speed(double value) {
  set_has_approach_cruise_speed();
  approach_cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.approach_cruise_speed)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 4 [default = 3];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 5 [default = 10];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioTrafficLightUnprotectedLeftTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
}

// optional double max_adc_speed_before_creep = 6 [default = 5.56];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_adc_speed_before_creep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_max_adc_speed_before_creep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_max_adc_speed_before_creep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_adc_speed_before_creep() {
  max_adc_speed_before_creep_ = 5.56;
  clear_has_max_adc_speed_before_creep();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_adc_speed_before_creep() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_speed_before_creep)
  return max_adc_speed_before_creep_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_adc_speed_before_creep(double value) {
  set_has_max_adc_speed_before_creep();
  max_adc_speed_before_creep_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_speed_before_creep)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightUnprotectedRightTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
}

// optional bool enable_right_turn_on_red = 2 [default = false];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_enable_right_turn_on_red() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_enable_right_turn_on_red() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_enable_right_turn_on_red() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_enable_right_turn_on_red() {
  enable_right_turn_on_red_ = false;
  clear_has_enable_right_turn_on_red();
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::enable_right_turn_on_red() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
  return enable_right_turn_on_red_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_enable_right_turn_on_red(bool value) {
  set_has_enable_right_turn_on_red();
  enable_right_turn_on_red_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 4 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
}

// optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_red_light_right_turn_stop_duration_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_red_light_right_turn_stop_duration_sec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_red_light_right_turn_stop_duration_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_red_light_right_turn_stop_duration_sec() {
  red_light_right_turn_stop_duration_sec_ = 3;
  clear_has_red_light_right_turn_stop_duration_sec();
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::red_light_right_turn_stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
  return red_light_right_turn_stop_duration_sec_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_red_light_right_turn_stop_duration_sec(float value) {
  set_has_red_light_right_turn_stop_duration_sec();
  red_light_right_turn_stop_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
}

// optional float creep_timeout_sec = 6 [default = 10];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
}

// optional double max_adc_speed_before_creep = 7 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_adc_speed_before_creep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_max_adc_speed_before_creep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_max_adc_speed_before_creep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_adc_speed_before_creep() {
  max_adc_speed_before_creep_ = 3;
  clear_has_max_adc_speed_before_creep();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::max_adc_speed_before_creep() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_speed_before_creep)
  return max_adc_speed_before_creep_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_adc_speed_before_creep(double value) {
  set_has_max_adc_speed_before_creep();
  max_adc_speed_before_creep_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_speed_before_creep)
}

// -------------------------------------------------------------------

// ScenarioPullOverConfig

// optional double start_pull_over_scenario_distance = 1 [default = 50];
inline bool ScenarioPullOverConfig::has_start_pull_over_scenario_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioPullOverConfig::set_has_start_pull_over_scenario_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioPullOverConfig::clear_has_start_pull_over_scenario_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioPullOverConfig::clear_start_pull_over_scenario_distance() {
  start_pull_over_scenario_distance_ = 50;
  clear_has_start_pull_over_scenario_distance();
}
inline double ScenarioPullOverConfig::start_pull_over_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
  return start_pull_over_scenario_distance_;
}
inline void ScenarioPullOverConfig::set_start_pull_over_scenario_distance(double value) {
  set_has_start_pull_over_scenario_distance();
  start_pull_over_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
}

// optional double pull_over_min_distance_buffer = 2 [default = 10];
inline bool ScenarioPullOverConfig::has_pull_over_min_distance_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioPullOverConfig::set_has_pull_over_min_distance_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioPullOverConfig::clear_has_pull_over_min_distance_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioPullOverConfig::clear_pull_over_min_distance_buffer() {
  pull_over_min_distance_buffer_ = 10;
  clear_has_pull_over_min_distance_buffer();
}
inline double ScenarioPullOverConfig::pull_over_min_distance_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
  return pull_over_min_distance_buffer_;
}
inline void ScenarioPullOverConfig::set_pull_over_min_distance_buffer(double value) {
  set_has_pull_over_min_distance_buffer();
  pull_over_min_distance_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
}

// optional double max_distance_stop_search = 3 [default = 25];
inline bool ScenarioPullOverConfig::has_max_distance_stop_search() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_distance_stop_search() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioPullOverConfig::clear_has_max_distance_stop_search() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioPullOverConfig::clear_max_distance_stop_search() {
  max_distance_stop_search_ = 25;
  clear_has_max_distance_stop_search();
}
inline double ScenarioPullOverConfig::max_distance_stop_search() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_distance_stop_search)
  return max_distance_stop_search_;
}
inline void ScenarioPullOverConfig::set_max_distance_stop_search(double value) {
  set_has_max_distance_stop_search();
  max_distance_stop_search_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_distance_stop_search)
}

// optional double max_s_error_to_end_point = 4 [default = 0.2];
inline bool ScenarioPullOverConfig::has_max_s_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_s_error_to_end_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioPullOverConfig::clear_has_max_s_error_to_end_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioPullOverConfig::clear_max_s_error_to_end_point() {
  max_s_error_to_end_point_ = 0.2;
  clear_has_max_s_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_s_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
  return max_s_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_s_error_to_end_point(double value) {
  set_has_max_s_error_to_end_point();
  max_s_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
}

// optional double max_l_error_to_end_point = 5 [default = 0.5];
inline bool ScenarioPullOverConfig::has_max_l_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_l_error_to_end_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioPullOverConfig::clear_has_max_l_error_to_end_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioPullOverConfig::clear_max_l_error_to_end_point() {
  max_l_error_to_end_point_ = 0.5;
  clear_has_max_l_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_l_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
  return max_l_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_l_error_to_end_point(double value) {
  set_has_max_l_error_to_end_point();
  max_l_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
}

// optional double max_theta_error_to_end_point = 6 [default = 0.2];
inline bool ScenarioPullOverConfig::has_max_theta_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_theta_error_to_end_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioPullOverConfig::clear_has_max_theta_error_to_end_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioPullOverConfig::clear_max_theta_error_to_end_point() {
  max_theta_error_to_end_point_ = 0.2;
  clear_has_max_theta_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_theta_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
  return max_theta_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_theta_error_to_end_point(double value) {
  set_has_max_theta_error_to_end_point();
  max_theta_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
}

// optional double max_distance_error_to_end_point = 7 [default = 0.2];
inline bool ScenarioPullOverConfig::has_max_distance_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_distance_error_to_end_point() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioPullOverConfig::clear_has_max_distance_error_to_end_point() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioPullOverConfig::clear_max_distance_error_to_end_point() {
  max_distance_error_to_end_point_ = 0.2;
  clear_has_max_distance_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_distance_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
  return max_distance_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_distance_error_to_end_point(double value) {
  set_has_max_distance_error_to_end_point();
  max_distance_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
}

// optional double pass_destination_threshold = 8 [default = 10];
inline bool ScenarioPullOverConfig::has_pass_destination_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScenarioPullOverConfig::set_has_pass_destination_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScenarioPullOverConfig::clear_has_pass_destination_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScenarioPullOverConfig::clear_pass_destination_threshold() {
  pass_destination_threshold_ = 10;
  clear_has_pass_destination_threshold();
}
inline double ScenarioPullOverConfig::pass_destination_threshold() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.pass_destination_threshold)
  return pass_destination_threshold_;
}
inline void ScenarioPullOverConfig::set_pass_destination_threshold(double value) {
  set_has_pass_destination_threshold();
  pass_destination_threshold_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.pass_destination_threshold)
}

// optional double max_valid_stop_distance = 9 [default = 1];
inline bool ScenarioPullOverConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScenarioPullOverConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScenarioPullOverConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioPullOverConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioPullOverConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.max_valid_stop_distance)
}

// optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
inline bool ScenarioPullOverConfig::has_s_distance_to_stop_for_open_space_parking() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScenarioPullOverConfig::set_has_s_distance_to_stop_for_open_space_parking() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScenarioPullOverConfig::clear_has_s_distance_to_stop_for_open_space_parking() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScenarioPullOverConfig::clear_s_distance_to_stop_for_open_space_parking() {
  s_distance_to_stop_for_open_space_parking_ = 7;
  clear_has_s_distance_to_stop_for_open_space_parking();
}
inline double ScenarioPullOverConfig::s_distance_to_stop_for_open_space_parking() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
  return s_distance_to_stop_for_open_space_parking_;
}
inline void ScenarioPullOverConfig::set_s_distance_to_stop_for_open_space_parking(double value) {
  set_has_s_distance_to_stop_for_open_space_parking();
  s_distance_to_stop_for_open_space_parking_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
}

// -------------------------------------------------------------------

// ScenarioEmergencyPullOverConfig

// optional double max_stop_deceleration = 1 [default = 3];
inline bool ScenarioEmergencyPullOverConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioEmergencyPullOverConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 3;
  clear_has_max_stop_deceleration();
}
inline double ScenarioEmergencyPullOverConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void ScenarioEmergencyPullOverConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.max_stop_deceleration)
}

// optional double slow_down_deceleration_time = 2 [default = 3];
inline bool ScenarioEmergencyPullOverConfig::has_slow_down_deceleration_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_slow_down_deceleration_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_slow_down_deceleration_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioEmergencyPullOverConfig::clear_slow_down_deceleration_time() {
  slow_down_deceleration_time_ = 3;
  clear_has_slow_down_deceleration_time();
}
inline double ScenarioEmergencyPullOverConfig::slow_down_deceleration_time() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.slow_down_deceleration_time)
  return slow_down_deceleration_time_;
}
inline void ScenarioEmergencyPullOverConfig::set_slow_down_deceleration_time(double value) {
  set_has_slow_down_deceleration_time();
  slow_down_deceleration_time_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.slow_down_deceleration_time)
}

// optional double target_slow_down_speed = 3 [default = 2.5];
inline bool ScenarioEmergencyPullOverConfig::has_target_slow_down_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_target_slow_down_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_target_slow_down_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioEmergencyPullOverConfig::clear_target_slow_down_speed() {
  target_slow_down_speed_ = 2.5;
  clear_has_target_slow_down_speed();
}
inline double ScenarioEmergencyPullOverConfig::target_slow_down_speed() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.target_slow_down_speed)
  return target_slow_down_speed_;
}
inline void ScenarioEmergencyPullOverConfig::set_target_slow_down_speed(double value) {
  set_has_target_slow_down_speed();
  target_slow_down_speed_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.target_slow_down_speed)
}

// optional double stop_distance = 4 [default = 1.5];
inline bool ScenarioEmergencyPullOverConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioEmergencyPullOverConfig::clear_stop_distance() {
  stop_distance_ = 1.5;
  clear_has_stop_distance();
}
inline double ScenarioEmergencyPullOverConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyPullOverConfig.stop_distance)
  return stop_distance_;
}
inline void ScenarioEmergencyPullOverConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyPullOverConfig.stop_distance)
}

// -------------------------------------------------------------------

// ScenarioEmergencyStopConfig

// optional double max_stop_deceleration = 1 [default = 6];
inline bool ScenarioEmergencyStopConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioEmergencyStopConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioEmergencyStopConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioEmergencyStopConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 6;
  clear_has_max_stop_deceleration();
}
inline double ScenarioEmergencyStopConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyStopConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void ScenarioEmergencyStopConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyStopConfig.max_stop_deceleration)
}

// optional double stop_distance = 2 [default = 1];
inline bool ScenarioEmergencyStopConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioEmergencyStopConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioEmergencyStopConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioEmergencyStopConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double ScenarioEmergencyStopConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioEmergencyStopConfig.stop_distance)
  return stop_distance_;
}
inline void ScenarioEmergencyStopConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioEmergencyStopConfig.stop_distance)
}

// -------------------------------------------------------------------

// ScenarioValetParkingConfig

// optional double parking_spot_range_to_start = 1 [default = 20];
inline bool ScenarioValetParkingConfig::has_parking_spot_range_to_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioValetParkingConfig::set_has_parking_spot_range_to_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioValetParkingConfig::clear_has_parking_spot_range_to_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioValetParkingConfig::clear_parking_spot_range_to_start() {
  parking_spot_range_to_start_ = 20;
  clear_has_parking_spot_range_to_start();
}
inline double ScenarioValetParkingConfig::parking_spot_range_to_start() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
  return parking_spot_range_to_start_;
}
inline void ScenarioValetParkingConfig::set_parking_spot_range_to_start(double value) {
  set_has_parking_spot_range_to_start();
  parking_spot_range_to_start_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
}

// optional double max_valid_stop_distance = 2 [default = 1];
inline bool ScenarioValetParkingConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioValetParkingConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioValetParkingConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioValetParkingConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioValetParkingConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioValetParkingConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
}

// -------------------------------------------------------------------

// ScenarioNarrowStreetUTurnConfig

// -------------------------------------------------------------------

// ScenarioParkAndGoConfig

// optional double front_obstacle_buffer = 1 [default = 4];
inline bool ScenarioParkAndGoConfig::has_front_obstacle_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_front_obstacle_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioParkAndGoConfig::clear_has_front_obstacle_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioParkAndGoConfig::clear_front_obstacle_buffer() {
  front_obstacle_buffer_ = 4;
  clear_has_front_obstacle_buffer();
}
inline double ScenarioParkAndGoConfig::front_obstacle_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.front_obstacle_buffer)
  return front_obstacle_buffer_;
}
inline void ScenarioParkAndGoConfig::set_front_obstacle_buffer(double value) {
  set_has_front_obstacle_buffer();
  front_obstacle_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.front_obstacle_buffer)
}

// optional double heading_buffer = 2 [default = 0.5];
inline bool ScenarioParkAndGoConfig::has_heading_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_heading_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioParkAndGoConfig::clear_has_heading_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioParkAndGoConfig::clear_heading_buffer() {
  heading_buffer_ = 0.5;
  clear_has_heading_buffer();
}
inline double ScenarioParkAndGoConfig::heading_buffer() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.heading_buffer)
  return heading_buffer_;
}
inline void ScenarioParkAndGoConfig::set_heading_buffer(double value) {
  set_has_heading_buffer();
  heading_buffer_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.heading_buffer)
}

// optional double min_dist_to_dest = 3 [default = 25];
inline bool ScenarioParkAndGoConfig::has_min_dist_to_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_min_dist_to_dest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioParkAndGoConfig::clear_has_min_dist_to_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioParkAndGoConfig::clear_min_dist_to_dest() {
  min_dist_to_dest_ = 25;
  clear_has_min_dist_to_dest();
}
inline double ScenarioParkAndGoConfig::min_dist_to_dest() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.min_dist_to_dest)
  return min_dist_to_dest_;
}
inline void ScenarioParkAndGoConfig::set_min_dist_to_dest(double value) {
  set_has_min_dist_to_dest();
  min_dist_to_dest_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.min_dist_to_dest)
}

// optional double max_steering_percentage_when_cruise = 4 [default = 90];
inline bool ScenarioParkAndGoConfig::has_max_steering_percentage_when_cruise() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_max_steering_percentage_when_cruise() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioParkAndGoConfig::clear_has_max_steering_percentage_when_cruise() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioParkAndGoConfig::clear_max_steering_percentage_when_cruise() {
  max_steering_percentage_when_cruise_ = 90;
  clear_has_max_steering_percentage_when_cruise();
}
inline double ScenarioParkAndGoConfig::max_steering_percentage_when_cruise() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioParkAndGoConfig.max_steering_percentage_when_cruise)
  return max_steering_percentage_when_cruise_;
}
inline void ScenarioParkAndGoConfig::set_max_steering_percentage_when_cruise(double value) {
  set_has_max_steering_percentage_when_cruise();
  max_steering_percentage_when_cruise_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioParkAndGoConfig.max_steering_percentage_when_cruise)
}

// -------------------------------------------------------------------

// ScenarioYieldSignConfig

// optional double start_yield_sign_scenario_distance = 1 [default = 10];
inline bool ScenarioYieldSignConfig::has_start_yield_sign_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_start_yield_sign_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioYieldSignConfig::clear_has_start_yield_sign_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioYieldSignConfig::clear_start_yield_sign_scenario_distance() {
  start_yield_sign_scenario_distance_ = 10;
  clear_has_start_yield_sign_scenario_distance();
}
inline double ScenarioYieldSignConfig::start_yield_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.start_yield_sign_scenario_distance)
  return start_yield_sign_scenario_distance_;
}
inline void ScenarioYieldSignConfig::set_start_yield_sign_scenario_distance(double value) {
  set_has_start_yield_sign_scenario_distance();
  start_yield_sign_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.start_yield_sign_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 4.5];
inline bool ScenarioYieldSignConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioYieldSignConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioYieldSignConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 4.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioYieldSignConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioYieldSignConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioYieldSignConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioYieldSignConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioYieldSignConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioYieldSignConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioYieldSignConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 4 [default = 10];
inline bool ScenarioYieldSignConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioYieldSignConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioYieldSignConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioYieldSignConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioYieldSignConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioYieldSignConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioYieldSignConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioTestLearningModelConfig

// optional string model_file = 1;
inline bool ScenarioTestLearningModelConfig::has_model_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTestLearningModelConfig::set_has_model_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTestLearningModelConfig::clear_has_model_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTestLearningModelConfig::clear_model_file() {
  model_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_file();
}
inline const ::std::string& ScenarioTestLearningModelConfig::model_file() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
  return model_file_.GetNoArena();
}
inline void ScenarioTestLearningModelConfig::set_model_file(const ::std::string& value) {
  set_has_model_file();
  model_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
#if LANG_CXX11
inline void ScenarioTestLearningModelConfig::set_model_file(::std::string&& value) {
  set_has_model_file();
  model_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
#endif
inline void ScenarioTestLearningModelConfig::set_model_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_file();
  model_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
inline void ScenarioTestLearningModelConfig::set_model_file(const char* value, size_t size) {
  set_has_model_file();
  model_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}
inline ::std::string* ScenarioTestLearningModelConfig::mutable_model_file() {
  set_has_model_file();
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
  return model_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScenarioTestLearningModelConfig::release_model_file() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
  clear_has_model_file();
  return model_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScenarioTestLearningModelConfig::set_allocated_model_file(::std::string* model_file) {
  if (model_file != NULL) {
    set_has_model_file();
  } else {
    clear_has_model_file();
  }
  model_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_file);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioTestLearningModelConfig.model_file)
}

// optional int32 input_feature_num = 2;
inline bool ScenarioTestLearningModelConfig::has_input_feature_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTestLearningModelConfig::set_has_input_feature_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTestLearningModelConfig::clear_has_input_feature_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTestLearningModelConfig::clear_input_feature_num() {
  input_feature_num_ = 0;
  clear_has_input_feature_num();
}
inline ::google::protobuf::int32 ScenarioTestLearningModelConfig::input_feature_num() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioTestLearningModelConfig.input_feature_num)
  return input_feature_num_;
}
inline void ScenarioTestLearningModelConfig::set_input_feature_num(::google::protobuf::int32 value) {
  set_has_input_feature_num();
  input_feature_num_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioTestLearningModelConfig.input_feature_num)
}

// -------------------------------------------------------------------

// ScenarioConfig_StageConfig

// optional .jmc_auto.planning.ScenarioConfig.StageType stage_type = 1;
inline bool ScenarioConfig_StageConfig::has_stage_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioConfig_StageConfig::set_has_stage_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioConfig_StageConfig::clear_has_stage_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioConfig_StageConfig::clear_stage_type() {
  stage_type_ = 0;
  clear_has_stage_type();
}
inline ::jmc_auto::planning::ScenarioConfig_StageType ScenarioConfig_StageConfig::stage_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.stage_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(stage_type_);
}
inline void ScenarioConfig_StageConfig::set_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  set_has_stage_type();
  stage_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.StageConfig.stage_type)
}

// optional bool enabled = 2 [default = true];
inline bool ScenarioConfig_StageConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioConfig_StageConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioConfig_StageConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioConfig_StageConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool ScenarioConfig_StageConfig::enabled() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.enabled)
  return enabled_;
}
inline void ScenarioConfig_StageConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.StageConfig.enabled)
}

// repeated .jmc_auto.planning.TaskConfig.TaskType task_type = 3;
inline int ScenarioConfig_StageConfig::task_type_size() const {
  return task_type_.size();
}
inline void ScenarioConfig_StageConfig::clear_task_type() {
  task_type_.Clear();
}
inline ::jmc_auto::planning::TaskConfig_TaskType ScenarioConfig_StageConfig::task_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
  return static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(task_type_.Get(index));
}
inline void ScenarioConfig_StageConfig::set_task_type(int index, ::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
}
inline void ScenarioConfig_StageConfig::add_task_type(::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ScenarioConfig_StageConfig::task_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
  return task_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ScenarioConfig_StageConfig::mutable_task_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_type)
  return &task_type_;
}

// repeated .jmc_auto.planning.TaskConfig task_config = 4;
inline int ScenarioConfig_StageConfig::task_config_size() const {
  return task_config_.size();
}
inline void ScenarioConfig_StageConfig::clear_task_config() {
  task_config_.Clear();
}
inline const ::jmc_auto::planning::TaskConfig& ScenarioConfig_StageConfig::task_config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Get(index);
}
inline ::jmc_auto::planning::TaskConfig* ScenarioConfig_StageConfig::mutable_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Mutable(index);
}
inline ::jmc_auto::planning::TaskConfig* ScenarioConfig_StageConfig::add_task_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >*
ScenarioConfig_StageConfig::mutable_task_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return &task_config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >&
ScenarioConfig_StageConfig::task_config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_;
}

// -------------------------------------------------------------------

// ScenarioConfig

// optional .jmc_auto.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline bool ScenarioConfig::has_scenario_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioConfig::set_has_scenario_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioConfig::clear_has_scenario_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioConfig::clear_scenario_type() {
  scenario_type_ = 0;
  clear_has_scenario_type();
}
inline ::jmc_auto::planning::ScenarioConfig_ScenarioType ScenarioConfig::scenario_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.scenario_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
inline void ScenarioConfig::set_scenario_type(::jmc_auto::planning::ScenarioConfig_ScenarioType value) {
  assert(::jmc_auto::planning::ScenarioConfig_ScenarioType_IsValid(value));
  set_has_scenario_type();
  scenario_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.scenario_type)
}

// optional .jmc_auto.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
inline bool ScenarioConfig::has_lane_follow_config() const {
  return scenario_config_case() == kLaneFollowConfig;
}
inline void ScenarioConfig::set_has_lane_follow_config() {
  _oneof_case_[0] = kLaneFollowConfig;
}
inline void ScenarioConfig::clear_lane_follow_config() {
  if (has_lane_follow_config()) {
    delete scenario_config_.lane_follow_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioLaneFollowConfig& ScenarioConfig::lane_follow_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.lane_follow_config)
  return has_lane_follow_config()
      ? *scenario_config_.lane_follow_config_
      : ::jmc_auto::planning::ScenarioLaneFollowConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioLaneFollowConfig* ScenarioConfig::mutable_lane_follow_config() {
  if (!has_lane_follow_config()) {
    clear_scenario_config();
    set_has_lane_follow_config();
    scenario_config_.lane_follow_config_ = new ::jmc_auto::planning::ScenarioLaneFollowConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.lane_follow_config)
  return scenario_config_.lane_follow_config_;
}
inline ::jmc_auto::planning::ScenarioLaneFollowConfig* ScenarioConfig::release_lane_follow_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.lane_follow_config)
  if (has_lane_follow_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioLaneFollowConfig* temp = scenario_config_.lane_follow_config_;
    scenario_config_.lane_follow_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_lane_follow_config(::jmc_auto::planning::ScenarioLaneFollowConfig* lane_follow_config) {
  clear_scenario_config();
  if (lane_follow_config) {
    set_has_lane_follow_config();
    scenario_config_.lane_follow_config_ = lane_follow_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.lane_follow_config)
}

// optional .jmc_auto.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 4;
inline bool ScenarioConfig::has_bare_intersection_unprotected_config() const {
  return scenario_config_case() == kBareIntersectionUnprotectedConfig;
}
inline void ScenarioConfig::set_has_bare_intersection_unprotected_config() {
  _oneof_case_[0] = kBareIntersectionUnprotectedConfig;
}
inline void ScenarioConfig::clear_bare_intersection_unprotected_config() {
  if (has_bare_intersection_unprotected_config()) {
    delete scenario_config_.bare_intersection_unprotected_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig& ScenarioConfig::bare_intersection_unprotected_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return has_bare_intersection_unprotected_config()
      ? *scenario_config_.bare_intersection_unprotected_config_
      : ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::mutable_bare_intersection_unprotected_config() {
  if (!has_bare_intersection_unprotected_config()) {
    clear_scenario_config();
    set_has_bare_intersection_unprotected_config();
    scenario_config_.bare_intersection_unprotected_config_ = new ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return scenario_config_.bare_intersection_unprotected_config_;
}
inline ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::release_bare_intersection_unprotected_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
  if (has_bare_intersection_unprotected_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* temp = scenario_config_.bare_intersection_unprotected_config_;
    scenario_config_.bare_intersection_unprotected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_bare_intersection_unprotected_config(::jmc_auto::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config) {
  clear_scenario_config();
  if (bare_intersection_unprotected_config) {
    set_has_bare_intersection_unprotected_config();
    scenario_config_.bare_intersection_unprotected_config_ = bare_intersection_unprotected_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.bare_intersection_unprotected_config)
}

// optional .jmc_auto.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 5;
inline bool ScenarioConfig::has_emergency_pull_over_config() const {
  return scenario_config_case() == kEmergencyPullOverConfig;
}
inline void ScenarioConfig::set_has_emergency_pull_over_config() {
  _oneof_case_[0] = kEmergencyPullOverConfig;
}
inline void ScenarioConfig::clear_emergency_pull_over_config() {
  if (has_emergency_pull_over_config()) {
    delete scenario_config_.emergency_pull_over_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioEmergencyPullOverConfig& ScenarioConfig::emergency_pull_over_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
  return has_emergency_pull_over_config()
      ? *scenario_config_.emergency_pull_over_config_
      : ::jmc_auto::planning::ScenarioEmergencyPullOverConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* ScenarioConfig::mutable_emergency_pull_over_config() {
  if (!has_emergency_pull_over_config()) {
    clear_scenario_config();
    set_has_emergency_pull_over_config();
    scenario_config_.emergency_pull_over_config_ = new ::jmc_auto::planning::ScenarioEmergencyPullOverConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
  return scenario_config_.emergency_pull_over_config_;
}
inline ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* ScenarioConfig::release_emergency_pull_over_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
  if (has_emergency_pull_over_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioEmergencyPullOverConfig* temp = scenario_config_.emergency_pull_over_config_;
    scenario_config_.emergency_pull_over_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_emergency_pull_over_config(::jmc_auto::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config) {
  clear_scenario_config();
  if (emergency_pull_over_config) {
    set_has_emergency_pull_over_config();
    scenario_config_.emergency_pull_over_config_ = emergency_pull_over_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.emergency_pull_over_config)
}

// optional .jmc_auto.planning.ScenarioEmergencyStopConfig emergency_stop_config = 6;
inline bool ScenarioConfig::has_emergency_stop_config() const {
  return scenario_config_case() == kEmergencyStopConfig;
}
inline void ScenarioConfig::set_has_emergency_stop_config() {
  _oneof_case_[0] = kEmergencyStopConfig;
}
inline void ScenarioConfig::clear_emergency_stop_config() {
  if (has_emergency_stop_config()) {
    delete scenario_config_.emergency_stop_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioEmergencyStopConfig& ScenarioConfig::emergency_stop_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
  return has_emergency_stop_config()
      ? *scenario_config_.emergency_stop_config_
      : ::jmc_auto::planning::ScenarioEmergencyStopConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioEmergencyStopConfig* ScenarioConfig::mutable_emergency_stop_config() {
  if (!has_emergency_stop_config()) {
    clear_scenario_config();
    set_has_emergency_stop_config();
    scenario_config_.emergency_stop_config_ = new ::jmc_auto::planning::ScenarioEmergencyStopConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
  return scenario_config_.emergency_stop_config_;
}
inline ::jmc_auto::planning::ScenarioEmergencyStopConfig* ScenarioConfig::release_emergency_stop_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
  if (has_emergency_stop_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioEmergencyStopConfig* temp = scenario_config_.emergency_stop_config_;
    scenario_config_.emergency_stop_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_emergency_stop_config(::jmc_auto::planning::ScenarioEmergencyStopConfig* emergency_stop_config) {
  clear_scenario_config();
  if (emergency_stop_config) {
    set_has_emergency_stop_config();
    scenario_config_.emergency_stop_config_ = emergency_stop_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.emergency_stop_config)
}

// optional .jmc_auto.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
inline bool ScenarioConfig::has_narrow_street_u_turn_config() const {
  return scenario_config_case() == kNarrowStreetUTurnConfig;
}
inline void ScenarioConfig::set_has_narrow_street_u_turn_config() {
  _oneof_case_[0] = kNarrowStreetUTurnConfig;
}
inline void ScenarioConfig::clear_narrow_street_u_turn_config() {
  if (has_narrow_street_u_turn_config()) {
    delete scenario_config_.narrow_street_u_turn_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig& ScenarioConfig::narrow_street_u_turn_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
  return has_narrow_street_u_turn_config()
      ? *scenario_config_.narrow_street_u_turn_config_
      : ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::mutable_narrow_street_u_turn_config() {
  if (!has_narrow_street_u_turn_config()) {
    clear_scenario_config();
    set_has_narrow_street_u_turn_config();
    scenario_config_.narrow_street_u_turn_config_ = new ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
  return scenario_config_.narrow_street_u_turn_config_;
}
inline ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::release_narrow_street_u_turn_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
  if (has_narrow_street_u_turn_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* temp = scenario_config_.narrow_street_u_turn_config_;
    scenario_config_.narrow_street_u_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_narrow_street_u_turn_config(::jmc_auto::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config) {
  clear_scenario_config();
  if (narrow_street_u_turn_config) {
    set_has_narrow_street_u_turn_config();
    scenario_config_.narrow_street_u_turn_config_ = narrow_street_u_turn_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.narrow_street_u_turn_config)
}

// optional .jmc_auto.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 8;
inline bool ScenarioConfig::has_stop_sign_unprotected_config() const {
  return scenario_config_case() == kStopSignUnprotectedConfig;
}
inline void ScenarioConfig::set_has_stop_sign_unprotected_config() {
  _oneof_case_[0] = kStopSignUnprotectedConfig;
}
inline void ScenarioConfig::clear_stop_sign_unprotected_config() {
  if (has_stop_sign_unprotected_config()) {
    delete scenario_config_.stop_sign_unprotected_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig& ScenarioConfig::stop_sign_unprotected_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
  return has_stop_sign_unprotected_config()
      ? *scenario_config_.stop_sign_unprotected_config_
      : ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::mutable_stop_sign_unprotected_config() {
  if (!has_stop_sign_unprotected_config()) {
    clear_scenario_config();
    set_has_stop_sign_unprotected_config();
    scenario_config_.stop_sign_unprotected_config_ = new ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
  return scenario_config_.stop_sign_unprotected_config_;
}
inline ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::release_stop_sign_unprotected_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
  if (has_stop_sign_unprotected_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* temp = scenario_config_.stop_sign_unprotected_config_;
    scenario_config_.stop_sign_unprotected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_stop_sign_unprotected_config(::jmc_auto::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config) {
  clear_scenario_config();
  if (stop_sign_unprotected_config) {
    set_has_stop_sign_unprotected_config();
    scenario_config_.stop_sign_unprotected_config_ = stop_sign_unprotected_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.stop_sign_unprotected_config)
}

// optional .jmc_auto.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 9;
inline bool ScenarioConfig::has_traffic_light_protected_config() const {
  return scenario_config_case() == kTrafficLightProtectedConfig;
}
inline void ScenarioConfig::set_has_traffic_light_protected_config() {
  _oneof_case_[0] = kTrafficLightProtectedConfig;
}
inline void ScenarioConfig::clear_traffic_light_protected_config() {
  if (has_traffic_light_protected_config()) {
    delete scenario_config_.traffic_light_protected_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig& ScenarioConfig::traffic_light_protected_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
  return has_traffic_light_protected_config()
      ? *scenario_config_.traffic_light_protected_config_
      : ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::mutable_traffic_light_protected_config() {
  if (!has_traffic_light_protected_config()) {
    clear_scenario_config();
    set_has_traffic_light_protected_config();
    scenario_config_.traffic_light_protected_config_ = new ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
  return scenario_config_.traffic_light_protected_config_;
}
inline ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::release_traffic_light_protected_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
  if (has_traffic_light_protected_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* temp = scenario_config_.traffic_light_protected_config_;
    scenario_config_.traffic_light_protected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_traffic_light_protected_config(::jmc_auto::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config) {
  clear_scenario_config();
  if (traffic_light_protected_config) {
    set_has_traffic_light_protected_config();
    scenario_config_.traffic_light_protected_config_ = traffic_light_protected_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.traffic_light_protected_config)
}

// optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 10;
inline bool ScenarioConfig::has_traffic_light_unprotected_right_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedRightTurnConfig;
}
inline void ScenarioConfig::set_has_traffic_light_unprotected_right_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedRightTurnConfig;
}
inline void ScenarioConfig::clear_traffic_light_unprotected_right_turn_config() {
  if (has_traffic_light_unprotected_right_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_right_turn_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioConfig::traffic_light_unprotected_right_turn_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return has_traffic_light_unprotected_right_turn_config()
      ? *scenario_config_.traffic_light_unprotected_right_turn_config_
      : ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_right_turn_config() {
  if (!has_traffic_light_unprotected_right_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_right_turn_config();
    scenario_config_.traffic_light_unprotected_right_turn_config_ = new ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return scenario_config_.traffic_light_unprotected_right_turn_config_;
}
inline ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::release_traffic_light_unprotected_right_turn_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  if (has_traffic_light_unprotected_right_turn_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* temp = scenario_config_.traffic_light_unprotected_right_turn_config_;
    scenario_config_.traffic_light_unprotected_right_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_traffic_light_unprotected_right_turn_config(::jmc_auto::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config) {
  clear_scenario_config();
  if (traffic_light_unprotected_right_turn_config) {
    set_has_traffic_light_unprotected_right_turn_config();
    scenario_config_.traffic_light_unprotected_right_turn_config_ = traffic_light_unprotected_right_turn_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
}

// optional .jmc_auto.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 11;
inline bool ScenarioConfig::has_traffic_light_unprotected_left_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedLeftTurnConfig;
}
inline void ScenarioConfig::set_has_traffic_light_unprotected_left_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedLeftTurnConfig;
}
inline void ScenarioConfig::clear_traffic_light_unprotected_left_turn_config() {
  if (has_traffic_light_unprotected_left_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_left_turn_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioConfig::traffic_light_unprotected_left_turn_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return has_traffic_light_unprotected_left_turn_config()
      ? *scenario_config_.traffic_light_unprotected_left_turn_config_
      : ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_left_turn_config() {
  if (!has_traffic_light_unprotected_left_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_left_turn_config();
    scenario_config_.traffic_light_unprotected_left_turn_config_ = new ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return scenario_config_.traffic_light_unprotected_left_turn_config_;
}
inline ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::release_traffic_light_unprotected_left_turn_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  if (has_traffic_light_unprotected_left_turn_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* temp = scenario_config_.traffic_light_unprotected_left_turn_config_;
    scenario_config_.traffic_light_unprotected_left_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_traffic_light_unprotected_left_turn_config(::jmc_auto::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config) {
  clear_scenario_config();
  if (traffic_light_unprotected_left_turn_config) {
    set_has_traffic_light_unprotected_left_turn_config();
    scenario_config_.traffic_light_unprotected_left_turn_config_ = traffic_light_unprotected_left_turn_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
}

// optional .jmc_auto.planning.ScenarioParkAndGoConfig park_and_go_config = 12;
inline bool ScenarioConfig::has_park_and_go_config() const {
  return scenario_config_case() == kParkAndGoConfig;
}
inline void ScenarioConfig::set_has_park_and_go_config() {
  _oneof_case_[0] = kParkAndGoConfig;
}
inline void ScenarioConfig::clear_park_and_go_config() {
  if (has_park_and_go_config()) {
    delete scenario_config_.park_and_go_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioParkAndGoConfig& ScenarioConfig::park_and_go_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.park_and_go_config)
  return has_park_and_go_config()
      ? *scenario_config_.park_and_go_config_
      : ::jmc_auto::planning::ScenarioParkAndGoConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioParkAndGoConfig* ScenarioConfig::mutable_park_and_go_config() {
  if (!has_park_and_go_config()) {
    clear_scenario_config();
    set_has_park_and_go_config();
    scenario_config_.park_and_go_config_ = new ::jmc_auto::planning::ScenarioParkAndGoConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.park_and_go_config)
  return scenario_config_.park_and_go_config_;
}
inline ::jmc_auto::planning::ScenarioParkAndGoConfig* ScenarioConfig::release_park_and_go_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.park_and_go_config)
  if (has_park_and_go_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioParkAndGoConfig* temp = scenario_config_.park_and_go_config_;
    scenario_config_.park_and_go_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_park_and_go_config(::jmc_auto::planning::ScenarioParkAndGoConfig* park_and_go_config) {
  clear_scenario_config();
  if (park_and_go_config) {
    set_has_park_and_go_config();
    scenario_config_.park_and_go_config_ = park_and_go_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.park_and_go_config)
}

// optional .jmc_auto.planning.ScenarioPullOverConfig pull_over_config = 13;
inline bool ScenarioConfig::has_pull_over_config() const {
  return scenario_config_case() == kPullOverConfig;
}
inline void ScenarioConfig::set_has_pull_over_config() {
  _oneof_case_[0] = kPullOverConfig;
}
inline void ScenarioConfig::clear_pull_over_config() {
  if (has_pull_over_config()) {
    delete scenario_config_.pull_over_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioPullOverConfig& ScenarioConfig::pull_over_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.pull_over_config)
  return has_pull_over_config()
      ? *scenario_config_.pull_over_config_
      : ::jmc_auto::planning::ScenarioPullOverConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioPullOverConfig* ScenarioConfig::mutable_pull_over_config() {
  if (!has_pull_over_config()) {
    clear_scenario_config();
    set_has_pull_over_config();
    scenario_config_.pull_over_config_ = new ::jmc_auto::planning::ScenarioPullOverConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.pull_over_config)
  return scenario_config_.pull_over_config_;
}
inline ::jmc_auto::planning::ScenarioPullOverConfig* ScenarioConfig::release_pull_over_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.pull_over_config)
  if (has_pull_over_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioPullOverConfig* temp = scenario_config_.pull_over_config_;
    scenario_config_.pull_over_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_pull_over_config(::jmc_auto::planning::ScenarioPullOverConfig* pull_over_config) {
  clear_scenario_config();
  if (pull_over_config) {
    set_has_pull_over_config();
    scenario_config_.pull_over_config_ = pull_over_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.pull_over_config)
}

// optional .jmc_auto.planning.ScenarioValetParkingConfig valet_parking_config = 14;
inline bool ScenarioConfig::has_valet_parking_config() const {
  return scenario_config_case() == kValetParkingConfig;
}
inline void ScenarioConfig::set_has_valet_parking_config() {
  _oneof_case_[0] = kValetParkingConfig;
}
inline void ScenarioConfig::clear_valet_parking_config() {
  if (has_valet_parking_config()) {
    delete scenario_config_.valet_parking_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioValetParkingConfig& ScenarioConfig::valet_parking_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.valet_parking_config)
  return has_valet_parking_config()
      ? *scenario_config_.valet_parking_config_
      : ::jmc_auto::planning::ScenarioValetParkingConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioValetParkingConfig* ScenarioConfig::mutable_valet_parking_config() {
  if (!has_valet_parking_config()) {
    clear_scenario_config();
    set_has_valet_parking_config();
    scenario_config_.valet_parking_config_ = new ::jmc_auto::planning::ScenarioValetParkingConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.valet_parking_config)
  return scenario_config_.valet_parking_config_;
}
inline ::jmc_auto::planning::ScenarioValetParkingConfig* ScenarioConfig::release_valet_parking_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.valet_parking_config)
  if (has_valet_parking_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioValetParkingConfig* temp = scenario_config_.valet_parking_config_;
    scenario_config_.valet_parking_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_valet_parking_config(::jmc_auto::planning::ScenarioValetParkingConfig* valet_parking_config) {
  clear_scenario_config();
  if (valet_parking_config) {
    set_has_valet_parking_config();
    scenario_config_.valet_parking_config_ = valet_parking_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.valet_parking_config)
}

// optional .jmc_auto.planning.ScenarioYieldSignConfig yield_sign_config = 15;
inline bool ScenarioConfig::has_yield_sign_config() const {
  return scenario_config_case() == kYieldSignConfig;
}
inline void ScenarioConfig::set_has_yield_sign_config() {
  _oneof_case_[0] = kYieldSignConfig;
}
inline void ScenarioConfig::clear_yield_sign_config() {
  if (has_yield_sign_config()) {
    delete scenario_config_.yield_sign_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioYieldSignConfig& ScenarioConfig::yield_sign_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.yield_sign_config)
  return has_yield_sign_config()
      ? *scenario_config_.yield_sign_config_
      : ::jmc_auto::planning::ScenarioYieldSignConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioYieldSignConfig* ScenarioConfig::mutable_yield_sign_config() {
  if (!has_yield_sign_config()) {
    clear_scenario_config();
    set_has_yield_sign_config();
    scenario_config_.yield_sign_config_ = new ::jmc_auto::planning::ScenarioYieldSignConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.yield_sign_config)
  return scenario_config_.yield_sign_config_;
}
inline ::jmc_auto::planning::ScenarioYieldSignConfig* ScenarioConfig::release_yield_sign_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.yield_sign_config)
  if (has_yield_sign_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioYieldSignConfig* temp = scenario_config_.yield_sign_config_;
    scenario_config_.yield_sign_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_yield_sign_config(::jmc_auto::planning::ScenarioYieldSignConfig* yield_sign_config) {
  clear_scenario_config();
  if (yield_sign_config) {
    set_has_yield_sign_config();
    scenario_config_.yield_sign_config_ = yield_sign_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.yield_sign_config)
}

// optional .jmc_auto.planning.ScenarioTestLearningModelConfig test_learning_model_config = 18;
inline bool ScenarioConfig::has_test_learning_model_config() const {
  return scenario_config_case() == kTestLearningModelConfig;
}
inline void ScenarioConfig::set_has_test_learning_model_config() {
  _oneof_case_[0] = kTestLearningModelConfig;
}
inline void ScenarioConfig::clear_test_learning_model_config() {
  if (has_test_learning_model_config()) {
    delete scenario_config_.test_learning_model_config_;
    clear_has_scenario_config();
  }
}
inline  const ::jmc_auto::planning::ScenarioTestLearningModelConfig& ScenarioConfig::test_learning_model_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
  return has_test_learning_model_config()
      ? *scenario_config_.test_learning_model_config_
      : ::jmc_auto::planning::ScenarioTestLearningModelConfig::default_instance();
}
inline ::jmc_auto::planning::ScenarioTestLearningModelConfig* ScenarioConfig::mutable_test_learning_model_config() {
  if (!has_test_learning_model_config()) {
    clear_scenario_config();
    set_has_test_learning_model_config();
    scenario_config_.test_learning_model_config_ = new ::jmc_auto::planning::ScenarioTestLearningModelConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
  return scenario_config_.test_learning_model_config_;
}
inline ::jmc_auto::planning::ScenarioTestLearningModelConfig* ScenarioConfig::release_test_learning_model_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
  if (has_test_learning_model_config()) {
    clear_has_scenario_config();
    ::jmc_auto::planning::ScenarioTestLearningModelConfig* temp = scenario_config_.test_learning_model_config_;
    scenario_config_.test_learning_model_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ScenarioConfig::set_allocated_test_learning_model_config(::jmc_auto::planning::ScenarioTestLearningModelConfig* test_learning_model_config) {
  clear_scenario_config();
  if (test_learning_model_config) {
    set_has_test_learning_model_config();
    scenario_config_.test_learning_model_config_ = test_learning_model_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.ScenarioConfig.test_learning_model_config)
}

// repeated .jmc_auto.planning.ScenarioConfig.StageType stage_type = 16;
inline int ScenarioConfig::stage_type_size() const {
  return stage_type_.size();
}
inline void ScenarioConfig::clear_stage_type() {
  stage_type_.Clear();
}
inline ::jmc_auto::planning::ScenarioConfig_StageType ScenarioConfig::stage_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.stage_type)
  return static_cast< ::jmc_auto::planning::ScenarioConfig_StageType >(stage_type_.Get(index));
}
inline void ScenarioConfig::set_stage_type(int index, ::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.ScenarioConfig.stage_type)
}
inline void ScenarioConfig::add_stage_type(::jmc_auto::planning::ScenarioConfig_StageType value) {
  assert(::jmc_auto::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.stage_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ScenarioConfig::stage_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.stage_type)
  return stage_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ScenarioConfig::mutable_stage_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.stage_type)
  return &stage_type_;
}

// repeated .jmc_auto.planning.ScenarioConfig.StageConfig stage_config = 17;
inline int ScenarioConfig::stage_config_size() const {
  return stage_config_.size();
}
inline void ScenarioConfig::clear_stage_config() {
  stage_config_.Clear();
}
inline const ::jmc_auto::planning::ScenarioConfig_StageConfig& ScenarioConfig::stage_config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_.Get(index);
}
inline ::jmc_auto::planning::ScenarioConfig_StageConfig* ScenarioConfig::mutable_stage_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_.Mutable(index);
}
inline ::jmc_auto::planning::ScenarioConfig_StageConfig* ScenarioConfig::add_stage_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig >*
ScenarioConfig::mutable_stage_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.ScenarioConfig.stage_config)
  return &stage_config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::ScenarioConfig_StageConfig >&
ScenarioConfig::stage_config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.ScenarioConfig.stage_config)
  return stage_config_;
}

inline bool ScenarioConfig::has_scenario_config() const {
  return scenario_config_case() != SCENARIO_CONFIG_NOT_SET;
}
inline void ScenarioConfig::clear_has_scenario_config() {
  _oneof_case_[0] = SCENARIO_CONFIG_NOT_SET;
}
inline ScenarioConfig::ScenarioConfigCase ScenarioConfig::scenario_config_case() const {
  return ScenarioConfig::ScenarioConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlannerPublicRoadConfig

// -------------------------------------------------------------------

// PlannerNaviConfig

// repeated .jmc_auto.planning.TaskConfig.TaskType task = 1;
inline int PlannerNaviConfig::task_size() const {
  return task_.size();
}
inline void PlannerNaviConfig::clear_task() {
  task_.Clear();
}
inline ::jmc_auto::planning::TaskConfig_TaskType PlannerNaviConfig::task(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.task)
  return static_cast< ::jmc_auto::planning::TaskConfig_TaskType >(task_.Get(index));
}
inline void PlannerNaviConfig::set_task(int index, ::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.PlannerNaviConfig.task)
}
inline void PlannerNaviConfig::add_task(::jmc_auto::planning::TaskConfig_TaskType value) {
  assert(::jmc_auto::planning::TaskConfig_TaskType_IsValid(value));
  task_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PlannerNaviConfig.task)
}
inline const ::google::protobuf::RepeatedField<int>&
PlannerNaviConfig::task() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PlannerNaviConfig.task)
  return task_;
}
inline ::google::protobuf::RepeatedField<int>*
PlannerNaviConfig::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PlannerNaviConfig.task)
  return &task_;
}

// optional .jmc_auto.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
inline bool PlannerNaviConfig::has_navi_path_decider_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerNaviConfig::set_has_navi_path_decider_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlannerNaviConfig::clear_has_navi_path_decider_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlannerNaviConfig::clear_navi_path_decider_config() {
  if (navi_path_decider_config_ != NULL) navi_path_decider_config_->::jmc_auto::planning::NaviPathDeciderConfig::Clear();
  clear_has_navi_path_decider_config();
}
inline const ::jmc_auto::planning::NaviPathDeciderConfig& PlannerNaviConfig::navi_path_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
  return navi_path_decider_config_ != NULL ? *navi_path_decider_config_
                         : *::jmc_auto::planning::NaviPathDeciderConfig::internal_default_instance();
}
inline ::jmc_auto::planning::NaviPathDeciderConfig* PlannerNaviConfig::mutable_navi_path_decider_config() {
  set_has_navi_path_decider_config();
  if (navi_path_decider_config_ == NULL) {
    navi_path_decider_config_ = new ::jmc_auto::planning::NaviPathDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
  return navi_path_decider_config_;
}
inline ::jmc_auto::planning::NaviPathDeciderConfig* PlannerNaviConfig::release_navi_path_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
  clear_has_navi_path_decider_config();
  ::jmc_auto::planning::NaviPathDeciderConfig* temp = navi_path_decider_config_;
  navi_path_decider_config_ = NULL;
  return temp;
}
inline void PlannerNaviConfig::set_allocated_navi_path_decider_config(::jmc_auto::planning::NaviPathDeciderConfig* navi_path_decider_config) {
  delete navi_path_decider_config_;
  navi_path_decider_config_ = navi_path_decider_config;
  if (navi_path_decider_config) {
    set_has_navi_path_decider_config();
  } else {
    clear_has_navi_path_decider_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlannerNaviConfig.navi_path_decider_config)
}

// optional .jmc_auto.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
inline bool PlannerNaviConfig::has_navi_speed_decider_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerNaviConfig::set_has_navi_speed_decider_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlannerNaviConfig::clear_has_navi_speed_decider_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlannerNaviConfig::clear_navi_speed_decider_config() {
  if (navi_speed_decider_config_ != NULL) navi_speed_decider_config_->::jmc_auto::planning::NaviSpeedDeciderConfig::Clear();
  clear_has_navi_speed_decider_config();
}
inline const ::jmc_auto::planning::NaviSpeedDeciderConfig& PlannerNaviConfig::navi_speed_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
  return navi_speed_decider_config_ != NULL ? *navi_speed_decider_config_
                         : *::jmc_auto::planning::NaviSpeedDeciderConfig::internal_default_instance();
}
inline ::jmc_auto::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::mutable_navi_speed_decider_config() {
  set_has_navi_speed_decider_config();
  if (navi_speed_decider_config_ == NULL) {
    navi_speed_decider_config_ = new ::jmc_auto::planning::NaviSpeedDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
  return navi_speed_decider_config_;
}
inline ::jmc_auto::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::release_navi_speed_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
  clear_has_navi_speed_decider_config();
  ::jmc_auto::planning::NaviSpeedDeciderConfig* temp = navi_speed_decider_config_;
  navi_speed_decider_config_ = NULL;
  return temp;
}
inline void PlannerNaviConfig::set_allocated_navi_speed_decider_config(::jmc_auto::planning::NaviSpeedDeciderConfig* navi_speed_decider_config) {
  delete navi_speed_decider_config_;
  navi_speed_decider_config_ = navi_speed_decider_config;
  if (navi_speed_decider_config) {
    set_has_navi_speed_decider_config();
  } else {
    clear_has_navi_speed_decider_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlannerNaviConfig.navi_speed_decider_config)
}

// optional .jmc_auto.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
inline bool PlannerNaviConfig::has_navi_obstacle_decider_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerNaviConfig::set_has_navi_obstacle_decider_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlannerNaviConfig::clear_has_navi_obstacle_decider_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlannerNaviConfig::clear_navi_obstacle_decider_config() {
  if (navi_obstacle_decider_config_ != NULL) navi_obstacle_decider_config_->::jmc_auto::planning::NaviObstacleDeciderConfig::Clear();
  clear_has_navi_obstacle_decider_config();
}
inline const ::jmc_auto::planning::NaviObstacleDeciderConfig& PlannerNaviConfig::navi_obstacle_decider_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return navi_obstacle_decider_config_ != NULL ? *navi_obstacle_decider_config_
                         : *::jmc_auto::planning::NaviObstacleDeciderConfig::internal_default_instance();
}
inline ::jmc_auto::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::mutable_navi_obstacle_decider_config() {
  set_has_navi_obstacle_decider_config();
  if (navi_obstacle_decider_config_ == NULL) {
    navi_obstacle_decider_config_ = new ::jmc_auto::planning::NaviObstacleDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return navi_obstacle_decider_config_;
}
inline ::jmc_auto::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::release_navi_obstacle_decider_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  clear_has_navi_obstacle_decider_config();
  ::jmc_auto::planning::NaviObstacleDeciderConfig* temp = navi_obstacle_decider_config_;
  navi_obstacle_decider_config_ = NULL;
  return temp;
}
inline void PlannerNaviConfig::set_allocated_navi_obstacle_decider_config(::jmc_auto::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config) {
  delete navi_obstacle_decider_config_;
  navi_obstacle_decider_config_ = navi_obstacle_decider_config;
  if (navi_obstacle_decider_config) {
    set_has_navi_obstacle_decider_config();
  } else {
    clear_has_navi_obstacle_decider_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlannerNaviConfig.navi_obstacle_decider_config)
}

// -------------------------------------------------------------------

// RtkPlanningConfig

// optional .jmc_auto.planning.PlannerType planner_type = 1;
inline bool RtkPlanningConfig::has_planner_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtkPlanningConfig::set_has_planner_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtkPlanningConfig::clear_has_planner_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtkPlanningConfig::clear_planner_type() {
  planner_type_ = 0;
  clear_has_planner_type();
}
inline ::jmc_auto::planning::PlannerType RtkPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.RtkPlanningConfig.planner_type)
  return static_cast< ::jmc_auto::planning::PlannerType >(planner_type_);
}
inline void RtkPlanningConfig::set_planner_type(::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  set_has_planner_type();
  planner_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.planning.RtkPlanningConfig.planner_type)
}

// -------------------------------------------------------------------

// StandardPlanningConfig

// repeated .jmc_auto.planning.PlannerType planner_type = 1;
inline int StandardPlanningConfig::planner_type_size() const {
  return planner_type_.size();
}
inline void StandardPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
inline ::jmc_auto::planning::PlannerType StandardPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StandardPlanningConfig.planner_type)
  return static_cast< ::jmc_auto::planning::PlannerType >(planner_type_.Get(index));
}
inline void StandardPlanningConfig::set_planner_type(int index, ::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.StandardPlanningConfig.planner_type)
}
inline void StandardPlanningConfig::add_planner_type(::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.StandardPlanningConfig.planner_type)
}
inline const ::google::protobuf::RepeatedField<int>&
StandardPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.StandardPlanningConfig.planner_type)
  return planner_type_;
}
inline ::google::protobuf::RepeatedField<int>*
StandardPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.StandardPlanningConfig.planner_type)
  return &planner_type_;
}

// optional .jmc_auto.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
inline bool StandardPlanningConfig::has_planner_public_road_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StandardPlanningConfig::set_has_planner_public_road_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StandardPlanningConfig::clear_has_planner_public_road_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StandardPlanningConfig::clear_planner_public_road_config() {
  if (planner_public_road_config_ != NULL) planner_public_road_config_->::jmc_auto::planning::PlannerPublicRoadConfig::Clear();
  clear_has_planner_public_road_config();
}
inline const ::jmc_auto::planning::PlannerPublicRoadConfig& StandardPlanningConfig::planner_public_road_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
  return planner_public_road_config_ != NULL ? *planner_public_road_config_
                         : *::jmc_auto::planning::PlannerPublicRoadConfig::internal_default_instance();
}
inline ::jmc_auto::planning::PlannerPublicRoadConfig* StandardPlanningConfig::mutable_planner_public_road_config() {
  set_has_planner_public_road_config();
  if (planner_public_road_config_ == NULL) {
    planner_public_road_config_ = new ::jmc_auto::planning::PlannerPublicRoadConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
  return planner_public_road_config_;
}
inline ::jmc_auto::planning::PlannerPublicRoadConfig* StandardPlanningConfig::release_planner_public_road_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
  clear_has_planner_public_road_config();
  ::jmc_auto::planning::PlannerPublicRoadConfig* temp = planner_public_road_config_;
  planner_public_road_config_ = NULL;
  return temp;
}
inline void StandardPlanningConfig::set_allocated_planner_public_road_config(::jmc_auto::planning::PlannerPublicRoadConfig* planner_public_road_config) {
  delete planner_public_road_config_;
  planner_public_road_config_ = planner_public_road_config;
  if (planner_public_road_config) {
    set_has_planner_public_road_config();
  } else {
    clear_has_planner_public_road_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.StandardPlanningConfig.planner_public_road_config)
}

// -------------------------------------------------------------------

// NavigationPlanningConfig

// repeated .jmc_auto.planning.PlannerType planner_type = 1;
inline int NavigationPlanningConfig::planner_type_size() const {
  return planner_type_.size();
}
inline void NavigationPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
inline ::jmc_auto::planning::PlannerType NavigationPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.NavigationPlanningConfig.planner_type)
  return static_cast< ::jmc_auto::planning::PlannerType >(planner_type_.Get(index));
}
inline void NavigationPlanningConfig::set_planner_type(int index, ::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.planning.NavigationPlanningConfig.planner_type)
}
inline void NavigationPlanningConfig::add_planner_type(::jmc_auto::planning::PlannerType value) {
  assert(::jmc_auto::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.planning.NavigationPlanningConfig.planner_type)
}
inline const ::google::protobuf::RepeatedField<int>&
NavigationPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.NavigationPlanningConfig.planner_type)
  return planner_type_;
}
inline ::google::protobuf::RepeatedField<int>*
NavigationPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.NavigationPlanningConfig.planner_type)
  return &planner_type_;
}

// optional .jmc_auto.planning.PlannerNaviConfig planner_navi_config = 4;
inline bool NavigationPlanningConfig::has_planner_navi_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigationPlanningConfig::set_has_planner_navi_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigationPlanningConfig::clear_has_planner_navi_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigationPlanningConfig::clear_planner_navi_config() {
  if (planner_navi_config_ != NULL) planner_navi_config_->::jmc_auto::planning::PlannerNaviConfig::Clear();
  clear_has_planner_navi_config();
}
inline const ::jmc_auto::planning::PlannerNaviConfig& NavigationPlanningConfig::planner_navi_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
  return planner_navi_config_ != NULL ? *planner_navi_config_
                         : *::jmc_auto::planning::PlannerNaviConfig::internal_default_instance();
}
inline ::jmc_auto::planning::PlannerNaviConfig* NavigationPlanningConfig::mutable_planner_navi_config() {
  set_has_planner_navi_config();
  if (planner_navi_config_ == NULL) {
    planner_navi_config_ = new ::jmc_auto::planning::PlannerNaviConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
  return planner_navi_config_;
}
inline ::jmc_auto::planning::PlannerNaviConfig* NavigationPlanningConfig::release_planner_navi_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
  clear_has_planner_navi_config();
  ::jmc_auto::planning::PlannerNaviConfig* temp = planner_navi_config_;
  planner_navi_config_ = NULL;
  return temp;
}
inline void NavigationPlanningConfig::set_allocated_planner_navi_config(::jmc_auto::planning::PlannerNaviConfig* planner_navi_config) {
  delete planner_navi_config_;
  planner_navi_config_ = planner_navi_config;
  if (planner_navi_config) {
    set_has_planner_navi_config();
  } else {
    clear_has_planner_navi_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.NavigationPlanningConfig.planner_navi_config)
}

// -------------------------------------------------------------------

// PlanningConfig

// optional .jmc_auto.planning.RtkPlanningConfig rtk_planning_config = 1;
inline bool PlanningConfig::has_rtk_planning_config() const {
  return planning_config_case() == kRtkPlanningConfig;
}
inline void PlanningConfig::set_has_rtk_planning_config() {
  _oneof_case_[0] = kRtkPlanningConfig;
}
inline void PlanningConfig::clear_rtk_planning_config() {
  if (has_rtk_planning_config()) {
    delete planning_config_.rtk_planning_config_;
    clear_has_planning_config();
  }
}
inline  const ::jmc_auto::planning::RtkPlanningConfig& PlanningConfig::rtk_planning_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.rtk_planning_config)
  return has_rtk_planning_config()
      ? *planning_config_.rtk_planning_config_
      : ::jmc_auto::planning::RtkPlanningConfig::default_instance();
}
inline ::jmc_auto::planning::RtkPlanningConfig* PlanningConfig::mutable_rtk_planning_config() {
  if (!has_rtk_planning_config()) {
    clear_planning_config();
    set_has_rtk_planning_config();
    planning_config_.rtk_planning_config_ = new ::jmc_auto::planning::RtkPlanningConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.rtk_planning_config)
  return planning_config_.rtk_planning_config_;
}
inline ::jmc_auto::planning::RtkPlanningConfig* PlanningConfig::release_rtk_planning_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningConfig.rtk_planning_config)
  if (has_rtk_planning_config()) {
    clear_has_planning_config();
    ::jmc_auto::planning::RtkPlanningConfig* temp = planning_config_.rtk_planning_config_;
    planning_config_.rtk_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PlanningConfig::set_allocated_rtk_planning_config(::jmc_auto::planning::RtkPlanningConfig* rtk_planning_config) {
  clear_planning_config();
  if (rtk_planning_config) {
    set_has_rtk_planning_config();
    planning_config_.rtk_planning_config_ = rtk_planning_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningConfig.rtk_planning_config)
}

// optional .jmc_auto.planning.StandardPlanningConfig standard_planning_config = 2;
inline bool PlanningConfig::has_standard_planning_config() const {
  return planning_config_case() == kStandardPlanningConfig;
}
inline void PlanningConfig::set_has_standard_planning_config() {
  _oneof_case_[0] = kStandardPlanningConfig;
}
inline void PlanningConfig::clear_standard_planning_config() {
  if (has_standard_planning_config()) {
    delete planning_config_.standard_planning_config_;
    clear_has_planning_config();
  }
}
inline  const ::jmc_auto::planning::StandardPlanningConfig& PlanningConfig::standard_planning_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.standard_planning_config)
  return has_standard_planning_config()
      ? *planning_config_.standard_planning_config_
      : ::jmc_auto::planning::StandardPlanningConfig::default_instance();
}
inline ::jmc_auto::planning::StandardPlanningConfig* PlanningConfig::mutable_standard_planning_config() {
  if (!has_standard_planning_config()) {
    clear_planning_config();
    set_has_standard_planning_config();
    planning_config_.standard_planning_config_ = new ::jmc_auto::planning::StandardPlanningConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.standard_planning_config)
  return planning_config_.standard_planning_config_;
}
inline ::jmc_auto::planning::StandardPlanningConfig* PlanningConfig::release_standard_planning_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningConfig.standard_planning_config)
  if (has_standard_planning_config()) {
    clear_has_planning_config();
    ::jmc_auto::planning::StandardPlanningConfig* temp = planning_config_.standard_planning_config_;
    planning_config_.standard_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PlanningConfig::set_allocated_standard_planning_config(::jmc_auto::planning::StandardPlanningConfig* standard_planning_config) {
  clear_planning_config();
  if (standard_planning_config) {
    set_has_standard_planning_config();
    planning_config_.standard_planning_config_ = standard_planning_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningConfig.standard_planning_config)
}

// optional .jmc_auto.planning.NavigationPlanningConfig navigation_planning_config = 3;
inline bool PlanningConfig::has_navigation_planning_config() const {
  return planning_config_case() == kNavigationPlanningConfig;
}
inline void PlanningConfig::set_has_navigation_planning_config() {
  _oneof_case_[0] = kNavigationPlanningConfig;
}
inline void PlanningConfig::clear_navigation_planning_config() {
  if (has_navigation_planning_config()) {
    delete planning_config_.navigation_planning_config_;
    clear_has_planning_config();
  }
}
inline  const ::jmc_auto::planning::NavigationPlanningConfig& PlanningConfig::navigation_planning_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.navigation_planning_config)
  return has_navigation_planning_config()
      ? *planning_config_.navigation_planning_config_
      : ::jmc_auto::planning::NavigationPlanningConfig::default_instance();
}
inline ::jmc_auto::planning::NavigationPlanningConfig* PlanningConfig::mutable_navigation_planning_config() {
  if (!has_navigation_planning_config()) {
    clear_planning_config();
    set_has_navigation_planning_config();
    planning_config_.navigation_planning_config_ = new ::jmc_auto::planning::NavigationPlanningConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.navigation_planning_config)
  return planning_config_.navigation_planning_config_;
}
inline ::jmc_auto::planning::NavigationPlanningConfig* PlanningConfig::release_navigation_planning_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.planning.PlanningConfig.navigation_planning_config)
  if (has_navigation_planning_config()) {
    clear_has_planning_config();
    ::jmc_auto::planning::NavigationPlanningConfig* temp = planning_config_.navigation_planning_config_;
    planning_config_.navigation_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PlanningConfig::set_allocated_navigation_planning_config(::jmc_auto::planning::NavigationPlanningConfig* navigation_planning_config) {
  clear_planning_config();
  if (navigation_planning_config) {
    set_has_navigation_planning_config();
    planning_config_.navigation_planning_config_ = navigation_planning_config;
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.planning.PlanningConfig.navigation_planning_config)
}

// repeated .jmc_auto.planning.TaskConfig default_task_config = 5;
inline int PlanningConfig::default_task_config_size() const {
  return default_task_config_.size();
}
inline void PlanningConfig::clear_default_task_config() {
  default_task_config_.Clear();
}
inline const ::jmc_auto::planning::TaskConfig& PlanningConfig::default_task_config(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_.Get(index);
}
inline ::jmc_auto::planning::TaskConfig* PlanningConfig::mutable_default_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_.Mutable(index);
}
inline ::jmc_auto::planning::TaskConfig* PlanningConfig::add_default_task_config() {
  // @@protoc_insertion_point(field_add:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >*
PlanningConfig::mutable_default_task_config() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.planning.PlanningConfig.default_task_config)
  return &default_task_config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::planning::TaskConfig >&
PlanningConfig::default_task_config() const {
  // @@protoc_insertion_point(field_list:jmc_auto.planning.PlanningConfig.default_task_config)
  return default_task_config_;
}

inline bool PlanningConfig::has_planning_config() const {
  return planning_config_case() != PLANNING_CONFIG_NOT_SET;
}
inline void PlanningConfig::clear_has_planning_config() {
  _oneof_case_[0] = PLANNING_CONFIG_NOT_SET;
}
inline PlanningConfig::PlanningConfigCase PlanningConfig::planning_config_case() const {
  return PlanningConfig::PlanningConfigCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace planning
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::planning::TaskConfig_TaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::TaskConfig_TaskType>() {
  return ::jmc_auto::planning::TaskConfig_TaskType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::planning::ScenarioConfig_ScenarioType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::ScenarioConfig_ScenarioType>() {
  return ::jmc_auto::planning::ScenarioConfig_ScenarioType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::planning::ScenarioConfig_StageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::ScenarioConfig_StageType>() {
  return ::jmc_auto::planning::ScenarioConfig_StageType_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::planning::PlannerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::planning::PlannerType>() {
  return ::jmc_auto::planning::PlannerType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto__INCLUDED
