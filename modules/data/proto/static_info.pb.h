// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/data/proto/static_info.proto

#ifndef PROTOBUF_modules_2fdata_2fproto_2fstatic_5finfo_2eproto__INCLUDED
#define PROTOBUF_modules_2fdata_2fproto_2fstatic_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/canbus_conf.pb.h"
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/common/configs/proto/vehicle_config.pb.h"
#include "modules/control/proto/control_conf.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace canbus {
class CanbusConf;
class CanbusConfDefaultTypeInternal;
extern CanbusConfDefaultTypeInternal _CanbusConf_default_instance_;
class Chassis;
class ChassisDefaultTypeInternal;
extern ChassisDefaultTypeInternal _Chassis_default_instance_;
class ChassisGPS;
class ChassisGPSDefaultTypeInternal;
extern ChassisGPSDefaultTypeInternal _ChassisGPS_default_instance_;
class License;
class LicenseDefaultTypeInternal;
extern LicenseDefaultTypeInternal _License_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Sonar;
class SonarDefaultTypeInternal;
extern SonarDefaultTypeInternal _Sonar_default_instance_;
class Surround;
class SurroundDefaultTypeInternal;
extern SurroundDefaultTypeInternal _Surround_default_instance_;
class WheelSpeed;
class WheelSpeedDefaultTypeInternal;
extern WheelSpeedDefaultTypeInternal _WheelSpeed_default_instance_;
}  // namespace canbus
namespace common {
class Extrinsics;
class ExtrinsicsDefaultTypeInternal;
extern ExtrinsicsDefaultTypeInternal _Extrinsics_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class VehicleConfig;
class VehicleConfigDefaultTypeInternal;
extern VehicleConfigDefaultTypeInternal _VehicleConfig_default_instance_;
class VehicleParam;
class VehicleParamDefaultTypeInternal;
extern VehicleParamDefaultTypeInternal _VehicleParam_default_instance_;
}  // namespace common
namespace control {
class ControlConf;
class ControlConfDefaultTypeInternal;
extern ControlConfDefaultTypeInternal _ControlConf_default_instance_;
}  // namespace control
namespace data {
class EnvironmentInfo;
class EnvironmentInfoDefaultTypeInternal;
extern EnvironmentInfoDefaultTypeInternal _EnvironmentInfo_default_instance_;
class HardwareInfo;
class HardwareInfoDefaultTypeInternal;
extern HardwareInfoDefaultTypeInternal _HardwareInfo_default_instance_;
class HardwareInfo_ConfigsEntry;
class HardwareInfo_ConfigsEntryDefaultTypeInternal;
extern HardwareInfo_ConfigsEntryDefaultTypeInternal _HardwareInfo_ConfigsEntry_default_instance_;
class SoftwareInfo;
class SoftwareInfoDefaultTypeInternal;
extern SoftwareInfoDefaultTypeInternal _SoftwareInfo_default_instance_;
class SoftwareInfo_ConfigsEntry;
class SoftwareInfo_ConfigsEntryDefaultTypeInternal;
extern SoftwareInfo_ConfigsEntryDefaultTypeInternal _SoftwareInfo_ConfigsEntry_default_instance_;
class StaticInfo;
class StaticInfoDefaultTypeInternal;
extern StaticInfoDefaultTypeInternal _StaticInfo_default_instance_;
class StaticInfoConf;
class StaticInfoConfDefaultTypeInternal;
extern StaticInfoConfDefaultTypeInternal _StaticInfoConf_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class VehicleInfo;
class VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
}  // namespace data
namespace routing {
class LaneSegment;
class LaneSegmentDefaultTypeInternal;
extern LaneSegmentDefaultTypeInternal _LaneSegment_default_instance_;
class LaneWaypoint;
class LaneWaypointDefaultTypeInternal;
extern LaneWaypointDefaultTypeInternal _LaneWaypoint_default_instance_;
class Measurement;
class MeasurementDefaultTypeInternal;
extern MeasurementDefaultTypeInternal _Measurement_default_instance_;
class Passage;
class PassageDefaultTypeInternal;
extern PassageDefaultTypeInternal _Passage_default_instance_;
class RoadSegment;
class RoadSegmentDefaultTypeInternal;
extern RoadSegmentDefaultTypeInternal _RoadSegment_default_instance_;
class RoutingRequest;
class RoutingRequestDefaultTypeInternal;
extern RoutingRequestDefaultTypeInternal _RoutingRequest_default_instance_;
class RoutingResponse;
class RoutingResponseDefaultTypeInternal;
extern RoutingResponseDefaultTypeInternal _RoutingResponse_default_instance_;
}  // namespace routing
}  // namespace jmc_auto

namespace jmc_auto {
namespace data {

namespace protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto

enum VehicleInfo_Brand {
  VehicleInfo_Brand_LINCOLN = 1
};
bool VehicleInfo_Brand_IsValid(int value);
const VehicleInfo_Brand VehicleInfo_Brand_Brand_MIN = VehicleInfo_Brand_LINCOLN;
const VehicleInfo_Brand VehicleInfo_Brand_Brand_MAX = VehicleInfo_Brand_LINCOLN;
const int VehicleInfo_Brand_Brand_ARRAYSIZE = VehicleInfo_Brand_Brand_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleInfo_Brand_descriptor();
inline const ::std::string& VehicleInfo_Brand_Name(VehicleInfo_Brand value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleInfo_Brand_descriptor(), value);
}
inline bool VehicleInfo_Brand_Parse(
    const ::std::string& name, VehicleInfo_Brand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleInfo_Brand>(
    VehicleInfo_Brand_descriptor(), name, value);
}
enum VehicleInfo_Model {
  VehicleInfo_Model_MKZ = 1
};
bool VehicleInfo_Model_IsValid(int value);
const VehicleInfo_Model VehicleInfo_Model_Model_MIN = VehicleInfo_Model_MKZ;
const VehicleInfo_Model VehicleInfo_Model_Model_MAX = VehicleInfo_Model_MKZ;
const int VehicleInfo_Model_Model_ARRAYSIZE = VehicleInfo_Model_Model_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleInfo_Model_descriptor();
inline const ::std::string& VehicleInfo_Model_Name(VehicleInfo_Model value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleInfo_Model_descriptor(), value);
}
inline bool VehicleInfo_Model_Parse(
    const ::std::string& name, VehicleInfo_Model* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleInfo_Model>(
    VehicleInfo_Model_descriptor(), name, value);
}
// ===================================================================

class VehicleInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.VehicleInfo) */ {
 public:
  VehicleInfo();
  virtual ~VehicleInfo();

  VehicleInfo(const VehicleInfo& from);

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleInfo& default_instance();

  static inline const VehicleInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleInfo*>(
               &_VehicleInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VehicleInfo* other);

  // implements Message ----------------------------------------------

  inline VehicleInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleInfo& from);
  void MergeFrom(const VehicleInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VehicleInfo_Brand Brand;
  static const Brand LINCOLN =
    VehicleInfo_Brand_LINCOLN;
  static inline bool Brand_IsValid(int value) {
    return VehicleInfo_Brand_IsValid(value);
  }
  static const Brand Brand_MIN =
    VehicleInfo_Brand_Brand_MIN;
  static const Brand Brand_MAX =
    VehicleInfo_Brand_Brand_MAX;
  static const int Brand_ARRAYSIZE =
    VehicleInfo_Brand_Brand_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brand_descriptor() {
    return VehicleInfo_Brand_descriptor();
  }
  static inline const ::std::string& Brand_Name(Brand value) {
    return VehicleInfo_Brand_Name(value);
  }
  static inline bool Brand_Parse(const ::std::string& name,
      Brand* value) {
    return VehicleInfo_Brand_Parse(name, value);
  }

  typedef VehicleInfo_Model Model;
  static const Model MKZ =
    VehicleInfo_Model_MKZ;
  static inline bool Model_IsValid(int value) {
    return VehicleInfo_Model_IsValid(value);
  }
  static const Model Model_MIN =
    VehicleInfo_Model_Model_MIN;
  static const Model Model_MAX =
    VehicleInfo_Model_Model_MAX;
  static const int Model_ARRAYSIZE =
    VehicleInfo_Model_Model_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Model_descriptor() {
    return VehicleInfo_Model_descriptor();
  }
  static inline const ::std::string& Model_Name(Model value) {
    return VehicleInfo_Model_Name(value);
  }
  static inline bool Model_Parse(const ::std::string& name,
      Model* value) {
    return VehicleInfo_Model_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .jmc_auto.canbus.License license = 4;
  bool has_license() const;
  void clear_license();
  static const int kLicenseFieldNumber = 4;
  const ::jmc_auto::canbus::License& license() const;
  ::jmc_auto::canbus::License* mutable_license();
  ::jmc_auto::canbus::License* release_license();
  void set_allocated_license(::jmc_auto::canbus::License* license);

  // optional .jmc_auto.canbus.CanbusConf canbus_conf = 5;
  bool has_canbus_conf() const;
  void clear_canbus_conf();
  static const int kCanbusConfFieldNumber = 5;
  const ::jmc_auto::canbus::CanbusConf& canbus_conf() const;
  ::jmc_auto::canbus::CanbusConf* mutable_canbus_conf();
  ::jmc_auto::canbus::CanbusConf* release_canbus_conf();
  void set_allocated_canbus_conf(::jmc_auto::canbus::CanbusConf* canbus_conf);

  // optional .jmc_auto.common.VehicleConfig vehicle_config = 6;
  bool has_vehicle_config() const;
  void clear_vehicle_config();
  static const int kVehicleConfigFieldNumber = 6;
  const ::jmc_auto::common::VehicleConfig& vehicle_config() const;
  ::jmc_auto::common::VehicleConfig* mutable_vehicle_config();
  ::jmc_auto::common::VehicleConfig* release_vehicle_config();
  void set_allocated_vehicle_config(::jmc_auto::common::VehicleConfig* vehicle_config);

  // optional .jmc_auto.control.ControlConf control_config = 7;
  bool has_control_config() const;
  void clear_control_config();
  static const int kControlConfigFieldNumber = 7;
  const ::jmc_auto::control::ControlConf& control_config() const;
  ::jmc_auto::control::ControlConf* mutable_control_config();
  ::jmc_auto::control::ControlConf* release_control_config();
  void set_allocated_control_config(::jmc_auto::control::ControlConf* control_config);

  // optional .jmc_auto.data.VehicleInfo.Brand brand = 2;
  bool has_brand() const;
  void clear_brand();
  static const int kBrandFieldNumber = 2;
  ::jmc_auto::data::VehicleInfo_Brand brand() const;
  void set_brand(::jmc_auto::data::VehicleInfo_Brand value);

  // optional .jmc_auto.data.VehicleInfo.Model model = 3;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 3;
  ::jmc_auto::data::VehicleInfo_Model model() const;
  void set_model(::jmc_auto::data::VehicleInfo_Model value);

  // @@protoc_insertion_point(class_scope:jmc_auto.data.VehicleInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_brand();
  void clear_has_brand();
  void set_has_model();
  void clear_has_model();
  void set_has_license();
  void clear_has_license();
  void set_has_canbus_conf();
  void clear_has_canbus_conf();
  void set_has_vehicle_config();
  void clear_has_vehicle_config();
  void set_has_control_config();
  void clear_has_control_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::jmc_auto::canbus::License* license_;
  ::jmc_auto::canbus::CanbusConf* canbus_conf_;
  ::jmc_auto::common::VehicleConfig* vehicle_config_;
  ::jmc_auto::control::ControlConf* control_config_;
  int brand_;
  int model_;
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnvironmentInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.EnvironmentInfo) */ {
 public:
  EnvironmentInfo();
  virtual ~EnvironmentInfo();

  EnvironmentInfo(const EnvironmentInfo& from);

  inline EnvironmentInfo& operator=(const EnvironmentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnvironmentInfo& default_instance();

  static inline const EnvironmentInfo* internal_default_instance() {
    return reinterpret_cast<const EnvironmentInfo*>(
               &_EnvironmentInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(EnvironmentInfo* other);

  // implements Message ----------------------------------------------

  inline EnvironmentInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EnvironmentInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnvironmentInfo& from);
  void MergeFrom(const EnvironmentInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnvironmentInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional float temperature = 2;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 2;
  float temperature() const;
  void set_temperature(float value);

  // @@protoc_insertion_point(class_scope:jmc_auto.data.EnvironmentInfo)
 private:
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_temperature();
  void clear_has_temperature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  float temperature_;
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class HardwareInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.HardwareInfo) */ {
 public:
  HardwareInfo();
  virtual ~HardwareInfo();

  HardwareInfo(const HardwareInfo& from);

  inline HardwareInfo& operator=(const HardwareInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HardwareInfo& default_instance();

  static inline const HardwareInfo* internal_default_instance() {
    return reinterpret_cast<const HardwareInfo*>(
               &_HardwareInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(HardwareInfo* other);

  // implements Message ----------------------------------------------

  inline HardwareInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HardwareInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HardwareInfo& from);
  void MergeFrom(const HardwareInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HardwareInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> configs = 1;
  int configs_size() const;
  void clear_configs();
  static const int kConfigsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      configs() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_configs();

  // @@protoc_insertion_point(class_scope:jmc_auto.data.HardwareInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  public:
  class HardwareInfo_ConfigsEntry : public ::google::protobuf::internal::MapEntry<HardwareInfo_ConfigsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<HardwareInfo_ConfigsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > SuperType;
    HardwareInfo_ConfigsEntry();
    HardwareInfo_ConfigsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const HardwareInfo_ConfigsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_HardwareInfo_ConfigsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  ::google::protobuf::internal::MapField<
      HardwareInfo_ConfigsEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > configs_;
  private:
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class SoftwareInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.SoftwareInfo) */ {
 public:
  SoftwareInfo();
  virtual ~SoftwareInfo();

  SoftwareInfo(const SoftwareInfo& from);

  inline SoftwareInfo& operator=(const SoftwareInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftwareInfo& default_instance();

  static inline const SoftwareInfo* internal_default_instance() {
    return reinterpret_cast<const SoftwareInfo*>(
               &_SoftwareInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SoftwareInfo* other);

  // implements Message ----------------------------------------------

  inline SoftwareInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SoftwareInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SoftwareInfo& from);
  void MergeFrom(const SoftwareInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SoftwareInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> configs = 4;
  int configs_size() const;
  void clear_configs();
  static const int kConfigsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      configs() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_configs();

  // optional string docker_image = 1;
  bool has_docker_image() const;
  void clear_docker_image();
  static const int kDockerImageFieldNumber = 1;
  const ::std::string& docker_image() const;
  void set_docker_image(const ::std::string& value);
  #if LANG_CXX11
  void set_docker_image(::std::string&& value);
  #endif
  void set_docker_image(const char* value);
  void set_docker_image(const char* value, size_t size);
  ::std::string* mutable_docker_image();
  ::std::string* release_docker_image();
  void set_allocated_docker_image(::std::string* docker_image);

  // optional string commit_id = 2;
  bool has_commit_id() const;
  void clear_commit_id();
  static const int kCommitIdFieldNumber = 2;
  const ::std::string& commit_id() const;
  void set_commit_id(const ::std::string& value);
  #if LANG_CXX11
  void set_commit_id(::std::string&& value);
  #endif
  void set_commit_id(const char* value);
  void set_commit_id(const char* value, size_t size);
  ::std::string* mutable_commit_id();
  ::std::string* release_commit_id();
  void set_allocated_commit_id(::std::string* commit_id);

  // optional string mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // optional .jmc_auto.routing.RoutingRequest latest_routing_request = 5;
  bool has_latest_routing_request() const;
  void clear_latest_routing_request();
  static const int kLatestRoutingRequestFieldNumber = 5;
  const ::jmc_auto::routing::RoutingRequest& latest_routing_request() const;
  ::jmc_auto::routing::RoutingRequest* mutable_latest_routing_request();
  ::jmc_auto::routing::RoutingRequest* release_latest_routing_request();
  void set_allocated_latest_routing_request(::jmc_auto::routing::RoutingRequest* latest_routing_request);

  // @@protoc_insertion_point(class_scope:jmc_auto.data.SoftwareInfo)
 private:
  void set_has_docker_image();
  void clear_has_docker_image();
  void set_has_commit_id();
  void clear_has_commit_id();
  void set_has_mode();
  void clear_has_mode();
  void set_has_latest_routing_request();
  void clear_has_latest_routing_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  public:
  class SoftwareInfo_ConfigsEntry : public ::google::protobuf::internal::MapEntry<SoftwareInfo_ConfigsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<SoftwareInfo_ConfigsEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > SuperType;
    SoftwareInfo_ConfigsEntry();
    SoftwareInfo_ConfigsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const SoftwareInfo_ConfigsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_SoftwareInfo_ConfigsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  ::google::protobuf::internal::MapField<
      SoftwareInfo_ConfigsEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > configs_;
  private:
  ::google::protobuf::internal::ArenaStringPtr docker_image_;
  ::google::protobuf::internal::ArenaStringPtr commit_id_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::jmc_auto::routing::RoutingRequest* latest_routing_request_;
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  inline UserInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  UserInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string entity = 1;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 1;
  const ::std::string& entity() const;
  void set_entity(const ::std::string& value);
  #if LANG_CXX11
  void set_entity(::std::string&& value);
  #endif
  void set_entity(const char* value);
  void set_entity(const char* value, size_t size);
  ::std::string* mutable_entity();
  ::std::string* release_entity();
  void set_allocated_entity(::std::string* entity);

  // optional string driver = 2;
  bool has_driver() const;
  void clear_driver();
  static const int kDriverFieldNumber = 2;
  const ::std::string& driver() const;
  void set_driver(const ::std::string& value);
  #if LANG_CXX11
  void set_driver(::std::string&& value);
  #endif
  void set_driver(const char* value);
  void set_driver(const char* value, size_t size);
  ::std::string* mutable_driver();
  ::std::string* release_driver();
  void set_allocated_driver(::std::string* driver);

  // optional string co_driver = 3;
  bool has_co_driver() const;
  void clear_co_driver();
  static const int kCoDriverFieldNumber = 3;
  const ::std::string& co_driver() const;
  void set_co_driver(const ::std::string& value);
  #if LANG_CXX11
  void set_co_driver(::std::string&& value);
  #endif
  void set_co_driver(const char* value);
  void set_co_driver(const char* value, size_t size);
  ::std::string* mutable_co_driver();
  ::std::string* release_co_driver();
  void set_allocated_co_driver(::std::string* co_driver);

  // @@protoc_insertion_point(class_scope:jmc_auto.data.UserInfo)
 private:
  void set_has_entity();
  void clear_has_entity();
  void set_has_driver();
  void clear_has_driver();
  void set_has_co_driver();
  void clear_has_co_driver();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr entity_;
  ::google::protobuf::internal::ArenaStringPtr driver_;
  ::google::protobuf::internal::ArenaStringPtr co_driver_;
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaticInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.StaticInfo) */ {
 public:
  StaticInfo();
  virtual ~StaticInfo();

  StaticInfo(const StaticInfo& from);

  inline StaticInfo& operator=(const StaticInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticInfo& default_instance();

  static inline const StaticInfo* internal_default_instance() {
    return reinterpret_cast<const StaticInfo*>(
               &_StaticInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(StaticInfo* other);

  // implements Message ----------------------------------------------

  inline StaticInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  StaticInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaticInfo& from);
  void MergeFrom(const StaticInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaticInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .jmc_auto.data.VehicleInfo vehicle = 1;
  bool has_vehicle() const;
  void clear_vehicle();
  static const int kVehicleFieldNumber = 1;
  const ::jmc_auto::data::VehicleInfo& vehicle() const;
  ::jmc_auto::data::VehicleInfo* mutable_vehicle();
  ::jmc_auto::data::VehicleInfo* release_vehicle();
  void set_allocated_vehicle(::jmc_auto::data::VehicleInfo* vehicle);

  // optional .jmc_auto.data.EnvironmentInfo environment = 2;
  bool has_environment() const;
  void clear_environment();
  static const int kEnvironmentFieldNumber = 2;
  const ::jmc_auto::data::EnvironmentInfo& environment() const;
  ::jmc_auto::data::EnvironmentInfo* mutable_environment();
  ::jmc_auto::data::EnvironmentInfo* release_environment();
  void set_allocated_environment(::jmc_auto::data::EnvironmentInfo* environment);

  // optional .jmc_auto.data.HardwareInfo hardware = 3;
  bool has_hardware() const;
  void clear_hardware();
  static const int kHardwareFieldNumber = 3;
  const ::jmc_auto::data::HardwareInfo& hardware() const;
  ::jmc_auto::data::HardwareInfo* mutable_hardware();
  ::jmc_auto::data::HardwareInfo* release_hardware();
  void set_allocated_hardware(::jmc_auto::data::HardwareInfo* hardware);

  // optional .jmc_auto.data.SoftwareInfo software = 4;
  bool has_software() const;
  void clear_software();
  static const int kSoftwareFieldNumber = 4;
  const ::jmc_auto::data::SoftwareInfo& software() const;
  ::jmc_auto::data::SoftwareInfo* mutable_software();
  ::jmc_auto::data::SoftwareInfo* release_software();
  void set_allocated_software(::jmc_auto::data::SoftwareInfo* software);

  // optional .jmc_auto.data.UserInfo user = 5;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 5;
  const ::jmc_auto::data::UserInfo& user() const;
  ::jmc_auto::data::UserInfo* mutable_user();
  ::jmc_auto::data::UserInfo* release_user();
  void set_allocated_user(::jmc_auto::data::UserInfo* user);

  // @@protoc_insertion_point(class_scope:jmc_auto.data.StaticInfo)
 private:
  void set_has_vehicle();
  void clear_has_vehicle();
  void set_has_environment();
  void clear_has_environment();
  void set_has_hardware();
  void clear_has_hardware();
  void set_has_software();
  void clear_has_software();
  void set_has_user();
  void clear_has_user();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::jmc_auto::data::VehicleInfo* vehicle_;
  ::jmc_auto::data::EnvironmentInfo* environment_;
  ::jmc_auto::data::HardwareInfo* hardware_;
  ::jmc_auto::data::SoftwareInfo* software_;
  ::jmc_auto::data::UserInfo* user_;
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaticInfoConf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.data.StaticInfoConf) */ {
 public:
  StaticInfoConf();
  virtual ~StaticInfoConf();

  StaticInfoConf(const StaticInfoConf& from);

  inline StaticInfoConf& operator=(const StaticInfoConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticInfoConf& default_instance();

  static inline const StaticInfoConf* internal_default_instance() {
    return reinterpret_cast<const StaticInfoConf*>(
               &_StaticInfoConf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StaticInfoConf* other);

  // implements Message ----------------------------------------------

  inline StaticInfoConf* New() const PROTOBUF_FINAL { return New(NULL); }

  StaticInfoConf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaticInfoConf& from);
  void MergeFrom(const StaticInfoConf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaticInfoConf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string hardware_configs = 1;
  int hardware_configs_size() const;
  void clear_hardware_configs();
  static const int kHardwareConfigsFieldNumber = 1;
  const ::std::string& hardware_configs(int index) const;
  ::std::string* mutable_hardware_configs(int index);
  void set_hardware_configs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_hardware_configs(int index, ::std::string&& value);
  #endif
  void set_hardware_configs(int index, const char* value);
  void set_hardware_configs(int index, const char* value, size_t size);
  ::std::string* add_hardware_configs();
  void add_hardware_configs(const ::std::string& value);
  #if LANG_CXX11
  void add_hardware_configs(::std::string&& value);
  #endif
  void add_hardware_configs(const char* value);
  void add_hardware_configs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& hardware_configs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hardware_configs();

  // repeated string software_configs = 2;
  int software_configs_size() const;
  void clear_software_configs();
  static const int kSoftwareConfigsFieldNumber = 2;
  const ::std::string& software_configs(int index) const;
  ::std::string* mutable_software_configs(int index);
  void set_software_configs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_software_configs(int index, ::std::string&& value);
  #endif
  void set_software_configs(int index, const char* value);
  void set_software_configs(int index, const char* value, size_t size);
  ::std::string* add_software_configs();
  void add_software_configs(const ::std::string& value);
  #if LANG_CXX11
  void add_software_configs(::std::string&& value);
  #endif
  void add_software_configs(const char* value);
  void add_software_configs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& software_configs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_software_configs();

  // @@protoc_insertion_point(class_scope:jmc_auto.data.StaticInfoConf)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hardware_configs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> software_configs_;
  friend struct protobuf_modules_2fdata_2fproto_2fstatic_5finfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// VehicleInfo

// optional string name = 1;
inline bool VehicleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& VehicleInfo::name() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.name)
  return name_.GetNoArena();
}
inline void VehicleInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.VehicleInfo.name)
}
#if LANG_CXX11
inline void VehicleInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.VehicleInfo.name)
}
#endif
inline void VehicleInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.VehicleInfo.name)
}
inline void VehicleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.VehicleInfo.name)
}
inline ::std::string* VehicleInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.VehicleInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleInfo::release_name() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.VehicleInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.VehicleInfo.name)
}

// optional .jmc_auto.data.VehicleInfo.Brand brand = 2;
inline bool VehicleInfo::has_brand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleInfo::set_has_brand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleInfo::clear_has_brand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleInfo::clear_brand() {
  brand_ = 1;
  clear_has_brand();
}
inline ::jmc_auto::data::VehicleInfo_Brand VehicleInfo::brand() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.brand)
  return static_cast< ::jmc_auto::data::VehicleInfo_Brand >(brand_);
}
inline void VehicleInfo::set_brand(::jmc_auto::data::VehicleInfo_Brand value) {
  assert(::jmc_auto::data::VehicleInfo_Brand_IsValid(value));
  set_has_brand();
  brand_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.data.VehicleInfo.brand)
}

// optional .jmc_auto.data.VehicleInfo.Model model = 3;
inline bool VehicleInfo::has_model() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleInfo::set_has_model() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleInfo::clear_model() {
  model_ = 1;
  clear_has_model();
}
inline ::jmc_auto::data::VehicleInfo_Model VehicleInfo::model() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.model)
  return static_cast< ::jmc_auto::data::VehicleInfo_Model >(model_);
}
inline void VehicleInfo::set_model(::jmc_auto::data::VehicleInfo_Model value) {
  assert(::jmc_auto::data::VehicleInfo_Model_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.data.VehicleInfo.model)
}

// optional .jmc_auto.canbus.License license = 4;
inline bool VehicleInfo::has_license() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleInfo::set_has_license() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleInfo::clear_has_license() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleInfo::clear_license() {
  if (license_ != NULL) license_->::jmc_auto::canbus::License::Clear();
  clear_has_license();
}
inline const ::jmc_auto::canbus::License& VehicleInfo::license() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.license)
  return license_ != NULL ? *license_
                         : *::jmc_auto::canbus::License::internal_default_instance();
}
inline ::jmc_auto::canbus::License* VehicleInfo::mutable_license() {
  set_has_license();
  if (license_ == NULL) {
    license_ = new ::jmc_auto::canbus::License;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.VehicleInfo.license)
  return license_;
}
inline ::jmc_auto::canbus::License* VehicleInfo::release_license() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.VehicleInfo.license)
  clear_has_license();
  ::jmc_auto::canbus::License* temp = license_;
  license_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_license(::jmc_auto::canbus::License* license) {
  delete license_;
  license_ = license;
  if (license) {
    set_has_license();
  } else {
    clear_has_license();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.VehicleInfo.license)
}

// optional .jmc_auto.canbus.CanbusConf canbus_conf = 5;
inline bool VehicleInfo::has_canbus_conf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleInfo::set_has_canbus_conf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleInfo::clear_has_canbus_conf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleInfo::clear_canbus_conf() {
  if (canbus_conf_ != NULL) canbus_conf_->::jmc_auto::canbus::CanbusConf::Clear();
  clear_has_canbus_conf();
}
inline const ::jmc_auto::canbus::CanbusConf& VehicleInfo::canbus_conf() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.canbus_conf)
  return canbus_conf_ != NULL ? *canbus_conf_
                         : *::jmc_auto::canbus::CanbusConf::internal_default_instance();
}
inline ::jmc_auto::canbus::CanbusConf* VehicleInfo::mutable_canbus_conf() {
  set_has_canbus_conf();
  if (canbus_conf_ == NULL) {
    canbus_conf_ = new ::jmc_auto::canbus::CanbusConf;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.VehicleInfo.canbus_conf)
  return canbus_conf_;
}
inline ::jmc_auto::canbus::CanbusConf* VehicleInfo::release_canbus_conf() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.VehicleInfo.canbus_conf)
  clear_has_canbus_conf();
  ::jmc_auto::canbus::CanbusConf* temp = canbus_conf_;
  canbus_conf_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_canbus_conf(::jmc_auto::canbus::CanbusConf* canbus_conf) {
  delete canbus_conf_;
  canbus_conf_ = canbus_conf;
  if (canbus_conf) {
    set_has_canbus_conf();
  } else {
    clear_has_canbus_conf();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.VehicleInfo.canbus_conf)
}

// optional .jmc_auto.common.VehicleConfig vehicle_config = 6;
inline bool VehicleInfo::has_vehicle_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleInfo::set_has_vehicle_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleInfo::clear_has_vehicle_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleInfo::clear_vehicle_config() {
  if (vehicle_config_ != NULL) vehicle_config_->::jmc_auto::common::VehicleConfig::Clear();
  clear_has_vehicle_config();
}
inline const ::jmc_auto::common::VehicleConfig& VehicleInfo::vehicle_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.vehicle_config)
  return vehicle_config_ != NULL ? *vehicle_config_
                         : *::jmc_auto::common::VehicleConfig::internal_default_instance();
}
inline ::jmc_auto::common::VehicleConfig* VehicleInfo::mutable_vehicle_config() {
  set_has_vehicle_config();
  if (vehicle_config_ == NULL) {
    vehicle_config_ = new ::jmc_auto::common::VehicleConfig;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.VehicleInfo.vehicle_config)
  return vehicle_config_;
}
inline ::jmc_auto::common::VehicleConfig* VehicleInfo::release_vehicle_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.VehicleInfo.vehicle_config)
  clear_has_vehicle_config();
  ::jmc_auto::common::VehicleConfig* temp = vehicle_config_;
  vehicle_config_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_vehicle_config(::jmc_auto::common::VehicleConfig* vehicle_config) {
  delete vehicle_config_;
  vehicle_config_ = vehicle_config;
  if (vehicle_config) {
    set_has_vehicle_config();
  } else {
    clear_has_vehicle_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.VehicleInfo.vehicle_config)
}

// optional .jmc_auto.control.ControlConf control_config = 7;
inline bool VehicleInfo::has_control_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleInfo::set_has_control_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleInfo::clear_has_control_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleInfo::clear_control_config() {
  if (control_config_ != NULL) control_config_->::jmc_auto::control::ControlConf::Clear();
  clear_has_control_config();
}
inline const ::jmc_auto::control::ControlConf& VehicleInfo::control_config() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.VehicleInfo.control_config)
  return control_config_ != NULL ? *control_config_
                         : *::jmc_auto::control::ControlConf::internal_default_instance();
}
inline ::jmc_auto::control::ControlConf* VehicleInfo::mutable_control_config() {
  set_has_control_config();
  if (control_config_ == NULL) {
    control_config_ = new ::jmc_auto::control::ControlConf;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.VehicleInfo.control_config)
  return control_config_;
}
inline ::jmc_auto::control::ControlConf* VehicleInfo::release_control_config() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.VehicleInfo.control_config)
  clear_has_control_config();
  ::jmc_auto::control::ControlConf* temp = control_config_;
  control_config_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_control_config(::jmc_auto::control::ControlConf* control_config) {
  delete control_config_;
  control_config_ = control_config;
  if (control_config) {
    set_has_control_config();
  } else {
    clear_has_control_config();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.VehicleInfo.control_config)
}

// -------------------------------------------------------------------

// EnvironmentInfo

// optional string map_name = 1;
inline bool EnvironmentInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnvironmentInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnvironmentInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnvironmentInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& EnvironmentInfo::map_name() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.EnvironmentInfo.map_name)
  return map_name_.GetNoArena();
}
inline void EnvironmentInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.EnvironmentInfo.map_name)
}
#if LANG_CXX11
inline void EnvironmentInfo::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.EnvironmentInfo.map_name)
}
#endif
inline void EnvironmentInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.EnvironmentInfo.map_name)
}
inline void EnvironmentInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.EnvironmentInfo.map_name)
}
inline ::std::string* EnvironmentInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.EnvironmentInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnvironmentInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.EnvironmentInfo.map_name)
  clear_has_map_name();
  return map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnvironmentInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.EnvironmentInfo.map_name)
}

// optional float temperature = 2;
inline bool EnvironmentInfo::has_temperature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnvironmentInfo::set_has_temperature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnvironmentInfo::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnvironmentInfo::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float EnvironmentInfo::temperature() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.EnvironmentInfo.temperature)
  return temperature_;
}
inline void EnvironmentInfo::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.data.EnvironmentInfo.temperature)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HardwareInfo

// map<string, string> configs = 1;
inline int HardwareInfo::configs_size() const {
  return configs_.size();
}
inline void HardwareInfo::clear_configs() {
  configs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
HardwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:jmc_auto.data.HardwareInfo.configs)
  return configs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
HardwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:jmc_auto.data.HardwareInfo.configs)
  return configs_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SoftwareInfo

// optional string docker_image = 1;
inline bool SoftwareInfo::has_docker_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftwareInfo::set_has_docker_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftwareInfo::clear_has_docker_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftwareInfo::clear_docker_image() {
  docker_image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docker_image();
}
inline const ::std::string& SoftwareInfo::docker_image() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.SoftwareInfo.docker_image)
  return docker_image_.GetNoArena();
}
inline void SoftwareInfo::set_docker_image(const ::std::string& value) {
  set_has_docker_image();
  docker_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.SoftwareInfo.docker_image)
}
#if LANG_CXX11
inline void SoftwareInfo::set_docker_image(::std::string&& value) {
  set_has_docker_image();
  docker_image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.SoftwareInfo.docker_image)
}
#endif
inline void SoftwareInfo::set_docker_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_docker_image();
  docker_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.SoftwareInfo.docker_image)
}
inline void SoftwareInfo::set_docker_image(const char* value, size_t size) {
  set_has_docker_image();
  docker_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.SoftwareInfo.docker_image)
}
inline ::std::string* SoftwareInfo::mutable_docker_image() {
  set_has_docker_image();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.SoftwareInfo.docker_image)
  return docker_image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SoftwareInfo::release_docker_image() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.SoftwareInfo.docker_image)
  clear_has_docker_image();
  return docker_image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_docker_image(::std::string* docker_image) {
  if (docker_image != NULL) {
    set_has_docker_image();
  } else {
    clear_has_docker_image();
  }
  docker_image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docker_image);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.SoftwareInfo.docker_image)
}

// optional string commit_id = 2;
inline bool SoftwareInfo::has_commit_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftwareInfo::set_has_commit_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftwareInfo::clear_has_commit_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftwareInfo::clear_commit_id() {
  commit_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_commit_id();
}
inline const ::std::string& SoftwareInfo::commit_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.SoftwareInfo.commit_id)
  return commit_id_.GetNoArena();
}
inline void SoftwareInfo::set_commit_id(const ::std::string& value) {
  set_has_commit_id();
  commit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.SoftwareInfo.commit_id)
}
#if LANG_CXX11
inline void SoftwareInfo::set_commit_id(::std::string&& value) {
  set_has_commit_id();
  commit_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.SoftwareInfo.commit_id)
}
#endif
inline void SoftwareInfo::set_commit_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_commit_id();
  commit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.SoftwareInfo.commit_id)
}
inline void SoftwareInfo::set_commit_id(const char* value, size_t size) {
  set_has_commit_id();
  commit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.SoftwareInfo.commit_id)
}
inline ::std::string* SoftwareInfo::mutable_commit_id() {
  set_has_commit_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.SoftwareInfo.commit_id)
  return commit_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SoftwareInfo::release_commit_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.SoftwareInfo.commit_id)
  clear_has_commit_id();
  return commit_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_commit_id(::std::string* commit_id) {
  if (commit_id != NULL) {
    set_has_commit_id();
  } else {
    clear_has_commit_id();
  }
  commit_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commit_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.SoftwareInfo.commit_id)
}

// optional string mode = 3;
inline bool SoftwareInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SoftwareInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SoftwareInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SoftwareInfo::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mode();
}
inline const ::std::string& SoftwareInfo::mode() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.SoftwareInfo.mode)
  return mode_.GetNoArena();
}
inline void SoftwareInfo::set_mode(const ::std::string& value) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.SoftwareInfo.mode)
}
#if LANG_CXX11
inline void SoftwareInfo::set_mode(::std::string&& value) {
  set_has_mode();
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.SoftwareInfo.mode)
}
#endif
inline void SoftwareInfo::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.SoftwareInfo.mode)
}
inline void SoftwareInfo::set_mode(const char* value, size_t size) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.SoftwareInfo.mode)
}
inline ::std::string* SoftwareInfo::mutable_mode() {
  set_has_mode();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.SoftwareInfo.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SoftwareInfo::release_mode() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.SoftwareInfo.mode)
  clear_has_mode();
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    set_has_mode();
  } else {
    clear_has_mode();
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.SoftwareInfo.mode)
}

// map<string, string> configs = 4;
inline int SoftwareInfo::configs_size() const {
  return configs_.size();
}
inline void SoftwareInfo::clear_configs() {
  configs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
SoftwareInfo::configs() const {
  // @@protoc_insertion_point(field_map:jmc_auto.data.SoftwareInfo.configs)
  return configs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
SoftwareInfo::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:jmc_auto.data.SoftwareInfo.configs)
  return configs_.MutableMap();
}

// optional .jmc_auto.routing.RoutingRequest latest_routing_request = 5;
inline bool SoftwareInfo::has_latest_routing_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SoftwareInfo::set_has_latest_routing_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SoftwareInfo::clear_has_latest_routing_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SoftwareInfo::clear_latest_routing_request() {
  if (latest_routing_request_ != NULL) latest_routing_request_->::jmc_auto::routing::RoutingRequest::Clear();
  clear_has_latest_routing_request();
}
inline const ::jmc_auto::routing::RoutingRequest& SoftwareInfo::latest_routing_request() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.SoftwareInfo.latest_routing_request)
  return latest_routing_request_ != NULL ? *latest_routing_request_
                         : *::jmc_auto::routing::RoutingRequest::internal_default_instance();
}
inline ::jmc_auto::routing::RoutingRequest* SoftwareInfo::mutable_latest_routing_request() {
  set_has_latest_routing_request();
  if (latest_routing_request_ == NULL) {
    latest_routing_request_ = new ::jmc_auto::routing::RoutingRequest;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.SoftwareInfo.latest_routing_request)
  return latest_routing_request_;
}
inline ::jmc_auto::routing::RoutingRequest* SoftwareInfo::release_latest_routing_request() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.SoftwareInfo.latest_routing_request)
  clear_has_latest_routing_request();
  ::jmc_auto::routing::RoutingRequest* temp = latest_routing_request_;
  latest_routing_request_ = NULL;
  return temp;
}
inline void SoftwareInfo::set_allocated_latest_routing_request(::jmc_auto::routing::RoutingRequest* latest_routing_request) {
  delete latest_routing_request_;
  latest_routing_request_ = latest_routing_request;
  if (latest_routing_request) {
    set_has_latest_routing_request();
  } else {
    clear_has_latest_routing_request();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.SoftwareInfo.latest_routing_request)
}

// -------------------------------------------------------------------

// UserInfo

// optional string entity = 1;
inline bool UserInfo::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_entity() {
  entity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entity();
}
inline const ::std::string& UserInfo::entity() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.UserInfo.entity)
  return entity_.GetNoArena();
}
inline void UserInfo::set_entity(const ::std::string& value) {
  set_has_entity();
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.UserInfo.entity)
}
#if LANG_CXX11
inline void UserInfo::set_entity(::std::string&& value) {
  set_has_entity();
  entity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.UserInfo.entity)
}
#endif
inline void UserInfo::set_entity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entity();
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.UserInfo.entity)
}
inline void UserInfo::set_entity(const char* value, size_t size) {
  set_has_entity();
  entity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.UserInfo.entity)
}
inline ::std::string* UserInfo::mutable_entity() {
  set_has_entity();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.UserInfo.entity)
  return entity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_entity() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.UserInfo.entity)
  clear_has_entity();
  return entity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_entity(::std::string* entity) {
  if (entity != NULL) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
  entity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entity);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.UserInfo.entity)
}

// optional string driver = 2;
inline bool UserInfo::has_driver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_driver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_driver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_driver() {
  driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driver();
}
inline const ::std::string& UserInfo::driver() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.UserInfo.driver)
  return driver_.GetNoArena();
}
inline void UserInfo::set_driver(const ::std::string& value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.UserInfo.driver)
}
#if LANG_CXX11
inline void UserInfo::set_driver(::std::string&& value) {
  set_has_driver();
  driver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.UserInfo.driver)
}
#endif
inline void UserInfo::set_driver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.UserInfo.driver)
}
inline void UserInfo::set_driver(const char* value, size_t size) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.UserInfo.driver)
}
inline ::std::string* UserInfo::mutable_driver() {
  set_has_driver();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.UserInfo.driver)
  return driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_driver() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.UserInfo.driver)
  clear_has_driver();
  return driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_driver(::std::string* driver) {
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.UserInfo.driver)
}

// optional string co_driver = 3;
inline bool UserInfo::has_co_driver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_co_driver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_co_driver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_co_driver() {
  co_driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_co_driver();
}
inline const ::std::string& UserInfo::co_driver() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.UserInfo.co_driver)
  return co_driver_.GetNoArena();
}
inline void UserInfo::set_co_driver(const ::std::string& value) {
  set_has_co_driver();
  co_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.data.UserInfo.co_driver)
}
#if LANG_CXX11
inline void UserInfo::set_co_driver(::std::string&& value) {
  set_has_co_driver();
  co_driver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.data.UserInfo.co_driver)
}
#endif
inline void UserInfo::set_co_driver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_co_driver();
  co_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.UserInfo.co_driver)
}
inline void UserInfo::set_co_driver(const char* value, size_t size) {
  set_has_co_driver();
  co_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.UserInfo.co_driver)
}
inline ::std::string* UserInfo::mutable_co_driver() {
  set_has_co_driver();
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.UserInfo.co_driver)
  return co_driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_co_driver() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.UserInfo.co_driver)
  clear_has_co_driver();
  return co_driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_co_driver(::std::string* co_driver) {
  if (co_driver != NULL) {
    set_has_co_driver();
  } else {
    clear_has_co_driver();
  }
  co_driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), co_driver);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.UserInfo.co_driver)
}

// -------------------------------------------------------------------

// StaticInfo

// optional .jmc_auto.data.VehicleInfo vehicle = 1;
inline bool StaticInfo::has_vehicle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StaticInfo::set_has_vehicle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StaticInfo::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StaticInfo::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::jmc_auto::data::VehicleInfo::Clear();
  clear_has_vehicle();
}
inline const ::jmc_auto::data::VehicleInfo& StaticInfo::vehicle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfo.vehicle)
  return vehicle_ != NULL ? *vehicle_
                         : *::jmc_auto::data::VehicleInfo::internal_default_instance();
}
inline ::jmc_auto::data::VehicleInfo* StaticInfo::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) {
    vehicle_ = new ::jmc_auto::data::VehicleInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfo.vehicle)
  return vehicle_;
}
inline ::jmc_auto::data::VehicleInfo* StaticInfo::release_vehicle() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.StaticInfo.vehicle)
  clear_has_vehicle();
  ::jmc_auto::data::VehicleInfo* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void StaticInfo::set_allocated_vehicle(::jmc_auto::data::VehicleInfo* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.StaticInfo.vehicle)
}

// optional .jmc_auto.data.EnvironmentInfo environment = 2;
inline bool StaticInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StaticInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StaticInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StaticInfo::clear_environment() {
  if (environment_ != NULL) environment_->::jmc_auto::data::EnvironmentInfo::Clear();
  clear_has_environment();
}
inline const ::jmc_auto::data::EnvironmentInfo& StaticInfo::environment() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfo.environment)
  return environment_ != NULL ? *environment_
                         : *::jmc_auto::data::EnvironmentInfo::internal_default_instance();
}
inline ::jmc_auto::data::EnvironmentInfo* StaticInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) {
    environment_ = new ::jmc_auto::data::EnvironmentInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfo.environment)
  return environment_;
}
inline ::jmc_auto::data::EnvironmentInfo* StaticInfo::release_environment() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.StaticInfo.environment)
  clear_has_environment();
  ::jmc_auto::data::EnvironmentInfo* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void StaticInfo::set_allocated_environment(::jmc_auto::data::EnvironmentInfo* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.StaticInfo.environment)
}

// optional .jmc_auto.data.HardwareInfo hardware = 3;
inline bool StaticInfo::has_hardware() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StaticInfo::set_has_hardware() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StaticInfo::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StaticInfo::clear_hardware() {
  if (hardware_ != NULL) hardware_->::jmc_auto::data::HardwareInfo::Clear();
  clear_has_hardware();
}
inline const ::jmc_auto::data::HardwareInfo& StaticInfo::hardware() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfo.hardware)
  return hardware_ != NULL ? *hardware_
                         : *::jmc_auto::data::HardwareInfo::internal_default_instance();
}
inline ::jmc_auto::data::HardwareInfo* StaticInfo::mutable_hardware() {
  set_has_hardware();
  if (hardware_ == NULL) {
    hardware_ = new ::jmc_auto::data::HardwareInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfo.hardware)
  return hardware_;
}
inline ::jmc_auto::data::HardwareInfo* StaticInfo::release_hardware() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.StaticInfo.hardware)
  clear_has_hardware();
  ::jmc_auto::data::HardwareInfo* temp = hardware_;
  hardware_ = NULL;
  return temp;
}
inline void StaticInfo::set_allocated_hardware(::jmc_auto::data::HardwareInfo* hardware) {
  delete hardware_;
  hardware_ = hardware;
  if (hardware) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.StaticInfo.hardware)
}

// optional .jmc_auto.data.SoftwareInfo software = 4;
inline bool StaticInfo::has_software() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StaticInfo::set_has_software() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StaticInfo::clear_has_software() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StaticInfo::clear_software() {
  if (software_ != NULL) software_->::jmc_auto::data::SoftwareInfo::Clear();
  clear_has_software();
}
inline const ::jmc_auto::data::SoftwareInfo& StaticInfo::software() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfo.software)
  return software_ != NULL ? *software_
                         : *::jmc_auto::data::SoftwareInfo::internal_default_instance();
}
inline ::jmc_auto::data::SoftwareInfo* StaticInfo::mutable_software() {
  set_has_software();
  if (software_ == NULL) {
    software_ = new ::jmc_auto::data::SoftwareInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfo.software)
  return software_;
}
inline ::jmc_auto::data::SoftwareInfo* StaticInfo::release_software() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.StaticInfo.software)
  clear_has_software();
  ::jmc_auto::data::SoftwareInfo* temp = software_;
  software_ = NULL;
  return temp;
}
inline void StaticInfo::set_allocated_software(::jmc_auto::data::SoftwareInfo* software) {
  delete software_;
  software_ = software;
  if (software) {
    set_has_software();
  } else {
    clear_has_software();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.StaticInfo.software)
}

// optional .jmc_auto.data.UserInfo user = 5;
inline bool StaticInfo::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StaticInfo::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StaticInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StaticInfo::clear_user() {
  if (user_ != NULL) user_->::jmc_auto::data::UserInfo::Clear();
  clear_has_user();
}
inline const ::jmc_auto::data::UserInfo& StaticInfo::user() const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfo.user)
  return user_ != NULL ? *user_
                         : *::jmc_auto::data::UserInfo::internal_default_instance();
}
inline ::jmc_auto::data::UserInfo* StaticInfo::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    user_ = new ::jmc_auto::data::UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfo.user)
  return user_;
}
inline ::jmc_auto::data::UserInfo* StaticInfo::release_user() {
  // @@protoc_insertion_point(field_release:jmc_auto.data.StaticInfo.user)
  clear_has_user();
  ::jmc_auto::data::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void StaticInfo::set_allocated_user(::jmc_auto::data::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.data.StaticInfo.user)
}

// -------------------------------------------------------------------

// StaticInfoConf

// repeated string hardware_configs = 1;
inline int StaticInfoConf::hardware_configs_size() const {
  return hardware_configs_.size();
}
inline void StaticInfoConf::clear_hardware_configs() {
  hardware_configs_.Clear();
}
inline const ::std::string& StaticInfoConf::hardware_configs(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Get(index);
}
inline ::std::string* StaticInfoConf::mutable_hardware_configs(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Mutable(index);
}
inline void StaticInfoConf::set_hardware_configs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.data.StaticInfoConf.hardware_configs)
  hardware_configs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StaticInfoConf::set_hardware_configs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.data.StaticInfoConf.hardware_configs)
  hardware_configs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StaticInfoConf::set_hardware_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hardware_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::set_hardware_configs(int index, const char* value, size_t size) {
  hardware_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.StaticInfoConf.hardware_configs)
}
inline ::std::string* StaticInfoConf::add_hardware_configs() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.data.StaticInfoConf.hardware_configs)
  return hardware_configs_.Add();
}
inline void StaticInfoConf::add_hardware_configs(const ::std::string& value) {
  hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.data.StaticInfoConf.hardware_configs)
}
#if LANG_CXX11
inline void StaticInfoConf::add_hardware_configs(::std::string&& value) {
  hardware_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.data.StaticInfoConf.hardware_configs)
}
#endif
inline void StaticInfoConf::add_hardware_configs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hardware_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.data.StaticInfoConf.hardware_configs)
}
inline void StaticInfoConf::add_hardware_configs(const char* value, size_t size) {
  hardware_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.data.StaticInfoConf.hardware_configs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StaticInfoConf::hardware_configs() const {
  // @@protoc_insertion_point(field_list:jmc_auto.data.StaticInfoConf.hardware_configs)
  return hardware_configs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StaticInfoConf::mutable_hardware_configs() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.data.StaticInfoConf.hardware_configs)
  return &hardware_configs_;
}

// repeated string software_configs = 2;
inline int StaticInfoConf::software_configs_size() const {
  return software_configs_.size();
}
inline void StaticInfoConf::clear_software_configs() {
  software_configs_.Clear();
}
inline const ::std::string& StaticInfoConf::software_configs(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.data.StaticInfoConf.software_configs)
  return software_configs_.Get(index);
}
inline ::std::string* StaticInfoConf::mutable_software_configs(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.data.StaticInfoConf.software_configs)
  return software_configs_.Mutable(index);
}
inline void StaticInfoConf::set_software_configs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.data.StaticInfoConf.software_configs)
  software_configs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StaticInfoConf::set_software_configs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:jmc_auto.data.StaticInfoConf.software_configs)
  software_configs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StaticInfoConf::set_software_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  software_configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jmc_auto.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::set_software_configs(int index, const char* value, size_t size) {
  software_configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.data.StaticInfoConf.software_configs)
}
inline ::std::string* StaticInfoConf::add_software_configs() {
  // @@protoc_insertion_point(field_add_mutable:jmc_auto.data.StaticInfoConf.software_configs)
  return software_configs_.Add();
}
inline void StaticInfoConf::add_software_configs(const ::std::string& value) {
  software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jmc_auto.data.StaticInfoConf.software_configs)
}
#if LANG_CXX11
inline void StaticInfoConf::add_software_configs(::std::string&& value) {
  software_configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jmc_auto.data.StaticInfoConf.software_configs)
}
#endif
inline void StaticInfoConf::add_software_configs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  software_configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jmc_auto.data.StaticInfoConf.software_configs)
}
inline void StaticInfoConf::add_software_configs(const char* value, size_t size) {
  software_configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jmc_auto.data.StaticInfoConf.software_configs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StaticInfoConf::software_configs() const {
  // @@protoc_insertion_point(field_list:jmc_auto.data.StaticInfoConf.software_configs)
  return software_configs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StaticInfoConf::mutable_software_configs() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.data.StaticInfoConf.software_configs)
  return &software_configs_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace data
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::data::VehicleInfo_Brand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::data::VehicleInfo_Brand>() {
  return ::jmc_auto::data::VehicleInfo_Brand_descriptor();
}
template <> struct is_proto_enum< ::jmc_auto::data::VehicleInfo_Model> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::data::VehicleInfo_Model>() {
  return ::jmc_auto::data::VehicleInfo_Model_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fdata_2fproto_2fstatic_5finfo_2eproto__INCLUDED
