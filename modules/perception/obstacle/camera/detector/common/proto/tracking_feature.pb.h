// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/perception/obstacle/camera/detector/common/proto/tracking_feature.proto

#ifndef PROTOBUF_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto__INCLUDED
#define PROTOBUF_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace perception {
class ExtractorParam;
class ExtractorParamDefaultTypeInternal;
extern ExtractorParamDefaultTypeInternal _ExtractorParam_default_instance_;
class FeatureParam;
class FeatureParamDefaultTypeInternal;
extern FeatureParamDefaultTypeInternal _FeatureParam_default_instance_;
class ROIPoolingParam;
class ROIPoolingParamDefaultTypeInternal;
extern ROIPoolingParamDefaultTypeInternal _ROIPoolingParam_default_instance_;
class ReorgParam;
class ReorgParamDefaultTypeInternal;
extern ReorgParamDefaultTypeInternal _ReorgParam_default_instance_;
}  // namespace perception
}  // namespace jmc_auto

namespace jmc_auto {
namespace perception {

namespace protobuf_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto

enum ExtractorParam_FeatureType {
  ExtractorParam_FeatureType_Reorg = 0,
  ExtractorParam_FeatureType_ROIPooling = 1
};
bool ExtractorParam_FeatureType_IsValid(int value);
const ExtractorParam_FeatureType ExtractorParam_FeatureType_FeatureType_MIN = ExtractorParam_FeatureType_Reorg;
const ExtractorParam_FeatureType ExtractorParam_FeatureType_FeatureType_MAX = ExtractorParam_FeatureType_ROIPooling;
const int ExtractorParam_FeatureType_FeatureType_ARRAYSIZE = ExtractorParam_FeatureType_FeatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExtractorParam_FeatureType_descriptor();
inline const ::std::string& ExtractorParam_FeatureType_Name(ExtractorParam_FeatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExtractorParam_FeatureType_descriptor(), value);
}
inline bool ExtractorParam_FeatureType_Parse(
    const ::std::string& name, ExtractorParam_FeatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExtractorParam_FeatureType>(
    ExtractorParam_FeatureType_descriptor(), name, value);
}
// ===================================================================

class FeatureParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.perception.FeatureParam) */ {
 public:
  FeatureParam();
  virtual ~FeatureParam();

  FeatureParam(const FeatureParam& from);

  inline FeatureParam& operator=(const FeatureParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureParam& default_instance();

  static inline const FeatureParam* internal_default_instance() {
    return reinterpret_cast<const FeatureParam*>(
               &_FeatureParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FeatureParam* other);

  // implements Message ----------------------------------------------

  inline FeatureParam* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FeatureParam& from);
  void MergeFrom(const FeatureParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FeatureParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.perception.ExtractorParam extractor = 2;
  int extractor_size() const;
  void clear_extractor();
  static const int kExtractorFieldNumber = 2;
  const ::jmc_auto::perception::ExtractorParam& extractor(int index) const;
  ::jmc_auto::perception::ExtractorParam* mutable_extractor(int index);
  ::jmc_auto::perception::ExtractorParam* add_extractor();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::perception::ExtractorParam >*
      mutable_extractor();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::perception::ExtractorParam >&
      extractor() const;

  // optional string remap_model = 3;
  bool has_remap_model() const;
  void clear_remap_model();
  static const int kRemapModelFieldNumber = 3;
  const ::std::string& remap_model() const;
  void set_remap_model(const ::std::string& value);
  #if LANG_CXX11
  void set_remap_model(::std::string&& value);
  #endif
  void set_remap_model(const char* value);
  void set_remap_model(const char* value, size_t size);
  ::std::string* mutable_remap_model();
  ::std::string* release_remap_model();
  void set_allocated_remap_model(::std::string* remap_model);

  // optional int32 feat_stride = 1 [default = 32];
  bool has_feat_stride() const;
  void clear_feat_stride();
  static const int kFeatStrideFieldNumber = 1;
  ::google::protobuf::int32 feat_stride() const;
  void set_feat_stride(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.perception.FeatureParam)
 private:
  void set_has_feat_stride();
  void clear_has_feat_stride();
  void set_has_remap_model();
  void clear_has_remap_model();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::perception::ExtractorParam > extractor_;
  ::google::protobuf::internal::ArenaStringPtr remap_model_;
  ::google::protobuf::int32 feat_stride_;
  friend struct protobuf_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtractorParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.perception.ExtractorParam) */ {
 public:
  ExtractorParam();
  virtual ~ExtractorParam();

  ExtractorParam(const ExtractorParam& from);

  inline ExtractorParam& operator=(const ExtractorParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtractorParam& default_instance();

  static inline const ExtractorParam* internal_default_instance() {
    return reinterpret_cast<const ExtractorParam*>(
               &_ExtractorParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ExtractorParam* other);

  // implements Message ----------------------------------------------

  inline ExtractorParam* New() const PROTOBUF_FINAL { return New(NULL); }

  ExtractorParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExtractorParam& from);
  void MergeFrom(const ExtractorParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExtractorParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ExtractorParam_FeatureType FeatureType;
  static const FeatureType Reorg =
    ExtractorParam_FeatureType_Reorg;
  static const FeatureType ROIPooling =
    ExtractorParam_FeatureType_ROIPooling;
  static inline bool FeatureType_IsValid(int value) {
    return ExtractorParam_FeatureType_IsValid(value);
  }
  static const FeatureType FeatureType_MIN =
    ExtractorParam_FeatureType_FeatureType_MIN;
  static const FeatureType FeatureType_MAX =
    ExtractorParam_FeatureType_FeatureType_MAX;
  static const int FeatureType_ARRAYSIZE =
    ExtractorParam_FeatureType_FeatureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FeatureType_descriptor() {
    return ExtractorParam_FeatureType_descriptor();
  }
  static inline const ::std::string& FeatureType_Name(FeatureType value) {
    return ExtractorParam_FeatureType_Name(value);
  }
  static inline bool FeatureType_Parse(const ::std::string& name,
      FeatureType* value) {
    return ExtractorParam_FeatureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string feat_blob = 1;
  bool has_feat_blob() const;
  void clear_feat_blob();
  static const int kFeatBlobFieldNumber = 1;
  const ::std::string& feat_blob() const;
  void set_feat_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_feat_blob(::std::string&& value);
  #endif
  void set_feat_blob(const char* value);
  void set_feat_blob(const char* value, size_t size);
  ::std::string* mutable_feat_blob();
  ::std::string* release_feat_blob();
  void set_allocated_feat_blob(::std::string* feat_blob);

  // optional .jmc_auto.perception.ROIPoolingParam roi_pooling_param = 3;
  bool has_roi_pooling_param() const;
  void clear_roi_pooling_param();
  static const int kRoiPoolingParamFieldNumber = 3;
  const ::jmc_auto::perception::ROIPoolingParam& roi_pooling_param() const;
  ::jmc_auto::perception::ROIPoolingParam* mutable_roi_pooling_param();
  ::jmc_auto::perception::ROIPoolingParam* release_roi_pooling_param();
  void set_allocated_roi_pooling_param(::jmc_auto::perception::ROIPoolingParam* roi_pooling_param);

  // optional .jmc_auto.perception.ReorgParam reorg_param = 4;
  bool has_reorg_param() const;
  void clear_reorg_param();
  static const int kReorgParamFieldNumber = 4;
  const ::jmc_auto::perception::ReorgParam& reorg_param() const;
  ::jmc_auto::perception::ReorgParam* mutable_reorg_param();
  ::jmc_auto::perception::ReorgParam* release_reorg_param();
  void set_allocated_reorg_param(::jmc_auto::perception::ReorgParam* reorg_param);

  // optional .jmc_auto.perception.ExtractorParam.FeatureType feat_type = 2 [default = Reorg];
  bool has_feat_type() const;
  void clear_feat_type();
  static const int kFeatTypeFieldNumber = 2;
  ::jmc_auto::perception::ExtractorParam_FeatureType feat_type() const;
  void set_feat_type(::jmc_auto::perception::ExtractorParam_FeatureType value);

  // @@protoc_insertion_point(class_scope:jmc_auto.perception.ExtractorParam)
 private:
  void set_has_feat_blob();
  void clear_has_feat_blob();
  void set_has_feat_type();
  void clear_has_feat_type();
  void set_has_roi_pooling_param();
  void clear_has_roi_pooling_param();
  void set_has_reorg_param();
  void clear_has_reorg_param();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr feat_blob_;
  ::jmc_auto::perception::ROIPoolingParam* roi_pooling_param_;
  ::jmc_auto::perception::ReorgParam* reorg_param_;
  int feat_type_;
  friend struct protobuf_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ROIPoolingParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.perception.ROIPoolingParam) */ {
 public:
  ROIPoolingParam();
  virtual ~ROIPoolingParam();

  ROIPoolingParam(const ROIPoolingParam& from);

  inline ROIPoolingParam& operator=(const ROIPoolingParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROIPoolingParam& default_instance();

  static inline const ROIPoolingParam* internal_default_instance() {
    return reinterpret_cast<const ROIPoolingParam*>(
               &_ROIPoolingParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ROIPoolingParam* other);

  // implements Message ----------------------------------------------

  inline ROIPoolingParam* New() const PROTOBUF_FINAL { return New(NULL); }

  ROIPoolingParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ROIPoolingParam& from);
  void MergeFrom(const ROIPoolingParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ROIPoolingParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_floor = 3 [default = false];
  bool has_use_floor() const;
  void clear_use_floor();
  static const int kUseFloorFieldNumber = 3;
  bool use_floor() const;
  void set_use_floor(bool value);

  // optional int32 pooled_h = 1 [default = 3];
  bool has_pooled_h() const;
  void clear_pooled_h();
  static const int kPooledHFieldNumber = 1;
  ::google::protobuf::int32 pooled_h() const;
  void set_pooled_h(::google::protobuf::int32 value);

  // optional int32 pooled_w = 2 [default = 3];
  bool has_pooled_w() const;
  void clear_pooled_w();
  static const int kPooledWFieldNumber = 2;
  ::google::protobuf::int32 pooled_w() const;
  void set_pooled_w(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.perception.ROIPoolingParam)
 private:
  void set_has_pooled_h();
  void clear_has_pooled_h();
  void set_has_pooled_w();
  void clear_has_pooled_w();
  void set_has_use_floor();
  void clear_has_use_floor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool use_floor_;
  ::google::protobuf::int32 pooled_h_;
  ::google::protobuf::int32 pooled_w_;
  friend struct protobuf_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReorgParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.perception.ReorgParam) */ {
 public:
  ReorgParam();
  virtual ~ReorgParam();

  ReorgParam(const ReorgParam& from);

  inline ReorgParam& operator=(const ReorgParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReorgParam& default_instance();

  static inline const ReorgParam* internal_default_instance() {
    return reinterpret_cast<const ReorgParam*>(
               &_ReorgParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ReorgParam* other);

  // implements Message ----------------------------------------------

  inline ReorgParam* New() const PROTOBUF_FINAL { return New(NULL); }

  ReorgParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReorgParam& from);
  void MergeFrom(const ReorgParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReorgParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ref_height = 1 [default = 0];
  bool has_ref_height() const;
  void clear_ref_height();
  static const int kRefHeightFieldNumber = 1;
  ::google::protobuf::int32 ref_height() const;
  void set_ref_height(::google::protobuf::int32 value);

  // optional int32 ref_width = 2 [default = 0];
  bool has_ref_width() const;
  void clear_ref_width();
  static const int kRefWidthFieldNumber = 2;
  ::google::protobuf::int32 ref_width() const;
  void set_ref_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.perception.ReorgParam)
 private:
  void set_has_ref_height();
  void clear_has_ref_height();
  void set_has_ref_width();
  void clear_has_ref_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 ref_height_;
  ::google::protobuf::int32 ref_width_;
  friend struct protobuf_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FeatureParam

// optional int32 feat_stride = 1 [default = 32];
inline bool FeatureParam::has_feat_stride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureParam::set_has_feat_stride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureParam::clear_has_feat_stride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureParam::clear_feat_stride() {
  feat_stride_ = 32;
  clear_has_feat_stride();
}
inline ::google::protobuf::int32 FeatureParam::feat_stride() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.FeatureParam.feat_stride)
  return feat_stride_;
}
inline void FeatureParam::set_feat_stride(::google::protobuf::int32 value) {
  set_has_feat_stride();
  feat_stride_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.FeatureParam.feat_stride)
}

// repeated .jmc_auto.perception.ExtractorParam extractor = 2;
inline int FeatureParam::extractor_size() const {
  return extractor_.size();
}
inline void FeatureParam::clear_extractor() {
  extractor_.Clear();
}
inline const ::jmc_auto::perception::ExtractorParam& FeatureParam::extractor(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.FeatureParam.extractor)
  return extractor_.Get(index);
}
inline ::jmc_auto::perception::ExtractorParam* FeatureParam::mutable_extractor(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.perception.FeatureParam.extractor)
  return extractor_.Mutable(index);
}
inline ::jmc_auto::perception::ExtractorParam* FeatureParam::add_extractor() {
  // @@protoc_insertion_point(field_add:jmc_auto.perception.FeatureParam.extractor)
  return extractor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::perception::ExtractorParam >*
FeatureParam::mutable_extractor() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.perception.FeatureParam.extractor)
  return &extractor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::perception::ExtractorParam >&
FeatureParam::extractor() const {
  // @@protoc_insertion_point(field_list:jmc_auto.perception.FeatureParam.extractor)
  return extractor_;
}

// optional string remap_model = 3;
inline bool FeatureParam::has_remap_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureParam::set_has_remap_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureParam::clear_has_remap_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureParam::clear_remap_model() {
  remap_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_remap_model();
}
inline const ::std::string& FeatureParam::remap_model() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.FeatureParam.remap_model)
  return remap_model_.GetNoArena();
}
inline void FeatureParam::set_remap_model(const ::std::string& value) {
  set_has_remap_model();
  remap_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.perception.FeatureParam.remap_model)
}
#if LANG_CXX11
inline void FeatureParam::set_remap_model(::std::string&& value) {
  set_has_remap_model();
  remap_model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.perception.FeatureParam.remap_model)
}
#endif
inline void FeatureParam::set_remap_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_remap_model();
  remap_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.perception.FeatureParam.remap_model)
}
inline void FeatureParam::set_remap_model(const char* value, size_t size) {
  set_has_remap_model();
  remap_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.perception.FeatureParam.remap_model)
}
inline ::std::string* FeatureParam::mutable_remap_model() {
  set_has_remap_model();
  // @@protoc_insertion_point(field_mutable:jmc_auto.perception.FeatureParam.remap_model)
  return remap_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeatureParam::release_remap_model() {
  // @@protoc_insertion_point(field_release:jmc_auto.perception.FeatureParam.remap_model)
  clear_has_remap_model();
  return remap_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeatureParam::set_allocated_remap_model(::std::string* remap_model) {
  if (remap_model != NULL) {
    set_has_remap_model();
  } else {
    clear_has_remap_model();
  }
  remap_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remap_model);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.perception.FeatureParam.remap_model)
}

// -------------------------------------------------------------------

// ExtractorParam

// optional string feat_blob = 1;
inline bool ExtractorParam::has_feat_blob() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtractorParam::set_has_feat_blob() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtractorParam::clear_has_feat_blob() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtractorParam::clear_feat_blob() {
  feat_blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_feat_blob();
}
inline const ::std::string& ExtractorParam::feat_blob() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ExtractorParam.feat_blob)
  return feat_blob_.GetNoArena();
}
inline void ExtractorParam::set_feat_blob(const ::std::string& value) {
  set_has_feat_blob();
  feat_blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ExtractorParam.feat_blob)
}
#if LANG_CXX11
inline void ExtractorParam::set_feat_blob(::std::string&& value) {
  set_has_feat_blob();
  feat_blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.perception.ExtractorParam.feat_blob)
}
#endif
inline void ExtractorParam::set_feat_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_feat_blob();
  feat_blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.perception.ExtractorParam.feat_blob)
}
inline void ExtractorParam::set_feat_blob(const char* value, size_t size) {
  set_has_feat_blob();
  feat_blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.perception.ExtractorParam.feat_blob)
}
inline ::std::string* ExtractorParam::mutable_feat_blob() {
  set_has_feat_blob();
  // @@protoc_insertion_point(field_mutable:jmc_auto.perception.ExtractorParam.feat_blob)
  return feat_blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtractorParam::release_feat_blob() {
  // @@protoc_insertion_point(field_release:jmc_auto.perception.ExtractorParam.feat_blob)
  clear_has_feat_blob();
  return feat_blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtractorParam::set_allocated_feat_blob(::std::string* feat_blob) {
  if (feat_blob != NULL) {
    set_has_feat_blob();
  } else {
    clear_has_feat_blob();
  }
  feat_blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), feat_blob);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.perception.ExtractorParam.feat_blob)
}

// optional .jmc_auto.perception.ExtractorParam.FeatureType feat_type = 2 [default = Reorg];
inline bool ExtractorParam::has_feat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtractorParam::set_has_feat_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtractorParam::clear_has_feat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtractorParam::clear_feat_type() {
  feat_type_ = 0;
  clear_has_feat_type();
}
inline ::jmc_auto::perception::ExtractorParam_FeatureType ExtractorParam::feat_type() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ExtractorParam.feat_type)
  return static_cast< ::jmc_auto::perception::ExtractorParam_FeatureType >(feat_type_);
}
inline void ExtractorParam::set_feat_type(::jmc_auto::perception::ExtractorParam_FeatureType value) {
  assert(::jmc_auto::perception::ExtractorParam_FeatureType_IsValid(value));
  set_has_feat_type();
  feat_type_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ExtractorParam.feat_type)
}

// optional .jmc_auto.perception.ROIPoolingParam roi_pooling_param = 3;
inline bool ExtractorParam::has_roi_pooling_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtractorParam::set_has_roi_pooling_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtractorParam::clear_has_roi_pooling_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtractorParam::clear_roi_pooling_param() {
  if (roi_pooling_param_ != NULL) roi_pooling_param_->::jmc_auto::perception::ROIPoolingParam::Clear();
  clear_has_roi_pooling_param();
}
inline const ::jmc_auto::perception::ROIPoolingParam& ExtractorParam::roi_pooling_param() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ExtractorParam.roi_pooling_param)
  return roi_pooling_param_ != NULL ? *roi_pooling_param_
                         : *::jmc_auto::perception::ROIPoolingParam::internal_default_instance();
}
inline ::jmc_auto::perception::ROIPoolingParam* ExtractorParam::mutable_roi_pooling_param() {
  set_has_roi_pooling_param();
  if (roi_pooling_param_ == NULL) {
    roi_pooling_param_ = new ::jmc_auto::perception::ROIPoolingParam;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.perception.ExtractorParam.roi_pooling_param)
  return roi_pooling_param_;
}
inline ::jmc_auto::perception::ROIPoolingParam* ExtractorParam::release_roi_pooling_param() {
  // @@protoc_insertion_point(field_release:jmc_auto.perception.ExtractorParam.roi_pooling_param)
  clear_has_roi_pooling_param();
  ::jmc_auto::perception::ROIPoolingParam* temp = roi_pooling_param_;
  roi_pooling_param_ = NULL;
  return temp;
}
inline void ExtractorParam::set_allocated_roi_pooling_param(::jmc_auto::perception::ROIPoolingParam* roi_pooling_param) {
  delete roi_pooling_param_;
  roi_pooling_param_ = roi_pooling_param;
  if (roi_pooling_param) {
    set_has_roi_pooling_param();
  } else {
    clear_has_roi_pooling_param();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.perception.ExtractorParam.roi_pooling_param)
}

// optional .jmc_auto.perception.ReorgParam reorg_param = 4;
inline bool ExtractorParam::has_reorg_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtractorParam::set_has_reorg_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtractorParam::clear_has_reorg_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtractorParam::clear_reorg_param() {
  if (reorg_param_ != NULL) reorg_param_->::jmc_auto::perception::ReorgParam::Clear();
  clear_has_reorg_param();
}
inline const ::jmc_auto::perception::ReorgParam& ExtractorParam::reorg_param() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ExtractorParam.reorg_param)
  return reorg_param_ != NULL ? *reorg_param_
                         : *::jmc_auto::perception::ReorgParam::internal_default_instance();
}
inline ::jmc_auto::perception::ReorgParam* ExtractorParam::mutable_reorg_param() {
  set_has_reorg_param();
  if (reorg_param_ == NULL) {
    reorg_param_ = new ::jmc_auto::perception::ReorgParam;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.perception.ExtractorParam.reorg_param)
  return reorg_param_;
}
inline ::jmc_auto::perception::ReorgParam* ExtractorParam::release_reorg_param() {
  // @@protoc_insertion_point(field_release:jmc_auto.perception.ExtractorParam.reorg_param)
  clear_has_reorg_param();
  ::jmc_auto::perception::ReorgParam* temp = reorg_param_;
  reorg_param_ = NULL;
  return temp;
}
inline void ExtractorParam::set_allocated_reorg_param(::jmc_auto::perception::ReorgParam* reorg_param) {
  delete reorg_param_;
  reorg_param_ = reorg_param;
  if (reorg_param) {
    set_has_reorg_param();
  } else {
    clear_has_reorg_param();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.perception.ExtractorParam.reorg_param)
}

// -------------------------------------------------------------------

// ROIPoolingParam

// optional int32 pooled_h = 1 [default = 3];
inline bool ROIPoolingParam::has_pooled_h() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROIPoolingParam::set_has_pooled_h() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROIPoolingParam::clear_has_pooled_h() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROIPoolingParam::clear_pooled_h() {
  pooled_h_ = 3;
  clear_has_pooled_h();
}
inline ::google::protobuf::int32 ROIPoolingParam::pooled_h() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ROIPoolingParam.pooled_h)
  return pooled_h_;
}
inline void ROIPoolingParam::set_pooled_h(::google::protobuf::int32 value) {
  set_has_pooled_h();
  pooled_h_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ROIPoolingParam.pooled_h)
}

// optional int32 pooled_w = 2 [default = 3];
inline bool ROIPoolingParam::has_pooled_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ROIPoolingParam::set_has_pooled_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ROIPoolingParam::clear_has_pooled_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ROIPoolingParam::clear_pooled_w() {
  pooled_w_ = 3;
  clear_has_pooled_w();
}
inline ::google::protobuf::int32 ROIPoolingParam::pooled_w() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ROIPoolingParam.pooled_w)
  return pooled_w_;
}
inline void ROIPoolingParam::set_pooled_w(::google::protobuf::int32 value) {
  set_has_pooled_w();
  pooled_w_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ROIPoolingParam.pooled_w)
}

// optional bool use_floor = 3 [default = false];
inline bool ROIPoolingParam::has_use_floor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROIPoolingParam::set_has_use_floor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROIPoolingParam::clear_has_use_floor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROIPoolingParam::clear_use_floor() {
  use_floor_ = false;
  clear_has_use_floor();
}
inline bool ROIPoolingParam::use_floor() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ROIPoolingParam.use_floor)
  return use_floor_;
}
inline void ROIPoolingParam::set_use_floor(bool value) {
  set_has_use_floor();
  use_floor_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ROIPoolingParam.use_floor)
}

// -------------------------------------------------------------------

// ReorgParam

// optional int32 ref_height = 1 [default = 0];
inline bool ReorgParam::has_ref_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReorgParam::set_has_ref_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReorgParam::clear_has_ref_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReorgParam::clear_ref_height() {
  ref_height_ = 0;
  clear_has_ref_height();
}
inline ::google::protobuf::int32 ReorgParam::ref_height() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ReorgParam.ref_height)
  return ref_height_;
}
inline void ReorgParam::set_ref_height(::google::protobuf::int32 value) {
  set_has_ref_height();
  ref_height_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ReorgParam.ref_height)
}

// optional int32 ref_width = 2 [default = 0];
inline bool ReorgParam::has_ref_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReorgParam::set_has_ref_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReorgParam::clear_has_ref_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReorgParam::clear_ref_width() {
  ref_width_ = 0;
  clear_has_ref_width();
}
inline ::google::protobuf::int32 ReorgParam::ref_width() const {
  // @@protoc_insertion_point(field_get:jmc_auto.perception.ReorgParam.ref_width)
  return ref_width_;
}
inline void ReorgParam::set_ref_width(::google::protobuf::int32 value) {
  set_has_ref_width();
  ref_width_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.perception.ReorgParam.ref_width)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace perception
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::perception::ExtractorParam_FeatureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::perception::ExtractorParam_FeatureType>() {
  return ::jmc_auto::perception::ExtractorParam_FeatureType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fperception_2fobstacle_2fcamera_2fdetector_2fcommon_2fproto_2ftracking_5ffeature_2eproto__INCLUDED
